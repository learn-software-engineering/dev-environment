[{"content":" En el módulo anterior exploramos los fundamentos conceptuales de la Inteligencia Artificial. Ahora es momento de sumergirnos en una de las áreas de la matemática que hacen posible que los algoritmos de Machine Learning funcionen: el álgebra lineal.\nSi eres como la mayoría de los ingenieros de software, probablemente te preguntes: \u0026ldquo;¿por qué necesito álgebra lineal para programar IA?\u0026rdquo; La respuesta es simple pero profunda: el álgebra lineal es el lenguaje nativo del machine learning.\n¿Por qué el Álgebra Lineal es crucial en IA? # Imagina que estás desarrollando un sistema de recomendaciones para Netflix. Cada usuario tiene preferencias (acción, comedia, drama) que pueden representarse como un vector. Cada película también tiene características (género, año, rating) que forman otro vector. El problema de recomendar películas se convierte en encontrar similitudes entre vectores: álgebra lineal.\nO considera una red neuronal procesando una imagen de \\(224x224\\) píxeles. Esa imagen se convierte en un vector de \\(50176\\) elementos. Las operaciones de la red (convoluciones, transformaciones) son multiplicaciones de matrices. El entrenamiento optimiza estas matrices, otra vez: álgebra lineal.\nLos tres pilares del ML que dependen del Álgebra Lineal # Representación de Datos: Todo en ML se convierte en vectores y matrices Transformaciones: Los algoritmos manipulan datos mediante operaciones lineales Optimización: Los métodos de entrenamiento usan gradientes (derivadas de operaciones matriciales) Como programadores, estamos acostumbrados a pensar en estructuras de datos como arrays, listas o objetos. En machine learning, pensamos en vectores y matrices. En este módulo aprenderemos a hacer esa transición mental.\nVectores: más que arrays # Un vector no es simplemente un array de números. Es una entidad matemática que representa tanto magnitud como dirección. En el contexto de machine learning, un vector es una forma de codificar información.\nDefinición formal # Un vector \\(v\\) en el espacio \\(R^n\\) es una tupla ordenada de \\(n\\) números reales:\n$$v = \\begin{pmatrix} v_1 \\\\ v_2 \\\\ \\vdots \\\\ v_n \\end{pmatrix}$$Pero más importante que la definición formal es la interpretación práctica:\nEn un sistema de recomendaciones: $$v = \\begin{pmatrix} rating_{accion} \\\\ rating_{comedia} \\\\ rating_{drama} \\end{pmatrix}$$ En procesamiento de texto: $$v = \\begin{pmatrix} frecuencia_{palabra1} \\\\ frecuencia_{palabra2} \\\\ frecuencia_{palabra3} \\\\ \\vdots \\end{pmatrix}$$ En visión por computadora: $$v = \\begin{pmatrix} pixel_1 \\\\ pixel_2 \\\\ pixel_3 \\\\ \\vdots \\end{pmatrix}$$ Interpretación geométrica # Un vector en dos dimensiones (2D) se puede visualizar como una flecha desde el origen \\((0,0)\\) hasta el punto \\((v_1, v_2)\\). Esta visualización es clave para entender las operaciones vectoriales.\nimport matplotlib.pyplot as plt import numpy as np def plot_vector(vector, color=\u0026#39;blue\u0026#39;, label=\u0026#39;Vector\u0026#39;): plt.quiver(0, 0, vector[0], vector[1], angles=\u0026#39;xy\u0026#39;, scale_units=\u0026#39;xy\u0026#39;, scale=1, color=color, label=label, width=0.005) plt.xlim(-1, 5) plt.ylim(-1, 5) plt.grid(True) plt.axhline(y=0, color=\u0026#39;k\u0026#39;, linewidth=0.5) plt.axvline(x=0, color=\u0026#39;k\u0026#39;, linewidth=0.5) # Ejemplo: vector que representa preferencias de usuario user_preferences = np.array([3, 4]) # [acción: 3, comedia: 4] plt.figure(figsize=(8, 6)) plot_vector(user_preferences, \u0026#39;blue\u0026#39;, \u0026#39;Preferencias Usuario\u0026#39;) plt.xlabel(\u0026#39;Rating Acción\u0026#39;) plt.ylabel(\u0026#39;Rating Comedia\u0026#39;) plt.title(\u0026#39;Vector de Preferencias de Usuario\u0026#39;) plt.legend() plt.show() Suma de vectores # La suma vectorial es componente a componente:\n$$\\mathbf{u} + \\mathbf{v} = \\begin{pmatrix} u_1 + v_1 \\\\ u_2 + v_2 \\\\ \\vdots \\\\ u_n + v_n \\end{pmatrix}$$Interpretación en ML: Si tenemos las preferencias de dos usuarios similares, podemos promediar sus vectores para encontrar preferencias \u0026ldquo;típicas\u0026rdquo; de ese segmento.\nMultiplicación por escalar # $$c \\cdot \\mathbf{v} = \\begin{pmatrix} c \\cdot v_1 \\\\ c \\cdot v_2 \\\\ \\vdots \\\\ c \\cdot v_n \\end{pmatrix}$$Interpretación en ML: Amplificar o reducir la importancia de ciertas características.\nProducto Punto # El producto punto es quizás la operación más importante en ML:\n$$\\mathbf{u} \\cdot \\mathbf{v} = \\sum_{i=1}^{n} u_i v_i = u_1 v_1 + u_2 v_2 + ... + u_n v_n$$¿Por qué es tan importante?\nSimilitud: Vectores similares tienen productos punto altos Proyección: Mide cuánto un vector \u0026ldquo;apunta\u0026rdquo; en la dirección de otro Redes neuronales: La base de las operaciones en cada neurona La interpretación geométrica es crucial, el producto punto es igual al producto entre las magnitudes de cada vector y el coseno del ángulo entre ellos:\n$$\\mathbf{u} \\cdot \\mathbf{v} = ||\\mathbf{u}|| \\cdot ||\\mathbf{v}|| \\cdot \\cos(\\theta)$$Donde \\(\\theta\\) es el ángulo entre los vectores.\nO de otra manera:\n$$\\cos(\\theta) = \\frac{\\mathbf{u} \\cdot \\mathbf{v}}{||\\mathbf{u}|| \\cdot ||\\mathbf{v}||}$$$$\\theta = \\arccos(\\frac{\\mathbf{u} \\cdot \\mathbf{v}}{||\\mathbf{u}|| \\cdot ||\\mathbf{v}||})$$Conocer el ángulo entre los vectores permite determinar que tan alineados están.\nImplementación desde cero: clase Vector # Antes de usar NumPy, implementemos nuestras propias operaciones vectoriales para entender qué sucede en el detrás de escena:\nimport math from typing import List class Vector: \u0026#34;\u0026#34;\u0026#34; Implementación básica de un vector matemático. Esta clase nos ayuda a entender las operaciones vectoriales antes de usar bibliotecas optimizadas como NumPy. \u0026#34;\u0026#34;\u0026#34; def __init__(self, componentes: List[float]): \u0026#34;\u0026#34;\u0026#34; Inicializa un vector con una lista de componentes. Args: componentes: Lista de números que forman el vector \u0026#34;\u0026#34;\u0026#34; if not componentes: raise ValueError(\u0026#34;Un vector debe tener al menos un componente\u0026#34;) self.componentes = componentes self.dimension = len(componentes) def __repr__(self): return f\u0026#34;Vector({self.componentes})\u0026#34; def __len__(self): return self.dimension def __getitem__(self, index): return self.componentes[index] def __add__(self, otro_vector): \u0026#34;\u0026#34;\u0026#34; Suma vectorial: componente por componente. Ejemplo: v1 = Vector([1, 2, 3]) v2 = Vector([4, 5, 6]) v3 = v1 + v2 # Vector([5, 7, 9]) \u0026#34;\u0026#34;\u0026#34; if self.dimension != otro_vector.dimension: raise ValueError(\u0026#34;Los vectores deben tener la misma dimensión\u0026#34;) componentes_resultado = [ a + b for a, b in zip(self.componentes, otro_vector.componentes) ] return Vector(componentes_resultado) def __sub__(self, otro_vector): \u0026#34;\u0026#34;\u0026#34;Resta vectorial.\u0026#34;\u0026#34;\u0026#34; if self.dimension != otro_vector.dimension: raise ValueError(\u0026#34;Los vectores deben tener la misma dimensión\u0026#34;) componentes_resultado = [ a - b for a, b in zip(self.componentes, otro_vector.componentes) ] return Vector(componentes_resultado) def __mul__(self, escalar): \u0026#34;\u0026#34;\u0026#34; Multiplicación por escalar. Ejemplo: v = Vector([1, 2, 3]) v_scaled = v * 2 # Vector([2, 4, 6]) \u0026#34;\u0026#34;\u0026#34; return Vector([escalar * componente for componente in self.componentes]) def producto_punto(self, otro_vector): \u0026#34;\u0026#34;\u0026#34; Producto punto: la operación más importante en Machine Learning. El producto punto mide la similitud direccional entre vectores. - Producto alto: vectores apuntan en direcciones similares - Producto cero: vectores perpendiculares - Producto negativo: vectores apuntan en direcciones opuestas Args: otro_vector: Otro vector de la misma dimensión Returns: float: El producto punto \u0026#34;\u0026#34;\u0026#34; if self.dimension != otro_vector.dimension: raise ValueError(\u0026#34;Los vectores deben tener la misma dimensión\u0026#34;) return sum(a * b for a, b in zip(self.componentes, otro_vector.componentes)) def magnitud(self): \u0026#34;\u0026#34;\u0026#34; Calcula la magnitud (norma) del vector. La magnitud representa la \u0026#34;longitud\u0026#34; del vector. Es importante para normalización y cálculo de distancias. Returns: float: La magnitud del vector \u0026#34;\u0026#34;\u0026#34; return math.sqrt(sum(componente ** 2 for componente in self.componentes)) def normalizar(self): \u0026#34;\u0026#34;\u0026#34; Normaliza el vector (magnitud = 1). Los vectores normalizados son cruciales en Machine Learning porque: - Eliminan el efecto de la escala - Facilitan la comparación de direcciones - Son requeridos en muchos algoritmos Returns: Vector: Nuevo vector normalizado \u0026#34;\u0026#34;\u0026#34; mag = self.magnitud() if mag == 0: raise ValueError(\u0026#34;No se puede normalizar el vector cero\u0026#34;) return Vector([componente / mag for componente in self.componentes]) def similitud_coseno(self, otro_vector): \u0026#34;\u0026#34;\u0026#34; Calcula la similitud coseno entre dos vectores. La similitud coseno es fundamental en: - Sistemas de recomendación - Procesamiento de lenguaje natural - Búsqueda semántica Retorna valores entre -1 y 1: - 1: Vectores idénticos en dirección - 0: Vectores perpendiculares - -1: Vectores opuestos Args: otro_vector: Otro vector Returns: float: Similitud coseno \u0026#34;\u0026#34;\u0026#34; dot_prod = self.producto_punto(otro_vector) producto_magnitudes = self.magnitud() * otro_vector.magnitud() if producto_magnitudes == 0: return 0 return dot_prod / producto_magnitudes # Ejemplos de uso def demo_operaciones_vectoriales(): \u0026#34;\u0026#34;\u0026#34; Prueba las operaciones vectoriales con ejemplos de Machine Learning. \u0026#34;\u0026#34;\u0026#34; mensaje = \u0026#34;Ejemplos de Operaciones Vectoriales\u0026#34; print(\u0026#34;#\u0026#34; * len(mensaje)) print(mensaje) print(\u0026#34;#\u0026#34; * len(mensaje)) print(\u0026#34;\\n\u0026#34;) # Ejemplo 1: Preferencias de usuarios print(\u0026#34;=== Ejemplo 1: Preferencias de usuarios ===\u0026#34;) print(\u0026#34; Cada usuario se corresponde con un vector que mapea sus preferencias en películas\u0026#34;) print(\u0026#34; Vector([acción, comedia, drama])\u0026#34;) print(\u0026#34;\\n\u0026#34;) usuarios = [ Vector([4, 2, 5]), Vector([3, 4, 2]), Vector([9, 1, 2]), Vector([3, 8, 1]), Vector([1, 2, 9]) ] for index_i, usuario_i in enumerate(usuarios): print(f\u0026#34; Usuario {index_i}: {usuario_i}\u0026#34;) for index_j in range(index_i + 1, len(usuarios)): usuario_j = usuarios[index_j] print(f\u0026#34; Cálculos de similitud con el usuario {index_j}\u0026#34;) combinadas = usuario_i + usuario_j print(f\u0026#34; Suma: preferencias combinadas: {combinadas}\u0026#34;) similitud_producto_punto = usuario_i.producto_punto(usuario_j) print(f\u0026#34; Similitud (producto punto): {similitud_producto_punto}\u0026#34;) similitud_coseno = usuario_i.similitud_coseno(usuario_j) print(f\u0026#34; Similitud coseno: {similitud_coseno:.3f}\u0026#34;) print(\u0026#34;\\n\u0026#34;) # Ejemplo 2: Vectores de características print(\u0026#34;=== Ejemplo 2: Análisis de Documentos ===\u0026#34;) print(\u0026#34; Cada documento se corresponde con un vector que mapea las frecuencias de las palabras que contiene\u0026#34;) print(\u0026#34; Vector([frecuencia_palabra_1, frecuencia_palabra_2, frecuencia_palabra_3, frecuencia_palabra_4])\u0026#34;) documento_1 = Vector([2, 1, 0, 3]) # Frecuencias de palabras documento_2 = Vector([1, 2, 1, 2]) # Frecuencias de palabras print(f\u0026#34; Documento 1: {documento_1}\u0026#34;) print(f\u0026#34; Documento 2: {documento_2}\u0026#34;) similitud_documentos_producto_punto = documento_1.producto_punto(documento_2) print(f\u0026#34; Similitud (producto punto): {similitud_documentos_producto_punto}\u0026#34;) similitud_documentos_coseno = documento_1.similitud_coseno(documento_2) print(f\u0026#34; Similitud entre documentos (coseno): {similitud_documentos_coseno:.3f}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: demo_operaciones_vectoriales() Al ejecutar el código anterior obtenemos:\n\u0026gt; python vector.py ################################### Ejemplos de Operaciones Vectoriales ################################### === Ejemplo 1: Preferencias de usuarios === Cada usuario se corresponde con un vector que mapea sus preferencias en películas Vector([acción, comedia, drama]) Usuario 0: Vector([4, 2, 5]) Cálculos de similitud con el usuario 1 Suma: preferencias combinadas: Vector([7, 6, 7]) Similitud (producto punto): 30 Similitud coseno: 0.830 Cálculos de similitud con el usuario 2 Suma: preferencias combinadas: Vector([13, 3, 7]) Similitud (producto punto): 48 Similitud coseno: 0.772 Cálculos de similitud con el usuario 3 Suma: preferencias combinadas: Vector([7, 10, 6]) Similitud (producto punto): 33 Similitud coseno: 0.572 Cálculos de similitud con el usuario 4 Suma: preferencias combinadas: Vector([5, 4, 14]) Similitud (producto punto): 53 Similitud coseno: 0.852 Usuario 1: Vector([3, 4, 2]) Cálculos de similitud con el usuario 2 Suma: preferencias combinadas: Vector([12, 5, 4]) Similitud (producto punto): 35 Similitud coseno: 0.701 Cálculos de similitud con el usuario 3 Suma: preferencias combinadas: Vector([6, 12, 3]) Similitud (producto punto): 43 Similitud coseno: 0.928 Cálculos de similitud con el usuario 4 Suma: preferencias combinadas: Vector([4, 6, 11]) Similitud (producto punto): 29 Similitud coseno: 0.581 Usuario 2: Vector([9, 1, 2]) Cálculos de similitud con el usuario 3 Suma: preferencias combinadas: Vector([12, 9, 3]) Similitud (producto punto): 37 Similitud coseno: 0.464 Cálculos de similitud con el usuario 4 Suma: preferencias combinadas: Vector([10, 3, 11]) Similitud (producto punto): 29 Similitud coseno: 0.337 Usuario 3: Vector([3, 8, 1]) Cálculos de similitud con el usuario 4 Suma: preferencias combinadas: Vector([4, 10, 10]) Similitud (producto punto): 28 Similitud coseno: 0.351 Usuario 4: Vector([1, 2, 9]) === Ejemplo 2: Análisis de Documentos === Cada documento se corresponde con un vector que mapea las frecuencias de las palabras que contiene Vector([frecuencia_palabra_1, frecuencia_palabra_2, frecuencia_palabra_3, frecuencia_palabra_4]) Documento 1: Vector([2, 1, 0, 3]) Documento 2: Vector([1, 2, 1, 2]) Similitud (producto punto): 10 Similitud entre documentos (coseno): 0.845 Matrices: transformaciones de datos # Si los vectores representan datos, las matrices representan transformaciones de esos datos. Una matriz es una tabla rectangular de números organizados en filas y columnas.\n$$\\mathbf{A} = \\begin{pmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ a_{m1} \u0026 a_{m2} \u0026 \\cdots \u0026 a_{mn} \\end{pmatrix}$$En machine learning, las matrices son omnipresentes:\nDataset: Cada fila es un ejemplo, cada columna una característica Pesos de red neuronal: Transforman entradas en salidas Transformaciones: Rotación, escalado, proyección de datos Multiplicación Matriz-Vector # Esta es la operación más común en ML. Transforma un vector usando una matriz:\n$$\\mathbf{A}\\mathbf{v} = \\begin{pmatrix} \\sum_{i=1}^{n} a_{1i} v_i \\\\ \\sum_{i=1}^{n} a_{2i} v_i \\\\ \\sum_{i=1}^{n} a_{3i} v_i \\\\ \\vdots \\\\ \\sum_{i=1}^{n} a_{mi} v_i \\\\ \\end{pmatrix}$$$$\\mathbf{A}\\mathbf{v} = \\begin{pmatrix} a_{11} \u0026 a_{12} \u0026 a_{13} \u0026 \\cdots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 a_{33} \u0026 \\cdots \u0026 a_{2n} \\\\ a_{31} \u0026 a_{32} \u0026 a_{33} \u0026 \\cdots \u0026 a_{3n} \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ a_{m1} \u0026 a_{m2} \u0026 a_{m3} \u0026 \\cdots \u0026 a_{mn} \\\\ \\end{pmatrix} \\cdot \\begin{pmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ \\vdots \\\\ v_n \\end{pmatrix}$$$$\\mathbf{A}\\mathbf{v} = \\begin{pmatrix} a_{11} \\cdot v_1 + a_{12} \\cdot v_2 + a_{13} \\cdot v_3 + \\cdots + a_{1n} \\cdot v_n \\\\ a_{21} \\cdot v_1 + a_{22} \\cdot v_2 + a_{23} \\cdot v_3 + \\cdots + a_{2n} \\cdot v_n \\\\ a_{31} \\cdot v_1 + a_{32} \\cdot v_2 + a_{33} \\cdot v_3 + \\cdots + a_{3n} \\cdot v_n \\\\ \\vdots \\\\ a_{m1} \\cdot v_1 + a_{m2} \\cdot v_2 + a_{m3} \\cdot v_3 + \\cdots + a_{mn} \\cdot v_n \\\\ \\end{pmatrix}$$Cuando se multiplica una matriz por un vector, es necesario que el número de elementos del vector coincida con el número de columnas de la matriz. Si no es así, la multiplicación no está definida.\nEjemplo práctico: En una red neuronal, cada capa aplica una transformación lineal:\nsalida = pesos × entrada + sesgo Si aún no lo notaste, se puede establecer una conexión entre la multiplicación de una matriz por un vector y el producto punto entre vectores.\nLa conexión es directa: multiplicar una matriz por un vector es, en el fondo, hacer varios productos punto seguidos.\nSi \\(A\\) es una matriz de \\(m \\times n\\) y \\(v\\) es un vector de dimensión \\(n\\), el resultado de \\(A \\ v\\) es un vector de dimensión \\(m\\) donde cada componente se obtiene haciendo el producto punto de una fila de la matriz con el vector.\n$$(A \\ v)_j = fila_j(A) \\cdot v$$ Multiplicación Matriz-Matriz # Para que el producto de dos matrices \\(A\\) y \\(B\\) es decir, \\(AB\\) esté definido, la matriz \\(A\\) debe tener el mismo número de columnas que la matriz \\(B\\) tenga de filas. Si \\(A\\) es de tamaño \\(m x n\\) y \\(B\\) es de tamaño \\(n x p\\), entonces el resultado \\(C = AB\\) será una matriz de tamaño \\(m x p\\).\n$$\\mathbf{C} = \\mathbf{A}\\mathbf{B} = \\begin{pmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\\\ a_{31} \u0026 a_{32} \u0026 \\cdots \u0026 a_{3n} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ a_{m1} \u0026 a_{m2} \u0026 \\cdots \u0026 a_{mn} \\\\ \\end{pmatrix} \\cdot \\begin{pmatrix} b_{11} \u0026 b_{12} \u0026 \\cdots \u0026 b_{1p} \\\\ b_{21} \u0026 b_{22} \u0026 \\cdots \u0026 b_{2p} \\\\ b_{31} \u0026 b_{32} \u0026 \\cdots \u0026 b_{3p} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ b_{n1} \u0026 b_{n2} \u0026 \\cdots \u0026 b_{np} \\\\ \\end{pmatrix}$$$$\\mathbf{C} = \\mathbf{A}\\mathbf{B} = \\begin{pmatrix} \\sum_{k=1}^{n} a_{1k} b_{k1} \u0026 \\sum_{k=1}^{n} a_{1k} b_{k2} \u0026 \\cdots \u0026 \\sum_{k=1}^{n} a_{1k} b_{kp} \\\\ \\sum_{k=1}^{n} a_{2k} b_{k1} \u0026 \\sum_{k=1}^{n} a_{2k} b_{k2} \u0026 \\cdots \u0026 \\sum_{k=1}^{n} a_{2k} b_{kp} \\\\ \\sum_{k=1}^{n} a_{3k} b_{k1} \u0026 \\sum_{k=1}^{n} a_{3k} b_{k2} \u0026 \\cdots \u0026 \\sum_{k=1}^{n} a_{3k} b_{kp} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\sum_{k=1}^{n} a_{mk} b_{k1} \u0026 \\sum_{k=1}^{n} a_{mk} b_{k2} \u0026 \\cdots \u0026 \\sum_{k=1}^{n} a_{mk} b_{kp} \\\\ \\end{pmatrix}$$Es decir, cada elemento \\(ij\\) de la matriz resultado (\\(C\\)) será:\n$$\\mathbf{C}_{ij} = (\\mathbf{AB})_{ij} = \\sum_{k=1}^{n} a_{ik} b_{kj}$$Esta operación permite componer transformaciones lineales.\nNuevamente, la multiplicación de matrices está muy relacionada con el producto punto de vectores.\nEn la multiplicación entre las matrices \\(A(m \\times n)\\) por \\(B(n \\times p)\\), el elemento \\(c_{ij}\\) de la matriz resultado \\(C\\) se obtiene como:\n$$\\mathbf{C}_{ij} = \\sum_{k=1}^{n} a_{ik} b_{kj}$$Esto es exactamente el producto punto entre la fila \\(i\\) de \\(A\\) y la columna \\(j\\) de \\(B\\).\n$$\\mathbf{C}_{ij} = a_{i} \\cdot b_{j}$$ Implementación desde cero: clase Matriz # import math from typing import List from vector import Vector class Matriz: \u0026#34;\u0026#34;\u0026#34; Implementación básica de una matriz matemática. Esta clase nos ayuda a entender las operaciones matriciales fundamentales en Machine Learning. \u0026#34;\u0026#34;\u0026#34; def __init__(self, datos: List[List[float]]): \u0026#34;\u0026#34;\u0026#34; Inicializa una matriz con una lista de listas. Args: datos: Lista de filas, donde cada fila es una lista de números \u0026#34;\u0026#34;\u0026#34; if not datos or not datos[0]: raise ValueError(\u0026#34;La matriz debe tener al menos un elemento\u0026#34;) # Verificar que todas las filas tengan la misma longitud longitud_fila = len(datos[0]) for fila in datos: if len(fila) != longitud_fila: raise ValueError(\u0026#34;Todas las filas deben tener la misma longitud\u0026#34;) self.datos = datos self.filas = len(datos) self.columnas = len(datos[0]) self.forma = (self.filas, self.columnas) def __repr__(self): \u0026#34;\u0026#34;\u0026#34;Representación legible de la matriz.\u0026#34;\u0026#34;\u0026#34; filas = [] for fila in self.datos: row_str = \u0026#34; \u0026#34;.join(f\u0026#34;{x:8.3f}\u0026#34; for x in fila) filas.append(f\u0026#34;[{row_str}]\u0026#34;) return f\u0026#34;Matriz(\\n \u0026#34; + \u0026#34;\\n \u0026#34;.join(filas) + \u0026#34;\\n)\u0026#34; def __getitem__(self, indices): \u0026#34;\u0026#34;\u0026#34;Permite acceso con matriz[i][j] o matriz[i, j].\u0026#34;\u0026#34;\u0026#34; if isinstance(indices, tuple): fila, columna = indices return self.datos[fila][columna] else: return self.datos[indices] def __setitem__(self, indices, value): \u0026#34;\u0026#34;\u0026#34;Permite asignación con matriz[i][j] = value.\u0026#34;\u0026#34;\u0026#34; if isinstance(indices, tuple): fila, columna = indices self.datos[fila][columna] = value else: fila = indices self.datos[fila] = value def __add__(self, otra): \u0026#34;\u0026#34;\u0026#34;Suma de matrices (elemento por elemento).\u0026#34;\u0026#34;\u0026#34; if self.forma != otra.shape: raise ValueError(\u0026#34;Las matrices deben tener la misma forma\u0026#34;) datos_resultado = [ [self.datos[i][j] + otra.datos[i][j] for j in range(self.columnas)] for i in range(self.filas) ] return Matriz(datos_resultado) def trasponer(self): \u0026#34;\u0026#34;\u0026#34; Calcula la transpuesta de la matriz. La transpuesta intercambia filas por columnas. Es fundamental en álgebra lineal y en Machine Learning. Returns: Matriz: Nueva matriz transpuesta \u0026#34;\u0026#34;\u0026#34; datos_transpuestos = [ [self.datos[fila][columna] for fila in range(self.filas)] for columna in range(self.columnas) ] return Matriz(datos_transpuestos) def multiplicar_por_escalar(self, escalar): \u0026#34;\u0026#34;\u0026#34;Multiplicación por escalar.\u0026#34;\u0026#34;\u0026#34; datos_resultado = [ [escalar * self.datos[i][j] for j in range(self.columnas)] for i in range(self.filas) ] return Matriz(datos_resultado) def multiplicar_por_vector(self, vector: Vector): \u0026#34;\u0026#34;\u0026#34; Multiplica la matriz por un vector. Esta es la operación fundamental en redes neuronales: cada capa aplica una transformación lineal Ax + b. Args: vector: Vector a multiplicar Returns: Vector: Resultado de la multiplicación \u0026#34;\u0026#34;\u0026#34; if self.columnas != len(vector): raise ValueError(f\u0026#34;Dimensiones incompatibles: matriz {self.forma} * vector {len(vector)}\u0026#34;) componentes_resultado = [] for index_fila in range(self.filas): fila = [ self.datos[index_fila][columna] for columna in range(self.columnas) ] producto_punto = Vector(fila).producto_punto(vector) componentes_resultado.append(producto_punto) return Vector(componentes_resultado) def multiplicar_matrices(self, otra): \u0026#34;\u0026#34;\u0026#34; Multiplica dos matrices. La multiplicación de matrices permite componer transformaciones. En deep learning, representa la composición de capas. Args: otra: Otra matriz Returns: Matriz: Resultado de la multiplicación \u0026#34;\u0026#34;\u0026#34; if self.columnas != otra.filas: raise ValueError(f\u0026#34;Dimensiones incompatibles: {self.forma} * {otra.forma}\u0026#34;) print(f\u0026#34; Forma matriz A: {self.forma}\u0026#34;) print(f\u0026#34; Forma matriz B: {otra.forma}\u0026#34;) datos_resultado = [] for index_fila in range(self.filas): fila_i_matriz = [ self.datos[index_fila][columna] for columna in range(self.columnas) ] vector_fila_i_matriz = Vector(fila_i_matriz) fila_resultado = [] for index_columna_otra in range(otra.columnas): columna_j_matriz_otra = [ otra.datos[fila][index_columna_otra] for fila in range(otra.filas) ] vector_columna_j_matriz_otra = Vector(columna_j_matriz_otra) fila_resultado.append(vector_fila_i_matriz.producto_punto(vector_columna_j_matriz_otra)) datos_resultado.append(fila_resultado) return Matriz(datos_resultado) @staticmethod def identidad(tamano: int): \u0026#34;\u0026#34;\u0026#34; Crea una matriz identidad de tamaño size * size. La matriz identidad es el \u0026#34;1\u0026#34; de las matrices: A * I = I * A = A Args: tamano: Tamaño de la matriz cuadrada Returns: Matriz: Matriz identidad \u0026#34;\u0026#34;\u0026#34; datos = [ [1.0 if i == j else 0.0 for j in range(tamano)] for i in range(tamano) ] return Matriz(datos) def rotar_vector(vector: Vector, angulo: int): \u0026#34;\u0026#34;\u0026#34;Rotar vector\u0026#34;\u0026#34;\u0026#34; angulo_radianes = angulo * math.pi / 180 # angulo en grados convertido a radianes matriz_transformacion = Matriz([ [math.cos(angulo_radianes), -math.sin(angulo_radianes)], [math.sin(angulo_radianes), math.cos(angulo_radianes)] ]) return { \u0026#34;matriz_transformacion\u0026#34;: matriz_transformacion, \u0026#34;vector_rotado\u0026#34;: matriz_transformacion.multiplicar_por_vector(vector) } # Ejemplos de uso def demo_operaciones_matriciales(): \u0026#34;\u0026#34;\u0026#34; Demuestra las operaciones matriciales con ejemplos de Machine Learning. \u0026#34;\u0026#34;\u0026#34; mensaje = \u0026#34;Ejemplos de Operaciones Matriciales\u0026#34; print(\u0026#34;#\u0026#34; * len(mensaje)) print(mensaje) print(\u0026#34;#\u0026#34; * len(mensaje)) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;=== Ejemplo 1: Transponer ===\u0026#34;) datos = Matriz([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ]) print(datos) print(\u0026#34;Transponer...\u0026#34;) print(datos.trasponer()) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;=== Ejemplo 2: Multiplicación matriz por escalar ===\u0026#34;) print(datos) escalar = 3 print(f\u0026#34;Multiplicación por el escalar: {escalar}...\u0026#34;) print(datos.multiplicar_por_escalar(escalar)) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;=== Ejemplo 3: Multiplicación matriz por vector ===\u0026#34;) print(datos) vector = Vector([1.0, 2.0, 3.0]) print(f\u0026#34;Multiplicación por el vector: {vector}...\u0026#34;) print(datos.multiplicar_por_vector(vector)) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;=== Ejemplo 4: Multiplicación matriz por matriz ===\u0026#34;) print(datos) otra = Matriz([ [9.0, 8.0, 7.0], [6.0, 5.0, 4.0], [3.0, 2.0, 1.0] ]) print(f\u0026#34;Multiplicación por la matriz: {otra}...\u0026#34;) print(datos.multiplicar_matrices(otra)) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;=== Ejemplo 5: Rotación de un vector en 2D ===\u0026#34;) vector_original = Vector([1.0, 0.0]) print(\u0026#34;\\n\u0026#34;) angulo = 45 rotacion = rotar_vector(vector_original, angulo) print(f\u0026#34;Vector original en 2D: {vector_original}\u0026#34;) print(f\u0026#34;Matriz de rotacion en {angulo} grados: {rotacion[\u0026#34;matriz_transformacion\u0026#34;]}\u0026#34;) print(f\u0026#34;Vector rotado en {angulo} grados: {rotacion[\u0026#34;vector_rotado\u0026#34;]}\u0026#34;) print(\u0026#34;\\n\u0026#34;) angulo = 90 rotacion = rotar_vector(vector_original, angulo) print(f\u0026#34;Vector original en 2D: {vector_original}\u0026#34;) print(f\u0026#34;Matriz de rotacion en {angulo} grados: {rotacion[\u0026#34;matriz_transformacion\u0026#34;]}\u0026#34;) print(f\u0026#34;Vector rotado en {angulo} grados: {rotacion[\u0026#34;vector_rotado\u0026#34;]}\u0026#34;) print(\u0026#34;\\n\u0026#34;) angulo = 180 rotacion = rotar_vector(vector_original, angulo) print(f\u0026#34;Vector original en 2D: {vector_original}\u0026#34;) print(f\u0026#34;Matriz de rotacion en {angulo} grados: {rotacion[\u0026#34;matriz_transformacion\u0026#34;]}\u0026#34;) print(f\u0026#34;Vector rotado en {angulo} grados: {rotacion[\u0026#34;vector_rotado\u0026#34;]}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: demo_operaciones_matriciales() Al ejecutar el código anterior obtenemos:\n\u0026gt; python matriz.py ################################### Ejemplos de Operaciones Matriciales ################################### === Ejemplo 1: Transponer === Matriz( [ 1.000 2.000 3.000] [ 4.000 5.000 6.000] [ 7.000 8.000 9.000] ) Transponer... Matriz( [ 1.000 4.000 7.000] [ 2.000 5.000 8.000] [ 3.000 6.000 9.000] ) === Ejemplo 2: Multiplicación matriz por escalar === Matriz( [ 1.000 2.000 3.000] [ 4.000 5.000 6.000] [ 7.000 8.000 9.000] ) Multiplicación por el escalar: 3... Matriz( [ 3.000 6.000 9.000] [ 12.000 15.000 18.000] [ 21.000 24.000 27.000] ) === Ejemplo 3: Multiplicación matriz por vector === Matriz( [ 1.000 2.000 3.000] [ 4.000 5.000 6.000] [ 7.000 8.000 9.000] ) Multiplicación por el vector: Vector([1.0, 2.0, 3.0])... Vector([14.0, 32.0, 50.0]) === Ejemplo 4: Multiplicación matriz por matriz === Matriz( [ 1.000 2.000 3.000] [ 4.000 5.000 6.000] [ 7.000 8.000 9.000] ) Multiplicación por la matriz: Matriz( [ 9.000 8.000 7.000] [ 6.000 5.000 4.000] [ 3.000 2.000 1.000] )... Forma matriz A: (3, 3) Forma matriz B: (3, 3) Matriz( [ 30.000 24.000 18.000] [ 84.000 69.000 54.000] [ 138.000 114.000 90.000] ) === Ejemplo 5: Rotación de un vector en 2D === Vector original en 2D: Vector([1.0, 0.0]) Matriz de rotacion en 45 grados: Matriz( [ 0.707 -0.707] [ 0.707 0.707] ) Vector rotado en 45 grados: Vector([0.7071067811865476, 0.7071067811865475]) Vector original en 2D: Vector([1.0, 0.0]) Matriz de rotacion en 90 grados: Matriz( [ 0.000 -1.000] [ 1.000 0.000] ) Vector rotado en 90 grados: Vector([6.123233995736766e-17, 1.0]) Vector original en 2D: Vector([1.0, 0.0]) Matriz de rotacion en 180 grados: Matriz( [ -1.000 -0.000] [ 0.000 -1.000] ) Vector rotado en 180 grados: Vector([-1.0, 1.2246467991473532e-16]) Espacios Vectoriales y Transformaciones Lineales # Un espacio vectorial (o espacio lineal) es un conjunto no vacío de vectores, en el que se han definido dos operaciones: la suma de vectores y la multiplicación de un vector por un escalar (número real o complejo). Para que un conjunto sea considerado un espacio vectorial, debe cumplir con ciertos axiomas fundamentales.\nConmutatividad: \\(u + v = v + u\\)\nAsociatividad: \\((u + v) + w = u + (v + w)\\)\nExistencia del vector nulo: \\(\\exists \\ v_0 \\in V \\ \\;|\\; \\ v_0 + u = u \\ \\forall \\ u \\in V \\)\nExistencia del opuesto: \\(\\forall \\ v_i \\in V \\ \\exists \\ -v_i \\in V \\ \\;|\\; \\ v_i + (-v_i) = 0\\)\nDistributividad del producto respecto a la suma vectorial: \\(\\alpha (u + v) = \\alpha u + \\alpha v\\)\nDistributividad del producto respecto a la suma escalar: \\((\\alpha + \\beta) u = \\alpha u + \\beta u\\)\nAsociatividad del producto de escalares: \\(\\alpha (\\beta u) = (\\alpha \\beta) u\\)\nElemento neutro: \\(1 u = u \\ \\forall \\ u \\in V\\)\nEntre algunos ejemplos de espacios vectoriales podemos mencionar:\nVectores en el plano: Los vectores en \\(\\mathbb{R}^2\\) son un ejemplo clásico de espacio vectorial, donde cada vector se representa como un par ordenado \\((x,y)\\) Vectores en el espacio tridimensional: En \\(\\mathbb{R}^3\\), un vector se puede escribir como \\(V = \\alpha i + \\beta j + \\gamma k \\) donde \\(i\\), \\(j\\) y \\(k\\) son vectores base. Los espacios vectoriales son fundamentales en diversas áreas, incluyendo matemáticas, física, ingeniería y ciencias de la computación, ya que permiten modelar y resolver problemas complejos mediante el uso de vectores y matrices.\n¿Por qué importa en Machine Learning?\nCaracterísticas: Cada dataset define un espacio vectorial Modelos: Los algoritmos de Machine Learning operan en estos espacios Transformaciones: Cambiamos de un espacio a otro para facilitar el aprendizaje Transformaciones lineales # Una transformación \\(T: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m\\) se define como una función que asigna a cada vector \\(v\\) en un espacio vectorial \\(V\\) un único vector \\(w\\) en otro espacio vectorial \\(W\\).\nPara que \\(T\\) sea considerada lineal, debe cumplir dos condiciones fundamentales:\nAdición: Para cualquier par de vectores \\(u\\) y \\(v\\) en \\(V\\), se cumple que: $$ T(u + v) = T(u) + T(v) $$ Homogeneidad: Para cualquier escalar \\(c\\) y cualquier vector \\(v\\) en \\(V\\) se cumple que: $$ T(c \\ v) = c \\ T(v) $$ Toda transformación lineal entre espacios vectoriales de dimensión finita puede representarse mediante una matriz, por ejemplo:\nImaginemos una transformación \\(T: \\mathbb{R}^2 \\rightarrow \\mathbb{R}^2\\) definida por:\n$$T(x,y) = (2x+y,3x-4y)$$En base canónica:\n\\(T(1,0) = (2,3) \\rightarrow \\) primera columna \\(\\begin{pmatrix} 2 \\\\ 3 \\end{pmatrix}\\) \\(T(0,1) = (1,-4) \\rightarrow \\) segunda columna \\(\\begin{pmatrix} 1 \\\\ -4 \\end{pmatrix}\\) La matriz asociada a la transformación \\(T\\) es:\n$$|\\mathbf{T}| = \\begin{pmatrix} 2 \u0026 1 \\\\ 3 \u0026 -4 \\end{pmatrix}$$ La base canónica es un conjunto de vectores que forma una base ortonormal en un espacio vectorial. En el plano, la base canónica está compuesta por los vectores \\(i\\) y \\(j\\), que representan las direcciones de los ejes \\(x\\) e \\(y\\), respectivamente. Estos vectores se utilizan para expresar otros vectores como combinaciones lineales de la base canónica. Además, la base canónica es fundamental para entender la dimensión y la estructura de los espacios vectoriales.\nVectores y valores propios # Los valores propios o autovalores y los vectores propios o autovectores revelan las direcciones \u0026ldquo;especiales\u0026rdquo; de una transformación lineal.\nLos vectores propios o autovectores de una transformación lineal son los vectores no nulos que, cuando son transformados, dan lugar a un múltiplo escalar de sí mismos, con lo que no cambian su dirección. Este escalar \\(\\lambda\\) recibe el nombre de valor propio o autovalor. En muchos casos, una transformación queda completamente determinada por sus vectores propios y valores propios. Un espacio propio o autoespacio asociado al valor propio \\(\\lambda\\) es el conjunto de vectores propios con un valor propio común.\nPara una transformación lineal representada por la matriz \\(\\mathbf{A}\\), un vector \\(\\mathbf{v}\\) es un vector propio con valor propio \\(\\lambda\\) si:\n$$\\mathbf{A}\\mathbf{v} = \\lambda \\mathbf{v}$$Interpretación: La transformación \\(\\mathbf{A}\\) solo escala el vector \\(\\mathbf{v}\\) por el factor \\(\\lambda\\), sin cambiar su dirección.\nImagen de J. Finkelstein y Vb on Wikimedia Commons, dominio público En esta transformación de la Mona Lisa, la imagen se ha deformado de tal forma que su eje vertical no ha cambiado. El vector azul, representado por la flecha azul que va desde el pecho hasta el hombro, ha cambiado de dirección, mientras que el rojo, representado por la flecha roja, no ha cambiado. El vector rojo es entonces un vector propio o autovector de la transformación, mientras que el azul no lo es. Dado que el vector rojo no ha cambiado de longitud, su valor propio o autovalor es \\(1\\). Todos los vectores de esta misma dirección son vectores propios, con el mismo valor propio. Forman un subespacio del espacio propio de este valor propio.\n— Vector, valor y espacio propios. Wikipedia\nAplicaciones en Machine Learning # PCA (Análisis de Componentes Principales): Los vectores propios de la matriz de covarianza muestran las direcciones de mayor varianza en los datos.\nReducción de dimensionalidad: Proyectar datos en los vectores propios principales.\nEstabilidad de sistemas: Los valores propios indican si un sistema dinámico es estable.\nVisualizando valores y vectores propios # Crea un archivo Python con el siguiente contenido:\ndef ver_valores_propios(): \u0026#34;\u0026#34;\u0026#34; Visualiza conceptualmente los valores y los vectores propios. Esta es una simplificación para matrices 2x2. \u0026#34;\u0026#34;\u0026#34; import matplotlib.pyplot as plt import numpy as np # Matriz de ejemplo A = np.array([[3, 1], [0, 2]]) # Calcular valores y vectores propios usando NumPy valores_propios, vectores_propios = np.linalg.eig(A) # Crear varios vectores para mostrar la transformación angles = np.linspace(0, 2*np.pi, 16) vectores_originales = np.array([[np.cos(a), np.sin(a)] for a in angles]) vectores_transformados = np.array([A @ v for v in vectores_originales]) fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5)) # Vectores originales ax1.set_aspect(\u0026#39;equal\u0026#39;) for v in vectores_originales: ax1.arrow(0, 0, v[0], v[1], head_width=0.05, head_length=0.1, fc=\u0026#39;blue\u0026#39;, ec=\u0026#39;blue\u0026#39;, alpha=0.6) # Vectores propios originales for i, (val, vec) in enumerate(zip(valores_propios, vectores_propios.T)): ax1.arrow(0, 0, vec[0], vec[1], head_width=0.1, head_length=0.15, fc=\u0026#39;red\u0026#39;, ec=\u0026#39;red\u0026#39;, linewidth=3, label=f\u0026#39;Vector propio {i+1}\u0026#39;) ax1.set_xlim(-2, 2) ax1.set_ylim(-2, 2) ax1.set_title(\u0026#39;Vectores Originales\u0026#39;) ax1.grid(True) ax1.legend() # Vectores transformados ax2.set_aspect(\u0026#39;equal\u0026#39;) for v in vectores_transformados: ax2.arrow(0, 0, v[0], v[1], head_width=0.05, head_length=0.1, fc=\u0026#39;green\u0026#39;, ec=\u0026#39;green\u0026#39;, alpha=0.6) # Vectores propios transformados (escalados por valor propio) for i, (val, vec) in enumerate(zip(valores_propios, vectores_propios.T)): vectores_propios_transformados = val * vec ax2.arrow(0, 0, vectores_propios_transformados[0], vectores_propios_transformados[1], head_width=0.1, head_length=0.15, fc=\u0026#39;red\u0026#39;, ec=\u0026#39;red\u0026#39;, linewidth=3, label=f\u0026#39;λ{i+1}={val:.1f} × eigenvec{i+1}\u0026#39;) ax2.set_xlim(-4, 4) ax2.set_ylim(-4, 4) ax2.set_title(\u0026#39;Vectores Transformados por A\u0026#39;) ax2.grid(True) ax2.legend() plt.tight_layout() plt.show() print(f\u0026#34;Valores propios: {valores_propios}\u0026#34;) print(f\u0026#34;Vectores propios:\\n{vectores_propios}\u0026#34;) ver_valores_propios() Lo ejecutamos\u0026hellip;\nvirtualenv venv source venv/bin/activate pip install numpy pip install matplotlib python valores_vectores_propios.py y obtenemos:\nVisualizando vectores propios con Python Implementación práctica: un sistema de recomendaciones usando álgebra lineal # En el siguiente artículo de este módulo, vamos a actualizar nuestro sistema de recomendaciones para utilizar los conceptos de álgebra lineal que aprendimos hasta acá.\n¡Nos vemos allí! 🚀\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"12 September 2025","externalUrl":null,"permalink":"/ai/module2/algebra/","section":"Inteligencia Artificial","summary":"","title":"Álgebra Lineal para Machine Learning: vectores y matrices que todo ingeniero en IA debe conocer","type":"ai"},{"content":"","date":"04 September 2025","externalUrl":null,"permalink":"/ai/module1/","section":"Inteligencia Artificial","summary":"","title":"Fundamentos de Inteligencia Artificial para Programadores","type":"ai"},{"content":" Bienvenido al primer módulo para convertirte en un ingeniero en IA. Si llegaste hasta aquí, es porque ya dominas Python y tienes experiencia como software engineer, pero el mundo de la inteligencia artificial te resulta un territorio desconocido. No te preocupes: estás exactamente donde necesitas estar.\nDurante los próximos módulos, vamos a transformar tus habilidades de programación en expertise en inteligencia artificial. No vamos a tomar atajos ni a usar \u0026ldquo;soluciones mágicas\u0026rdquo;, cada concepto será explicado desde sus fundamentos hasta su implementación práctica.\n¿Por qué necesitas entender los fundamentos? # Como programador, probablemente has escuchado términos como \u0026ldquo;IA\u0026rdquo;, \u0026ldquo;Machine Learning\u0026rdquo; y \u0026ldquo;Deep Learning\u0026rdquo; lanzados como sinónimos. Tal vez has visto demos impresionantes de ChatGPT o has leído sobre coches autónomos. Pero hay una diferencia enorme entre usar una API y realmente entender cómo funciona la tecnología por debajo.\nUn ingeniero en IA no es solo alguien que conecta APIs de OpenAI. Es un profesional que:\nEntiende cuándo y por qué usar cada técnica de IA Puede diagnosticar y resolver problemas en sistemas de ML Diseña arquitecturas de datos y modelos desde cero Evalúa críticamente el rendimiento y las limitaciones Implementa soluciones éticas y responsables Objetivos de este primer módulo # Al finalizar este módulo, vas a poder:\nDistinguir claramente entre IA, Machine Learning y Deep Learning Identificar qué tipo de problema requiere cada enfoque Implementar tu primer sistema inteligente usando lógica de reglas Entender los fundamentos teóricos que sustentan todas las técnicas avanzadas Crear un sistema de recomendaciones básico desde cero No vamos a usar bibliotecas complejas como TensorFlow o PyTorch todavía. Vamos a construir todo con Python puro para que entiendas realmente qué está pasando.\nTeoría fundamental: desenmascarando la IA # IA, Machine Learning y Deep Learning: aclarando la confusión # Empecemos destruyendo algunos mitos. Estos tres términos no son sinónimos, aunque a menudo se usan como si lo fueran.\nInteligencia Artificial (IA): el concepto más amplio # La Inteligencia Artificial es cualquier técnica que permite a las máquinas imitar el comportamiento inteligente humano. Esto incluye desde un simple sistema de reglas hasta las redes neuronales más complejas.\nImagina que estás construyendo un sistema para diagnosticar enfermedades. Si escribes:\ndef diagnosticar_gripe(temperatura: float, dolor_cabeza: bool, fatiga: bool): if temperatura \u0026gt; 38.0 and dolor_cabeza and fatiga: return \u0026#34;Posible gripe\u0026#34; return \u0026#34;Síntomas insuficientes\u0026#34; ¡Felicitaciones! Acabas de crear un sistema de IA. Es simple, pero es IA porque simula el proceso de razonamiento de un médico.\nMachine Learning: IA que aprende de los datos # Machine Learning es un subconjunto de la IA donde el sistema aprende patrones de los datos en lugar de seguir reglas programadas explícitamente.\nEn lugar de escribir reglas manualmente, le damos al sistema ejemplos:\nPaciente A: temperatura=38.5°, dolor=sí, fatiga=sí → Gripe Paciente B: temperatura=36.8°, dolor=no, fatiga=no → No gripe [\u0026hellip; más ejemplos \u0026hellip;] El sistema aprende automáticamente a identificar los patrones que distinguen gripe de no-gripe.\nDeep Learning: Machine Learning con redes neuronales profundas # Deep Learning es un subconjunto de Machine Learning que usa redes neuronales con múltiples capas (de ahí \u0026ldquo;profundo\u0026rdquo;). Es especialmente poderoso para datos complejos como imágenes, texto y audio.\nUna historia muy breve (pero necesaria) de la IA # Conocer y comprender la historia te ayuda a ver y entender el estado actual del desarrollo de la IA y su futuro.\nLos pioneros 1950s - 1960s Alan Turing propone el Test de Turing (1950) John McCarthy acuña el término Artificial Intelligence (1956) Primeros programas que juegan ajedrez y demuestran teoremas El primer invierno de la IA 1970s - 1980s Las expectativas eran demasiado altas. Los computadores eran lentos y la memoria limitada. La financiación se redujo drásticamente. El renacimiento con Machine Learning 1990s - 2000s Mejores algoritmos (Support Vector Machines, Random Forest) Más datos disponibles con internet Computadoras más poderosas La explosión del Deep Learning 2010s - Presente GPUs permiten entrenar redes neuronales gigantes Big Data proporciona millones de ejemplos de entrenamiento Nuevos Avances como ImageNet (2012) y GPT (2018) Tipos de aprendizaje automático # Como programador, necesitas entender cuándo usar cada enfoque. No existe una solución única para todos los problemas.\nAprendizaje Supervisado # Tienes ejemplos de entrada y salida conocida. El algoritmo aprende a mapear entradas a salidas correctas. Se utiliza cuando tienes datos históricos con respuestas correctas. Algunos ejemplos comunes de uso:\nClasificación de emails (spam/no spam) Predicción de precios de viviendas Diagnóstico médico Reconocimiento de objetos en imágenes La matemática básica: Buscamos una función \\(f\\) tal que \\(f(x) \\approx y\\), donde:\n\\(x\\) = datos de entrada (features) \\(y\\) = resultado conocido (label/target) Aprendizaje No Supervisado # En este caso, solo tienes datos de entrada, sin respuestas correctas. El algoritmo busca patrones ocultos. Se usa cuando quieres explorar datos o encontrar estructura desconocida. Algunos ejemplos comunes:\nSegmentación de clientes Detección de anomalías Compresión de datos Sistemas de recomendación Aprendizaje por Refuerzo # Aquí, el algoritmo aprende mediante prueba y error, recibiendo recompensas o castigos por sus acciones. Se utiliza en problemas secuenciales donde las decisiones afectan el futuro. Por ejemplo:\nJuegos (ajedrez, Go, videojuegos) Trading algorítmico Robots autónomos Optimización de rutas Implementación práctica: tus primeros sistemas inteligentes # En los siguientes artículos de este módulo, veremos algunos ejemplos para que te vayas adentrando en el mundo de la inteligencia artificial y el aprendizaje automático.\n¡Nos vemos allí! 🚀\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"22 August 2025","externalUrl":null,"permalink":"/ai/module1/intro/","section":"Inteligencia Artificial","summary":"","title":"Introducción","type":"ai"},{"content":"Data structures are ways of organizing and storing information in a computer program so that it can be accessed and modified efficiently. As programmers, it is essential to understand the different data structures available and know when to apply each one to optimize the performance and utility of our programs.\nA data structure is a particular way of organizing data in the computer\u0026rsquo;s memory so that it can be used efficiently. Data structures come in many forms, such as arrays, lists, stacks, queues, graphs, trees, hashes, etc.\nEach structure organizes the data according to a specific logical model and supports efficient operations to access, modify, add, and delete elements according to that model. For example, an array organizes elements sequentially in memory to facilitate random access by indices. A linked list connects elements in memory using \u0026ldquo;nodes\u0026rdquo; with references to the next node to facilitate insertion and deletion.\nBy choosing the appropriate data structure for the task to be solved, we can write more efficient programs and reduce computational complexity, using fewer resources like memory and processing.\nData structures help us:\nOrganize large amounts of data to make them easier to access and modify.\nModel complex relationships between data, such as with graphs and trees.\nAccess and modify data efficiently, optimizing performance.\nReuse existing code and data structures instead of having to rewrite solutions from scratch.\nFor example, a program that needs to store thousands of user records benefits from using a hash data structure to associate each user with data like first name, last name, email, etc. This way specific users can be found very quickly without having to iterate over the entire collection.\nAnother example are binary search trees, which allow finding elements very quickly in ordered sets of millions of elements. This is achieved by discarding halves of the tree as the desired element is searched.\nTypes of data structures # There are many types of data structures. Below are some useful categories to classify them.\nAccording to relationship between elements # Linear: Elements are organized sequentially one after the other. For example, arrays, lists, stacks, queues.\nNon-linear: Elements are organized in a hierarchy or graph. This is the case with trees and graphs.\nAccording to element type # Homogeneous: Store a single data type. For example, arrays in a language like Java.\nHeterogeneous: Allow different data types. Objects, records are examples of this classification.\nAccording to access mode # Sequential access: Elements can only be accessed in sequential order. For example, linked lists.\nDirect access: Any element can be accessed directly by its position. Arrays fall into this group.\nAssociative access: Elements are accessed by an associated key. Dictionaries, hashes fall into this category.\nAccording to functionality # Arrays: Fast access to elements by index but difficult to insert/delete.\nLists: Easy to insert/delete anywhere but sequential access is slow.\nStacks: LIFO (Last In First Out) access. Useful for undo/redo.\nQueues: FIFO (First In First Out) access. Useful for event processing.\nTrees: Allow modeling hierarchical relationships like file directories or task dependencies.\nGraphs: Allow modeling interconnectivity networks like maps, social relationships, etc.\nHashes / Dictionaries: Associate elements with unique keys for ultra fast access.\nThis classification is not exhaustive but gives an idea of the diversity of data structures and their different properties that allow us to efficiently model complex problems.\nExample # Let\u0026rsquo;s look at a Python example to see how a data structure is created and used. Suppose we want to represent a print queue where prints are processed in order of arrival (FIFO).\nFirst, we define a PrintQueue class to represent our queue:\nclass PrintQueue: def __init__(self): self.items = [] def enqueue(self, item): self.items.append(item) def dequeue(self): return self.items.pop(0) def is_empty(self): return len(self.items) == 0 Then we use it to add prints and process them in order:\nprint_queue = PrintQueue() print_queue.enqueue(\u0026#34;document1.doc\u0026#34;) print_queue.enqueue(\u0026#34;image3.jpg\u0026#34;) print_queue.enqueue(\u0026#34;presentation.ppt\u0026#34;) while not print_queue.is_empty(): next_item = print_queue.dequeue() print(f\u0026#34;Printing {next_item}\u0026#34;) This will print:\nPrinting document1.doc Printing image3.jpg Printing presentation.ppt With a data structure like the queue we implement FIFO logic in a simple, reusable way. And this is just one example, the possibilities are endless!\nConclusion # Data structures are fundamental programming tools that allow us to optimally organize information to solve complex problems. Knowing the different types of structures available, like arrays, lists, stacks, queues, hashes, graphs, and trees, allows us to build more efficient programs. I hope this introduction has given you some knowledge and tools to start mastering this exciting topic!\n","date":"04 August 2025","externalUrl":null,"permalink":"/en/programming/data-structures/introduction/","section":"Programming","summary":"","title":"Introduction","type":"programming"},{"content":"Object-Oriented Programming (OOP) is a programming paradigm that has become indispensable nowadays. This approach models real-world elements as \u0026ldquo;objects\u0026rdquo; that have properties and behaviours, which allows for more intuitive and maintainable programmes to be created. In this article we will look at the basic concepts of OOP and its advantages over other paradigms like procedural programming. Let\u0026rsquo;s get started!\nThis paradigm is based on two fundamental concepts:\nObjects: entities that combine state (data) and behaviour (operations) in a single unit. For example, a \u0026ldquo;car\u0026rdquo; object would have properties like colour, number of doors, maximum speed, etc. And behaviours like accelerate, brake, steer, etc. Classes: specifications that define the common structure and behaviour of a group of objects. The \u0026ldquo;car\u0026rdquo; class would serve as a template for creating car objects with the same characteristics. As explained by programmer Alan Kay, one of the creators of OOP:\n\u0026ldquo;The big idea is to design programmes in terms of conceptual objects and concepts from the real world. The interfaces with the real world should, therefore, be constructed in terms of these conceptual objects.\u0026rdquo;\nThat is, OOP conceptually models real-world elements to make programming more intuitive.\nProgramming paradigms # Before delving into OOP, it is worth understanding that there are different paradigms or approaches to tackle programming. The main ones are:\nProcedural programming # Ordered sequence of instructions that the programme must follow step-by-step. The focus is on procedures and functions. For example, C is a language geared towards procedural programming.\nProcedural programming is better for:\nSimple problems or sequential algorithms. Code that won\u0026rsquo;t need heavy reusing or expanding. Cases where performance and efficiency are critical. Object-Oriented programming # Model based on objects that contain data and code in cohesive units. The focus is on classes and the interaction between objects. For example, Java and Python are object-oriented languages.\nOOP allows modelling real-world elements more directly, better encapsulating data, and reusing code through inheritance between classes.\nThe main advantages of OOP over procedural programming are:\nModularity: objects group related data and operations, encapsulating internal complexity. This allows working with independent modules. Information hiding: Objects can expose a simple interface and hide internal implementation details. This reduces coupling. Reusability: Classes enable code reuse. An abstract class can inherit to multiple subclasses. Extensibility: We can extend the behaviour of parent classes by creating new subclasses. Conceptual mapping: Objects represent real-world entities, which eases the translation of requirements into code. However, OOP also has disadvantages. According to programmer Paul Graham:\n\u0026ldquo;Object-oriented programming often makes things harder than they need to be.\u0026rdquo;\nFor example, for simple problems OOP can be excessive. And in large projects there is a risk of overusing inheritance and polymorphism, making the code difficult to follow.\nUltimately, OOP is more suitable when:\nThe problem to be modelled has clear, structured entities. We want to reuse encapsulated code in modular classes. We work on systems that need to be easily extended and maintained. ","date":"04 August 2025","externalUrl":null,"permalink":"/en/programming/oop/introduction/","section":"Programming","summary":"","title":"Introduction","type":"programming"},{"content":"At its core, programming is the act of instructing a machine on how to perform a specific task. It\u0026rsquo;s like teaching your dog to fetch, but in this case, the dog is your computer, and the ball might be, let\u0026rsquo;s say, displaying a photo on your screen.\nNow, you might think that programming is just writing lines of code. Programming is actually a broader process that not only includes writing code but also problem-solving, system design, and logical thinking.\nIn the universe of programming, there are high-level and low-level languages. A low-level language, like assembly, is closer to what the machine understands, while a high-level language, such as Python or JavaScript, is more human-friendly. Picture having a conversation: high-level languages are like chatting with a friend over coffee in New York, while low-level languages are like trying to communicate with someone speaking a very specific, localized dialect.\nAdditionally, some programming languages are compiled, while others are interpreted. If a language is compiled, it means it\u0026rsquo;s translated into a machine-understandable language before being executed. On the other hand, interpreted languages are translated in real-time, as they run.\nA brief history of Programming # Programming isn\u0026rsquo;t a new concept. In fact, it\u0026rsquo;s been with us long before computers existed in the form we know today. Devices like the abacus and the astrolabe are early examples of tools we used for intricate calculations.\nHowever, it was with the advent of mechanical machines, like Charles Babbage\u0026rsquo;s Analytical Engine, that the foundation for modern programming was laid. We\u0026rsquo;re talking about the 19th century!\nOver time, landmark languages like Fortran and COBOL emerged. These languages paved the way for the technological revolutions that would follow. With the evolution of languages also came new paradigms: first Procedural, then Object-Oriented, and more recently, Functional.\nToday, we\u0026rsquo;re in a modern era dominated by web, mobile, and cloud programming. Every swipe on your phone or online purchase has lines and lines of code working behind the scenes.\nProgramming today # Programming is the engine of our modern society. From apps for ordering food to advanced artificial intelligence systems aiding medical research, programming is everywhere.\nBeyond simplifying our daily lives, programming has a profound societal impact. It has enabled progress in automation, data analysis, and entertainment. And what\u0026rsquo;s even more exhilarating is that we\u0026rsquo;re just scratching the surface. With upcoming prospects on artificial intelligence, quantum computing and the Internet of Things (IoT), who knows what marvels await us in the programming world?\n","date":"03 August 2025","externalUrl":null,"permalink":"/en/programming/intro/introduction/","section":"Programming","summary":"","title":"Introduction","type":"programming"},{"content":"","date":"03 August 2025","externalUrl":null,"permalink":"/en/programming/intro/","section":"Programming","summary":"","title":"Introduction to Programming","type":"programming"},{"content":" Variables # A variable is a container to store data in the computer\u0026rsquo;s memory. We can think of it as a box with a label. The label is the variable name and inside the box its value is stored.\nTo declare a variable in Python we just write the name and assign a value:\nage = 28 price = 19.95 student = True Variable names must start with letters or underscore, and can only contain letters, numbers and underscores. It is recommended to use meaningful names that represent the purpose of the variable.\nIn Python variables do not need to be declared with a particular type. The type is inferred automatically when assigning the value:\nage = 28 # age is integer type price = 19.95 # price is float type single = True # single is boolean type Once assigned, a variable can change its value at any time:\nage = 30 # We change age to 30 Scope and lifetime # The scope of a variable refers to the parts of the code where it is available. Variables declared outside functions are global and available throughout the file. Variables inside a function are local and only visible within it.\nThe lifetime is the period during which the variable exists in memory. Local variables exist while the function executes, then they are destroyed. Global variables exist while the program is running.\nAssignment # Assignment with the = operator allows changing or initializing a variable\u0026rsquo;s value:\nnumber = 10 number = 20 # Now number is 20 There are also compound assignment operators like += and -= that combine an operation with assignment:\nnumber += 5 # Adds 5 to number (number = number + 5) number -= 2 # Subtracts 2 from number Data types # Data types define what kind of value a variable can store. Python has several built-in types, including:\nNumerical: To store integer, float, and complex numeric values:\ninteger = 10 float = 10.5 complex = 3 + 4j Strings: To store text:\ntext = \u0026#34;Hello World\u0026#34; Boolean: For True or False logical values:\ntrue_variable = True false_variable = False Collections: To store multiple values like lists, tuples and dictionaries:\nLists: Mutable sequences of values:\nlist = [1, 2, 3] Tuples: Immutable sequences of values:\ntuple = (1, 2, 3) Dictionaries: Key-value pair structures:\ndictionary = {\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 20} It is important to choose the data type that best represents the information we want to store.\nOperators # Operators allow us to perform operations with values and variables in Python. Some common operators are:\nArithmetic: +, -, *, /, %, //, **\nComparison: ==, !=, \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;=\nLogical: and, or, not\nAssignment: =, +=, -=, *=, /=\nLet\u0026rsquo;s see concrete examples of expressions using these operators in Python:\n# Arithmetic 5 + 4 # Addition, result 9 10 - 3 # Subtraction, result 7 4 * 5 # Multiplication, result 20 # Comparison 5 \u0026gt; 4 # Greater than, result True 7 \u0026lt; 10 # Less than, result True # Logical True and False # Result False True or False # Result True not True # Result False # Assignment number = 10 number += 5 # Adds 5 to number, equivalent to number = number + 5 Each type of operator works with specific data types. We must use them consistently according to our variable data types.\nType conversions # Sometimes we need to convert one data type to another to perform certain operations. In Python we can convert explicitly or implicitly:\nExplicit: Using functions like int(), float(), str():\nfloat = 13.5 integer = int(float) # converts 13.5 to 13 text = \u0026#34;100\u0026#34; number = int(text) # converts \u0026#34;100\u0026#34; to 100 Implicit: Python automatically converts in some cases:\ninteger = 100 float = 3.5 result = integer + float # result is 103.5, integer converted to float Some conversions can generate data loss or errors:\nfloat = 13.5 integer = int(float) print(integer) # 13, decimals are lost To prevent this we must explicitly choose conversions that make sense for our data.\nConclusion # In this article we reviewed key concepts like variables, operators, data types and conversions in Python. Applying these concepts well will allow you to efficiently manipulate data in your programs. I recommend practising with your own examples to gain experience using these features. Good luck in your Python learning!\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"18 September 2023","externalUrl":null,"permalink":"/en/programming/starting-concepts/variables-data-types/","section":"Programming","summary":"","title":"Variables and Data Types","type":"programming"},{"content":" What is Software? # Several thought leaders in the world of computing have defined software in various ways:\nIan Sommerville1: Computer programs and associated documentation.\nRoger S. Pressman2: A collection of computer programs, procedures, rules, and associated documentation and data.\nAndrew S. Tanenbaum3: A series of instructions that tells a computer what to do.\nGrady Booch4: Set of items or objects that form a configuration that includes programs, documents, and data.\nPeter Denning5: Map of a machine, detailing its possible states, transitions, and the actions for these transitions.\nAnalysing these definitions, common themes emerge: software encompasses instructions, data, associated documentation, and serves as a guiding structure for computer operations. So we can conclude:\nSoftware is a meticulously structured collection of programs, data, and documentation that serves as a guiding blueprint, directing a computer\u0026rsquo;s operations and interactions with users and other systems.\nAlthough we can classify software in many different types, each with its specific function, we can define three primary categories:\nSystem Software: This forms the core of a computer\u0026rsquo;s operation. It includes operating systems like Windows, Linux, and macOS, which manage hardware resources and provide services for application software. Application Software: Tailored for end-users to perform specific tasks, this category ranges from word processors (like Microsoft Word) to graphic design tools (like Adobe Photoshop) and games. Embedded Software: Found within hardware devices such as washing machines, traffic lights, or digital watches, embedded software operates specific functions of these devices. Unlike general-purpose software, it\u0026rsquo;s dedicated to specific tasks or functions. What is Software Engineering? # Several prominent figures have also provided their perspectives on Software Engineering:\nIan Sommerville1: A discipline concerned with all aspects of software production.\nRoger S. Pressman2: Establishment and use of sound engineering principles to obtain economically software that is reliable and works efficiently on real machines.\nFrederick P. Brooks6: The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software.\nBarry W. Boehm7: Aims to produce quality software, software that is delivered on time, within budget, and that satisfies its requirements.\nFritz Bauer8: The establishment and use of sound engineering principles to economically obtain software that is reliable and works on real machines.\nFrom these definitions, we can discern that software engineering integrates principles of engineering, emphasizes systematic methods, seeks reliability and efficiency, and aims for the production of high-quality software that meets its specified requirements. Concluding that\nSoftware Engineering is the disciplined application of engineering principles and systematic methods to design, develop, and maintain reliable and efficient software that economically meets specified requirements and user needs.\nSoftware Engineering should not be confused with Computer Science. While the latter is a discipline that dives deep into the theoretical and mathematical aspects of computing, studying algorithms, computational theory, and more, the first one primarily focuses on designing and building large software systems. It emphasizes practical techniques and methodologies that ensure the production of high-quality, maintainable software.\nWhy it is important to develop quality software # Today, we\u0026rsquo;re surrounded by a digital ecosystem. Software runs our phones, cars, banks, hospitals, and even our homes. This ubiquity underscores its significance. That means that software flaws can have catastrophic outcomes. From banking systems to healthcare applications, the demand for faultless, efficient software is sky-high.\nSoftware Engineering, ensures this vast amount of software is reliable, efficient, and meets user needs. As technology advances at breakneck speed, the role of software engineers becomes even more pivotal, making sure innovations are safe and effective.\nWhether you\u0026rsquo;re using a social media app, making a bank transaction, or checking health diagnostics, remember there\u0026rsquo;s a meticulously engineered software system running behind the scenes, making it all possible.\nReferences # Sommerville, I., 2010. Software Engineering. 9th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPressman, R.S., 2010. Software Engineering: A Practitioner\u0026rsquo;s Approach. 7th ed. McGraw-Hill.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A.S., 2012. Structured Computer Organization. 6th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBooch, G., 2007. Object-Oriented Analysis and Design with Applications. 3rd ed. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDenning, P.J., 2009. The Profession of IT, Beyond Computational Thinking. Communications of the ACM, 52(6).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBrooks, F.P., 1995. The Mythical Man-Month: Essays on Software Engineering. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBoehm, B.W., 1988. A Spiral Model of Software Development and Enhancement. Computer, 21(5).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBauer, F.L., 1972. Software Engineering. Information Processing, 71.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"10 August 2023","externalUrl":null,"permalink":"/en/software-engineering/introduction/","section":"Software Engineering","summary":"","title":"Introduction to Software Engineering","type":"software-engineering"},{"content":"","date":"12 September 2025","externalUrl":null,"permalink":"/ai/module2/","section":"Inteligencia Artificial","summary":"","title":"Matemática para Machine Learning","type":"ai"},{"content":" Vamos a crear un sistema de IA clásica para diagnosticar problemas de rendimiento en aplicaciones web. Este ejemplo te muestra cómo estructurar conocimiento en reglas lógicas. Estructura del sistema # Como se mencionó, vamos a implementar un sistema que diagnostique problemas de rendimiento en aplicaciones web, el primer paso entonces es definir los síntomas que el sistema debe evaluar para emitir un diagnóstico.\nPara este caso sencillo se evaluará, el uso de CPU, uso de memoria RAM, cantidad de conexiones activas en simultáneo, tiempo de respuesta y la cantidad de solicitudes (requests) lentas, por poner un límite, aquellas que demoren más de un segundo en volver con una respuesta.\nCon ello, podemos generar una estructura inicial del sistema y ejecutarla. Es importante validar que el sistema continua funcionando luego de cada cambio.\nclass DiagnosticadorRendimiento: \u0026#34;\u0026#34;\u0026#34; Sistema experto para diagnosticar problemas de rendimiento en aplicaciones web usando reglas lógicas. \u0026#34;\u0026#34;\u0026#34; def __init__(self): # Base de conocimiento: conjunto de reglas de diagnóstico self.reglas = [] def diagnosticar(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Diagnostica problemas basándose en los síntomas reportados. Args: sintomas (dict): Diccionario con métricas del sistema - tiempo_respuesta: tiempo promedio en segundos - uso_memoria: porcentaje de memoria utilizada - queries_lentas: número de queries que tardan \u0026gt;1s - conexiones_activas: número de conexiones simultáneas - uso_cpu: porcentaje de CPU utilizada Returns: list: Lista de diagnósticos posibles con sus certezas \u0026#34;\u0026#34;\u0026#34; diagnosticos = [] # Evaluamos cada regla en nuestra base de conocimiento for regla in self.reglas: resultado = regla(sintomas) if resultado: diagnosticos.append(resultado) # Ordenamos por nivel de certeza (mayor a menor) diagnosticos.sort(key=lambda x: x[\u0026#39;certeza\u0026#39;], reverse=True) return diagnosticos # Ejemplo de uso del sistema experto if __name__ == \u0026#34;__main__\u0026#34;: # Creamos una instancia de nuestro diagnosticador diagnosticador = DiagnosticadorRendimiento() # Recibimos del usuario los valores de cada metrica print(\u0026#34;=\u0026#34; * 50) print(\u0026#34;Ingrese los valores de rendimiento del sistema\u0026#34;) cpu = int(input(\u0026#34;Porcentaje de CPU utilizada(int): \u0026#34;)) memoria = int(input(\u0026#34;Porcentaje de memoria utilizada(int): \u0026#34;)) tiempo_de_respuesta = float(input(\u0026#34;Cantidad de segundos en promedio para recibir una respuesta(float): \u0026#34;)) queries_lentas = int(input(\u0026#34;Cantidad de queries tardan más de 1 segundo(int): \u0026#34;)) conexiones_activas = int(input(\u0026#34;Cantidad de conexiones simultáneas(int): \u0026#34;)) # Simulamos métricas de un servidor con problemas metricas_servidor = { \u0026#39;tiempo_respuesta\u0026#39;: tiempo_de_respuesta, \u0026#39;uso_memoria\u0026#39;: memoria, \u0026#39;queries_lentas\u0026#39;: queries_lentas, \u0026#39;conexiones_activas\u0026#39;: conexiones_activas, \u0026#39;uso_cpu\u0026#39;: cpu } # Realizamos el diagnóstico print(\u0026#34;=\u0026#34; * 50) print(\u0026#34;DIAGNÓSTICO DEL SISTEMA\u0026#34;) print(\u0026#34;=\u0026#34; * 50) resultados = diagnosticador.diagnosticar(metricas_servidor) if not resultados: print(\u0026#34;No se detectaron problemas significativos\u0026#34;) else: for i, diagnostico in enumerate(resultados, 1): print(f\u0026#34;\\n#{i} - {diagnostico[\u0026#39;problema\u0026#39;]}\u0026#34;) print(f\u0026#34;Certeza: {diagnostico[\u0026#39;certeza\u0026#39;]:.1%}\u0026#34;) print(\u0026#34;Recomendaciones:\u0026#34;) for rec in diagnostico[\u0026#39;recomendaciones\u0026#39;]: print(f\u0026#34; • {rec}\u0026#34;) Al ejecutar el programa, vemos que el sistema dice que no hay problemas significativos. Esto se debe a que el DiagnosticadorRendimiento no tiene ninguna regla implementada, a continuación veremos cómo generar estas reglas que le darán el conocimiento necesario al diagnosticador para emitir un diagnóstico.\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 92 Cantidad de segundos en promedio para recibir una respuesta(float): 4.2 Cantidad de queries tardan más de 1 segundo(int): 15 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== No se detectaron problemas significativos Reglas # Como se observa en el método diagnosticar de la clase DiagnosticadorRendimiento, las reglas son simplemente funciones o métodos de la misma clase, que reciben con argumento un diccionario llamado sintomas que contiene las métricas del sistema definidas anteriormente.\n# Evaluamos cada regla en nuestra base de conocimiento for regla in self.reglas: resultado = regla(sintomas) if resultado: diagnosticos.append(resultado) Para que la función diagnosticar evalúe la regla, esta debe ser incluida en el diccionario de reglas definido en el constructor de la clase.\ndef __init__(self): # Base de conocimiento: conjunto de reglas de diagnóstico self.reglas = [] Se espera además que cada regla retorne un mapa con los campos:\nproblema: posible causa de un mal rendimiento. certeza: nivel de probabilidad de que el problema definido sea el causante de deficiencias en el rendimiento. recomendaciones: acciones que se podrían llevar a cabo para mejorar el rendimiento. Vale aclarar que estas reglas son ficticias y a la hora de generar un sistema experto de este tipo debes definirlas cuidadosamente en base al tipo de problema que intentas resolver y las condiciones de tu sistema.\nUso de CPU # La primera regla que implementaremos tendrá a su cargo determinar si el nivel de uso de CPU representa un problema de rendimiento o no.\nEl primer factor a decidir es que nivel se considera alto para el uso de CPU, por ejemplo \\(80\\%\\). También definimos que cuando el valor supere este límite, la certeza de que el uso de CPU es un problem será por los menos \\(0.85\\) y crecerá hasta \\(1\\) mientras el uso de CPU crezca hasta el \\(100\\%\\).\ndef _regla_cpu(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Regla: Uso de CPU alto puede indicar procesamiento intensivo o algoritmos ineficientes. \u0026#34;\u0026#34;\u0026#34; if sintomas.get(\u0026#39;uso_cpu\u0026#39;, 0) \u0026gt; 80: certeza = min(0.85, sintomas[\u0026#39;uso_cpu\u0026#39;] / 100) return { \u0026#39;problema\u0026#39;: \u0026#39;Procesamiento intensivo o algoritmos ineficientes\u0026#39;, \u0026#39;certeza\u0026#39;: certeza, \u0026#39;recomendaciones\u0026#39;: [ \u0026#39;Analizar el código para identificar cuellos de botella\u0026#39;, \u0026#39;Optimizar algoritmos, por ejemplo, aquellos O(n²) o peores\u0026#39;, \u0026#39;Implementar una cache para cálculos repetitivos\u0026#39;, \u0026#39;Considerar procesamiento asíncrono para tareas pesadas\u0026#39; ] } return None Ejecutando nuevamente el sistema con un valor de CPU del \\(93\\%\\) se obtiene:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 93 Porcentaje de memoria utilizada(int): 92 Cantidad de segundos en promedio para recibir una respuesta(float): 4.2 Cantidad de queries tardan más de 1 segundo(int): 15 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== #1 - Procesamiento intensivo o algoritmos ineficientes Certeza: 85.0% Recomendaciones: • Analizar el código para identificar cuellos de botella • Optimizar algoritmos, por ejemplo, aquellos O(n²) o peores • Implementar una cache para cálculos repetitivos • Considerar procesamiento asíncrono para tareas pesadas Uso de memoria # Para el caso de la memoria RAM, no solo consideraremos su uso (superior al \\(85\\%\\)) sino que también tenderemos en cuenta el tiempo de respuesta del sistema (mayor a \\(3.0\\) segundos).\ndef _regla_memoria(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Regla: Si el uso de memoria es alto Y el tiempo de respuesta es lento, probablemente hay una fuga (leak) de memoria. \u0026#34;\u0026#34;\u0026#34; if (sintomas.get(\u0026#39;uso_memoria\u0026#39;, 0) \u0026gt; 85 and sintomas.get(\u0026#39;tiempo_respuesta\u0026#39;, 0) \u0026gt; 3.0): # Calculamos certeza basada en qué tan extremos son los valores certeza = min(0.9, (sintomas[\u0026#39;uso_memoria\u0026#39;] / 100) * (sintomas[\u0026#39;tiempo_respuesta\u0026#39;] / 5)) return { \u0026#39;problema\u0026#39;: \u0026#39;Fuga de memoria o uso excesivo de memoria\u0026#39;, \u0026#39;certeza\u0026#39;: certeza, \u0026#39;recomendaciones\u0026#39;: [ \u0026#39;Revisar objetos no liberados en memoria\u0026#39;, \u0026#39;Implementar un grupo de conexiones para evitar abrir y cerrar nuevas\u0026#39;, \u0026#39;Analizar el consumo de memoria (memory_profiler)\u0026#39;, \u0026#39;Considerar aumentar la cantidad de RAM del servidor\u0026#39; ] } return None Veamos como funciona:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 92 Cantidad de segundos en promedio para recibir una respuesta(float): 4.2 Cantidad de queries tardan más de 1 segundo(int): 15 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== #1 - Fuga de memoria o uso excesivo de memoria Certeza: 77.3% Recomendaciones: • Revisar objetos no liberados en memoria • Implementar un grupo de conexiones para evitar abrir y cerrar nuevas • Analizar el consumo de memoria (memory_profiler) • Considerar aumentar la cantidad de RAM del servidor Si el tiempo de respuesta no se ve impactado aunque el consumo de memoria sea alto, obtenemos:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 92 Cantidad de segundos en promedio para recibir una respuesta(float): 2.8 Cantidad de queries tardan más de 1 segundo(int): 15 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== No se detectaron problemas significativos Nivel de concurrencia # De manera similar, implementaremos una regla para controlar la cantidad de conexiones simultaneas al servidor. Demasiadas conexiones pueden saturarlo y hacer que deje de responder. En este ejemplo, definiremos que \\(1000\\) conexiones simultaneas es el límite.\ndef _regla_concurrencia(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Regla: Muchas conexiones simultáneas pueden saturar el servidor. \u0026#34;\u0026#34;\u0026#34; if sintomas.get(\u0026#39;conexiones_activas\u0026#39;, 0) \u0026gt; 1000: certeza = min(0.8, sintomas[\u0026#39;conexiones_activas\u0026#39;] / 2000) return { \u0026#39;problema\u0026#39;: \u0026#39;Sobrecarga por exceso de conexiones concurrentes\u0026#39;, \u0026#39;certeza\u0026#39;: certeza, \u0026#39;recomendaciones\u0026#39;: [ \u0026#39;Implementar rate limiting\u0026#39;, \u0026#39;Usar un balanceador de carga (load balancer) con múltiples instancias\u0026#39;, \u0026#39;Utilizar un grupo de conexiones preestablecidas\u0026#39;, \u0026#39;Implementar colas para procesos no críticos\u0026#39; ] } return None Con la regla anterior, obtenemos los siguientes resultados:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 56 Cantidad de segundos en promedio para recibir una respuesta(float): 2.8 Cantidad de queries tardan más de 1 segundo(int): 15 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== No se detectaron problemas significativos \u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 56 Cantidad de segundos en promedio para recibir una respuesta(float): 2.8 Cantidad de queries tardan más de 1 segundo(int): 15 Cantidad de conexiones simultáneas(int): 1500 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== #1 - Sobrecarga por exceso de conexiones concurrentes Certeza: 75.0% Recomendaciones: • Implementar rate limiting • Usar un balanceador de carga (load balancer) con múltiples instancias • Utilizar un grupo de conexiones preestablecidas • Implementar colas para procesos no críticos Consultas a la base de datos # Una posible causa para recibir respuestas lentas puede ser el tiempo consumido en las consultas a la base de datos. Implementaremos una regla para que el sistema reconozca estos casos.\ndef _regla_base_datos(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Regla: Si hay muchas queries lentas, el problema está en la base de datos. \u0026#34;\u0026#34;\u0026#34; if sintomas.get(\u0026#39;queries_lentas\u0026#39;, 0) \u0026gt; 10: certeza = min(0.95, sintomas[\u0026#39;queries_lentas\u0026#39;] / 50) return { \u0026#39;problema\u0026#39;: \u0026#39;Queries de base de datos ineficientes\u0026#39;, \u0026#39;certeza\u0026#39;: certeza, \u0026#39;recomendaciones\u0026#39;: [ \u0026#39;Revisar índices en tablas frecuentemente consultadas\u0026#39;, \u0026#39;Optimizar queries con EXPLAIN ANALYZE\u0026#39;, \u0026#39;Implementar cache de queries (Redis)\u0026#39;, \u0026#39;Considerar particionado de tablas grandes\u0026#39; ] } return None Lo que nos da resultados como estos:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 56 Cantidad de segundos en promedio para recibir una respuesta(float): 1.5 Cantidad de queries tardan más de 1 segundo(int): 17 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== #1 - Queries de base de datos ineficientes Certeza: 34.0% Recomendaciones: • Revisar índices en tablas frecuentemente consultadas • Optimizar queries con EXPLAIN ANALYZE • Implementar cache de queries (Redis) • Considerar particionado de tablas grandes \u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 56 Cantidad de segundos en promedio para recibir una respuesta(float): 1.5 Cantidad de queries tardan más de 1 segundo(int): 49 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== #1 - Queries de base de datos ineficientes Certeza: 95.0% Recomendaciones: • Revisar índices en tablas frecuentemente consultadas • Optimizar queries con EXPLAIN ANALYZE • Implementar cache de queries (Redis) • Considerar particionado de tablas grandes Estado de la red # Si vemos que el tiempo de respuesta es alto pero CPU y memoria están bien, puede ser un problema de red. A continuación vemos el código para implementar esta regla.\ndef _regla_red(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Regla: Si el tiempo de respuesta es alto pero CPU y memoria están bien, puede ser un problema de red. \u0026#34;\u0026#34;\u0026#34; if (sintomas.get(\u0026#39;tiempo_respuesta\u0026#39;, 0) \u0026gt; 2.0 and sintomas.get(\u0026#39;uso_cpu\u0026#39;, 0) \u0026lt; 50 and sintomas.get(\u0026#39;uso_memoria\u0026#39;, 0) \u0026lt; 70): certeza = 0.7 # Menos certeza porque es por descarte return { \u0026#39;problema\u0026#39;: \u0026#39;Latencia de red o problemas de conectividad\u0026#39;, \u0026#39;certeza\u0026#39;: certeza, \u0026#39;recomendaciones\u0026#39;: [ \u0026#39;Verificar latencia entre servidor y clientes\u0026#39;, \u0026#39;Implementar CDN para recursos estáticos\u0026#39;, \u0026#39;Optimizar tamaño de respuestas (compresión)\u0026#39; ] } return None Con el siguiente resultado:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 56 Cantidad de segundos en promedio para recibir una respuesta(float): 2.8 Cantidad de queries tardan más de 1 segundo(int): 15 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== #1 - Latencia de red o problemas de conectividad Certeza: 70.0% Recomendaciones: • Verificar latencia entre servidor y clientes • Implementar CDN para recursos estáticos • Optimizar tamaño de respuestas (compresión) ¿Qué aprendemos de este ejemplo? # Estructura del conocimiento: Las reglas están separadas en métodos independientes, lo que hace el sistema modular y fácil de mantener.\nManejo de incertidumbre: Cada regla calcula una \u0026ldquo;certeza\u0026rdquo; basada en qué tan extremos son los valores.\nExplicación del razonamiento: El sistema no solo da un diagnóstico, sino que explica por qué llegó a esa conclusión.\nEscalabilidad: Agregar nuevas reglas es tan simple como crear un nuevo método _regla_*.\nCódigo completo # Aquí tienes el código completo del sistema. También puedes encontrarlo en el repositorio de ejemplos haciendo click en el siguiente enlace.\nlearn-software-engineering/examples Programming Course - Examples Python 1 0 ¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"22 August 2025","externalUrl":null,"permalink":"/ai/module1/sample1/","section":"Inteligencia Artificial","summary":"","title":"Machine Learning Ejemplo 1: Sistema Experto","type":"ai"},{"content":"An array is a data structure that represents a set of elements, which are accessed through contiguous numeric indices ranging from 0 to the size of the array minus 1. Arrays provide fast, direct access to elements based on their position.\nIn languages like Python and Ruby, arrays are known as \u0026rsquo;lists\u0026rsquo;. In Javascript they are known as \u0026lsquo;arrays\u0026rsquo;.\nArrays are typically homogeneous, storing elements of the same type like integers, strings, etc. Some languages allow heterogeneous arrays with values of different types.\nDiagram of an array Creating arrays # The way to create arrays varies according to the programming language:\nMY_ARRAY = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] # array literal my_array = list(range(5)) # array from range When creating a literal array its elements are initialized directly. When constructing an empty array its size is specified but its elements are initialized with a default value (0 for numbers, null for objects, etc).\nAccessing and modifying elements # Individual elements are quickly accessed by their index using brackets []:\nmy_array = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] print(my_array[0]) # \u0026#39;a\u0026#39; print(my_array[2]) # \u0026#39;c\u0026#39; my_array[2] = \u0026#39;z\u0026#39; print(my_array[2]) # \u0026#39;z\u0026#39; Indices start at 0, so in an array of size N, valid indices are between 0 and N-1.\nAccessing an invalid index causes an error, for example, accessing index 3 in an array of size 3. This is known as \u0026ldquo;index out of bounds\u0026rdquo;.\nTraversing an array # We can traverse all elements using a for loop:\nletters = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] for i in range(len(letters)): print(letters[i]) This prints each element in order. len() returns the total length of the array.\nAnother way is by directly iterating over the elements:\nletters = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] for letter in letters: print(letter) Searching in an array # We can search for an element in an array using a loop and comparing element by element:\nletters = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] def search_in_array(array, element): for i in range(len(array)): if array[i] == element: return i return False print(search_in_array(letters, \u0026#39;b\u0026#39;)) # 1 print(search_in_array(letters, \u0026#39;z\u0026#39;)) # False It returns the index if found or False if not found.\nMultidimensional array # Arrays can have more than one dimension, for example, 2D matrices, 3D cubes, etc.\nA 2D array can be seen as a table with rows and columns. To access an element two indices are specified, one for the row and one for the column:\nmatrix = [ [1, 2, 3], [4, 5, 6] ] print(matrix[0][2]) # 3 print(matrix[1][0]) # 4 They can have more dimensions, for example a 3D array to represent pixels in an image.\nConclusion # Arrays are fundamental data structures in programming that provide efficient access to elements in memory through numeric indices. Having a good command of arrays, matrices, and their uses is essential for any programmer.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"30 October 2023","externalUrl":null,"permalink":"/en/programming/data-structures/arrays/","section":"Programming","summary":"","title":"Arrays","type":"programming"},{"content":" Anatomy of a class # A class acts as a blueprint or mould to construct similar objects, defining their common characteristics and functionalities. It is similar to the blueprint used to construct houses in the same neighbourhood: they all share certain key attributes.\nThe typical components of a class are:\nAttributes (properties): Variables that characterise the object. For example, for a Person class, attributes like name, age, ID, etc.\nclass Person: id = \u0026#34;\u0026#34; name = \u0026#34;\u0026#34; age = 0 Methods: Functions that define behaviours. For example, a Person can walk(), talk(), eat(), etc. They access the attributes to implement said functionality.\nConstructor: Special __init__() method that executes when instantiating the class and allows initialising attributes.\nDestructor: __del__() method that executes when deleting the instance, freeing up resources. Optional in some languages.\nCreating objects # From the class we generate objects, which are specific instances with their own defined attributes. Let\u0026rsquo;s say the House class is the blueprint, and a specific house on a particular street is the object.\nIn code, we create an object by invoking the class as if it were a method:\n# Person class class Person: def __init__(self, n, a): self.name = n self.age = a # Specific Person objects john = Person(\u0026#34;John\u0026#34;, 30) mary = Person(\u0026#34;Mary\u0026#34;, 35) Each object shares the general structure and behaviour but can store different data.\nUsing properties and methods # We now have a Person class and a john object of type Person. How do we interact with the object?\nProperties: It is possible to access the value of an object attribute using the object reference (john) and the attribute name. john.name # \u0026#34;John\u0026#34; john.age # 30 Methods: Are invoked in the same way as accessing attributes but adding parentheses, and inside them, the arguments that are passed if it takes any. # Person class class Person: def __init__(self, n, a): self.name = n self.age = a def eat(self, food): print(f\u0026#34;Eating {food}\u0026#34;) # Specific Person object john = Person(\u0026#34;John\u0026#34;, 30) john.eat(\u0026#34;pizza\u0026#34;) # Prints \u0026#34;Eating pizza\u0026#34; The john object now has its own state (properties) and behaviour (methods).\nSelf vs This # An important detail in methods is how they access the object\u0026rsquo;s attributes and other methods. Here another difference between languages comes into play:\nSelf: In Python, attributes and methods are accessed within the class by prepending self. This points to the instantiated object. class Person: def __init__(self, name): self.name = name def greet(self): print(f\u0026#34;Hello! I\u0026#39;m {self.name}\u0026#34;) john = Person(\u0026#34;John\u0026#34;) john.greet() # Prints \u0026#34;Hello! I\u0026#39;m John\u0026#34; This: In Java or C#, this is used instead of self. It fulfils the same functionality of pointing to the object\u0026rsquo;s members. public class Person { private String name; public Person(String name) { this.name = name; } public void greet() { System.out.println(\u0026#34;Hello! I\u0026#39;m \u0026#34; + this.name); } } Person john = new Person(\u0026#34;John\u0026#34;); john.greet(); // Prints \u0026#34;Hello! I\u0026#39;m John\u0026#34; Conclusion # Classes and objects are the key concepts in OOP, allowing modelling real-world entities and generating modular, generic components of our system to construct more robust and easy to understand programmes.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"02 October 2023","externalUrl":null,"permalink":"/en/programming/oop/classes-objects/","section":"Programming","summary":"","title":"Classes and objects","type":"programming"},{"content":"","date":"30 September 2023","externalUrl":null,"permalink":"/en/programming/starting-concepts/","section":"Programming","summary":"","title":"Starting Concepts","type":"programming"},{"content":" Screen output # Python also provides functions to send program output to \u0026ldquo;standard output\u0026rdquo;, usually the screen or terminal.\nThe print() function displays the value passed as a parameter:\nname = \u0026#34;Eric\u0026#34; print(name) # displays \u0026#34;Eric\u0026#34; We can print multiple values separated by commas:\nprint(\u0026#34;Hello\u0026#34;, name, \u0026#34;!\u0026#34;) # displays \u0026#34;Hello Eric!\u0026#34; We can also use literal values without assigning to variables:\nprint(\u0026#34;2 + 3 =\u0026#34;, 2 + 3) # displays \u0026#34;2 + 3 = 5\u0026#34; Output formatting # Python provides various ways to format output:\nf-Strings: Allow inserting variables into a string:\nname = \u0026#34;Eric\u0026#34; print(f\u0026#34;Hello {name}\u0026#34;) # displays \u0026#34;Hello Eric\u0026#34; %s: Inserts string text into a format string:\nname = \u0026#34;Eric\u0026#34; print(\u0026#34;Hello %s\u0026#34; % name) # displays \u0026#34;Hello Eric\u0026#34; %d: Inserts integer numbers:\nvalue = 15 print(\u0026#34;The value is %d\u0026#34; % value) # displays \u0026#34;The value is 15\u0026#34; .format(): Inserts values into a format string:\nname = \u0026#34;Eric\u0026#34; print(\u0026#34;Hello {}. Welcome\u0026#34;.format(name)) # displays \u0026#34;Hello Eric. Welcome\u0026#34; These formatting options allow us to interpolate variables and values into text strings to generate custom outputs. We can combine multiple values and formats in a single output string.\nKeyboard input # Python provides built-in functions to read data entered by the user at runtime. This is known as \u0026ldquo;standard input\u0026rdquo;.\nThe input() function allows reading a value entered by the user and assigning it to a variable. For example:\nname = input(\u0026#34;Enter your name: \u0026#34;) This displays the message \u0026ldquo;Enter your name: \u0026quot; and waits for the user to enter text and press Enter. That value is assigned to the name variable.\nThe input() function always returns a string. If we want to ask for a number or other data type, we must convert it using int(), float(), etc:\nage = int(input(\u0026#34;Enter your age: \u0026#34;)) pi = float(input(\u0026#34;Enter the value of pi: \u0026#34;)) Reading multiple values # We can ask for and read multiple values on the same line separating them with commas:\nname, age = input(\u0026#34;Enter name and age: \u0026#34;).split() The split() method divides the input into parts and returns a list of strings. We then assign the list elements to separate variables.\nWe can also read multiple lines of input with a loop:\nnames = [] # empty list for x in range(3): name = input(\u0026#34;Enter a name: \u0026#34;) names.append(name) This code reads 3 names entered by the user and adds them to a list.\nOutput to a file # In addition to printing to the screen, we can write output to a file using the open() function:\nfile = open(\u0026#34;data.txt\u0026#34;, \u0026#34;w\u0026#34;) This opens data.txt for writing (\u0026ldquo;w\u0026rdquo;) and returns a file object.\nThen we use file.write() to write to that file:\nfile.write(\u0026#34;Hello World!\u0026#34;) file.write(\u0026#34;This text goes to the file\u0026#34;) We must close the file with file.close() when finished:\nfile.close() We can also use with to open and automatically close:\nwith open(\u0026#34;data.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: file.write(\u0026#34;Hello World!\u0026#34;) # no need to close, it\u0026#39;s automatic Reading files # To read a file we use open() in \u0026ldquo;r\u0026rdquo; mode and iterate over the file object:\nwith open(\u0026#34;data.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: for line in file: print(line) # prints each line of the file This prints each line, including newlines.\nWe can read all lines to a list with readlines():\nlines = file.readlines() print(lines) To read the full content to a string we use read():\ntext = file.read() print(text) We can also read a specific number of bytes or characters with read(n).\nFile handling operations # There are several built-in functions to handle files in Python:\nopen() - Opens a file and returns a file object close() - Closes the file write() - Writes data to the file read() - Reads data from the file readline() - Reads a line from the file truncate() - Empties the file seek() - Changes the reading/writing position rename() - Renames the file remove() - Deletes the file These allow us to perform advanced operations to read, write and maintain files.\nConclusion # In this article we explained Python input and output operations in detail, including reading from standard input and writing to standard output or files. Properly handling input and output is essential for many Python applications. I recommend practising with your own examples to master these functions.\nReferences # Downey, A. B. (2015). Think Python: How to think like a computer scientist. Needham, Massachusetts: Green Tea Press. McKinney, W. (2018). Python for data analysis: Data wrangling with Pandas, NumPy, and IPython. O\u0026rsquo;Reilly Media. Matthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. No Starch Press. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"19 September 2023","externalUrl":null,"permalink":"/en/programming/starting-concepts/io-operations/","section":"Programming","summary":"","title":"Input and output operations","type":"programming"},{"content":"To the uninitiated, a computer might seem like a mere box—perhaps sometimes sleek and shiny—but a box nonetheless. Yet, within this \u0026ldquo;box\u0026rdquo; lies a universe of complexity and coordination.\nHardware represents the physical components of a computer: the Central Processing Unit (CPU) which is often likened to the brain of the system, the Random Access Memory (RAM) acting as a temporary storage while tasks are underway, storage devices that retain data, and peripherals like keyboards, mice, and monitors.\nOn the other side of this duality is software, a set of instructions that guides the hardware. There are various types of software, from system software like the operating system (OS), which coordinates the myriad hardware components, to application software that allows users to perform specific tasks, such as word processing or gaming.\nThe role of the operating system is pivotal. It acts as a bridge, translating user commands into instructions that the hardware can execute. If the hardware were an orchestra, the OS would be its conductor, ensuring each instrument plays its part harmoniously.\nThe binary system: decoding the language of machines # Human civilizations have developed numerous numbering systems over the millennia, but computers, with their logical circuits, have settled on the binary system. But why binary? Simply put, at the most foundational level, a computer\u0026rsquo;s operation is based on switches (transistors) that can be either \u0026lsquo;on\u0026rsquo; or \u0026lsquo;off\u0026rsquo;, corresponding naturally to the binary digits, or \u0026lsquo;bits\u0026rsquo;, 1 and 0 respectively.\nIn this binary realm, a bit is the smallest data unit, representing a single binary value. A byte, comprising 8 bits, can represent 256 distinct values, ranging from \\(00000000\\) to \\(11111111\\). This binary encoding isn\u0026rsquo;t restricted to numbers; it extends to text, images, and virtually all forms of data. For instance, in ASCII encoding, the capital letter \u0026lsquo;A\u0026rsquo; is represented as \\(01000001\\).\nIn a following post we\u0026rsquo;ll describe in more details the binary system and introduce another system used a lot in relations to computers, the hexadecimal.\nMemory and Storage: the sanctuaries of data # The concepts of memory and storage are pivotal in understanding computer architecture. Though sometimes used interchangeably in colloquial parlance, their roles in a computer system are distinct.\nMemory, particularly RAM, is volatile, meaning information stored is lost once the computer is turned off. RAM serves as the computer\u0026rsquo;s \u0026ldquo;workspace\u0026rdquo;, temporarily storing data and instructions during operations. There are various RAM types, with DRAM and SRAM being the most prevalent.\nContrastingly, Read-Only Memory (ROM) is non-volatile, used predominantly to store firmware—software intrinsically linked to specific hardware, requiring infrequent alterations.\nIn terms of data storage, devices like hard drives, SSDs, and flash drives offer permanent data retention. These storage mechanisms are part of the memory hierarchy, which ranges from the swift but limited cache memory to the expansive but slower secondary storage.\nReferences # Patterson, D. \u0026amp; Hennessy, J. (2014). Computer Organization and Design. Elsevier. Silberschatz, A., Galvin, P. B., \u0026amp; Gagne, G. (2009). Operating System Concepts. John Wiley \u0026amp; Sons. Tanenbaum, A. (2012). Structured Computer Organization. Prentice Hall. Brookshear, J. G. (2011). Computer Science: An Overview. Addison-Wesley. Jacob, B., Ng, S. W., \u0026amp; Wang, D. T. (2007). Memory Systems: Cache, DRAM, Disk. Morgan Kaufmann. Siewiorek, D. P. \u0026amp; Swarz, R. S. (2017). Reliable Computer Systems: Design and Evaluation. A K Peters/CRC Press. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"02 September 2023","externalUrl":null,"permalink":"/en/programming/intro/computers/","section":"Programming","summary":"","title":"Computers","type":"programming"},{"content":" Ahora vamos a crear un clasificador de texto básico usando técnicas estadísticas simples. Esto te muestra los conceptos fundamentales detrás de algoritmos más complejos como Naive Bayes. Imaginá que trabajás en una empresa de software y cada día llegan cientos de tickets de soporte técnico. Algunos reportan errores (bugs), otros solicitan nuevas funcionalidades, y otros simplemente piden ayuda. Manualmente clasificar cada ticket tomaría horas de trabajo.\n¿Sería genial si pudiéramos enseñarle a una computadora a leer estos tickets y clasificarlos automáticamente? Este es exactamente el tipo de problema que resuelve el aprendizaje automático (machine learning).\nPara resolver este problema, implementaremos un Clasificador Bayesiano Ingenuo (Naive Bayes Classifier), uno de los algoritmos más elegantes y comprensibles del aprendizaje automático (machine learning). ¿Por qué es perfecto para empezar?\nEs intuitivo: funciona de manera similar a como los humanos categorizamos Es eficiente: requiere relativamente pocos datos de entrenamiento Es interpretable: podemos entender exactamente por qué toma cada decisión Fundamentos matemáticos: el teorema de Bayes # Antes de sumergirnos en el código, entendamos la base matemática. El teorema de Bayes es una regla matemática que nos para invertir probabilidades condicionadas, permitiendonos encontrar la probabilidad de una causa dado su efecto.\nLa probabilidad condicionada es una medida de la probabilidad de que ocurra un evento, dado que ya se sabe que ha ocurrido otro suceso. Si el suceso de interés es \\(A\\) y se sabe o se supone que ha ocurrido el suceso \\(B\\), la probabilidad condicional de \\(A\\) dado \\(B\\), suele escribirse como:\n$$P(A|B)$$Aunque las probabilidades condicionales pueden proporcionar información muy útil, a menudo se cuenta con información limitada. Por lo tanto, puede ser útil invertir la probabilidad condicional utilizando el teorema de Bayes:\n$$P(A|B) = \\frac{P(B|A) \\cdot P(A)}{P(B)}$$En nuestro contexto:\n\\(A\\) = la categoría (BUG, FEATURE, SUPPORT) \\(B\\) = el texto del ticket Entonces queremos calcular:\n$$P(\\text{categoría}|\\text{texto})$$Es decir, la probabilidad de la categoría de un ticket dado la probabilidad de un determinado texto.\nPara clasificación, podemos simplificar la fórmula a:\n$$P(\\text{categoría}|\\text{texto}) \\propto P(\\text{categoría}) \\cdot P(\\text{texto}|\\text{categoría})$$Siendo:\n\\(P(\\text{categoría}|\\text{texto})\\): la probabilidad de que un ticket corresponda a una determinada categoría dado un texto. \\(P(\\text{categoría})\\): la probabilidad de que un ticket sea clasificado como de una determinada categoría. \\(P(\\text{texto}|\\text{categoría})\\): la probabilidad de que el ticket contenta un determinado texto si pertenece a una categoría. En otras palabras, queremos conocer la probabilidad de que un ticket sea una categoría. Para ello, necesitamos saber la probabilidad de que dicha categoría aplique a un ticket, y la probabilidad con la que determinadas palabras aparecen en los tickets de una determinada categoría.\nEstructura básica del sistema # Comenzaremos definiendo la estructura del sistema, por lado, crearemos una clase que actuará como clasificador y una función main que será la encargada de entrenarlo y de enviarle nuevos tickets para determinar su categoría.\nfrom collections import defaultdict, Counter class ClasificadorTextoBasico: \u0026#34;\u0026#34;\u0026#34; Clasificador de texto usando probabilidades bayesianas básicas. Útil para clasificar emails, reseñas, tickets de soporte, etc. \u0026#34;\u0026#34;\u0026#34; def __init__(self): # Almacena las frecuencias de palabras por categoría self.palabras_por_categoria = defaultdict(Counter) # Almacena cuántos tickets hay por categoría self.tickets_por_categoria = defaultdict(int) # Lista de todas las categorías conocidas self.categorias = set() # Vocabulario total (todas las palabras únicas) self.vocabulario = set() def entrenar(self, datos): \u0026#34;\u0026#34;\u0026#34; Entrena el clasificador con ejemplos de texto etiquetados. Args: datos (list): Lista de tuplas cuyo primer valor es el contenido del ticket y el segundo valor, la categoría correspondiente. \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;Entrenando clasificador con {len(datos)} ejemplos...\u0026#34;) pass # Ejemplo práctico: Clasificador de tickets de soporte if __name__ == \u0026#34;__main__\u0026#34;: # Datos de entrenamiento simulando tickets de soporte técnico # Cada elemento de la lista contiene una tupla compuesta por # la descripción del ticket y la categoría a la que pertenece. datos_de_entrenamiento = [ (\u0026#34;La aplicación se cierra inesperadamente al hacer click en enviar\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;Error 500 al intentar subir archivo grande\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;El botón de guardar no funciona en Firefox\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;Pantalla en blanco después de iniciar sesión\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;Los datos no se actualizan correctamente en la tabla\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;Mensaje de error extraño al procesar el pago\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;Sería genial poder exportar reportes a Excel\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Necesitamos filtros avanzados en el listado de productos\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Propongo agregar notificaciones push para mensajes\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Falta la opción de cambiar el idioma de la interfaz\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Queremos integración con Google Calendar\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Deberíamos tener dashboard personalizable para cada usuario\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Cómo puedo cambiar mi contraseña\u0026#34;, \u0026#34;SUPPORT\u0026#34;), (\u0026#34;No entiendo cómo funciona el sistema de permisos\u0026#34;, \u0026#34;SUPPORT\u0026#34;), (\u0026#34;Necesito ayuda para configurar mi perfil\u0026#34;, \u0026#34;SUPPORT\u0026#34;), (\u0026#34;Dónde encuentro las estadísticas de ventas\u0026#34;, \u0026#34;SUPPORT\u0026#34;), (\u0026#34;Instrucciones para conectar con la API\u0026#34;, \u0026#34;SUPPORT\u0026#34;), (\u0026#34;Tutorial para usar las funciones avanzadas\u0026#34;, \u0026#34;SUPPORT\u0026#34;) ] # Crear y entrenar el clasificador clasificador = ClasificadorTextoBasico() clasificador.entrenar(datos_de_entrenamiento) El clasificador almacena los siguientes datos:\npalabras_por_categoria: automáticamente cuenta frecuencias de palabras que aparecen por categoría tickets_por_categoria: la cantidad de tickets conocidos en cada categoría. Necesario para calcular \\(P(\\text{categoría})\\) categorias: listado de las categorías conocidas vocabulario: conjunto de todas las palabras únicas que hemos visto Preprocesamiento del texto # Antes de continuar, es necesario incluir una función para preprocesar el texto. Los textos que escribimos pueden tener muchas variaciones, necesitamos convertirlo a una forma estándar, sin distinciones entre mayúsculas y minúsculas, signos de puntuación, tildes, etcétera.\ndef preprocesar_texto(self, texto): \u0026#34;\u0026#34;\u0026#34; Limpia y tokeniza el texto de entrada. Args: texto (str): Texto a procesar Returns: list: Lista de palabras limpias en minúsculas \u0026#34;\u0026#34;\u0026#34; # Convertir a minúsculas texto = texto.lower() # Separa las letras de sus diacríticos texto = unicodedata.normalize(\u0026#39;NFD\u0026#39;, texto) # Elimina los caracteres de tipo marca diacrítica (Mn), es decir, las tildes y diéresis texto = \u0026#39;\u0026#39;.join(c for c in texto if unicodedata.category(c) != \u0026#39;Mn\u0026#39;) # Tokenizar (dividir en palabras) palabras = texto.split() # Filtrar palabras muy cortas palabras = [p for p in palabras if len(p) \u0026gt;= 3] return palabras ¿Por qué estos pasos?\nMinúsculas: \u0026ldquo;Error\u0026rdquo; y \u0026ldquo;error\u0026rdquo; deben tratarse igual Sin puntuación: Nos enfocamos en las palabras, no en la estructura Filtrar palabras cortas: \u0026ldquo;el\u0026rdquo;, \u0026ldquo;de\u0026rdquo;, \u0026ldquo;un\u0026rdquo; aportan poco valor discriminativo Entrenando el sistema # El siguiente paso, es entrenar el sistema con datos conocidos para que aprenda a cuando aplicar una categoría u otra dependiendo del texto recibido. Durante el entrenamiento, el algoritmo \u0026ldquo;memoriza\u0026rdquo; qué palabras aparecen frecuentemente en cada categoría, y las agrupa según la categoría dada. Por ejemplo, si vemos \u0026ldquo;error\u0026rdquo; en 10 tickets con la categoría BUG y solo 1 perteneciente a FEATURE, el algoritmo aprende que \u0026ldquo;error\u0026rdquo; es una fuerte señal de BUG.\ndef entrenar(self, datos): \u0026#34;\u0026#34;\u0026#34; Entrena el clasificador con ejemplos de texto etiquetados. Args: datos (list): Lista de tuplas cuyo primer valor es el contenido del ticket y el segundo valor, la categoría correspondiente. \u0026#34;\u0026#34;\u0026#34; for texto, categoria in datos: palabras = self.preprocesar_texto(texto) # Actualizar contadores self.categorias.add(categoria) self.tickets_por_categoria[categoria] += 1 # Contar frecuencia de cada palabra en esta categoría for palabra in palabras: self.palabras_por_categoria[categoria][palabra] += 1 self.vocabulario.add(palabra) print(f\u0026#34;Entrenamiento completado:\u0026#34;) print(f\u0026#34; * Categorías: {sorted(self.categorias)}\u0026#34;) print(f\u0026#34; * Vocabulario: {len(self.vocabulario)} palabras únicas\u0026#34;) for cat in sorted(self.categorias): print(f\u0026#34; * \u0026#39;{cat}\u0026#39;: {self.tickets_por_categoria[cat]} tickets\u0026#34;) Hasta aquí obtendremos esto cuando ejecutamos el programa:\nEntrenando clasificador con 18 ejemplos... Entrenamiento completado: * Categorías: [\u0026#39;BUG\u0026#39;, \u0026#39;FEATURE\u0026#39;, \u0026#39;SUPPORT\u0026#39;] * Vocabulario: 80 palabras únicas * \u0026#39;BUG\u0026#39;: 6 tickets * \u0026#39;FEATURE\u0026#39;: 6 tickets * \u0026#39;SUPPORT\u0026#39;: 6 tickets Cálculo de probabilidades # Aquí presentamos el corazón del algoritmo, realizaremos los cálculos de probabilidades por palabra que luego servirán para clasificar tickets.\ndef calcular_probabilidad_palabra(self, palabra, categoria): \u0026#34;\u0026#34;\u0026#34; Calcula P(palabra|categoria) usando suavizado de Laplace. El suavizado evita probabilidades de 0 para palabras no vistas. Args: palabra (str): Palabra a evaluar categoria (str): Categoría a evaluar Returns: float: Probabilidad de la palabra dada la categoría \u0026#34;\u0026#34;\u0026#34; # Frecuencia de la palabra en esta categoría frecuencia_palabra = self.palabras_por_categoria[categoria][palabra] # Total de palabras en esta categoría total_palabras_categoria = sum(self.palabras_por_categoria[categoria].values()) # Suavizado de Laplace: sumamos 1 al numerador y |vocabulario| al denominador # Esto evita probabilidades de 0 para palabras nuevas probabilidad = (frecuencia_palabra + 1) / (total_palabras_categoria + len(self.vocabulario)) return probabilidad ¿Qué es el suavizado de Laplace?\nCon las técnicas de suavizado intentamos evitar las probabilidades cero producidas por palabras no vistas.\nSin suavizado, si una palabra nunca apareció en una categoría, su probabilidad sería \\(0\\), y todo el cálculo se volvería \\(0\\).\nCon la técnica de suavizado de Laplace, agregamos \\(1\\) al numerador y el tamaño del vocabulario al denominador. Esto da una probabilidad pequeña pero no nula a palabras no vistas.\n$$P(\\text{palabra}|\\text{categoría}) = \\frac{\\text{frecuencia} + 1}{\\text{palabras en categoría} + \\text{tamaño vocabulario}}$$ Clasificando nuevos tickets # Ahora sí llegó el momento de inyectar nuevos tickets y dejar que el algoritmo los clasifique utilizando las probabilidades calculadas antes.\ndef clasificar(self, texto): \u0026#34;\u0026#34;\u0026#34; Clasifica un texto usando el teorema de Bayes. P(categoria|texto) ∝ P(categoria) * ∏P(palabra|categoria) Args: texto (str): Texto a clasificar Returns: dict: Probabilidades por categoría \u0026#34;\u0026#34;\u0026#34; palabras = self.preprocesar_texto(texto) # Calculamos log-probabilidades para evitar underflow # (multiplicar muchas probabilidades pequeñas da números muy pequeños) log_probabilidades = {} for categoria in sorted(self.categorias): # P(categoria) = tickets_categoria / total_tickets total_tickets = sum(self.tickets_por_categoria.values()) prob_categoria = self.tickets_por_categoria[categoria] / total_tickets # Empezamos con log(P(categoria)) log_prob = math.log(prob_categoria) # Multiplicamos por P(palabra|categoria) para cada palabra # En log-space: log(a*b) = log(a) + log(b) for palabra in palabras: prob_palabra = self.calcular_probabilidad_palabra(palabra, categoria) log_prob += math.log(prob_palabra) log_probabilidades[categoria] = log_prob # Convertir de vuelta a probabilidades normales # Usamos el truco: exp(log_prob - max_log_prob) para estabilidad numérica max_log_prob = max(log_probabilidades.values()) probabilidades = {} for categoria, log_prob in log_probabilidades.items(): probabilidades[categoria] = math.exp(log_prob - max_log_prob) # Normalizar para que sumen 1 total = sum(probabilidades.values()) for categoria in probabilidades: probabilidades[categoria] /= total return probabilidades Te estarás preguntando, ¿por qué usar logaritmos?, lo que sucede es que multiplicar muchas probabilidades pequeñas puede resultar en números extremadamente pequeños, esto puede conducir a lo que en computación se denomina underflow. Esto significa que la computadora no puede representar un número tan pequeño y se pueden producir errores inesperados o excepciones.\nLos logaritmos transforman multiplicaciones en sumas y así evitamos el underflow.\n$$\\log(a \\times b \\times c) = \\log(a) + \\log(b) + \\log(c)$$ Probando el clasificador # Agregamos el siguiente código a la función main para ejecutar el clasificador en tickets diferentes utilizados en el entrenamiento.\n# Probar con tickets nuevos print(\u0026#34;\\n\\nPROBANDO CLASIFICADOR CON TICKETS NUEVOS:\u0026#34;) print(\u0026#34;=\u0026#34; * 60) tickets_prueba = [ \u0026#34;La pagina queda en blanco cuando cargo muchos productos\u0026#34;, \u0026#34;Me gustaría poder ordenar la lista por fecha de creación\u0026#34;, \u0026#34;No sé cómo resetear mi cuenta de usuario\u0026#34; ] for i, ticket in enumerate(tickets_prueba, 1): print(f\u0026#34;\\n#{i}: \u0026#39;{ticket}\u0026#39;\u0026#34;) resultados = clasificador.clasificar(ticket) # Mostrar probabilidades ordenadas for categoria, prob in sorted(resultados.items(), key=lambda x: x[1], reverse=True): print(f\u0026#34; {categoria}: {prob:.1%}\u0026#34;) # Mostrar predicción final mejor_categoria = max(resultados.items(), key=lambda x: x[1]) print(f\u0026#34; -\u0026gt; CLASIFICACIÓN: {mejor_categoria[0]} ({mejor_categoria[1]:.1%} confianza)\u0026#34;) Obtenemos la siguiente respuesta:\nPROBANDO CLASIFICADOR CON TICKETS NUEVOS: ============================================================ #1: \u0026#39;La pagina queda en blanco cuando cargo muchos productos\u0026#39; BUG: 41.9% FEATURE: 32.6% SUPPORT: 25.5% -\u0026gt; CLASIFICACIÓN: BUG (41.9% confianza) #2: \u0026#39;Me gustaría poder ordenar la lista por fecha de creación\u0026#39; FEATURE: 42.5% SUPPORT: 31.2% BUG: 26.4% -\u0026gt; CLASIFICACIÓN: FEATURE (42.5% confianza) #3: \u0026#39;No sé cómo resetear mi cuenta de usuario\u0026#39; SUPPORT: 55.1% FEATURE: 28.5% BUG: 16.4% -\u0026gt; CLASIFICACIÓN: SUPPORT (55.1% confianza) Entendiendo las decisiones (interpretabilidad) # Una ventaja clave de Naive Bayes es que podemos inspeccionar lo qué aprendió:\ndef palabras_mas_representativas(self, n=10): \u0026#34;\u0026#34;\u0026#34; Encuentra las palabras que mejor distinguen entre categorías. Útil para entender lo que aprendió el modelo. \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\nTOP {n} PALABRAS MÁS REPRESENTATIVAS POR CATEGORÍA:\u0026#34;) print(\u0026#34;=\u0026#34; * 60) for categoria in sorted(self.categorias): # Calculamos la \u0026#34;representatividad\u0026#34; de cada palabra # usando la frecuencia relativa en esta categoría vs otras scores = {} for palabra in sorted(self.vocabulario): freq_categoria = self.palabras_por_categoria[categoria][palabra] total_categoria = sum(self.palabras_por_categoria[categoria].values()) # Frecuencia en otras categorías freq_otras = 0 total_otras = 0 for otra_cat in self.categorias: if otra_cat != categoria: freq_otras += self.palabras_por_categoria[otra_cat][palabra] total_otras += sum(self.palabras_por_categoria[otra_cat].values()) if total_otras \u0026gt; 0: # Relación de frecuencias relativas rel_freq_cat = (freq_categoria + 1) / (total_categoria + len(self.vocabulario)) rel_freq_otras = (freq_otras + 1) / (total_otras + len(self.vocabulario)) scores[palabra] = rel_freq_cat / rel_freq_otras # Mostrar palabras mas representativas top_palabras = sorted(scores.items(), key=lambda x: (-x[1], x[0]))[:n] print(f\u0026#34;\\n {categoria.upper()}:\u0026#34;) for palabra, score in top_palabras: print(f\u0026#34; • {palabra:\u0026lt;15} (score: {score:.2f})\u0026#34;) Esto nos muestra qué palabras son más características de cada categoría.\nDesde la función main consultamos las palabras más representativas.\n# Mostrar palabras más representativas clasificador.palabras_mas_representativas(15) Obteniendo:\nTOP 15 PALABRAS MÁS REPRESENTATIVAS POR CATEGORÍA: ============================================================ BUG: * error (score: 3.83) * actualizan (score: 2.55) * aplicacion (score: 2.55) * archivo (score: 2.55) * blanco (score: 2.55) * boton (score: 2.55) * cierra (score: 2.55) * click (score: 2.55) * correctamente (score: 2.55) * datos (score: 2.55) * despues (score: 2.55) * enviar (score: 2.55) * extrano (score: 2.55) * firefox (score: 2.55) * grande (score: 2.55) FEATURE: * agregar (score: 2.39) * avanzados (score: 2.39) * cada (score: 2.39) * calendar (score: 2.39) * dashboard (score: 2.39) * deberiamos (score: 2.39) * excel (score: 2.39) * exportar (score: 2.39) * falta (score: 2.39) * filtros (score: 2.39) * genial (score: 2.39) * google (score: 2.39) * idioma (score: 2.39) * integracion (score: 2.39) * interfaz (score: 2.39) SUPPORT: * como (score: 4.02) * avanzadas (score: 2.68) * ayuda (score: 2.68) * conectar (score: 2.68) * configurar (score: 2.68) * contrasena (score: 2.68) * donde (score: 2.68) * encuentro (score: 2.68) * entiendo (score: 2.68) * estadisticas (score: 2.68) * funciones (score: 2.68) * instrucciones (score: 2.68) * necesito (score: 2.68) * perfil (score: 2.68) * permisos (score: 2.68) Análisis y extensiones # ¿Por qué se llama Naive (Ingenuo)? Porque asume que todas las palabras son independientes entre sí. En realidad, sabemos que esto no es cierto, \u0026ldquo;no funciona\u0026rdquo; tiene un significado diferente que \u0026ldquo;no\u0026rdquo; y \u0026ldquo;funciona\u0026rdquo; por separado.\nSin embargo, esta simplicidad es también su fortaleza:\nEficiencia: requiere menos datos y cómputo Robustez: funciona bien incluso cuando la suposición no se cumple perfectamente Interpretabilidad: fácil de entender y depurar Ventajas Limitaciones Rápido de entrenar y clasificar Asume independencia de palabras Funciona bien con pocos datos Sensible a características irrelevantes Maneja bien múltiples categorías Puede dar probabilidades mal calibradas Probabilidades interpretables No captura orden de palabras Resistente al sobreajuste Extensiones posibles # Una vez que domines este clasificador básico, puedes explorar:\nN-gramas: Considerar procesar grupos de dos, tres o \\(N\\) palabras TF-IDF: Pesar palabras por su importancia relativa Validación cruzada: Evaluar mejor el rendimiento Características adicionales: Longitud del texto, mayúsculas, etc. ¿Qué aprendemos de este ejemplo? # El preprocesamiento es crucial: Limpiar y normalizar el texto afecta directamente la calidad del modelo.\nTeorema de Bayes en acción: Combinamos la probabilidad previa P(categoría) con la evidencia P(palabras|categoría).\nSuavizado de Laplace: Técnica esencial para manejar palabras que no vimos durante el entrenamiento.\nLog-probabilidades: Truco numérico para evitar underflow al multiplicar muchas probabilidades pequeñas.\nInterpretabilidad: Podemos entender qué palabras son más importantes para cada categoría.\nCódigo completo # Aquí tienes el código completo del sistema. También puedes encontrarlo en el repositorio de ejemplos haciendo click en el siguiente enlace.\nlearn-software-engineering/examples Programming Course - Examples Python 1 0 Conclusión # ¡Has construido tu primer clasificador de Machine Learning desde cero! Este clasificador Bayesiano Ingenuo (Naive Bayes) demuestra algunos conceptos fundamentales:\nAprendizaje supervisado: Aprender de ejemplos etiquetados Probabilidad: Cuantificar incertidumbre Generalización: Aplicar lo aprendido a casos nuevos Interpretabilidad: Entender las decisiones del modelo Aunque se vea simple, este tipo de clasificador se usa en aplicaciones reales como filtros de spam, análisis de sentimientos, clasificación de documentos, moderación de contenido, entre otros.\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"26 August 2025","externalUrl":null,"permalink":"/ai/module1/sample2/","section":"Inteligencia Artificial","summary":"","title":"Machine Learning Ejemplo 2: Sistema de Clasificación","type":"ai"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/programming/oop/","section":"Programming","summary":"","title":"Object-Oriented Programming","type":"programming"},{"content":"In Object-Oriented Programming, classes don\u0026rsquo;t exist in isolation. They interact and relate to each other in various ways to model complex systems and relationships. Understanding these relationships is crucial for designing effective and maintainable object-oriented systems.\nThe main types of class relationships we\u0026rsquo;ll explore in depth are:\nAssociation (\u0026ldquo;uses-a\u0026rdquo;) Aggregation (weak \u0026ldquo;has-a\u0026rdquo; relationship) Composition (strong \u0026ldquo;has-a\u0026rdquo; relationship) Inheritance (\u0026ldquo;is-a\u0026rdquo; relationship) Realisation (Implementation) Dependency Each of these relationships represents a different way that classes can be connected and interact with each other. They vary in terms of the strength of the coupling between classes, the lifecycle dependencies, and the nature of the relationship.\nBefore we dive into each type of relationship, let\u0026rsquo;s visualise them using a UML class diagram:\nclassDiagram class ClassA class ClassB class ClassC class ClassD class ClassE class ClassF class InterfaceG ClassA --\u003e ClassB : Association ClassC o-- ClassD : Aggregation ClassE *-- ClassF : Composition ClassB --|\u003e ClassA : Inheritance ClassE ..|\u003e InterfaceG : Realisation ClassA ..\u003e ClassF : Dependency end This diagram provides a high-level overview of the different types of class relationships. In the following sections, we\u0026rsquo;ll explore each of these relationships in detail, providing explanations, examples, and more specific UML diagrams.\n","date":"07 December 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-introduction/","section":"Programming","summary":"","title":"Class relations","type":"programming"},{"content":"A dictionary, or map, consists of a collection of key-value pairs. The key is used to access the associated value. Keys must be unique within a dictionary. Values can be repeated.\nDiagram of a map Main operations # Add/update: Inserts a key-value pair. If the key existed, its value is replaced. dictionary[\u0026#39;key\u0026#39;] = \u0026#39;value\u0026#39; Get value: Accesses the value given a key. value = dictionary[\u0026#39;key\u0026#39;] Delete: Removes a key-value pair from the dictionary. del dictionary[\u0026#39;key\u0026#39;] Traverse: Iterate over the keys, values or pairs of the dictionary. for key in dictionary: print(key, dictionary[key]) # key, value Creating a dictionary or map # The syntax for creating maps or dictionaries in Python is:\nempty_dictionary = {} person = { \u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;, \u0026#39;age\u0026#39;: 25 } Usage examples # Dictionaries are useful in many cases. Below are some examples.\nObjects and mappings # We can model objects and entities with key-value attributes:\nproduct = { \u0026#39;name\u0026#39;: \u0026#39;Smartphone\u0026#39;, \u0026#39;price\u0026#39;: 500, \u0026#39;brand\u0026#39;: \u0026#39;XYZ\u0026#39; } Counts and frequencies # Counting occurrences of elements in sequences:\ntext = \u0026#34;Hello world world\u0026#34; frequencies = {} for word in text.split(): if word in frequencies: frequencies[word] += 1 else: frequencies[word] = 1 print(frequencies) # {\u0026#39;Hello\u0026#39;: 1, \u0026#39;world\u0026#39;: 2} Storing and accessing data # As a high performance alternative to lists and arrays.\nConclusion # Dictionaries are versatile data structures thanks to their fast access based on unique keys. They have uses in almost all programs, so mastering dictionaries is essential in any language.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"30 October 2023","externalUrl":null,"permalink":"/en/programming/data-structures/maps/","section":"Programming","summary":"","title":"Maps (Dictionaries)","type":"programming"},{"content":" Conditions: making decisions in code # Life is full of decisions: \u0026ldquo;If it rains, I\u0026rsquo;ll take an umbrella. Otherwise, I\u0026rsquo;ll wear sunglasses.\u0026rdquo; These decisions are also present in the world of programming. Conditions are like questions the computer asks itself. They allow us to make decisions and execute specific code based on a condition. They can be as simple as \u0026ldquo;Is it raining?\u0026rdquo; or as complex as \u0026ldquo;Is it the weekend and do I have less than $100 in my bank account?\u0026rdquo;.\nif # The if structure allows us to evaluate conditions and make decisions based on the result of that evaluation.\nage = 15 if age \u0026gt;= 18: print(\u0026#34;You are an adult\u0026#34;) The code above allows executing a portion of code if a person\u0026rsquo;s age is greater than or equal to 18 years.\nif-else # When you want to execute alternative code if the condition is false, you use the if-else structure.\nage = 21 if age \u0026gt;= 18: print(\u0026#34;You are an adult\u0026#34;) else: print(\u0026#34;You are a minor\u0026#34;) In this case, it determines if the person is an adult or a minor, and the message displayed is different.\nif-elif-else # When conditions are multiple and two paths are not enough, the if-elif-else structure is used to evaluate them in a chained way.\nage = 5 if age \u0026lt;= 13: print(\u0026#34;You are a child\u0026#34;) elif age \u0026gt; 13 and age \u0026lt; 18: print(\u0026#34;You are a teenager\u0026#34;) else: print(\u0026#34;You are an adult\u0026#34;) In the code above, there are three clear paths: one for when age is less than or equal to 13, one for when age is between 13 and 18, and another for when age is greater than or equal to 18.\nAnother way to solve this problem is through the switch-case structure, which, although Python does not natively incorporate, other languages like Java or C++ do, and it is an important tool to be familiar with. This structure allows programmers to handle multiple conditions in a more organized way than a series of if-elif-else.\nIn Java, for example:\nint day = 3; switch(day) { case 1: System.out.println(\u0026#34;Monday\u0026#34;); break; case 2: System.out.println(\u0026#34;Tuesday\u0026#34;); break; case 3: System.out.println(\u0026#34;Wednesday\u0026#34;); break; // ... and so on default: System.out.println(\u0026#34;Invalid day\u0026#34;); } In the previous example, depending on the value of day, the corresponding day will be printed.\nLoops: repeating actions # Sometimes in programming we need to repeat an action several times. Instead of writing the same code many times, we can use loops. These allow repeating the execution of a block of code while a condition is met.\nwhile # The while loop is useful when we want to repeat an action based on a condition.\n# Prints 1 to 5 i = 1 while i \u0026lt;= 5: print(i) i = i + 1 do-while # Similar to while but guarantees at least one execution since the code block is executed first and then the condition is evaluated. Python does not implement this structure, but other languages like Java and C++ do.\nint i = 1; do { System.out.println(i); i++; } while(i \u0026lt;= 5); int number = 0; do { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, world!\u0026#34; \u0026lt;\u0026lt; std::endl; number++; } while (number \u0026lt; 5); for # The for loop is useful when we know how many times we want to repeat an action.\nfor i in range(5): print(\u0026#34;Hello, world!\u0026#34;) The code above will print \u0026ldquo;Hello, world!\u0026rdquo; five times.\nWe can also iterate over the elements of a list or iterable object:\nnames = [\u0026#34;Maria\u0026#34;, \u0026#34;Florencia\u0026#34;, \u0026#34;Julian\u0026#34;] for name in names: print(f\u0026#34;Hello {name}\u0026#34;) # Prints # Hello Maria # Hello Florencia # Hello Julian The break and continue statements # We can use break to terminate the loop and continue to skip to the next iteration.\nbreak is used to completely terminate the loop when a condition is met, in the following example, when i reaches 5.\n# break example i = 0 while i \u0026lt; 10: print(i) if i == 5: break i += 1 # Prints: # 0 # 1 # 2 # 3 # 4 # 5 continue is used to skip an iteration of the loop and continue with the next one when a condition is met. Here we use it to skip even numbers.\n# continue example i = 0 while i \u0026lt; 10: i += 1 if i % 2 == 0: continue print(i) # Prints: # 1 # 3 # 5 # 7 # 9 Nesting: combining structures # Control flow structures can be nested within each other. For example, we can have loops within loops or conditions within loops.\nfor i in range(5): for j in range(10): if (i % 2 == 0 and j % 3 == 0): print(f\u0026#34;i = {i}, j = {j}\u0026#34;) This code will print combinations of i and j only when i is divisible by 2 and j is divisible by 3, demonstrating how loops are nested and executed.\nCommon usage patterns # There are specific patterns to solve common needs with control flow.\nSearch # Search for a value in a collection:\nfruits = [\u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;] searching = \u0026#34;orange\u0026#34; found = False for fruit in fruits: if fruit == searching: found = True break if found: print(\u0026#34;Fruit found!\u0026#34;) Accumulation # Accumulate incremental values in a loop:\ntotal = 0 for i in range(10): total += i print(total) # Sum from 0..9 = 45 Flowcharts: the visual route to understanding code # Programmers, whether beginners or experts, often find themselves facing challenges that require detailed planning before diving into code. This is where flowcharts come into play as an essential tool. These charts are graphical representations of the processes and logic behind a program or system. In this article, we will unravel the world of flowcharts, from basic concepts to advanced techniques, and how they can benefit programmers of all levels.\nA flowchart is a graphical representation of a process. It uses specific symbols to represent different types of instructions or actions. Its main purpose is to simplify understanding of a process by showing step by step how information or decisions flow. These charts:\nFacilitate understanding of complex processes. Aid in the design and planning phase of a program. Serve as documentation and reference for future developments. Flowcharts are a powerful tool that not only benefits beginners but also experienced programmers. They provide a clear and structured view of a process or program, facilitating planning, design, and communication between team members.\nBasic elements # Flowcharts consist of several symbols, each with a specific meaning:\nOval: Represents the start or end of a process. Rectangle: Denotes an operation or instruction. Diamond: Indicates a decision based on a condition. Arrows: Show the direction of flow. graph TD; start((Start)) process[Process] decision{Decision?} final((End)) start --\u003e process; process --\u003e decision; decision --\u003e |Yes| process decision --\u003e |No| final end Examples # Let\u0026rsquo;s design a flowchart for a program that asks for a number and tells us if it\u0026rsquo;s even or odd.\ngraph TB start((Start)) input[Input number] decision{Even?} isEven[Is even] isOdd[Is odd] final((End)) start --\u003e input input --\u003e decision decision --\u003e |Yes| isEven decision --\u003e |No| isOdd isEven --\u003e final isOdd --\u003e final end As programs become more complex, you may need to incorporate loops, multiple conditions, and other advanced elements into your flowchart. For example, here we diagram a program that sums numbers from 1 to a number entered by the user.\ngraph TD start((Start)) input[Input number] setVariables[Set sum=0 and counter=1] loop_condition{counter \u003c= N?} loop_code[Add value and increment counter] result[Show sum] final((End)) start --\u003e input input --\u003e setVariables setVariables --\u003e loop_condition loop_condition --\u003e |Yes| loop_code loop_code --\u003e loop_condition loop_condition --\u003e |No| result result --\u003e final end Conclusion # Control flow is the heart of programming. Without it, programs would be linear sequences of actions without the ability to make decisions or repeat tasks. By mastering these structures not only do you improve your ability to write code, but also your ability to think logically and solve complex problems.\nReferences # Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated. Deitel, P., \u0026amp; Deitel, H. (2012). Java: How to program. Upper Saddle River, NJ: Prentice Hall. Matthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. San Francisco, CA: No Starch Press. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"27 September 2023","externalUrl":null,"permalink":"/en/programming/starting-concepts/flow-control-structures/","section":"Programming","summary":"","title":"Flow Control","type":"programming"},{"content":" The decimal system: the bedrock of our daily life # From a tender age, we\u0026rsquo;re taught to count using ten digits: 0 through 9. This system, known as the decimal system, underpins almost all our mathematical and financial activities, from basic arithmetic to calculating bank interests. Its roots trace back to our anatomy: the ten fingers on our hands, making it the most intuitive and natural system for us. Yet, its true charm emanates from its positional nature.\nTo grasp this concept, let\u0026rsquo;s dissect the number 237:\nThe rightmost digit (7) stands for the units\u0026rsquo; position. That is, \\(7 \\times 10^0\\) (any number raised to the power of 0 is 1). Therefore, its value is simply 7. The middle digit (3) represents the tens\u0026rsquo; position, translating to \\(3 \\times 10^1 = 3 \\times 10 = 30\\). The leftmost digit (2) is in the hundreds\u0026rsquo; position, decoding to \\(2 \\times 10^2 = 2 \\times 100 = 200\\). When these values are combined,\n2 \\times 10^2 + 3 \\times 10^1 + 7 \\times 10^0 = 200 + 30 + 7 = 237 The binary system: computers\u0026rsquo; coded language # While the decimal system reigns supreme in our everyday lives, the machines we use daily, from our smartphones to computers, operate in a starkly different realm: the binary world. In this system, only two digits exist: 0 and 1. It might seem restrictive at first glance, but this system is the essence of digital electronics. Digital devices, with their billions of transistors, operate using these two states: on (1) and off (0).\nDespite its apparent simplicity, the binary system can express any number or information that the decimal system can. For instance, the decimal number 5 is represented as 101 in binary.\nBinary, with its ones and zeros, operates in a manner akin to the decimal system, but instead of powers of 10, it uses powers of 2.\nConsider the binary number 1011:\nThe rightmost bit denotes \\(1 \\times 2^0 = 1\\). The subsequent bit stands for \\(1 \\times 2^1 = 2\\). Next up is \\(0 \\times 2^2 = 0\\). The leftmost bit in this number signifies \\(1 \\times 2^3 = 8\\). Thus, 1011 in binary translates to the following in the decimal system:\n1011 = 1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 = 8 + 0 + 2 + 1 = 11 Hexadecimal system: bridging humans and machines # While the binary system is perfect for machines, it can get a tad cumbersome for us, especially when dealing with lengthy binary numbers. Here is where the hexadecimal system, employing sixteen distinct digits: 0-9 and A-F, with A representing 10, B as 11, and so forth, up to F, which stands for 15 comes to help.\nHexadecimal proves invaluable as it offers a more compact way to represent binary numbers. Each hexadecimal digit corresponds precisely to four binary bits. For instance, think of the binary representation of the number 41279 and notice how the hexadecimal system achieves a more succinct representation:\n41279 = 1010 0001 0011 1111 = A13F But the hexadecimal system is more than just a compressed representation of binary numbers; it\u0026rsquo;s a positional numbering system like decimal or binary but based on 16 instead of 10 or 2. Let\u0026rsquo;s see how to derive the decimal representation of the example number (A13F):\nThe rightmost digit represents \\(F \\times 16^0 = 15 \\times 16^0 = 15\\). The subsequent one stands for \\(3 \\times 16^1 = 48\\). The next digit denotes \\(1 \\times 16^2 = 256\\). The leftmost digit in this number signifies \\(A \\times 16^3 = 10 \\times 16^3 = 40960\\). Therefore, A13F in hexadecimal translates to the following in the decimal system:\nA13F = A \\times 16^3 + 1 \\times 16^2 + 3 \\times 16^1 + F \\times 16^0 = 10 \\times 4096 + 1 \\times 256 + 3 \\times 16 + 15 \\times 1 = 40960 + 256 + 48 + 15 = 41279 Conclusion # Numbering systems are like lenses through which we perceive and understand the world of mathematics and computing. Although the decimal system may be the linchpin of our daily existence, it\u0026rsquo;s crucial to appreciate and comprehend the binary and hexadecimal systems, especially in this digital age.\nSo, the next time you\u0026rsquo;re in front of your computer or using an app on your smartphone, remember that behind that user-friendly interface, a binary world is in full swing, with the hexadecimal system acting as a translator between that realm and us.\nReferences # Ifrah, G. (2000). The Universal History of Numbers. London: Harvill Press. Tanenbaum, A. (2012). Structured Computer Organization. New Jersey: Prentice Hall. Knuth, D. (2007). The Art of Computer Programming: SemiNumeral Algorithms. California: Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"05 September 2023","externalUrl":null,"permalink":"/en/programming/intro/numeral-systems/","section":"Programming","summary":"","title":"Numeral Systems","type":"programming"},{"content":" Para consolidar todo lo aprendido, vamos a crear un sistema de recomendaciones usando reglas lógicas. Este tipo de sistema es común en e-commerce, plataformas de contenido y aplicaciones móviles. Problema a resolver # Eres un ingeniero de software trabajando para una empresa de e-commerce que necesita implementar un sistema de recomendaciones para mejorar la experiencia de sus usuarios y aumentar las ventas.\nTu misión es desarrollar un sistema que pueda sugerir productos relevantes a los usuarios basándose en:\nSu perfil demográfico (edad, ubicación, intereses) Su historial de compras y navegación El comportamiento de usuarios similares Características de los productos Reglas específicas del negocio Datos disponibles # Para el desarrollo del sistema tenemos preparados un conjunto de datos que podés usar para verificar el funcionamiento de tu código.\nUsuarios: datos/usuarios.json\nDatos demográficos: edad, género, ubicación Intereses: lista de categorías preferidas Nivel de gasto: bajo, medio, alto Historial de actividad: compras, visualizaciones, ratings Productos: datos/productos.json\nInformación básica: nombre, categoría, precio Métricas de calidad: rating promedio, popularidad Metadatos: tags descriptivos, público objetivo Características comerciales: disponibilidad, promociones Interacciones: datos/interacciones.json\nTipos de interacción: compra, visualización, rating, wishlist Datos temporales: fecha y hora Valoraciones: puntuaciones de 1-5 estrellas Contexto: dispositivo, ubicación, sesión Requerimientos Funcionales # Calcular similitud entre usuarios ENTRADA: ID de usuario PROCESO: Calcular similitud con otros usuarios basándose en: - Productos en común que han comprado o visto - Similitud demográfica (edad, género, ubicación) - Intereses compartidos SALIDA: Lista de usuarios similares ordenada por similitud Generar recomendaciones por filtrado colaborativo ENTRADA: ID de usuario, número de recomendaciones deseadas PROCESO: - Encontrar usuarios similares - Identificar productos que les gustaron a esos usuarios - Filtrar productos ya conocidos por el usuario objetivo - Puntuar por similitud de usuarios y ratings SALIDA: Lista de productos recomendados con scores Generar recomendaciones por contenido ENTRADA: ID de usuario, número de recomendaciones deseadas PROCESO: - Analizar perfil del usuario (intereses, demografía) - Evaluar cada producto por compatibilidad: * Matching con intereses del usuario * Adecuación por edad y demografía * Calidad del producto (rating, popularidad) * Precio apropiado para nivel de gasto SALIDA: Lista de productos recomendados con scores Procesar reglas de negocio ENTRADA: Usuario, lista de recomendaciones preliminares PROCESO: Aplicar reglas como: - Boost a productos tech para usuarios jóvenes - Promocionar productos premium a usuarios de gasto alto - Priorizar productos económicos para presupuesto bajo - Aplicar preferencias regionales SALIDA: Recomendaciones ajustadas por reglas de negocio Generar explicaciones para las recomendaciones ENTRADA: Usuario, producto recomendado PROCESO: Generar explicación legible de por qué se recomienda: - \u0026#34;Coincide con tus intereses en tecnología\u0026#34; - \u0026#34;A usuarios similares también les gustó\u0026#34; - \u0026#34;Excelente rating (4.8/5)\u0026#34; - \u0026#34;Precio apropiado para tu perfil\u0026#34; SALIDA: Lista de razones explicativas Métricas de evaluación # Evalúa tu sistema considerando:\nPrecisión\n¿Las recomendaciones son relevantes para cada usuario? ¿Evita recomendar productos ya conocidos? Diversidad\n¿Ofrece variedad de categorías y precios? ¿Evita el sesgo hacia productos populares únicamente? Explicabilidad\n¿Las razones son claras y convincentes? Eficiencia\n¿Responde en tiempo razonable? Solución # Haciendo click en el siguiente enlace, puedes encontrar una posible solución para este problema. Incluye explicaciones detalladas.\n¡Intentá resolverlo por tu cuenta primero! 😀😀😀 Ejecución # Aquí hay algunos ejemplos de ejecución:\nDemostración completa # \u0026gt; python main.py Selecciona el tipo de demostración: 1- Demostración completa 2- Comparación de algoritmos 3- Usuario específico Opción (1-3): 1 Sistema de Recomendaciones - Demostración Completa ================================================== Cargando la configuración desde config.yaml Configuración cargada desde config.yaml Configuración validada exitosamente Inicializando Sistema de Recomendaciones * 6 usuarios cargados * 12 productos cargados * 22 interacciones cargadas Sistema listo! ======================== Estadísticas del Sistema ======================== Analizando sistema Usuarios: 6 * Por género: {\u0026#39;F\u0026#39;: 3, \u0026#39;M\u0026#39;: 3} * Por ubicación: {\u0026#39;Buenos Aires\u0026#39;: 2, \u0026#39;Córdoba\u0026#39;: 1, \u0026#39;Rosario\u0026#39;: 1, \u0026#39;Mendoza\u0026#39;: 1, \u0026#39;La Plata\u0026#39;: 1} * Por nivel de gasto: {\u0026#39;medio\u0026#39;: 3, \u0026#39;alto\u0026#39;: 2, \u0026#39;bajo\u0026#39;: 1} * Edad promedio: 31.5 años Productos: 12 * Por categoría: {\u0026#39;tecnologia\u0026#39;: 4, \u0026#39;lectura\u0026#39;: 2, \u0026#39;gaming\u0026#39;: 2, \u0026#39;hogar\u0026#39;: 1, \u0026#39;fitness\u0026#39;: 2, \u0026#39;cocina\u0026#39;: 1} * Precio promedio: $37,950 * Calificación promedio: 4.36/5 Interacciones: 22 * Por tipo: {\u0026#39;compra\u0026#39;: 11, \u0026#39;view\u0026#39;: 9, \u0026#39;wishlist\u0026#39;: 2} * Por usuario: {\u0026#39;user_001\u0026#39;: 4, \u0026#39;user_002\u0026#39;: 4, \u0026#39;user_003\u0026#39;: 4, \u0026#39;user_004\u0026#39;: 4, \u0026#39;user_005\u0026#39;: 3, \u0026#39;user_006\u0026#39;: 3} * Usuarios activos: 6 Similitudes: * Promedio: 0.162 * Máxima: 0.398 * Mínima: 0.000 ============================= Reporte Detallado - ANA LÓPEZ ============================= Perfil del usuario * Edad: 28 años * Género: F * Ubicación: Buenos Aires * Intereses: tecnologia, fitness, lectura * Nivel de gasto: medio Historial de actividad (4 interacciones): • 2024-08-17: WISHLIST - Cámara DSLR Canon EOS Rebel T7 • 2024-08-10: COMPRA - Proteína Whey Gold Standard (Calificación: 4/5) • 2024-08-05: VIEW - Auriculares Bluetooth Sport Pro • 2024-08-01: COMPRA - Smartphone Samsung Galaxy S24 (Calificación: 5/5) 3 usuarios más similares * Diego Silva: 0.398 (39.8% similar) * Roberto García: 0.322 (32.2% similar) * Laura Martínez: 0.246 (24.6% similar) Generando recomendaciones para Ana López ======================================== Aplicando filtrado colaborativo para Ana López... Usuarios similares encontrados: 5 6 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Ana López... 8 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 8 Aplicando reglas de negocio * Los usuarios jóvenes (\u0026lt;35) prefieren productos tecnológicos: 1 productos afectados 1 reglas aplicadas: boost_tecnologia_jovenes Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Tablet Samsung Galaxy Tab S9 Precio: $95,000 Calificación: 4.4/5 Puntuación: 3.214 Explicación: Te gusta la categoría tecnologia; Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.4/5); Producto muy popular #2 - Set Pesas Ajustables 40kg Precio: $15,000 Calificación: 4.1/5 Puntuación: 3.179 Explicación: Coincide con tu interés en fitness; Te gusta la categoría fitness; Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.1/5); A usuarios con perfil similar también les gustó #3 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificación: 4.5/5 Puntuación: 2.808 Explicación: Coincide con tu interés en tecnologia; Te gusta la categoría lectura; Apropiado para tu grupo de edad; Excelente valoración (4.5/5) #4 - Libro: Cocina Mediterránea Saludable Precio: $3,500 Calificación: 4.8/5 Puntuación: 2.14 Explicación: Te gusta la categoría lectura; Apropiado para tu grupo de edad; Excelente valoración (4.8/5) #5 - Cafetera Espresso DeLonghi Precio: $32,000 Calificación: 4.2/5 Puntuación: 1.792 Explicación: Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.2/5); A usuarios con perfil similar también les gustó ================================= Reporte Detallado - CARLOS MENDEZ ================================= Perfil del usuario * Edad: 35 años * Género: M * Ubicación: Córdoba * Intereses: deportes, gaming, musica * Nivel de gasto: alto Historial de actividad (4 interacciones): • 2024-08-18: VIEW - Tablet Samsung Galaxy Tab S9 • 2024-08-12: COMPRA - Auriculares Gaming HyperX Cloud III (Calificación: 5/5) • 2024-08-07: VIEW - Smartphone Samsung Galaxy S24 • 2024-08-03: COMPRA - Juego: Call of Duty Modern Warfare III (Calificación: 4/5) 3 usuarios más similares * Roberto García: 0.192 (19.2% similar) * Laura Martínez: 0.168 (16.8% similar) * Diego Silva: 0.120 (12.0% similar) Generando recomendaciones para Carlos Mendez ============================================ Aplicando filtrado colaborativo para Carlos Mendez... Usuarios similares encontrados: 5 6 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Carlos Mendez... 8 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 8 Aplicando reglas de negocio * Usuarios con gasto alto ven productos premium primero: 8 productos afectados 1 reglas aplicadas: usuarios_premium Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Auriculares Bluetooth Sport Pro Precio: $25,000 Calificación: 4.2/5 Puntuación: 2.392 Explicación: Coincide con tu interés en deportes; Apropiado para tu grupo de edad; Buena valoración (4.2/5); Producto muy popular #2 - Cámara DSLR Canon EOS Rebel T7 Precio: $85,000 Calificación: 4.3/5 Puntuación: 1.949 Explicación: Apropiado para tu grupo de edad; Producto premium que se ajusta a tu perfil; Buena valoración (4.3/5) #3 - Proteína Whey Gold Standard Precio: $7,200 Calificación: 4.6/5 Puntuación: 1.697 Explicación: Apropiado para tu grupo de edad; Excelente valoración (4.6/5); Producto muy popular #4 - Cafetera Espresso DeLonghi Precio: $32,000 Calificación: 4.2/5 Puntuación: 1.689 Explicación: Apropiado para tu grupo de edad; Buena valoración (4.2/5) #5 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificación: 4.5/5 Puntuación: 1.633 Explicación: Apropiado para tu grupo de edad; Excelente valoración (4.5/5) =================================== Reporte Detallado - MARÍA RODRIGUEZ =================================== Perfil del usuario * Edad: 42 años * Género: F * Ubicación: Rosario * Intereses: cocina, jardineria, arte * Nivel de gasto: bajo Historial de actividad (4 interacciones): • 2024-08-20: VIEW - Cámara DSLR Canon EOS Rebel T7 • 2024-08-15: COMPRA - Cafetera Espresso DeLonghi (Calificación: 3/5) • 2024-08-06: VIEW - Kit Herramientas Jardín Premium • 2024-08-02: COMPRA - Libro: Cocina Mediterránea Saludable (Calificación: 5/5) 3 usuarios más similares * Roberto García: 0.193 (19.3% similar) * Laura Martínez: 0.120 (12.0% similar) * Ana López: 0.060 (6.0% similar) Generando recomendaciones para María Rodriguez ============================================== Aplicando filtrado colaborativo para María Rodriguez... Usuarios similares encontrados: 5 7 recomendaciones colaborativas generadas Aplicando filtrado por contenido para María Rodriguez... 8 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 8 Aplicando reglas de negocio * Usuarios con presupuesto bajo ven productos económicos: 2 productos afectados 1 reglas aplicadas: productos_economicos Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Proteína Whey Gold Standard Precio: $7,200 Calificación: 4.6/5 Puntuación: 2.432 Explicación: Apropiado para tu grupo de edad; Precio económico y accesible; Excelente valoración (4.6/5); Producto muy popular #2 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificación: 4.5/5 Puntuación: 2.313 Explicación: Apropiado para tu grupo de edad; Precio económico y accesible; Excelente valoración (4.5/5) #3 - Set Pesas Ajustables 40kg Precio: $15,000 Calificación: 4.1/5 Puntuación: 1.588 Explicación: Apropiado para tu grupo de edad; Precio económico y accesible; Buena valoración (4.1/5) #4 - Smartphone Samsung Galaxy S24 Precio: $150,000 Calificación: 4.5/5 Puntuación: 1.572 Explicación: Apropiado para tu grupo de edad; Excelente valoración (4.5/5); Producto muy popular #5 - Tablet Samsung Galaxy Tab S9 Precio: $95,000 Calificación: 4.4/5 Puntuación: 1.352 Explicación: Apropiado para tu grupo de edad; Buena valoración (4.4/5); Producto muy popular =============================== Reporte Detallado - DIEGO SILVA =============================== Perfil del usuario * Edad: 24 años * Género: M * Ubicación: Buenos Aires * Intereses: tecnologia, gaming, fitness * Nivel de gasto: medio Historial de actividad (4 interacciones): • 2024-08-19: WISHLIST - Smartphone Samsung Galaxy S24 • 2024-08-14: COMPRA - Set Pesas Ajustables 40kg (Calificación: 4/5) • 2024-08-08: VIEW - Juego: Call of Duty Modern Warfare III • 2024-08-04: COMPRA - Auriculares Bluetooth Sport Pro (Calificación: 4/5) 3 usuarios más similares * Ana López: 0.398 (39.8% similar) * Roberto García: 0.310 (31.0% similar) * Carlos Mendez: 0.120 (12.0% similar) Generando recomendaciones para Diego Silva ========================================== Aplicando filtrado colaborativo para Diego Silva... Usuarios similares encontrados: 5 5 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Diego Silva... 8 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 8 Aplicando reglas de negocio * Los usuarios jóvenes (\u0026lt;35) prefieren productos tecnológicos: 2 productos afectados 1 reglas aplicadas: boost_tecnologia_jovenes Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Tablet Samsung Galaxy Tab S9 Precio: $95,000 Calificación: 4.4/5 Puntuación: 3.214 Explicación: Te gusta la categoría tecnologia; Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.4/5); Producto muy popular #2 - Cámara DSLR Canon EOS Rebel T7 Precio: $85,000 Calificación: 4.3/5 Puntuación: 3.151 Explicación: Te gusta la categoría tecnologia; Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.3/5) #3 - Auriculares Gaming HyperX Cloud III Precio: $18,000 Calificación: 4.4/5 Puntuación: 3.124 Explicación: Coincide con tu interés en gaming; Te gusta la categoría gaming; Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.4/5) #4 - Proteína Whey Gold Standard Precio: $7,200 Calificación: 4.6/5 Puntuación: 2.979 Explicación: Coincide con tu interés en fitness; Te gusta la categoría fitness; Apropiado para tu grupo de edad; Excelente valoración (4.6/5); A usuarios con perfil similar también les gustó; Producto muy popular #5 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificación: 4.5/5 Puntuación: 1.592 Explicación: Coincide con tu interés en tecnologia; Excelente valoración (4.5/5) ================================== Reporte Detallado - LAURA MARTÍNEZ ================================== Perfil del usuario * Edad: 31 años * Género: F * Ubicación: Mendoza * Intereses: lectura, arte, musica * Nivel de gasto: medio Historial de actividad (3 interacciones): • 2024-08-13: VIEW - Cámara DSLR Canon EOS Rebel T7 • 2024-08-11: COMPRA - Libro: El Arte de la Guerra Digital (Calificación: 5/5) • 2024-08-09: VIEW - Libro: Cocina Mediterránea Saludable 3 usuarios más similares * Ana López: 0.246 (24.6% similar) * Carlos Mendez: 0.168 (16.8% similar) * Roberto García: 0.144 (14.4% similar) Generando recomendaciones para Laura Martínez ============================================= Aplicando filtrado colaborativo para Laura Martínez... Usuarios similares encontrados: 5 7 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Laura Martínez... 9 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 9 Aplicando reglas de negocio * Los usuarios jóvenes (\u0026lt;35) prefieren productos tecnológicos: 3 productos afectados 1 reglas aplicadas: boost_tecnologia_jovenes Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Auriculares Bluetooth Sport Pro Precio: $25,000 Calificación: 4.2/5 Puntuación: 2.186 Explicación: Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.2/5); Producto muy popular #2 - Tablet Samsung Galaxy Tab S9 Precio: $95,000 Calificación: 4.4/5 Puntuación: 2.174 Explicación: Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.4/5); Producto muy popular #3 - Smartphone Samsung Galaxy S24 Precio: $150,000 Calificación: 4.5/5 Puntuación: 2.15 Explicación: Apropiado para tu grupo de edad; Excelente valoración (4.5/5); Producto muy popular #4 - Juego: Call of Duty Modern Warfare III Precio: $12,000 Calificación: 4.3/5 Puntuación: 1.785 Explicación: Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.3/5); Producto muy popular #5 - Auriculares Gaming HyperX Cloud III Precio: $18,000 Calificación: 4.4/5 Puntuación: 1.753 Explicación: Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.4/5) ================================== Reporte Detallado - ROBERTO GARCÍA ================================== Perfil del usuario * Edad: 29 años * Género: M * Ubicación: La Plata * Intereses: deportes, tecnologia, cocina * Nivel de gasto: alto Historial de actividad (3 interacciones): • 2024-08-16: VIEW - Tablet Samsung Galaxy Tab S9 • 2024-08-09: COMPRA - Cafetera Espresso DeLonghi (Calificación: 4/5) • 2024-08-05: COMPRA - Smartphone Samsung Galaxy S24 (Calificación: 5/5) 3 usuarios más similares * Ana López: 0.322 (32.2% similar) * Diego Silva: 0.310 (31.0% similar) * María Rodriguez: 0.193 (19.3% similar) Generando recomendaciones para Roberto García ============================================= Aplicando filtrado colaborativo para Roberto García... Usuarios similares encontrados: 5 7 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Roberto García... 9 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 9 Aplicando reglas de negocio * Los usuarios jóvenes (\u0026lt;35) prefieren productos tecnológicos: 2 productos afectados * Usuarios con gasto alto ven productos premium primero: 9 productos afectados 2 reglas aplicadas: boost_tecnologia_jovenes, usuarios_premium Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Auriculares Bluetooth Sport Pro Precio: $25,000 Calificación: 4.2/5 Puntuación: 4.5 Explicación: Coincide con tu interés en deportes; Te gusta la categoría tecnologia; Apropiado para tu grupo de edad; Buena valoración (4.2/5); A usuarios con perfil similar también les gustó; Producto muy popular #2 - Cámara DSLR Canon EOS Rebel T7 Precio: $85,000 Calificación: 4.3/5 Puntuación: 3.781 Explicación: Te gusta la categoría tecnologia; Apropiado para tu grupo de edad; Producto premium que se ajusta a tu perfil; Buena valoración (4.3/5) #3 - Libro: Cocina Mediterránea Saludable Precio: $3,500 Calificación: 4.8/5 Puntuación: 2.424 Explicación: Coincide con tu interés en cocina; Apropiado para tu grupo de edad; Excelente valoración (4.8/5) #4 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificación: 4.5/5 Puntuación: 2.336 Explicación: Coincide con tu interés en tecnologia; Apropiado para tu grupo de edad; Excelente valoración (4.5/5) #5 - Proteína Whey Gold Standard Precio: $7,200 Calificación: 4.6/5 Puntuación: 1.851 Explicación: Apropiado para tu grupo de edad; Excelente valoración (4.6/5); A usuarios con perfil similar también les gustó; Producto muy popular ===================================== Demostración Completada Exitosamente! Revisa los reportes anteriores para entender cómo funciona cada componente ===================================== Comparación de algoritmos # \u0026gt; python main.py Selecciona el tipo de demostración: 1- Demostración completa 2- Comparación de algoritmos 3- Usuario específico Opción (1-3): 2 ========================= Comparación de Algoritmos ========================= Cargando la configuración desde config.yaml Configuración cargada desde config.yaml Configuración validada exitosamente Inicializando Sistema de Recomendaciones * 6 usuarios cargados * 12 productos cargados * 22 interacciones cargadas Sistema listo! Usuario de prueba: Ana López Recomendaciones por filtrado colaborativo: Aplicando filtrado colaborativo para Ana López... Usuarios similares encontrados: 5 5 recomendaciones colaborativas generadas 1. Set Pesas Ajustables 40kg (Puntuación: 0.318) 2. Cafetera Espresso DeLonghi (Puntuación: 0.294) 3. Libro: El Arte de la Guerra Digital (Puntuación: 0.246) 4. Libro: Cocina Mediterránea Saludable (Puntuación: 0.060) 5. Auriculares Gaming HyperX Cloud III (Puntuación: 0.054) Recomendaciones por filtrado por contenido: Aplicando filtrado por contenido para Ana López... 5 recomendaciones por contenido generadas 1. Set Pesas Ajustables 40kg (Puntuación: 7.470) 2. Libro: El Arte de la Guerra Digital (Puntuación: 6.650) 3. Tablet Samsung Galaxy Tab S9 (Puntuación: 6.180) 4. Libro: Cocina Mediterránea Saludable (Puntuación: 5.260) 5. Juego: Call of Duty Modern Warfare III (Puntuación: 4.260) Sistema híbrido Generando recomendaciones para Ana López ======================================== Aplicando filtrado colaborativo para Ana López... Usuarios similares encontrados: 5 6 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Ana López... 8 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 8 Aplicando reglas de negocio * Los usuarios jóvenes (\u0026lt;35) prefieren productos tecnológicos: 1 productos afectados 1 reglas aplicadas: boost_tecnologia_jovenes Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 1. Tablet Samsung Galaxy Tab S9 (Puntuación: 3.214) 2. Set Pesas Ajustables 40kg (Puntuación: 3.179) 3. Libro: El Arte de la Guerra Digital (Puntuación: 2.808) 4. Libro: Cocina Mediterránea Saludable (Puntuación: 2.14) 5. Cafetera Espresso DeLonghi (Puntuación: 1.792) Observaciones * Colaborativo: Basado en usuarios similares * Contenido: Basado en perfil del usuario * Híbrido: Combina ambos enfoques Usuario específico # \u0026gt; python main.py Selecciona el tipo de demostración: 1- Demostración completa 2- Comparación de algoritmos 3- Usuario específico Opción (1-3): 3 Cargando la configuración desde config.yaml Configuración cargada desde config.yaml Configuración validada exitosamente Inicializando Sistema de Recomendaciones * 6 usuarios cargados * 12 productos cargados * 22 interacciones cargadas Sistema listo! Usuarios disponibles: user_001: Ana López user_002: Carlos Mendez user_003: María Rodriguez user_004: Diego Silva user_005: Laura Martínez user_006: Roberto García Ingresa ID de usuario: user_002 ================================= Reporte Detallado - CARLOS MENDEZ ================================= Perfil del usuario * Edad: 35 años * Género: M * Ubicación: Córdoba * Intereses: deportes, gaming, musica * Nivel de gasto: alto Historial de actividad (4 interacciones): • 2024-08-18: VIEW - Tablet Samsung Galaxy Tab S9 • 2024-08-12: COMPRA - Auriculares Gaming HyperX Cloud III (Calificación: 5/5) • 2024-08-07: VIEW - Smartphone Samsung Galaxy S24 • 2024-08-03: COMPRA - Juego: Call of Duty Modern Warfare III (Calificación: 4/5) 3 usuarios más similares * Roberto García: 0.192 (19.2% similar) * Laura Martínez: 0.168 (16.8% similar) * Diego Silva: 0.120 (12.0% similar) Generando recomendaciones para Carlos Mendez ============================================ Aplicando filtrado colaborativo para Carlos Mendez... Usuarios similares encontrados: 5 6 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Carlos Mendez... 8 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 8 Aplicando reglas de negocio * Usuarios con gasto alto ven productos premium primero: 8 productos afectados 1 reglas aplicadas: usuarios_premium Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Auriculares Bluetooth Sport Pro Precio: $25,000 Calificación: 4.2/5 Puntuación: 2.392 Explicación: Coincide con tu interés en deportes; Apropiado para tu grupo de edad; Buena valoración (4.2/5); Producto muy popular #2 - Cámara DSLR Canon EOS Rebel T7 Precio: $85,000 Calificación: 4.3/5 Puntuación: 1.949 Explicación: Apropiado para tu grupo de edad; Producto premium que se ajusta a tu perfil; Buena valoración (4.3/5) #3 - Proteína Whey Gold Standard Precio: $7,200 Calificación: 4.6/5 Puntuación: 1.697 Explicación: Apropiado para tu grupo de edad; Excelente valoración (4.6/5); Producto muy popular #4 - Cafetera Espresso DeLonghi Precio: $32,000 Calificación: 4.2/5 Puntuación: 1.689 Explicación: Apropiado para tu grupo de edad; Buena valoración (4.2/5) #5 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificación: 4.5/5 Puntuación: 1.633 Explicación: Apropiado para tu grupo de edad; Excelente valoración (4.5/5) ¿Qué nos aporta esta solución? # Sistema híbrido: Combinamos múltiples estrategias de recomendación para obtener mejores resultados. Reglas de negocio: Implementamos lógica específica del dominio que puede adaptarse fácilmente. Explicabilidad: El sistema puede explicar por qué recomienda cada producto, generando confianza. Escalabilidad: La arquitectura permite agregar nuevas fuentes de datos y reglas fácilmente. Ejercicios para profundizar # A continuación tienes algunos ejercicios que te ayudarán a profundizar tus conocimientos.\nEjercicio 1: Implementa una nueva regla de negocio que dé boost a productos en oferta durante los fines de semana. Ejercicio 2: Implementa un sistema de feedback que aprenda de las interacciones del usuario (like/dislike). Por supuesto, no tienes porque detenerte en estas recomendaciones, dejá volar tu imaginación y utilizá los conceptos aprendidos para otros casos.\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"03 September 2025","externalUrl":null,"permalink":"/ai/module1/project/","section":"Inteligencia Artificial","summary":"","title":"Proyecto usando Machine Learning: Sistema de Recomendaciones","type":"ai"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/programming/data-structures/","section":"Programming","summary":"","title":"Data Structures","type":"programming"},{"content":"Key characteristics of association:\nIt represents a loose coupling between classes. The associated classes can exist independently of each other. The lifetime of one class is not tied to the lifetime of the other. It can be unidirectional or bidirectional. There are two main types of association:\nUnidirectional Association Bidirectional Association Let\u0026rsquo;s explore each of these in more detail.\nUnidirectional association # In a unidirectional association, one class knows about and can interact with another class, but not vice versa. This is a one-way relationship.\nHere\u0026rsquo;s an example in Python:\nclass Customer: def __init__(self, name): self.name = name class Order: def __init__(self, order_number, customer): self.order_number = order_number self.customer = customer # This creates an association def display_info(self): return f\u0026#34;Order {self.order_number} placed by {self.customer.name}\u0026#34; # Creating instances customer = Customer(\u0026#34;John Doe\u0026#34;) order = Order(\u0026#34;12345\u0026#34;, customer) print(order.display_info()) # Output: Order 12345 placed by John Doe In this example, the Order class has a unidirectional association with the Customer class. An Order knows about its associated Customer, but a Customer doesn\u0026rsquo;t know about its Orders.\nHere\u0026rsquo;s a UML diagram representing this relationship:\nclassDiagram class Customer { +name: string } class Order { +order_number: string +customer: Customer +display_info() } Order --\u003e Customer : places end The arrow in the diagram points from Order to Customer, indicating that Order knows about Customer, but not the other way around.\nBidirectional association # In a bidirectional association, both classes are aware of each other and can interact with each other. This is a two-way relationship.\nHere\u0026rsquo;s an example in Python:\nclass Student: def __init__(self, name): self.name = name self.courses = [] def enrol(self, course): self.courses.append(course) course.add_student(self) def display_courses(self): return f\u0026#34;{self.name} is enrolled in: {\u0026#39;, \u0026#39;.join(course.name for course in self.courses)}\u0026#34; class Course: def __init__(self, name): self.name = name self.students = [] def add_student(self, student): self.students.append(student) def display_students(self): return f\u0026#34;{self.name} has students: {\u0026#39;, \u0026#39;.join(student.name for student in self.students)}\u0026#34; # Creating instances student1 = Student(\u0026#34;Alice\u0026#34;) student2 = Student(\u0026#34;Bob\u0026#34;) math_course = Course(\u0026#34;Mathematics\u0026#34;) physics_course = Course(\u0026#34;Physics\u0026#34;) # enrolling students in courses student1.enrol(math_course) student1.enrol(physics_course) student2.enrol(math_course) print(student1.display_courses()) print(math_course.display_students()) In this example, there\u0026rsquo;s a bidirectional association between Student and Course. A Student knows about their Courses, and a Course knows about its Students.\nHere\u0026rsquo;s a UML diagram representing this relationship:\nclassDiagram class Student { +name: string +courses: list +enrol(course) +display_courses() } class Course { +name: string +students: list +add_student(student) +display_students() } Student \"0..*\" \u003c--\u003e \"0..*\" Course : enrols in \u003e end The double-headed arrow in the diagram indicates that both Student and Course are aware of each other. The \u0026ldquo;0..*\u0026rdquo; notation indicates that a Student can be enrolled in zero or more Courses, and a Course can have zero or more Students.\nAssociation is a flexible relationship that can represent many real-world connections between objects. It\u0026rsquo;s important to choose between unidirectional and bidirectional associations carefully, as bidirectional associations can introduce more complexity and potential for errors if not managed properly.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-association/","section":"Programming","summary":"","title":"Class relations: Association","type":"programming"},{"content":"A linked list is composed of nodes where each node has two parts:\nData or information Reference to the next node Nodes are organized sequentially, each pointing to the next. The last node points to null to indicate the end.\nThis dynamic structure allows efficient insertion and deletion of nodes.\nTypes of linked lists # There are several types:\nSingly linked: Each node points to the next one. Useful for queues and stacks. Diagram of a single linked list Doubly linked: Each node has reference to the next and previous ones. Allows traversing in both directions. Diagram of a doubly linked list Circular: The last node points to the first forming a cycle. Useful for circular buffers. Diagram of a circular linked list Common operations # Insert: Add nodes to the beginning, end or middle of the list.\nDelete: Remove nodes by value or position.\nSearch: Find nodes by value by traversing the list.\nTraverse: Iterate through nodes by following the references.\nImplementation # Linked lists can be implemented as follows:\nUse the ListNode class to represent nodes:\nclass ListNode: def __init__(self, value): self.value = value self.next = None Then to create and use a list define a LinkedList class with methods for the operations:\nclass LinkedList: def __init__(self): self.head = None def add_to_start(self, new_value): new_node = ListNode(new_value) new_node.next = self.head self.head = new_node def print(self): current = self.head while current != None: print(current.value) current = current.next def search(self, searched_value): current = self.head while current != None: if current.value == searched_value: return True current = current.next return False #...other methods With this LinkedList class we can create a list, add nodes, print it, search elements, etc.\nWe could add other methods like insert at end, delete by value, get by index, etc. But this gives an idea of how to encapsulate the linked list functionality in a class. As practice, feel free to try adding these methods on your own. Don\u0026rsquo;t hesitate to leave your comments and contact me if you need help!\nAdvantages and disadvantages # Advantages:\nInserting and deleting nodes is efficient. Doesn\u0026rsquo;t require defining a fixed size like arrays. Dynamic, flexible structure. Disadvantages:\nMore memory usage from having to store references. Accessing elements by index is slower since it is sequential. Usage examples # Implementing structures like stacks and queues. In doubly linked lists, traverse the list in both directions. Blockchains like Bitcoin\u0026rsquo;s. Playing elements in order like music playlists. Conclusion # Linked lists are a versatile data structure for storing dynamic sequences of elements. Having a good handle on these lists, their operations, and uses is essential for any programmer.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"01 November 2023","externalUrl":null,"permalink":"/en/programming/data-structures/linked-lists/","section":"Programming","summary":"","title":"Linked Lists","type":"programming"},{"content":" What are functions? # A function, in simple terms, is a block of code that executes only when called. You can think of it as a small program within your main program, designed to perform a specific task. A function can also be seen as a black box: we pass an input (parameters), some internal processing occurs, and it produces an output (return value).\nFunctions allow us to segment our code into logical parts where each part performs a single action. This provides several benefits:\nReusability: Once defined, we can execute (call) that code from anywhere in our program as many times as needed. Organization: It allows dividing a large program into smaller, more manageable parts. Encapsulation: Functions reduce complexity by hiding internal implementation details. Maintainability: If we need to make changes, we only have to modify the code in one place (the function) instead of tracking down all instances of that code. Procedures vs. Functions\nIt is vital to distinguish between these two concepts. While a function always returns a value, a procedure performs a task but does not return anything. In some languages, this difference is clearer than in others. Python, for example, has functions that can optionally return values.\nAnatomy of a function # In Python, a function is declared using the def keyword, followed by the function name and parentheses. The code inside the function is called the body of the function and contains the set of instructions to execute to perform its task.\ndef my_function(): print(\u0026#34;Hello from my function!\u0026#34;) To call or invoke a function, we simply use its name followed by parentheses:\nmy_function() # Output: Hello from my function! Parameters and arguments # Functions become even more powerful when we pass information to them, known as parameters. These act as \u0026ldquo;variables\u0026rdquo; inside the function, allowing the function to work with different data each time it is called.\nWhile parameters are variables defined in the function definition, arguments are the actual values passed when calling the function.\ndef greet(name): print(f\u0026#34;Hello {name}!\u0026#34;) greet(\u0026#34;Maria\u0026#34;) # Output: # Hello Maria! Python allows default parameters, which have a predetermined value, making passing those arguments optional when calling the function. It also allows named parameters which enable passing arguments in any order by specifying their name.\ndef greet(name=\u0026#34;Maria\u0026#34;, repetitions=3): repetition = 1 while repetition \u0026lt;= repetitions: print(f\u0026#34;Hello {name}!\u0026#34;) repetition += 1 greet() # Output: # Hello Maria! # Hello Maria! # Hello Maria! greet(\u0026#34;Florencia\u0026#34;, 4) # Output: # Hello Florencia! # Hello Florencia! # Hello Florencia! # Hello Florencia! greet(repetitions=2, name=\u0026#34;Julian\u0026#34;) # Output # Hello Julian! # Hello Julian! Returning values # Functions can return a result or return value using the return keyword.\ndef circle_area(radius): return 3.14 * (radius ** 2) result = circle_area(10) print(result) # Output: 314 The return value is passed back to where the function was called and can be assigned to a variable for later use.\nFunctions can also perform some task without explicitly returning anything. In Python this is known as returning None.\nLocal and global variables # Local variables are defined inside a function and only exist in that scope, while global variables are defined outside and can be accessed from anywhere in the code. It is crucial to understand their scope (where a variable is accessible) and lifetime (how long a variable lives).\nx = 10 # x is global def add(): y = 5 # y is local return x + y add() # Output: 15 print(y) # Error, y does not exist outside the function We can read global variables from a function, but if we need to modify it we must declare it global.\nx = 10 def add(): global x x = x + 5 add() print(x) # 15 ","date":"29 September 2023","externalUrl":null,"permalink":"/en/programming/starting-concepts/functions/","section":"Programming","summary":"","title":"Functions","type":"programming"},{"content":"Named in honour of George Boole, a 19th-century English mathematician, Boolean logic is a mathematical system that deals with operations resulting in one of two possible outcomes: true or false, typically represented as 1 and 0, respectively. In his groundbreaking work, \u0026ldquo;An Investigation of the Laws of Thought,\u0026rdquo; Boole laid the foundations for this logic, introducing an algebraic system that could be employed to depict logical structures.\nBoolean operations # Within Boolean logic, several fundamental operations allow for the manipulation and combination of these binary expressions:\nAND: This operation yields true (1) only if both inputs are true. For instance, if you have two switches, both need to be in the on position for a light to illuminate.\nOR: It returns true if at least one of the inputs is true. Using the switch analogy, as long as one of them is in the on position, the light will shine.\nNOT: This unary operation (accepting only one input) simply inverts the input value. Provide it with a 1, and you\u0026rsquo;ll get a 0, and vice versa.\nNAND (NOT AND): It\u0026rsquo;s the negation of AND. It only returns false if both inputs are true.\nNOR (NOT OR): The negation of OR. It yields true only if both inputs are false.\nXOR (Exclusive OR): It returns true if the inputs differ. If both are the same, it returns false.\nXNOR (Exclusive NOR): The inverse of XOR. It yields true if both inputs are the same.\nWhy is this logic important in computing and programming? # Modern computing, at its core, is all about bit manipulation (those 1s and 0s we\u0026rsquo;ve mentioned). Every operation a computer undertakes, from basic arithmetic to rendering intricate graphics, involves Boolean operations at some level.\nIn programming, Boolean logic is used in control structures, such as conditional statements (if, else) and loops, allowing programs to make decisions based on specific conditions.\nTruth Tables: mapping Boolean logic # A truth table graphically represents a Boolean operation. It lists every possible input combination and displays the operation\u0026rsquo;s result for each combination.\nFor instance:\nA B A AND B A OR B A XOR B A NOR B A NAND B NOT A A NXOR B 1 1 1 1 0 0 0 0 1 1 0 0 1 1 0 1 0 0 0 1 0 1 1 0 1 1 0 0 0 0 0 0 1 1 1 1 Concluding thoughts # Boolean logic is more than a set of abstract mathematical rules. It\u0026rsquo;s the foundational language of machines, the code underpinning the digital age in which we live. By understanding its principles, not only do we become more proficient in working with technology, but we also gain a deeper appreciation of the structures supporting our digital world.\nReferences # Boole, G. (1854). An Investigation of the Laws of Thought. London: Walton and Maberly. Tanenbaum, A. (2012). Structured Computer Organization. New Jersey: Prentice Hall. Minsky, M. (1967). Computation: Finite and Infinite Machines. New Jersey: Prentice-Hall. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"09 September 2023","externalUrl":null,"permalink":"/en/programming/intro/boolean-logic/","section":"Programming","summary":"","title":"Boolean Logic","type":"programming"},{"content":" Llegó el momento de cerrar nuestro paso por los fundamentos de la Inteligencia Artificial. Ahora vamos a repasar lo aprendido, aclarar algunas dudas y prepararnos para el próximo módulo. FAQ: Dudas domunes # 1. ¿Por qué empezamos con reglas en lugar de Machine Learning avanzado? # Las reglas lógicas son la base de todo sistema inteligente. Antes de usar algoritmos complejos, necesitas entender:\nCómo estructurar el conocimiento Cómo manejar incertidumbre Cómo combinar múltiples fuentes de información Cómo hacer sistemas explicables Estos conceptos se aplican igual en Deep Learning.\n2. ¿Cuándo usar IA clásica vs Machine Learning? # IA Clásica (reglas, sistemas expertos):\n✅ Conocimiento del dominio bien definido ✅ Reglas claras y estables ✅ Necesitas explicabilidad total ✅ Pocos datos disponibles ❌ Patrones muy complejos ❌ Necesitas adaptación automática Machine Learning:\n✅ Muchos datos disponibles ✅ Patrones complejos o desconocidos ✅ El dominio cambia frecuentemente ✅ Necesitas adaptación automática ❌ Pocos datos de entrenamiento ❌ Explicabilidad crítica para el negocio 3. ¿Los sistemas de reglas son obsoletos? # No, para nada. Muchos sistemas en producción combinan ambos enfoques:\nNetflix: Usa ML para analizar patrones de viewing, pero reglas de negocio para decidir qué mostrar en diferentes contextos Sistemas médicos: Usan ML para análisis de imágenes, pero reglas expertas para diagnósticos críticos Trading algorítmico: Combina ML para predicciones con reglas de gestión de riesgos 4. ¿Por qué no usar directamente bibliotecas como scikit-learn? # En este primer módulo, la idea es que entiendas qué está pasando por debajo. Una vez que domines los conceptos fundamentales, las bibliotecas serán herramientas poderosas, no cajas negras.\nPiénsalo así: puedes usar un framework web como Django, pero es porque entiendes HTTP, requests, responses, etc.\n5. ¿Cómo sé si mi sistema de IA está funcionando bien? # Para sistemas de reglas:\nPrecisión: ¿Las predicciones son correctas? Cobertura: ¿El sistema puede manejar todos los casos? Consistencia: ¿Las reglas se contradicen entre sí? Performance: ¿Es lo suficientemente rápido para producción? Más adelante veremos métricas específicas para ML.\nPróximos pasos: módulo 2 # En el próximo módulo nos sumergiremos en las matemáticas esenciales para entender Machine Learning. No te preocupes, no vamos a ser académicos aburridos. Vamos a cubrir solo las matemáticas que realmente necesitas:\nÁlgebra Lineal práctica\nVectores y matrices (¿por qué importan?) Operaciones esenciales Representación de datos como matrices Estadística\nProbabilidades básicas Distribuciones importantes Correlación vs causalidad Cálculo para optimización\nDerivadas (solo las que necesitas) Gradientes y optimización ¿Por qué necesitas estas matemáticas? # Cada algoritmo de ML es fundamentalmente:\nUna función matemática que mapea entradas a salidas Un proceso de optimización que encuentra los mejores parámetros Un framework estadístico que maneja incertidumbre Sin entender esto, estarás ajustando hiperparámetros al azar y rogando que funcione.\nReflexión final # Has completado tu primer módulo en el camino a convertirte en un ingeniero en IA. Cubriste mucho terreno:\n✅ Desmitificaste la IA: ya sabes la diferencia real entre IA, ML y DL ✅ Implementaste sistemas inteligentes: desde cero, sin bibliotecas mágicas ✅ Entendiste los fundamentos: que se aplicarán a todo lo que aprendas después ✅ Construiste un proyecto real: sistema de recomendaciones funcional\nPero esto es solo el comienzo. La IA no es magia, es ingeniería sistemática aplicada a problemas complejos. Como cualquier habilidad de ingeniería, se domina con práctica y fundamentos sólidos.\nEn el próximo módulo agregaremos las matemáticas que necesitas. No para ser un académico, sino para ser un practicante efectivo que entiende sus herramientas.\nRecuerda: Cada experto fue alguna vez un principiante. La diferencia está en la consistencia y la profundidad de comprensión, no en la velocidad.\n¡Nos vemos en el siguiente módulo! 🚀\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"04 September 2025","externalUrl":null,"permalink":"/ai/module1/conclusion/","section":"Inteligencia Artificial","summary":"","title":"Fundamentos de Inteligencia Artificial: Conclusión","type":"ai"},{"content":"Key characteristics of aggregation:\nIt\u0026rsquo;s a stronger relationship than a simple association, but weaker than composition. The \u0026ldquo;part\u0026rdquo; object can exist independently of the \u0026ldquo;whole\u0026rdquo; object. Multiple \u0026ldquo;whole\u0026rdquo; objects can share the same \u0026ldquo;part\u0026rdquo; object. If the \u0026ldquo;whole\u0026rdquo; object is destroyed, the \u0026ldquo;part\u0026rdquo; object continues to exist. Let\u0026rsquo;s look at an example to illustrate aggregation:\nclass Department: def __init__(self, name): self.name = name self.employees = [] def add_employee(self, employee): self.employees.append(employee) def remove_employee(self, employee): self.employees.remove(employee) def list_employees(self): return f\u0026#34;Department {self.name} has employees: {\u0026#39;, \u0026#39;.join(emp.name for emp in self.employees)}\u0026#34; class Employee: def __init__(self, name, id): self.name = name self.id = id def __str__(self): return f\u0026#34;Employee(name={self.name}, id={self.id})\u0026#34; # Creating instances hr_dept = Department(\u0026#34;Human Resources\u0026#34;) it_dept = Department(\u0026#34;Information Technology\u0026#34;) emp1 = Employee(\u0026#34;Alice\u0026#34;, \u0026#34;E001\u0026#34;) emp2 = Employee(\u0026#34;Bob\u0026#34;, \u0026#34;E002\u0026#34;) emp3 = Employee(\u0026#34;Charlie\u0026#34;, \u0026#34;E003\u0026#34;) # Adding employees to departments hr_dept.add_employee(emp1) hr_dept.add_employee(emp2) it_dept.add_employee(emp2) # Note: Bob works in both HR and IT it_dept.add_employee(emp3) print(hr_dept.list_employees()) print(it_dept.list_employees()) # If we remove the HR department, the employees still exist del hr_dept print(emp1) # Employee still exists In this example, we have an aggregation relationship between Department and Employee. A Department has Employees, but Employees can exist independently of any particular Department. Also, an Employee can belong to multiple Departments (as we see with Bob).\nHere\u0026rsquo;s a UML diagram representing this aggregation relationship:\nclassDiagram class Department { +name: string +employees: list +add_employee(employee) +remove_employee(employee) +list_employees() } class Employee { +name: string +id: string +__str__() } Department o-- Employee : has end In this diagram, the open diamond on the Department side of the relationship indicates aggregation. This shows that Department is the \u0026ldquo;whole\u0026rdquo; and Employee is the \u0026ldquo;part\u0026rdquo; in this relationship.\nIt\u0026rsquo;s important to note that while aggregation implies a whole-part relationship, the \u0026ldquo;part\u0026rdquo; (in this case, Employee) can exist independently and can even be part of multiple \u0026ldquo;wholes\u0026rdquo; (multiple Departments).\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-aggregation/","section":"Programming","summary":"","title":"Class relations: Aggregation","type":"programming"},{"content":"The LIFO nature of stacks is due to the fact that only the top element can be accessed and manipulated. The operation of placing an element on the stack is known as \u0026ldquo;push\u0026rdquo;, while removing an element from the stack is a \u0026ldquo;pop\u0026rdquo;. The LIFO operation causes the last element placed in a stack to be the first to be removed.\nDiagram of a stack Main operations # The primary operations supported by a stack structure are:\nPush: adds an element to the top of the stack. Pop: removes the element at the top of the stack. Peek: allows accessing the top element without removing it from the stack. isEmpty: checks if the stack is empty. Most languages like Python and Java provide stack implementations in their standard libraries.\nImplementation # A stack can be implemented using a linked list so that each node points to the previous node.\nclass Node: def __init__(self, value): self.value = value self.previous = None class Stack: def __init__(self): self.top = None self.size = 0 def push(self, value): new_node = Node(value) if self.top is None: self.top = new_node else: new_node.previous = self.top self.top = new_node self.size += 1 def pop(self): if self.top is None: return None top_node = self.top self.top = self.top.previous self.size -= 1 return top_node.value def peek(self): if self.top is None: return None return self.top.value def is_empty(self): return self.top is None # Returns true if top is None def __len__(self): return self.size def __str__(self): values = [] current = self.top while current: values.append(str(current.value)) current = current.previous return \u0026#34;\\n\u0026#34;.join(values) print(\u0026#34;Creating a new stack\u0026#34;) stack = Stack() print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if stack is empty\u0026#34;) print(f\u0026#34;Is stack empty? {stack.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Push first element\u0026#34;) print(\u0026#34; stack.push(\\\u0026#34;First\\\u0026#34;)\u0026#34;) stack.push(\u0026#34;First\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print stack:\u0026#34;) print(stack) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print top element using peek\u0026#34;) print(f\u0026#34;stack.peek() =\u0026gt; {stack.peek()}\u0026#34;) print(\u0026#34;Add two more elements: stack.push(\\\u0026#34;\\\u0026#34;):\u0026#34;) print(\u0026#34; stack.push(\\\u0026#34;Second\\\u0026#34;)\u0026#34;) print(\u0026#34; stack.push(\\\u0026#34;Third\\\u0026#34;)\u0026#34;) stack.push(\u0026#34;Second\u0026#34;) stack.push(\u0026#34;Third\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print stack:\u0026#34;) print(stack) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print top element using peek\u0026#34;) print(f\u0026#34;stack.peek() =\u0026gt; {stack.peek()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if stack is empty\u0026#34;) print(f\u0026#34;Is stack empty? {stack.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get top element using pop\u0026#34;) print(f\u0026#34;stack.pop() =\u0026gt; {stack.pop()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print top element using peek\u0026#34;) print(f\u0026#34;stack.peek() =\u0026gt; {stack.peek()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get top element using pop\u0026#34;) print(f\u0026#34;stack.pop() =\u0026gt; {stack.pop()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get top element using pop\u0026#34;) print(f\u0026#34;stack.pop() =\u0026gt; {stack.pop()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if stack is empty\u0026#34;) print(f\u0026#34;Is stack empty? {stack.is_empty()}\u0026#34;) Usage examples # Stacks have many uses in programming:\nExecution stack (call stack): records pending function calls to resolve. Implements expected LIFO behaviour.\nBrowser stack: allows going back (undo) in the browser history similarly to a LIFO stack.\nMath expression execution: stacks can verify parentheses, brackets, braces, etc.\nAlgorithms and data structures: like in the quicksort algorithm and in data path implementations.\nConclusion # Stacks are versatile data structures thanks to their LIFO operation principle. Having a good command of stacks, their uses and applications is essential in computer science.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"02 November 2023","externalUrl":null,"permalink":"/en/programming/data-structures/stacks/","section":"Programming","summary":"","title":"Stacks","type":"programming"},{"content":" Recursion: the art of calling yourself # Imagine a box of mirrors where each mirror reflects what it sees in the next, creating an infinite series of reflections. Recursion in programming is something similar. It is a technique where a function calls itself directly or indirectly. This creates a cycle where the function solves a problem by dividing it into smaller instances of the same problem, until reaching a simple base case that can be solved directly.\nFor example, let\u0026rsquo;s imagine a function that prints a countdown:\ndef countdown(number): if number \u0026gt; 0: print(number) countdown(number - 1) else: print(\u0026#34;Blastoff!\u0026#34;) countdown(5) This function calls itself recursively decrementing the number each time until reaching 0, and then prints the blastoff message.\nRecursion is a declarative approach that focuses on dividing a problem into recursive cases without needing to explicitly control the loop using iterators or counters like in imperative programming.\nThe structure of a recursive function # The power of recursion lies in its simplicity. However, it is essential to understand its structure to avoid common pitfalls. A typical recursive function has two main parts:\nBase case: The simplest case with a known solution that doesn\u0026rsquo;t require recursion. It is the stopping condition that halts the recursion. Without a base case, we would fall into infinite recursion which eventually overflows the call stack. Recursive case: This is where the magical recursive call occurs. At this point, the function calls itself with a modified argument, usually a reduced version of the original problem. Classic recursion examples # Factorial # The factorial of a positive integer \\(n\\) is the product of all positive integers less than or equal to \\(n\\). For example:\n\\(5! = 5 * 4 * 3 * 2 * 1 = 120\\) \\(4! = 4 * 3 * 2 * 1 = 24\\) \\(3! = 3 * 2 * 1 = 6\\) Here is the Python code for calculating factorial using recursion:\ndef factorial(n): if n == 1: return 1 # Base case return n * factorial(n-1) # Recursive case Base case: The base case is the simplest, smallest instance of the problem that can be answered directly. For factorial, when \\(n = 1\\), the result is \\(1\\). Recursive case: If \\(n\\) is greater than \\(1\\), the function calls itself with \\(n-1\\), and multiplies the result by \\(n\\). Let\u0026rsquo;s say you want to calculate the factorial of \\(5\\), so you call factorial(5).\nHere is what happens:\nStep 1: Since \\(n = 5\\) is not \\(1\\), the function calls factorial(4), then multiplies the result by \\(5\\). Step 2: Now, inside factorial(4), \\(n = 4\\), so the function calls factorial(3), then multiplies the result by \\(4\\). Step 3: Inside factorial(3), \\(n = 3\\), so it calls factorial(2), then multiplies the result by \\(3\\). Step 4: Inside factorial(2), \\(n = 2\\), so it calls factorial(1), then multiplies the result by \\(2\\). Step 5: Finally, factorial(1) reaches the base case, where \\(n = 1\\), so it returns \\(1\\). Now the results unwind:\nfactorial(2) returns \\(2 * 1 = 2\\) factorial(3) returns \\(3 * 2 = 6\\) factorial(4) returns \\(4 * 6 = 24\\) factorial(5) returns \\(5 * 24 = 120\\) The final result is \\(120\\), which is the value of \\(5!\\).\nHere is a visual representation of the call stack:\nfactorial(5) -\u0026gt; factorial(4) -\u0026gt; factorial(3) -\u0026gt; factorial(2) -\u0026gt; factorial(1) return 1 return 2 return 6 return 24 return 120 Fibonacci sequence # The Fibonacci sequence is a series of numbers where each number is the sum of the previous two. It starts with \\(0\\) and \\(1\\), and each subsequent number is the sum of the two numbers before it. The beginning of the sequence is: \\(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \u0026hellip;\\)\nHere is the Python code for calculating the \\(n^th\\) Fibonacci number using tail recursion:\ndef fibonacci(n, a=0, b=1): if n == 0: return a return fibonacci(n-1, b, a+b) The function takes three parameters:\n\\(n\\): The position of the desired number in the sequence. \\(a\\) and \\(b\\): Two numbers that aid in the sequence calculation. Here is a breakdown of how the function works:\nBase case: If \\(n\\) is \\(0\\), the function returns \\(a\\). This is the value of the \\(n^th\\) number in the sequence. Recursive case: If \\(n\\) is not \\(0\\), the function calls itself with \\(n-1\\), \\(b\\), and \\(a+b\\). These parameters change the position in the sequence and prepare the next numbers for summation. Suppose we want to find the \\(5^th\\) number in the Fibonacci sequence by calling fibonacci(5).\nHere is what happens:\nStep 1: Since \\(n = 5\\), it calls fibonacci(4, 1, 1) (because \\(a = 0\\), \\(b = 1\\), \\(a + b = 1\\)). Step 2: Since \\(n = 4\\), it calls fibonacci(3, 1, 2) (because \\(a = 1\\), \\(b = 1\\), \\(a + b = 2\\)). Step 3: Since \\(n = 3\\), it calls fibonacci(2, 2, 3) (because \\(a = 1\\), \\(b = 2\\), \\(a + b = 3\\)). Step 4: Since \\(n = 2\\), it calls fibonacci(1, 3, 5) (because \\(a = 2\\), \\(b = 3\\), \\(a + b = 5\\)). Step 5: Since \\(n = 1\\), it calls fibonacci(0, 5, 8) (because \\(a = 3\\), \\(b = 5\\), \\(a + b = 8\\)). Step 6: Since \\(n = 0\\), it returns \\(a\\), which is \\(5\\). The result is \\(5\\), which is the \\(5^th\\) number in the Fibonacci sequence.\nHere is a visual representation of the call stack:\nfibonacci(5, 0, 1) -\u0026gt; fibonacci(4, 1, 1) -\u0026gt; fibonacci(3, 1, 2) -\u0026gt; fibonacci(2, 2, 3) -\u0026gt; fibonacci(1, 3, 5) -\u0026gt; fibonacci(0, 5, 8) return 5 Advantages and Disadvantages # Recursion has certain advantages:\nIt can result in simple, elegant solutions for problems that easily break down into subproblems. It eliminates the need for explicit loop control. It mirrors the mathematical structure of a recursive definition. The disadvantages include:\nIt can be less efficient (high memory consumption) than iteration due to repeated function calls and stack frame creation. Too much recursion can overflow the call stack and cause crashes. It can be harder to debug and analyze than iteration. Therefore, recursion is a powerful tool that should be used judiciously in appropriate cases.\nRecursion vs Iteration # Recursion and iteration (using loops) are parallel tools and we can use either one to solve many problems. Both techniques have the potential to solve the same problems, but their implementation and efficiency may vary. Let\u0026rsquo;s take the factorial example:\nIterative\ndef factorial_iterative(n): result = 1 for i in range(1, n+1): result *= i return result Recursive\ndef factorial_recursive(n): if n == 1: return 1 return n * factorial(n-1) The iterative version is more efficient in terms of space, but the recursive is cleaner and easier to understand. The choice between recursion and iteration often depends on the specific problem, memory constraints, and programmer preferences.\nConclusion # Recursion is a key technique that allows writing elegant, natural, and efficient algorithms when properly leveraged. Understanding how to break down a problem into recursive cases is essential to master this skill. Recursion provides a unique declarative alternative to solve complex problems without managing explicit loops. However, it is crucial to always remember to define an adequate base case and be aware of recursion limitations in terms of efficiency and memory usage. Knowing how to combine recursion and iteration gives flexibility when creating optimal solutions.\nAs always, the key lies in finding the right balance and using the right tool for the right job.\nReferences # Cormen, T.H., Leiserson, C.E., Rivest, R.L., \u0026amp; Stein, C. (2009). Introduction to Algorithms. MIT Press. Kindler, E., \u0026amp; Krivy, I. (2011). Object-Oriented Simulation of systems with Java: A working introduction. BoD–Books on Demand. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"30 September 2023","externalUrl":null,"permalink":"/en/programming/starting-concepts/recursive-functions/","section":"Programming","summary":"","title":"Recursive Functions","type":"programming"},{"content":" Choosing a programming language # Choosing a programming language is the first and perhaps the most crucial step in the learning process. Several factors to consider when selecting a language include:\nPurpose: What do you want to code for? If it\u0026rsquo;s web development, JavaScript or PHP might be good options. If you\u0026rsquo;re into data science, R or Python might be more appropriate. Community: A language with an active community can be vital for beginners. A vibrant community usually means more resources, tutorials, and solutions available online. Learning curve: Some languages are easier to pick up than others. It\u0026rsquo;s essential to pick one that matches your experience level and patience. Job opportunities: If you\u0026rsquo;re eyeing a career in programming, researching the job market demand for various languages can be insightful. While there are many valuable and potent languages, for the purpose of this course, we\u0026rsquo;ve chosen Python. This language is renowned for its simplicity and readability, making it ideal for those just starting out. Moreover, Python boasts an active community and a wide range of applications, from web development to artificial intelligence.\nInstalling Python # For Windows users: # Download the installer: Visit the official Python website at https://www.python.org/downloads/windows/ Click on the download link for the latest version of Python 3.x. Run the installer: Once the download is complete, locate and run the installer .exe file. Make sure to check the box that says \u0026ldquo;Add Python to PATH\u0026rdquo; during installation. This step is crucial for making Python accessible from the Command Prompt. Follow the installation prompts. Verify installation: Open the Command Prompt and type: python --version This should display the version of Python you just installed. For Mac users: # Download the installer: Visit the official Python website at https://www.python.org/downloads/mac-osx/ Click on the download link for the latest version of Python 3.x. Run the installer: Once the download is complete, locate and run the .pkg file. Follow the installation prompts. Verify installation: Open the Terminal and type: python3 --version This should display the version of Python you just installed. For Linux (Ubuntu/Debian) users: # Update packages: sudo apt update Install Python: sudo apt install python3 Verify installation: After installation, you can check the version of Python installed by typing: python3 --version Integrated Development Environments (IDEs) # An IDE is a tool that streamlines application development by combining commonly-used functionalities into a single software package: code editor, compiler, debugger, and more. Choosing the right IDE can make the programming process more fluid and efficient.\nWhen evaluating IDEs, consider:\nLanguage compatibility: Not all IDEs are compatible with every programming language. Features: Some IDEs offer features like auto-completion, syntax highlighting, and debugging tools. Extensions and plugins: Being able to customize and extend your IDE through plugins can be extremely beneficial. Price: There are free and paid IDEs. Evaluate whether the additional features of a paid IDE justify its cost. For this course, we\u0026rsquo;ve selected Visual Studio Code (VS Code). It\u0026rsquo;s a popular IDE that\u0026rsquo;s free and open-source. It\u0026rsquo;s known for its straightforward interface, a vast array of plugins, and its capability to handle multiple programming languages. Its active community ensures regular updates and a plethora of learning resources.\nInstalling Visual Studio Code # For Windows users: # Download the installer: Visit the official VS Code website at https://code.visualstudio.com/ Click on the \u0026ldquo;Download for Windows\u0026rdquo; button. Run the installer: Once the download is complete, locate and run the installer .exe file. Follow the installation prompts, including accepting the license agreement and choosing the installation location. Launch VS Code: After installation, you can find VS Code in your Start menu. Launch it, and you\u0026rsquo;re ready to start coding! For Mac users: # Download the installer: Visit the official VS Code website at https://code.visualstudio.com/ Click on the \u0026ldquo;Download for Mac\u0026rdquo; button. Install VS Code: Once the download is complete, open the downloaded .zip file. Drag the Visual Studio Code .app to the Applications folder, making it available in the Launchpad. Launch VS Code: Use Spotlight search or navigate to your Applications folder to launch VS Code. For Linux (Ubuntu/Debian) users: # Update packages and install dependencies: sudo apt update sudo apt install software-properties-common apt-transport-https wget Download and install the key: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Add the VS Code repository: sudo add-apt-repository \u0026#34;deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main\u0026#34; Install Visual Studio Code: sudo apt update sudo apt install code Launch VS Code: You can start VS Code from the terminal by typing code or find it in your list of installed applications. Write and execute your first program # Once you\u0026rsquo;ve set up your programming environment, it\u0026rsquo;s time to dive into coding.\nHello, World! # This is arguably the most iconic program for beginners. It\u0026rsquo;s simple, but it introduces you to the process of writing and executing code.\nprint(\u0026#34;Hello, World!\u0026#34;) Running the Hello World program Triangle area and perimeter calculation # This program is a tad more intricate. It doesn\u0026rsquo;t just print out a message; it also performs mathematical calculations.\n############ # User input ############ side1 = float(input(\u0026#34;Enter the length of the first side: \u0026#34;)) side2 = float(input(\u0026#34;Enter the length of the second side: \u0026#34;)) side3 = float(input(\u0026#34;Enter the length of the third side: \u0026#34;)) ####################### # Perimeter calculation ####################### perimeter = side1 + side2 + side3 print(f\u0026#34;The triangle\u0026#39;s perimeter is: {perimeter}\u0026#34;) ######################################## # Area calculation using Heron\u0026#39;s formula ######################################## s = perimeter / 2 area = (s*(s-side1)*(s-side2)*(s-side3)) ** 0.5 print(f\u0026#34;The triangle\u0026#39;s area is: {area:.2f}\u0026#34;) Running the Triangle program Conclusion # Setting up a programming environment might appear daunting at first, but with the right tools and resources, it becomes a manageable and rewarding task. We hope this article provided you with a solid foundation to kickstart your programming journey. Happy coding!\nReferences # Lutz, M. (2013). Learning Python. O\u0026rsquo;Reilly Media. Microsoft. (2020). Visual Studio Code Documentation. Microsoft Docs. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"10 September 2023","externalUrl":null,"permalink":"/en/programming/intro/setup-dev-environment/","section":"Programming","summary":"","title":"Set Up your Development Environment","type":"programming"},{"content":"Key characteristics of composition:\nIt represents a strong \u0026ldquo;has-a\u0026rdquo; relationship. The \u0026ldquo;part\u0026rdquo; object cannot exist independently of the \u0026ldquo;whole\u0026rdquo; object. When the \u0026ldquo;whole\u0026rdquo; object is destroyed, all its \u0026ldquo;part\u0026rdquo; objects are also destroyed. A \u0026ldquo;part\u0026rdquo; object belongs to only one \u0026ldquo;whole\u0026rdquo; object at a time. Let\u0026rsquo;s look at an example to illustrate composition:\nclass Engine: def __init__(self, horsepower): self.horsepower = horsepower def start(self): return \u0026#34;Engine started\u0026#34; class Car: def __init__(self, make, model, horsepower): self.make = make self.model = model self.engine = Engine(horsepower) # Composition: Car creates its own Engine def start_car(self): return f\u0026#34;{self.make} {self.model}: {self.engine.start()}\u0026#34; def __del__(self): print(f\u0026#34;{self.make} {self.model} is being destroyed, and so is its engine.\u0026#34;) # Creating a Car instance my_car = Car(\u0026#34;Toyota\u0026#34;, \u0026#34;Corolla\u0026#34;, 150) print(my_car.start_car()) # Output: Toyota Corolla: Engine started # When we delete the Car, its Engine is also deleted del my_car # This will print: Toyota Corolla is being destroyed, and so is its engine. In this example, we have a composition relationship between Car and Engine. A Car has an Engine, and the Engine cannot exist independently of the Car. When a Car object is created, it creates its own Engine. When the Car object is destroyed, its Engine is also destroyed.\nHere\u0026rsquo;s a UML diagram representing this composition relationship:\nclassDiagram class Car { +make: string +model: string -engine: Engine +start_car() +__del__() } class Engine { -horsepower: int +start() } Car *-- Engine : has end In this diagram, the filled diamond on the Car side of the relationship indicates composition. This shows that Car is the \u0026ldquo;whole\u0026rdquo; and Engine is the \u0026ldquo;part\u0026rdquo; in this relationship, and that the Engine\u0026rsquo;s lifetime is tied to the Car\u0026rsquo;s lifetime.\nThe key difference between aggregation and composition is the strength of the relationship and the lifecycle dependency. In aggregation, the \u0026ldquo;part\u0026rdquo; can exist independently of the \u0026ldquo;whole\u0026rdquo;, while in composition, the \u0026ldquo;part\u0026rdquo; cannot exist without the \u0026ldquo;whole\u0026rdquo;.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-composition/","section":"Programming","summary":"","title":"Class relations: Composition","type":"programming"},{"content":"The FIFO (first in, first out) nature of queues is because only the initial element can be accessed and manipulated. When an element is added to the queue it is known as \u0026ldquo;enqueue\u0026rdquo;, while removing an element is called \u0026ldquo;dequeue\u0026rdquo;.\nThis causes the first element to be added to the queue to also be the first to be removed, hence its FIFO behaviour.\nDiagram of a queue Main operations # The basic queue operations are:\nEnqueue: Adds an element to the end of the queue. Dequeue: Removes the element from the front of the queue. Peek: Gets the front element without removing it. isEmpty: Checks if the queue is empty. Implementation # Like stacks, queues can be implemented using linked lists. Elements are added at the end and removed from the front by keeping references to both ends.\nclass Node: def __init__(self, value): self.value = value self.next = None class Queue: def __init__(self): self.front = None self.end = None self.size = 0 def enqueue(self, value): new_node = Node(value) if self.end is None: self.end = new_node self.front = new_node return self.end.next = new_node self.end = new_node self.size += 1 def dequeue(self): if self.is_empty(): return None value = self.front.value self.front = self.front.next if self.front is None: self.end = None self.size -= 1 return value def peek(self): if self.is_empty(): return None return self.front.value def is_empty(self): return self.front is None # Returns true if front is None def __len__(self): return self.size def __str__(self): values = [] current = self.front while current: values.append(str(current.value)) current = current.next return \u0026#34;\\n\u0026#34;.join(values) print(\u0026#34;Creating a new queue\u0026#34;) queue = Queue() print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if queue is empty\u0026#34;) print(f\u0026#34;Is queue empty? {queue.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Enqueue three elements\u0026#34;) queue.enqueue(\u0026#34;ABC\u0026#34;) queue.enqueue(\u0026#34;DEF\u0026#34;) queue.enqueue(\u0026#34;GHI\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after enqueuing elements:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get front element using dequeue\u0026#34;) print(f\u0026#34;queue.dequeue() =\u0026gt; {queue.dequeue()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after dequeue element:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print front element using peek\u0026#34;) print(f\u0026#34;queue.peek() =\u0026gt; {queue.peek()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after peek:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get front element using dequeue\u0026#34;) print(f\u0026#34;queue.dequeue() =\u0026gt; {queue.dequeue()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after dequeue element:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if queue is empty\u0026#34;) print(f\u0026#34;Is queue empty? {queue.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get front element using dequeue\u0026#34;) print(f\u0026#34;queue.dequeue() =\u0026gt; {queue.dequeue()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after dequeue element:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if queue is empty\u0026#34;) print(f\u0026#34;Is queue empty? {queue.is_empty()}\u0026#34;) Usage examples # Some common uses of queues:\nPrint queues where first in, first printed. Task queues in operating systems for execution order. Simulations where arrival order must be respected like in banks. Message queues like RabbitMQ or Kafka. Circular buffers in audio for streaming. Conclusion # Queues are versatile structures thanks to their FIFO principle. Having a good handle on queues, implementation, and applications will reinforce your skills as a programmer.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"03 November 2023","externalUrl":null,"permalink":"/en/programming/data-structures/queues/","section":"Programming","summary":"","title":"Queues","type":"programming"},{"content":"Key characteristics of inheritance:\nIt promotes code reuse and establishes a hierarchy between classes. The subclass inherits all public and protected members from the superclass. The subclass can add its own members and override inherited members. It supports the concept of polymorphism. Let\u0026rsquo;s look at an example to illustrate inheritance:\nclass Animal: def __init__(self, name): self.name = name def speak(self): pass class Dog(Animal): def speak(self): return f\u0026#34;{self.name} says Woof!\u0026#34; class Cat(Animal): def speak(self): return f\u0026#34;{self.name} says Meow!\u0026#34; # Creating instances dog = Dog(\u0026#34;Buddy\u0026#34;) cat = Cat(\u0026#34;Whiskers\u0026#34;) print(dog.speak()) # Output: Buddy says Woof! print(cat.speak()) # Output: Whiskers says Meow! # Demonstrating polymorphism def animal_sound(animal): print(animal.speak()) animal_sound(dog) # Output: Buddy says Woof! animal_sound(cat) # Output: Whiskers says Meow! In this example, we have a base class Animal and two derived classes Dog and Cat. Both Dog and Cat inherit from Animal and override the speak method.\nHere\u0026rsquo;s a UML diagram representing this inheritance relationship:\nclassDiagram class Animal { +name: string +speak() } class Dog { +speak() } class Cat { +speak() } Animal \u003c|-- Dog Animal \u003c|-- Cat end In this diagram, the arrows pointing from Dog and Cat to Animal indicate inheritance. This shows that Dog and Cat are subclasses of Animal.\nInheritance is a powerful feature of OOP, but it should be used judiciously. Overuse of inheritance can lead to complex class hierarchies that are difficult to understand and maintain. The principle of \u0026ldquo;composition over inheritance\u0026rdquo; suggests that it\u0026rsquo;s often better to use composition (has-a relationship) rather than inheritance (is-a relationship) when designing class relationships.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-inheritance/","section":"Programming","summary":"","title":"Class relations: Inheritance","type":"programming"},{"content":"Key characteristics of realisation:\nIt represents a contract that the implementing class must fulfil. The class must provide implementations for all methods declared in the interface. It allows for polymorphism through interfaces. Python doesn\u0026rsquo;t have a built-in interface concept like some other languages (e.g., Java), but we can simulate interfaces using abstract base classes. Here\u0026rsquo;s an example:\nfrom abc import ABC, abstractmethod class Drawable(ABC): @abstractmethod def draw(self): pass class Circle(Drawable): def draw(self): return \u0026#34;Drawing a circle\u0026#34; class Square(Drawable): def draw(self): return \u0026#34;Drawing a square\u0026#34; def draw_shape(shape: Drawable): print(shape.draw()) # Creating instances circle = Circle() square = Square() # Using polymorphism through the interface draw_shape(circle) # Output: Drawing a circle draw_shape(square) # Output: Drawing a square In this example, Drawable is an abstract base class that acts like an interface. Both Circle and Square implement the Drawable interface by providing their own implementation of the draw method.\nHere\u0026rsquo;s a UML diagram representing this realisation relationship:\nclassDiagram class Drawable { \u003c\u003e +draw() } class Circle { +draw() } class Square { +draw() } Drawable \u003c|.. Circle Drawable \u003c|.. Square end In this diagram, the dashed arrows pointing from Circle and Square to Drawable indicate realisation. This shows that Circle and Square implement the Drawable interface.\nRealisation is a powerful concept that allows for designing loosely coupled systems. By programming to interfaces rather than concrete implementations, we can create more flexible and extensible software.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-realisation/","section":"Programming","summary":"","title":"Class relations: Realisation (Implementation)","type":"programming"},{"content":"Key characteristics of dependency:\nIt represents a \u0026ldquo;uses\u0026rdquo; relationship between classes. It\u0026rsquo;s a weaker relationship compared to association, aggregation, or composition. Changes in the used class may affect the using class. Here\u0026rsquo;s an example to illustrate dependency:\nclass Printer: def print_document(self, document): return f\u0026#34;Printing: {document.get_content()}\u0026#34; class PDFDocument: def get_content(self): return \u0026#34;PDF content\u0026#34; class WordDocument: def get_content(self): return \u0026#34;Word document content\u0026#34; # Using the Printer printer = Printer() pdf = PDFDocument() word = WordDocument() print(printer.print_document(pdf)) # Output: Printing: PDF content print(printer.print_document(word)) # Output: Printing: Word document content In this example, the Printer class has a dependency on both PDFDocument and WordDocument classes. The Printer uses these classes in its print_document method, but it doesn\u0026rsquo;t maintain a long-term relationship with them.\nHere\u0026rsquo;s a UML diagram representing these dependency relationships:\nclassDiagram class Printer { +print_document(document) } class PDFDocument { +get_content() } class WordDocument { +get_content() } Printer ..\u003e PDFDocument : uses Printer ..\u003e WordDocument : uses end In this diagram, the dashed arrows pointing from Printer to PDFDocument and WordDocument indicate dependency. This shows that Printer uses these classes, but doesn\u0026rsquo;t have a stronger relationship with them.\nDependency is often used to reduce coupling between classes. By depending on abstractions (like interfaces) rather than concrete classes, we can make our code more flexible and easier to change.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-dependency/","section":"Programming","summary":"","title":"Class relations: Dependency","type":"programming"},{"content":" Comparing and contrasting relations # Now that we\u0026rsquo;ve explored the various types of class relations, let\u0026rsquo;s compare and contrast them to better understand when to use each:\nAssociation vs Aggregation vs Composition\nAssociation is the most general relationship, representing any connection between classes. Aggregation is a specialised association representing a whole-part relationship where the part can exist independently. Composition is the strongest whole-part relationship where the part cannot exist independently of the whole. Inheritance vs Composition\nInheritance represents an \u0026ldquo;is-a\u0026rdquo; relationship (e.g., a Dog is an Animal). Composition represents a \u0026ldquo;has-a\u0026rdquo; relationship (e.g., a Car has an Engine). The principle of \u0026ldquo;composition over inheritance\u0026rdquo; suggests favouring composition for more flexible designs. Realisation vs Inheritance\nRealisation is about implementing an interface, focusing on behaviour. Inheritance is about extending a class, inheriting both state and behaviour. Dependency vs Association\nDependency is a weaker, often temporary relationship (e.g., a method parameter). Association implies a more permanent relationship, often represented by a class attribute. Here\u0026rsquo;s a comparison table summarising these relationships:\nRelationship Strength Lifecycle Binding \u0026ldquo;Is-a\u0026rdquo; or \u0026ldquo;Has-a\u0026rdquo; Symbol in UML Dependency Weakest None Uses - - - - \u0026gt; Association Weak Independent Has-a (loose) ———\u0026gt; Aggregation Medium Independent Has-a ◇———\u0026gt; Composition Strong Dependent Has-a (strong) ♦———\u0026gt; Inheritance Strong N/A Is-a ——— Realisation Medium N/A Behaves-as - - - Common pitfalls # While class relationships are powerful tools in OOP, they can also lead to common pitfalls if not used carefully. Here are some common issues and how to avoid them:\nOveruse of inheritance\nProblem: Creating deep inheritance hierarchies that are hard to understand and maintain. Solution: Prefer composition over inheritance. Use inheritance only for genuine \u0026ldquo;is-a\u0026rdquo; relationships. Tight coupling\nProblem: Creating strong dependencies between classes, making the system rigid and hard to change. Solution: Use interfaces and dependency injection to reduce coupling. Depend on abstractions rather than concrete classes. God objects\nProblem: Creating classes that try to do too much, violating the Single Responsibility Principle. Solution: Break large classes into smaller, more focused classes. Use composition to bring functionality together. Circular dependencies\nProblem: Creating mutual dependencies between classes, leading to complex and hard-to-maintain code. Solution: Refactor to remove circular dependencies. Consider using interfaces or introducing a new class to break the cycle. Leaky abstractions\nProblem: Exposing implementation details through interfaces or base classes. Solution: Design interfaces and base classes carefully. Hide implementation details and expose only what\u0026rsquo;s necessary. Inappropriate intimacy\nProblem: Classes that know too much about each other\u0026rsquo;s internal details. Solution: Encapsulate data and behaviour. Use public interfaces to interact between classes. Brittle base classes\nProblem: Changes to base classes breaking derived classes in unexpected ways. Solution: Design base classes for extension. Document how derived classes should interact with base classes. Diamond problem in multiple inheritance\nProblem: Ambiguity in method resolution when a class inherits from two classes with a common ancestor. Solution: Avoid multiple inheritance if possible. Use interfaces or mixins instead. Overuse of getters and setters\nProblem: Breaking encapsulation by providing unrestricted access to internal state. Solution: Use meaningful methods that represent behaviors rather than exposing internal data directly. Violation of Liskov Substitution Principle\nProblem: Derived classes that can\u0026rsquo;t be used interchangeably with their base classes. Solution: Ensure that derived classes truly represent specialisations of their base classes. Use composition if the \u0026ldquo;is-a\u0026rdquo; relationship doesn\u0026rsquo;t hold. By being aware of these pitfalls and following best practices, you can create more robust and maintainable object-oriented designs.\nConclusion # Key takeaways:\nAssociation is a general relationship between classes. Aggregation represents a whole-part relationship where parts can exist independently. Composition is a stronger whole-part relationship where parts cannot exist independently. Inheritance represents an \u0026ldquo;is-a\u0026rdquo; relationship and promotes code reuse. Realisation is about implementing interfaces and focusing on behaviour. Dependency is a weak, often temporary relationship between classes. Remember that good object-oriented design is not just about using these relationships, but about using them appropriately. Always consider the SOLID principles and the \u0026ldquo;composition over inheritance\u0026rdquo; guideline.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-conclusion/","section":"Programming","summary":"","title":"Class relations: Conclusion","type":"programming"},{"content":"At the heart of OOP lie four fundamental concepts: Encapsulation, Inheritance, Polymorphism, and Abstraction. These concepts, often referred to as the \u0026ldquo;four pillars\u0026rdquo; of OOP, form the foundation upon which complex software systems are built. In this guide, we will delve deep into each of these concepts, exploring their definitions, implementations, and practical applications. We\u0026rsquo;ll use Python, a language known for its clarity and versatility, to demonstrate these concepts in action. Whether you\u0026rsquo;re a beginner just starting your programming journey or a seasoned professional looking to refresh your knowledge, this article aims to provide valuable insights and a deeper understanding of OOP principles.\nEncapsulation allows us to bundle data and methods together, hiding internal details and protecting data integrity. Inheritance enables code reuse and the creation of hierarchical relationships between classes. Polymorphism provides a way to use objects of different types through a common interface, enhancing flexibility and extensibility. Abstraction allows us to create simplified models of complex systems, focusing on essential features and hiding unnecessary details. As you continue your journey in software development, you\u0026rsquo;ll find that mastering these concepts opens up new ways of thinking about and solving problems. Remember that OOP is not just about syntax or language features, it\u0026rsquo;s a mindset for modeling complex systems and managing complexity in software.\n","date":"07 December 2024","externalUrl":null,"permalink":"/en/programming/oop/the-four-pillars-introduction/","section":"Programming","summary":"","title":"The Four Pillars","type":"programming"},{"content":"The importance of encapsulation lies in several key aspects:\nData protection: By controlling access to object data through methods, we can ensure that the data remains consistent and valid. Modularity: Encapsulation allows objects to be self-contained, making it easier to understand and maintain code. Flexibility: The internal implementation can be changed without affecting other parts of the code that use the object. Reduced complexity: By hiding the details of internal workings, encapsulation reduces the complexity of the overall system from an external perspective. Implementation in Python # Python provides several mechanisms to implement encapsulation. Let\u0026rsquo;s explore these with examples:\n1. Using private attributes # In Python, we can create private attributes by prefixing the attribute name with double underscores (__). This triggers name mangling, which makes the attribute harder to access from outside the class.\nclass BankAccount: def __init__(self, account_number, balance): self.__account_number = account_number # Private attribute self.__balance = balance # Private attribute def deposit(self, amount): if amount \u0026gt; 0: self.__balance += amount return True return False def withdraw(self, amount): if 0 \u0026lt; amount \u0026lt;= self.__balance: self.__balance -= amount return True return False def get_balance(self): return self.__balance # Usage account = BankAccount(\u0026#34;1234567890\u0026#34;, 1000) print(account.get_balance()) # Output: 1000 account.deposit(500) print(account.get_balance()) # Output: 1500 account.withdraw(200) print(account.get_balance()) # Output: 1300 # This will raise an AttributeError # print(account.__balance) In this example:\n__account_number and __balance are private attributes. We provide public methods (deposit, withdraw, get_balance) to interact with these private attributes. Direct access to __balance from outside the class will raise an AttributeError exception. 2. Using properties # Python\u0026rsquo;s @property decorator allows us to define methods that can be accessed like attributes, providing a more Pythonic way of implementing getters and setters.\nclass Circle: def __init__(self, radius): self._radius = radius @property def radius(self): return self._radius @radius.setter def radius(self, value): if value \u0026gt; 0: self._radius = value else: raise ValueError(\u0026#34;Radius must be positive\u0026#34;) @property def area(self): return 3.14159 * self._radius ** 2 # Usage circle = Circle(5) print(circle.radius) # Output: 5 print(circle.area) # Output: 78.53975 circle.radius = 7 print(circle.radius) # Output: 7 print(circle.area) # Output: 153.93791 # This will raise a ValueError # circle.radius = -1 In this example:\n_radius is a protected attribute (single underscore is a convention for protected attributes in Python). The radius property provides get and set access to _radius with validation. The area property is read-only and calculated on-the-fly. Benefits and best practices # The benefits of encapsulation are numerous:\nImproved maintainability: Changes to the internal implementation don\u0026rsquo;t affect external code that uses the class. Enhanced security: Private attributes can\u0026rsquo;t be accidentally modified from outside the class. Flexibility in implementation: You can change how data is stored or calculated without changing the public interface. Better abstraction: Users of the class don\u0026rsquo;t need to know about its internal workings. Best practices for encapsulation in Python include:\nUse private attributes (double underscore prefix) for data that should not be accessed directly from outside the class. Provide public methods or properties for controlled access to internal data. Use properties instead of get/set methods for a more Pythonic approach. Document the public interface clearly, including any side effects of methods. Let\u0026rsquo;s look at a more complex example that demonstrates these practices:\nclass Employee: def __init__(self, name, salary): self.__name = name self.__salary = salary self.__projects = [] @property def name(self): return self.__name @property def salary(self): return self.__salary @salary.setter def salary(self, value): if value \u0026gt; 0: self.__salary = value else: raise ValueError(\u0026#34;Salary must be positive\u0026#34;) def add_project(self, project): \u0026#34;\u0026#34;\u0026#34; Add a project to the employee\u0026#39;s project list. :param project: string representing the project name \u0026#34;\u0026#34;\u0026#34; self.__projects.append(project) def remove_project(self, project): \u0026#34;\u0026#34;\u0026#34; Remove a project from the employee\u0026#39;s project list. :param project: string representing the project name :return: True if project was removed, False if not found \u0026#34;\u0026#34;\u0026#34; if project in self.__projects: self.__projects.remove(project) return True return False @property def project_count(self): return len(self.__projects) def __str__(self): return f\u0026#34;Employee: {self.__name}, Salary: ${self.__salary}, Projects: {self.project_count}\u0026#34; # Usage emp = Employee(\u0026#34;John Doe\u0026#34;, 50000) print(emp.name) # Output: John Doe print(emp.salary) # Output: 50000 emp.add_project(\u0026#34;Project A\u0026#34;) emp.add_project(\u0026#34;Project B\u0026#34;) print(emp.project_count) # Output: 2 emp.salary = 55000 print(emp) # Output: Employee: John Doe, Salary: $55000, Projects: 2 emp.remove_project(\u0026#34;Project A\u0026#34;) print(emp.project_count) # Output: 1 # This will raise an AttributeError # print(emp.__projects) This example demonstrates:\nPrivate attributes (__name, __salary, __projects) Properties for controlled access (name, salary, project_count) Public methods for manipulating private data (add_project, remove_project) Clear documentation of method behaviour A custom __str__ method for a nice string representation of the object By following these practices, we create a class that is both flexible and robust, embodying the principle of encapsulation.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/the-four-pillars-encapsulation/","section":"Programming","summary":"","title":"The Four Pillars: Encapsulation","type":"programming"},{"content":"Key aspects of inheritance include:\nCode reusability: Inheritance allows us to reuse code from existing classes, reducing redundancy and promoting efficient development. Hierarchical classification: It enables the creation of class hierarchies, representing relationships and commonalities among objects. Extensibility: New functionality can be added to existing classes without modifying them, following the open-closed principle. Polymorphism: Inheritance is a prerequisite for runtime polymorphism (which we\u0026rsquo;ll discuss in detail later). Types of inheritance # There are several types of inheritance, though not all programming languages support all types. The main types are:\nSingle inheritance: A derived class inherits from a single base class. Multiple inheritance: A derived class inherits from multiple base classes. Multilevel inheritance: A derived class inherits from another derived class. Hierarchical inheritance: Multiple derived classes inherit from a single base class. Hybrid inheritance: A combination of two or more types of inheritance. Python supports all these types of inheritance. Let\u0026rsquo;s explore each with examples.\nSingle inheritance # Single inheritance is the simplest form of inheritance, where a class inherits from one base class.\nclass Animal: def __init__(self, species): self.species = species def make_sound(self): pass class Dog(Animal): def __init__(self, name): super().__init__(\u0026#34;Canine\u0026#34;) self.name = name def make_sound(self): return \u0026#34;Woof!\u0026#34; # Usage dog = Dog(\u0026#34;Buddy\u0026#34;) print(f\u0026#34;{dog.name} is a {dog.species}\u0026#34;) # Output: Buddy is a Canine print(dog.make_sound()) # Output: Woof! In this example:\nAnimal is the base class with a generic make_sound method. Dog is derived from Animal, inheriting its attributes and methods. Dog overrides the make_sound method with its own implementation. We use super().__init__() to call the initialiser of the base class. Multiple inheritance # Multiple inheritance allows a class to inherit from multiple base classes.\nclass Flyer: def fly(self): return \u0026#34;I can fly!\u0026#34; class Swimmer: def swim(self): return \u0026#34;I can swim!\u0026#34; class Duck(Animal, Flyer, Swimmer): def __init__(self, name): Animal.__init__(self, \u0026#34;Aves\u0026#34;) self.name = name def make_sound(self): return \u0026#34;Quack!\u0026#34; # Usage duck = Duck(\u0026#34;Donald\u0026#34;) print(f\u0026#34;{duck.name} is a {duck.species}\u0026#34;) # Output: Donald is a Aves print(duck.make_sound()) # Output: Quack! print(duck.fly()) # Output: I can fly! print(duck.swim()) # Output: I can swim! Here, Duck inherits from Animal, Flyer, and Swimmer, combining attributes and methods from all three.\nMultilevel inheritance # In multilevel inheritance, a derived class inherits from another derived class.\nclass Mammal(Animal): def __init__(self, species, is_warm_blooded=True): super().__init__(species) self.is_warm_blooded = is_warm_blooded def give_birth(self): return \u0026#34;Giving birth to live young\u0026#34; class Cat(Mammal): def __init__(self, name): super().__init__(\u0026#34;Feline\u0026#34;) self.name = name def make_sound(self): return \u0026#34;Meow!\u0026#34; # Usage cat = Cat(\u0026#34;Whiskers\u0026#34;) print(f\u0026#34;{cat.name} is a {cat.species}\u0026#34;) # Output: Whiskers is a Feline print(cat.make_sound()) # Output: Meow! print(cat.give_birth()) # Output: Giving birth to live young print(f\u0026#34;Is warm-blooded: {cat.is_warm_blooded}\u0026#34;) # Output: Is warm-blooded: True In this example, Cat inherits from Mammal, which in turn inherits from Animal, forming a multilevel inheritance chain.\nHierarchical inheritance # Hierarchical inheritance involves multiple derived classes inheriting from a single base class.\nclass Bird(Animal): def __init__(self, species, can_fly=True): super().__init__(species) self.can_fly = can_fly class Parrot(Bird): def __init__(self, name): super().__init__(\u0026#34;Psittacine\u0026#34;, can_fly=True) self.name = name def make_sound(self): return \u0026#34;Squawk!\u0026#34; class Penguin(Bird): def __init__(self, name): super().__init__(\u0026#34;Spheniscidae\u0026#34;, can_fly=False) self.name = name def make_sound(self): return \u0026#34;Honk!\u0026#34; # Usage parrot = Parrot(\u0026#34;Polly\u0026#34;) penguin = Penguin(\u0026#34;Pingu\u0026#34;) print(f\u0026#34;{parrot.name} can fly: {parrot.can_fly}\u0026#34;) # Output: Polly can fly: True print(f\u0026#34;{penguin.name} can fly: {penguin.can_fly}\u0026#34;) # Output: Pingu can fly: False Here, both Parrot and Penguin inherit from Bird, which demonstrates hierarchical inheritance.\nHybrid inheritance # Hybrid inheritance is a combination of multiple inheritance types. Let\u0026rsquo;s create a more complex example to illustrate this:\nclass Terrestrial: def walk(self): return \u0026#34;Walking on land\u0026#34; class Aquatic: def swim(self): return \u0026#34;Swimming in water\u0026#34; class Amphibian(Animal, Terrestrial, Aquatic): def __init__(self, species): Animal.__init__(self, species) def adapt(self): return \u0026#34;Can survive both on land and in water\u0026#34; class Frog(Amphibian): def __init__(self, name): super().__init__(\u0026#34;Anura\u0026#34;) self.name = name def make_sound(self): return \u0026#34;Ribbit!\u0026#34; # Usage frog = Frog(\u0026#34;Kermit\u0026#34;) print(f\u0026#34;{frog.name} is a {frog.species}\u0026#34;) # Output: Kermit is a Anura print(frog.make_sound()) # Output: Ribbit! print(frog.walk()) # Output: Walking on land print(frog.swim()) # Output: Swimming in water print(frog.adapt()) # Output: Can survive both on land and in water This example demonstrates hybrid inheritance:\nFrog inherits from Amphibian Amphibian inherits from Animal, Terrestrial, and Aquatic This creates a combination of multilevel and multiple inheritance Considerations # Inheritance offers several advantages. However, there are also important considerations:\nComplexity: Deep inheritance hierarchies can become difficult to understand and maintain. Tight coupling: Inheritance creates a tight coupling between base and derived classes. Fragile base class problem: Changes in the base class can unexpectedly affect derived classes. Diamond problem: In multiple inheritance, conflicts can arise if two base classes have methods with the same name. To address these considerations:\nPrefer composition over inheritance when possible. Keep inheritance hierarchies shallow and focused. Use abstract base classes to define clear interfaces. Be cautious with multiple inheritance and resolve conflicts explicitly. Let\u0026rsquo;s visualise the inheritance relationships we\u0026rsquo;ve discussed using an UML class diagram:\nclassDiagram Animal \u003c|-- Mammal Animal \u003c|-- Bird Mammal \u003c|-- Dog Mammal \u003c|-- Cat Bird \u003c|-- Parrot Bird \u003c|-- Penguin Animal \u003c|-- Amphibian Terrestrial \u003c|-- Amphibian Aquatic \u003c|-- Amphibian Amphibian \u003c|-- Frog class Animal { +species: str +make_sound() } class Mammal { +is_warm_blooded: bool +give_birth() } class Bird { +can_fly: bool } class Amphibian { +adapt() } class Terrestrial { +walk() } class Aquatic { +swim() } end This diagram illustrates the inheritance relationships between the classes we\u0026rsquo;ve discussed, showing both single and multiple inheritance.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/the-four-pillars-inheritance/","section":"Programming","summary":"","title":"The Four Pillars: Inheritance","type":"programming"},{"content":"Polymorphism enables writing flexible and reusable code by allowing us to work with objects at a more abstract level, without needing to know their specific types.\nThere are two main types of polymorphism in object-oriented programming:\nCompile-time polymorphism (Static polymorphism)\nAchieved through method overloading. Resolved at compile time. Runtime polymorphism (Dynamic polymorphism)\nAchieved through method overriding. Resolved at runtime. Python primarily supports runtime polymorphism, as it is a dynamically typed language. However, we can demonstrate concepts similar to compile-time polymorphism as well.\nLet\u0026rsquo;s explore different aspects of polymorphism in Python:\nDuck typing # Python uses duck typing, which is a form of polymorphism. The idea is: \u0026ldquo;If it walks like a duck and quacks like a duck, then it must be a duck.\u0026rdquo; In other words, Python cares more about the methods an object has than the type of the object itself.\nclass Duck: def speak(self): return \u0026#34;Quack quack!\u0026#34; class Dog: def speak(self): return \u0026#34;Woof woof!\u0026#34; class Cat: def speak(self): return \u0026#34;Meow meow!\u0026#34; def animal_sound(animal): return animal.speak() # Usage duck = Duck() dog = Dog() cat = Cat() print(animal_sound(duck)) # Output: Quack quack! print(animal_sound(dog)) # Output: Woof woof! print(animal_sound(cat)) # Output: Meow meow! In this example, animal_sound() works with any object that has a speak() method, regardless of its class.\nMethod overriding # Method overriding is a key aspect of runtime polymorphism. It occurs when a derived class defines a method with the same name as a method in its base class.\nclass Shape: def area(self): pass class Rectangle(Shape): def __init__(self, width, height): self.width = width self.height = height def area(self): return self.width * self.height class Circle(Shape): def __init__(self, radius): self.radius = radius def area(self): return 3.14159 * self.radius ** 2 # Usage shapes = [Rectangle(5, 4), Circle(3)] for shape in shapes: print(f\u0026#34;Area: {shape.area()}\u0026#34;) # Output: # Area: 20 # Area: 28.27431 Here, Rectangle and Circle both override the area() method of the Shape class.\nOperator overloading # Python allows operator overloading, which is a form of compile-time polymorphism. It allows the same operator to have different meanings depending on the operands.\nclass Vector: def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): return Vector(self.x + other.x, self.y + other.y) def __str__(self): return f\u0026#34;Vector({self.x}, {self.y})\u0026#34; # Usage v1 = Vector(2, 3) v2 = Vector(3, 4) v3 = v1 + v2 print(v3) # Output: Vector(5, 7) Here, we\u0026rsquo;ve overloaded the + operator for our Vector class.\nAbstract base classes # Python\u0026rsquo;s abc module provides infrastructure for defining abstract base classes, which are a powerful way to define interfaces in Python.\nfrom abc import ABC, abstractmethod class Animal(ABC): @abstractmethod def make_sound(self): pass class Dog(Animal): def make_sound(self): return \u0026#34;Woof!\u0026#34; class Cat(Animal): def make_sound(self): return \u0026#34;Meow!\u0026#34; # Usage def animal_sound(animal): return animal.make_sound() dog = Dog() cat = Cat() print(animal_sound(dog)) # Output: Woof! print(animal_sound(cat)) # Output: Meow! # This will raise a TypeError # animal = Animal() Abstract base classes cannot be instantiated and force derived classes to implement certain methods, ensuring a consistent interface.\nReal-world Applications # Polymorphism is widely used in real-world applications:\nGUI frameworks: Different widgets (buttons, text boxes) can respond to common events (click, hover) in their own ways. Database interfaces: Different database systems can implement a common interface for querying, allowing applications to work with various databases without changing code. Plugin systems: Applications can work with plugins through a common interface, regardless of the specific implementation of each plugin. Game development: Different game entities can share common behaviors (move, collide) but implement them differently. Here\u0026rsquo;s a simple example of a plugin system:\nclass Plugin(ABC): @abstractmethod def process(self, data): pass class UppercasePlugin(Plugin): def process(self, data): return data.upper() class ReversePlugin(Plugin): def process(self, data): return data[::-1] class Application: def __init__(self): self.plugins = [] def add_plugin(self, plugin): self.plugins.append(plugin) def process_data(self, data): for plugin in self.plugins: data = plugin.process(data) return data # Usage app = Application() app.add_plugin(UppercasePlugin()) app.add_plugin(ReversePlugin()) result = app.process_data(\u0026#34;Hello, World!\u0026#34;) print(result) # Output: !DLROW ,OLLEH This example demonstrates how polymorphism allows the Application class to work with different plugins through a common interface.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/the-four-pillars-polymorphism/","section":"Programming","summary":"","title":"The Four Pillars: Polymorphism","type":"programming"},{"content":"Key aspects of abstraction include:\nSimplification: Abstraction reduces complexity by hiding unnecessary details. Focusing on essential features: It emphasises what an object does rather than how it does it. Separation of concerns: It allows separating the interface of a class from its implementation. Modularity: Abstraction promotes modular design by defining clear boundaries between components. Abstract classes and interfaces # In many object-oriented languages, abstraction is implemented through abstract classes and interfaces. While Python doesn\u0026rsquo;t have a built-in interface concept, we can achieve similar functionality using abstract base classes. Python\u0026rsquo;s abc module provides infrastructure for defining abstract base classes:\nfrom abc import ABC, abstractmethod class Shape(ABC): @abstractmethod def area(self): pass @abstractmethod def perimeter(self): pass class Rectangle(Shape): def __init__(self, width, height): self.width = width self.height = height def area(self): return self.width * self.height def perimeter(self): return 2 * (self.width + self.height) class Circle(Shape): def __init__(self, radius): self.radius = radius def area(self): return 3.14159 * self.radius ** 2 def perimeter(self): return 2 * 3.14159 * self.radius # Usage # shapes = [Shape()] # This would raise TypeError shapes = [Rectangle(5, 4), Circle(3)] for shape in shapes: print(f\u0026#34;Area: {shape.area()}, Perimeter: {shape.perimeter()}\u0026#34;) # Output: # Area: 20, Perimeter: 18 # Area: 28.27431, Perimeter: 18.84954 In this example:\nShape is an abstract base class that defines the interface for all shapes. Rectangle and Circle are concrete classes that implement the Shape interface. We can\u0026rsquo;t instantiate Shape directly, but we can use it as a common type for all shapes. Implementing abstraction in Python # While abstract base classes provide a formal way to define interfaces in Python, abstraction can also be achieved through convention and documentation. Here\u0026rsquo;s an example of abstraction without using ABC:\nclass Database: def connect(self): raise NotImplementedError(\u0026#34;Subclass must implement abstract method\u0026#34;) def execute(self, query): raise NotImplementedError(\u0026#34;Subclass must implement abstract method\u0026#34;) class MySQLDatabase(Database): def connect(self): print(\u0026#34;Connecting to MySQL database...\u0026#34;) def execute(self, query): print(f\u0026#34;Executing MySQL query: {query}\u0026#34;) class PostgreSQLDatabase(Database): def connect(self): print(\u0026#34;Connecting to PostgreSQL database...\u0026#34;) def execute(self, query): print(f\u0026#34;Executing PostgreSQL query: {query}\u0026#34;) def perform_database_operation(database): database.connect() database.execute(\u0026#34;SELECT * FROM users\u0026#34;) # Usage mysql_db = MySQLDatabase() postgres_db = PostgreSQLDatabase() perform_database_operation(mysql_db) perform_database_operation(postgres_db) # Output: # Connecting to MySQL database... # Executing MySQL query: SELECT * FROM users # Connecting to PostgreSQL database... # Executing PostgreSQL query: SELECT * FROM users In this example:\nDatabase is an abstract base class (though not using ABC) that defines the interface for all database types. MySQLDatabase and PostgreSQLDatabase are concrete implementations. perform_database_operation works with any object that adheres to the Database interface. Design principles and patterns # Abstraction is a key component of several important design principles and patterns:\nSOLID Principles:\nSingle Responsibility Principle (SRP). Open/Closed Principle (OCP). Liskov Substitution Principle (LSP). Interface Segregation Principle (ISP). Dependency Inversion Principle (DIP). Design Patterns:\nFactory method pattern. Abstract factory pattern. Strategy pattern. Template method pattern. Let\u0026rsquo;s implement the Strategy Pattern as an example:\nfrom abc import ABC, abstractmethod class SortStrategy(ABC): @abstractmethod def sort(self, data): pass class BubbleSort(SortStrategy): def sort(self, data): print(\u0026#34;Performing bubble sort\u0026#34;) return sorted(data) # Using Python\u0026#39;s built-in sort for simplicity class QuickSort(SortStrategy): def sort(self, data): print(\u0026#34;Performing quick sort\u0026#34;) return sorted(data) # Using Python\u0026#39;s built-in sort for simplicity class Sorter: def __init__(self, strategy): self.strategy = strategy def sort(self, data): return self.strategy.sort(data) # Usage data = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] bubble_sorter = Sorter(BubbleSort()) print(bubble_sorter.sort(data)) quick_sorter = Sorter(QuickSort()) print(quick_sorter.sort(data)) # Output: # Performing bubble sort # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Performing quick sort # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] This Strategy Pattern example demonstrates how abstraction allows us to define a family of algorithms, encapsulate each one, and make them interchangeable. The Sorter class doesn\u0026rsquo;t need to know the details of how each sorting algorithm works; it just knows that it can call the sort method on any SortStrategy object.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/the-four-pillars-abstraction/","section":"Programming","summary":"","title":"The Four Pillars: Abstraction","type":"programming"},{"content":"","date":"12 September 2025","externalUrl":null,"permalink":"/tags/%C3%A1lgebra-lineal/","section":"Etiquetas","summary":"","title":"Álgebra Lineal","type":"tags"},{"content":"","date":"12 September 2025","externalUrl":null,"permalink":"/tags/aprendizaje-autom%C3%A1tico/","section":"Etiquetas","summary":"","title":"Aprendizaje Automático","type":"tags"},{"content":" Te invito a acompañarme en un recorrido claro y concreto: pasar de saber programar en Python a desempeñarte como ingeniero en Inteligencia Artificial. Vamos a ir publicando módulos con ejemplos reales, código funcional y un desafío que podés resolver en tu propio entorno. El objetivo es avanzar sin saturarte, aprendiendo de verdad y disfrutando cada paso.\nEste espacio es para vos, que estás comenzando, y también para aquellos profesionales que quieren refrescar ideas, encontrar recursos útiles o incluso descubrir soluciones que no se usaron en el día a día. Cada artículo es una pieza autónoma, directa y práctica: te sirve tanto si necesitás cimentar tu aprendizaje como si venís con experiencia y querés repasar o inspirarte. Arrancamos desde Python y caminaremos juntos hasta llegar al mundo profesional de IA.\nEn los ejemplos, no se hace mención a las prácticas esenciales para desarrollar software, como por ejemplo, utilizar un sistema de control de versiones, generar casos de prueba, etcétera.\nEsto se debe a que la intención es hacer foco en los conceptos de IA y ML, pero a la hora de encarar un proyecto real siempre debes tener en cuenta las mejores prácticas y proceso para el desarrollo profesional de software.\n","date":"12 September 2025","externalUrl":null,"permalink":"/ai/","section":"Inteligencia Artificial","summary":"","title":"Inteligencia Artificial","type":"ai"},{"content":"","date":"12 September 2025","externalUrl":null,"permalink":"/tags/inteligencia-artificial/","section":"Etiquetas","summary":"","title":"Inteligencia Artificial","type":"tags"},{"content":"","date":"12 September 2025","externalUrl":null,"permalink":"/tags/machine-learning/","section":"Etiquetas","summary":"","title":"Machine Learning","type":"tags"},{"content":"","date":"12 September 2025","externalUrl":null,"permalink":"/tags/matem%C3%A1tica/","section":"Etiquetas","summary":"","title":"Matemática","type":"tags"},{"content":"","date":"12 September 2025","externalUrl":null,"permalink":"/series/matem%C3%A1tica-para-machine-learning/","section":"Series","summary":"","title":"Matemática Para Machine Learning","type":"series"},{"content":"","date":"12 September 2025","externalUrl":null,"permalink":"/tags/matrices/","section":"Etiquetas","summary":"","title":"Matrices","type":"tags"},{"content":"","date":"12 September 2025","externalUrl":null,"permalink":"/tags/vectores/","section":"Etiquetas","summary":"","title":"Vectores","type":"tags"},{"content":"","date":"04 September 2025","externalUrl":null,"permalink":"/series/fundamentos-de-ia-para-programadores/","section":"Series","summary":"","title":"Fundamentos De IA Para Programadores","type":"series"},{"content":"","date":"03 September 2025","externalUrl":null,"permalink":"/tags/recomendaciones/","section":"Etiquetas","summary":"","title":"Recomendaciones","type":"tags"},{"content":"","date":"26 August 2025","externalUrl":null,"permalink":"/tags/clasificaci%C3%B3n/","section":"Etiquetas","summary":"","title":"Clasificación","type":"tags"},{"content":"","date":"22 August 2025","externalUrl":null,"permalink":"/tags/sistema-experto/","section":"Etiquetas","summary":"","title":"Sistema Experto","type":"tags"},{"content":"","date":"05 August 2025","externalUrl":null,"permalink":"/tags/kubernetes/","section":"Etiquetas","summary":"","title":"Kubernetes","type":"tags"},{"content":" Luego de desplegar una aplicación en Kubernetes, independientemente del método elegido para ello, si queremos que sea alcanzable por otras aplicaciones necesitamos crear un servicio. En este artículo vamos a explicar que es un servicio, como se utilizan y a repasar los cuatro tipos de servicios que están disponibles en Kubernetes, ClusterIP, NodePort, LoadBalancer y ExternalName, revisaremos sus detalles y cuando se debe utilizar cada uno. Al desplegar una aplicación en Kubernetes utilizando un objeto del tipo Deployment, los pods pertenecientes a dicho Deployment pueden ser creados y destruidos en cualquier momento en base a su funcionamiento, por ejemplo si en nuestro Deployment pedimos que existan 3 réplicas y por cualquier razón alguna de ellas deja de funcionar, una nueva réplica será creada automáticamente para reemplazar a la que falló.\nCada pod tiene su propia dirección IP dentro del cluster. En general, las demás aplicaciones que necesitan interactuar con nuestra aplicación desconocen el nombre de cada una de sus replicas, su estado y su dirección IP para iniciar una comunicación. Kubernetes nos provee el objeto Service como una forma nativa de Service Discovery sin que necesitemos hacer cambios en nuestra aplicación o en las que necesitan comunicarse con ella. Entonces, el fin para el cual creamos un servicio es para exponer una aplicación que puede estar constituida por múltiples pods a traves de un único punto de acceso. De esta manera otras aplicación contactaran al Service y este redirigirá la comunicación a alguno de los pods de nuestra aplicación.\nPods detrás de un servicio en Kubernetes Creando un servicio # Un Service puede crearse mediante una declaración en un archivo .yaml al igual que otros objetos de Kubernetes. Por ejemplo:\napiVersion: v1 kind: Service metadata: name: servicio-de-prueba spec: type: ClusterIP selector: app_name: mi-aplicacion ports: - protocol: TCP port: 8080 targetPort: 1234 En dicho ejemplo, estaremos creando un servicio llamado my-service del tipo ClusterIP que redirige las comunicaciones que llegan al puerto 8080 hacia el puerto 1234 de cualquier Pod que tenga la etiqueta app-name: my-app.\nEl nombre del servicio debe ser una etiqueta válida bajo las reglas de RFC 1035 Como se ve en el archivo, el campo ports es del tipo array, lo que significa que pueden mapearse múltiples puertos.\nCada definición de un puerto debe contener los siguientes campos:\nport: es el puerto en el que el servicio estará accesible dentro del cluster. No puede omitirse. targetPort: es un valor opcional, indica el puerto en el cual el pod estará recibiendo las comunicaciones. Si se omite, se asume que es el mismo valor que el indicado en el campo port. Puede ser un número o el nombre del puerto si es que en el pod se especificaron nombres. Se recomienda utilizarlo sólo cuando difiere del valor de port. protocol: establece el protocolo utilizado para las comunicaciones, los valores válidos son: SCTP, TCP y UDP. En caso de no indicarse explícitamente, el valor por defecto es TCP. name: permite darle un nombre al puerto. Es útil para referenciar por DNS o en situaciones donde hay múltiples puertos en un mismo servicio. Es un valor opcional, pero dentro de un mismo servicio, cada puerto debe tener un nombre único. Tipos de servicios # Como se muestra en la sección anterior, el tipo de servicio se especifica mediante el valor spec.type:\napiVersion: v1 kind: Service metadata: name: servicio-de-prueba spec: ... type: \u0026lt;TIPO_DE_SERVICIO\u0026gt; ... A continuación veremos cada uno de ellos.\nClusterIP # Es el tipo de servicio por defecto. Kubernetes asigna una dirección IP al servicio que las demás aplicaciones pueden utilizar para comunicarse. La dirección asignada proviene de un grupo de direcciones reservadas para este fin mediante el valor service-cluster-ip-range en el servidor de API de Kubernetes.\nCuando se crea un servicio del tipo ClusterIP el servicio no es accesible desde el exterior y los pods detrás de este servicio solo pueden ser contactados por otros pods del mismo cluster. Si se desea exponer el servicio al exterior se debe utilizar un objeto del tipo Ingress.\nEsquema de un servicio del tipo ClusterIP NodePort # En este caso, Kubernetes asigna al servicio un puerto del rango definido en la configuración service-node-port-range, usualmente entre los puertos 30000 y 32767. Luego, cada nodo abre dicho puerto para las comunicaciones hacia el servicio.\nEste tipo de servicio, permite un rápido acceso desde el exterior sin necesidad de infraestructura adicional, pero no contempla un mecanismo de balance de carga (load balancing), lo que puede provocar la saturación de alguno de ellos. Por otro lado, en un sistema donde existan múltiples servicios, la gestión de puertos puede volverse demasiado compleja.\nEsquema de un servicio del tipo NodePort LoadBalancer # En proveedores de servicios en la nube que soporten load balancers como Amazon Web Services, Google Cloud Platform o Microsoft Azure, crear un servicio de este tipo dispara la creación de un load balancer externo en la platform de nube utilizada. La creación ocurre de manera asíncrona e información sobre su estado es publicada en el estado del servicio (.status.loadbalancer).\nEl proveedor de servicios en la nube decide como se balancea la carga.\nLa gran ventaja de este tipo de servicio es que mediante el uso de servicios en la nube se obtiene un balanceo de carga automático y de alta disponibilidad. La desventaja es que puede generar costos adicionales.\nEsquema de un servicio del tipo LoadBalancer ExternalName # Este tipo de servicio redirecciona el tráfico a un nombre de DNS en lugar de a un conjunto de pods. El DNS al cual se apunta, se indica mediante el campo .spec.externalName\nPor ejemplo, redirige las comunicaciones hacia la dirección learn-software.com.\napiVersion: v1 kind: Service metadata: name: mi-servicio spec: type: ExternalName externalName: learn-software.com Esquema de un servicio del tipo ExternalName Headless Services # Existen casos en los que, por ejemplo, es necesario utilizar otros mecanismos de Service Discovery o en los que necesitemos conocer las direcciones IP de todos aquellos pods que podríamos contactar. Para ello existen los headless services. Se crean indicando el valor None en el campo .spec.clusterIP.\nUn headless service no tiene asignada una dirección IP única del cluster. Retorna directamente las direcciones IPs de pods en una respuesta DNS. Esto es útil para descubrimiento de servicios personalizados, bases de datos distribuidas o control detallado del balanceo. La desventaja es que el cliente del servicio debe ser capaz de resolver y gestionar por sí mismo una respuesta DNS conteniendo múltiples direcciones.\nEsquema de un Headless Service Referencias # Puedes leer más sobre el tema en la documentación oficial de Kubernetes ","date":"05 August 2025","externalUrl":null,"permalink":"/blog/k8s-services/","section":"Blog","summary":"","title":"Kubernetes Services","type":"blog"},{"content":"","date":"05 August 2025","externalUrl":null,"permalink":"/tags/service-discovery/","section":"Etiquetas","summary":"","title":"Service Discovery","type":"tags"},{"content":"","date":"05 August 2025","externalUrl":null,"permalink":"/tags/services/","section":"Etiquetas","summary":"","title":"Services","type":"tags"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/tags/data-structures/","section":"Tags","summary":"","title":"Data Structures","type":"tags"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/tags/estructuras-de-datos/","section":"Etiquetas","summary":"","title":"Estructuras De Datos","type":"tags"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/authors/jnonino/","section":"Authors","summary":"","title":"Julian Nonino","type":"authors"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/","section":"Learn-Software.com","summary":"","title":"Learn-Software.com","type":"page"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/tags/object-oriented-programming/","section":"Tags","summary":"","title":"Object-Oriented Programming","type":"tags"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/tags/programaci%C3%B3n/","section":"Etiquetas","summary":"","title":"Programación","type":"tags"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/tags/programaci%C3%B3n-orientada-a-objetos/","section":"Etiquetas","summary":"","title":"Programación Orientada a Objetos","type":"tags"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/series/programaci%C3%B3n-aprendiendo-estructuras-de-datos/","section":"Series","summary":"","title":"Programación: Aprendiendo Estructuras De Datos","type":"series"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/series/programaci%C3%B3n-aprendiendo-orientaci%C3%B3n-a-objetos/","section":"Series","summary":"","title":"Programación: Aprendiendo Orientación a Objetos","type":"series"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/programming/","section":"Programming","summary":"","title":"Programming","type":"programming"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/tags/programming/","section":"Tags","summary":"","title":"Programming","type":"tags"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/series/programming-learning-data-structures/","section":"Series","summary":"","title":"Programming: Learning Data Structures","type":"series"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/series/programming-learning-object-oriented-concepts/","section":"Series","summary":"","title":"Programming: Learning Object-Oriented Concepts","type":"series"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"03 August 2025","externalUrl":null,"permalink":"/series/programaci%C3%B3n-aprendiendo-las-bases/","section":"Series","summary":"","title":"Programación: Aprendiendo Las Bases","type":"series"},{"content":"","date":"03 August 2025","externalUrl":null,"permalink":"/en/series/programming-learning-the-bases/","section":"Series","summary":"","title":"Programming: Learning the Bases","type":"series"},{"content":"","date":"07 December 2024","externalUrl":null,"permalink":"/en/tags/class-relations/","section":"Tags","summary":"","title":"Class Relations","type":"tags"},{"content":"","date":"07 December 2024","externalUrl":null,"permalink":"/tags/los-cuatro-pilares/","section":"Etiquetas","summary":"","title":"Los Cuatro Pilares","type":"tags"},{"content":"","date":"07 December 2024","externalUrl":null,"permalink":"/en/tags/oop/","section":"Tags","summary":"","title":"OOP","type":"tags"},{"content":"","date":"07 December 2024","externalUrl":null,"permalink":"/en/tags/the-four-pillars/","section":"Tags","summary":"","title":"The Four Pillars","type":"tags"},{"content":"","date":"12 October 2024","externalUrl":null,"permalink":"/tags/abstracci%C3%B3n/","section":"Etiquetas","summary":"","title":"Abstracción","type":"tags"},{"content":"","date":"12 October 2024","externalUrl":null,"permalink":"/en/tags/abstraction/","section":"Tags","summary":"","title":"Abstraction","type":"tags"},{"content":"","date":"12 October 2024","externalUrl":null,"permalink":"/en/tags/aggregation/","section":"Tags","summary":"","title":"Aggregation","type":"tags"},{"content":"","date":"12 October 2024","externalUrl":null,"permalink":"/en/tags/association/","section":"Tags","summary":"","title":"Association","type":"tags"},{"content":"","date":"12 October 2024","externalUrl":null,"permalink":"/en/tags/composition/","section":"Tags","summary":"","title":"Composition","type":"tags"},{"content":"","date":"12 October 2024","externalUrl":null,"permalink":"/en/tags/dependency/","section":"Tags","summary":"","title":"Dependency","type":"tags"},{"content":"","date":"12 October 2024","externalUrl":null,"permalink":"/tags/encapsulamiento/","section":"Etiquetas","summary":"","title":"Encapsulamiento","type":"tags"},{"content":"","date":"12 October 2024","externalUrl":null,"permalink":"/en/tags/encapsulation/","section":"Tags","summary":"","title":"Encapsulation","type":"tags"},{"content":"","date":"12 October 2024","externalUrl":null,"permalink":"/tags/herencia/","section":"Etiquetas","summary":"","title":"Herencia","type":"tags"},{"content":"","date":"12 October 2024","externalUrl":null,"permalink":"/en/tags/implementation/","section":"Tags","summary":"","title":"Implementation","type":"tags"},{"content":"","date":"12 October 2024","externalUrl":null,"permalink":"/en/tags/inheritance/","section":"Tags","summary":"","title":"Inheritance","type":"tags"},{"content":"","date":"12 October 2024","externalUrl":null,"permalink":"/tags/polimorfismo/","section":"Etiquetas","summary":"","title":"Polimorfismo","type":"tags"},{"content":"","date":"12 October 2024","externalUrl":null,"permalink":"/en/tags/polymorphism/","section":"Tags","summary":"","title":"Polymorphism","type":"tags"},{"content":"","date":"12 October 2024","externalUrl":null,"permalink":"/en/tags/realisation/","section":"Tags","summary":"","title":"Realisation","type":"tags"},{"content":"","date":"03 November 2023","externalUrl":null,"permalink":"/tags/colas/","section":"Etiquetas","summary":"","title":"Colas","type":"tags"},{"content":"","date":"03 November 2023","externalUrl":null,"permalink":"/en/tags/linked-lists/","section":"Tags","summary":"","title":"Linked Lists","type":"tags"},{"content":"","date":"03 November 2023","externalUrl":null,"permalink":"/tags/listas/","section":"Etiquetas","summary":"","title":"Listas","type":"tags"},{"content":"","date":"03 November 2023","externalUrl":null,"permalink":"/tags/listas-enlazadas/","section":"Etiquetas","summary":"","title":"Listas Enlazadas","type":"tags"},{"content":"","date":"03 November 2023","externalUrl":null,"permalink":"/en/tags/lists/","section":"Tags","summary":"","title":"Lists","type":"tags"},{"content":"","date":"03 November 2023","externalUrl":null,"permalink":"/en/tags/queues/","section":"Tags","summary":"","title":"Queues","type":"tags"},{"content":"","date":"02 November 2023","externalUrl":null,"permalink":"/tags/pilas/","section":"Etiquetas","summary":"","title":"Pilas","type":"tags"},{"content":"","date":"02 November 2023","externalUrl":null,"permalink":"/en/tags/stacks/","section":"Tags","summary":"","title":"Stacks","type":"tags"},{"content":"","date":"30 October 2023","externalUrl":null,"permalink":"/en/tags/arrays/","section":"Tags","summary":"","title":"Arrays","type":"tags"},{"content":"","date":"30 October 2023","externalUrl":null,"permalink":"/tags/arreglos/","section":"Etiquetas","summary":"","title":"Arreglos","type":"tags"},{"content":"","date":"30 October 2023","externalUrl":null,"permalink":"/tags/diccionarios/","section":"Etiquetas","summary":"","title":"Diccionarios","type":"tags"},{"content":"","date":"30 October 2023","externalUrl":null,"permalink":"/en/tags/dictionaries/","section":"Tags","summary":"","title":"Dictionaries","type":"tags"},{"content":"","date":"30 October 2023","externalUrl":null,"permalink":"/tags/mapas/","section":"Etiquetas","summary":"","title":"Mapas","type":"tags"},{"content":"","date":"30 October 2023","externalUrl":null,"permalink":"/en/tags/maps/","section":"Tags","summary":"","title":"Maps","type":"tags"},{"content":"","date":"02 October 2023","externalUrl":null,"permalink":"/tags/clases/","section":"Etiquetas","summary":"","title":"Clases","type":"tags"},{"content":"","date":"02 October 2023","externalUrl":null,"permalink":"/en/tags/classes/","section":"Tags","summary":"","title":"Classes","type":"tags"},{"content":"","date":"02 October 2023","externalUrl":null,"permalink":"/en/tags/objects/","section":"Tags","summary":"","title":"Objects","type":"tags"},{"content":"","date":"02 October 2023","externalUrl":null,"permalink":"/tags/objetos/","section":"Etiquetas","summary":"","title":"Objetos","type":"tags"},{"content":"","date":"30 September 2023","externalUrl":null,"permalink":"/tags/conceptos-iniciales/","section":"Etiquetas","summary":"","title":"Conceptos Iniciales","type":"tags"},{"content":"","date":"30 September 2023","externalUrl":null,"permalink":"/tags/funciones/","section":"Etiquetas","summary":"","title":"Funciones","type":"tags"},{"content":"","date":"30 September 2023","externalUrl":null,"permalink":"/en/tags/functions/","section":"Tags","summary":"","title":"Functions","type":"tags"},{"content":"","date":"30 September 2023","externalUrl":null,"permalink":"/en/tags/methods/","section":"Tags","summary":"","title":"Methods","type":"tags"},{"content":"","date":"30 September 2023","externalUrl":null,"permalink":"/tags/m%C3%A9todos/","section":"Etiquetas","summary":"","title":"Métodos","type":"tags"},{"content":"","date":"30 September 2023","externalUrl":null,"permalink":"/series/programaci%C3%B3n-aprendiendo-los-conceptos-iniciales/","section":"Series","summary":"","title":"Programación: Aprendiendo Los Conceptos Iniciales","type":"series"},{"content":"","date":"30 September 2023","externalUrl":null,"permalink":"/en/series/programming-learning-the-starting-concepts/","section":"Series","summary":"","title":"Programming: Learning the Starting Concepts","type":"series"},{"content":"","date":"30 September 2023","externalUrl":null,"permalink":"/en/tags/recursion/","section":"Tags","summary":"","title":"Recursion","type":"tags"},{"content":"","date":"30 September 2023","externalUrl":null,"permalink":"/tags/recursi%C3%B3n/","section":"Etiquetas","summary":"","title":"Recursión","type":"tags"},{"content":"","date":"30 September 2023","externalUrl":null,"permalink":"/en/tags/starting-concepts/","section":"Tags","summary":"","title":"Starting Concepts","type":"tags"},{"content":"","date":"27 September 2023","externalUrl":null,"permalink":"/en/tags/boolean-logic/","section":"Tags","summary":"","title":"Boolean Logic","type":"tags"},{"content":"","date":"27 September 2023","externalUrl":null,"permalink":"/tags/bucles/","section":"Etiquetas","summary":"","title":"Bucles","type":"tags"},{"content":"","date":"27 September 2023","externalUrl":null,"permalink":"/tags/condicionales/","section":"Etiquetas","summary":"","title":"Condicionales","type":"tags"},{"content":"","date":"27 September 2023","externalUrl":null,"permalink":"/en/tags/conditionals/","section":"Tags","summary":"","title":"Conditionals","type":"tags"},{"content":"","date":"27 September 2023","externalUrl":null,"permalink":"/tags/control-de-flujo/","section":"Etiquetas","summary":"","title":"Control De Flujo","type":"tags"},{"content":"","date":"27 September 2023","externalUrl":null,"permalink":"/en/tags/flow-control/","section":"Tags","summary":"","title":"Flow Control","type":"tags"},{"content":"","date":"27 September 2023","externalUrl":null,"permalink":"/tags/l%C3%B3gica-booleana/","section":"Etiquetas","summary":"","title":"Lógica Booleana","type":"tags"},{"content":"","date":"27 September 2023","externalUrl":null,"permalink":"/en/tags/loops/","section":"Tags","summary":"","title":"Loops","type":"tags"},{"content":"","date":"19 September 2023","externalUrl":null,"permalink":"/tags/entrada/salida/","section":"Etiquetas","summary":"","title":"Entrada/Salida","type":"tags"},{"content":"","date":"19 September 2023","externalUrl":null,"permalink":"/en/tags/i/o/","section":"Tags","summary":"","title":"I/O","type":"tags"},{"content":"","date":"19 September 2023","externalUrl":null,"permalink":"/en/tags/input/output/","section":"Tags","summary":"","title":"Input/Output","type":"tags"},{"content":"","date":"18 September 2023","externalUrl":null,"permalink":"/en/tags/data-types/","section":"Tags","summary":"","title":"Data Types","type":"tags"},{"content":"","date":"18 September 2023","externalUrl":null,"permalink":"/tags/tipos-de-datos/","section":"Etiquetas","summary":"","title":"Tipos De Datos","type":"tags"},{"content":"","date":"18 September 2023","externalUrl":null,"permalink":"/en/tags/variables/","section":"Tags","summary":"","title":"Variables","type":"tags"},{"content":"","date":"10 September 2023","externalUrl":null,"permalink":"/tags/herramientas/","section":"Etiquetas","summary":"","title":"Herramientas","type":"tags"},{"content":"","date":"10 September 2023","externalUrl":null,"permalink":"/en/tags/ide/","section":"Tags","summary":"","title":"IDE","type":"tags"},{"content":"","date":"10 September 2023","externalUrl":null,"permalink":"/en/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"10 September 2023","externalUrl":null,"permalink":"/en/tags/tools/","section":"Tags","summary":"","title":"Tools","type":"tags"},{"content":"","date":"05 September 2023","externalUrl":null,"permalink":"/tags/binario/","section":"Etiquetas","summary":"","title":"Binario","type":"tags"},{"content":"","date":"05 September 2023","externalUrl":null,"permalink":"/en/tags/binary/","section":"Tags","summary":"","title":"Binary","type":"tags"},{"content":"","date":"05 September 2023","externalUrl":null,"permalink":"/en/tags/decimal/","section":"Tags","summary":"","title":"Decimal","type":"tags"},{"content":"","date":"05 September 2023","externalUrl":null,"permalink":"/en/tags/hexadecimal/","section":"Tags","summary":"","title":"Hexadecimal","type":"tags"},{"content":"","date":"05 September 2023","externalUrl":null,"permalink":"/en/tags/numeral-systems/","section":"Tags","summary":"","title":"Numeral Systems","type":"tags"},{"content":"","date":"05 September 2023","externalUrl":null,"permalink":"/tags/sistemas-de-numeraci%C3%B3n/","section":"Etiquetas","summary":"","title":"Sistemas De Numeración","type":"tags"},{"content":" Latests news and tutorials about programming, software engineering, DevOps and much more! ","date":"02 September 2023","externalUrl":null,"permalink":"/en/blog/","section":"Blog","summary":"","title":"Blog","type":"blog"},{"content":"","date":"02 September 2023","externalUrl":null,"permalink":"/en/tags/cd/","section":"Tags","summary":"","title":"CD","type":"tags"},{"content":"","date":"02 September 2023","externalUrl":null,"permalink":"/tags/computadoras/","section":"Etiquetas","summary":"","title":"Computadoras","type":"tags"},{"content":"","date":"02 September 2023","externalUrl":null,"permalink":"/en/tags/computers/","section":"Tags","summary":"","title":"Computers","type":"tags"},{"content":"Continuous Delivery (CD) is deeply rooted in the first principle of the Agile Manifesto posted in 20011:\nOur highest priority is to satisfy the customer through early and continuous delivery of valuable software.\nAccording to Martin Fowler2, a project is truly embracing Continuous Delivery when:\nThe software can be deployed at any stage of its lifecycle. The team values keeping the software deployment-ready over adding new features. Any software version can be deployed to any environment on-demand. In many ways, Continuous Delivery is the next step from Continuous Integration, seamlessly automating processes all the way to the software\u0026rsquo;s end user.\nMuch like in Continuous Integration, the pipeline stands as the cornerstone of Continuous Delivery. However, it\u0026rsquo;s not just about integrating code, testing it, and generating a deliverable artifact. With CD, this artifact progresses through a series of test phases in environments that increasingly resemble production settings. After passing through the Continuous Integration pipeline, what emerges is a potentially deployable artifact. CD then takes this artifact and puts it through the necessary tests, ensuring it\u0026rsquo;s primed for a live deployment.\nThe delivery process # The following figure illustrates the fundamental steps of a Continuous Delivery (CD) process. It\u0026rsquo;s vital to note that an effective CD process presupposes a well-oiled Continuous Integration (CI) system as its foundation.\nCD process flowchart The CD process adds two distinct phases to the CI system: deployment stages and system validation and verification testing. A critical premise is that the deployment process is paramount to product delivery. Thus, automating and frequently testing it is essential. Ideally, testing should also be automated to facilitate execution, especially if you aim for Continuous Deployment. However, it\u0026rsquo;s not imperative to automate all tests, especially at the beginning of the CD process implementation.\nUpon creating a potentially deliverable artifact in the CI pipeline, the initial step is to deploy it in a testing or QA environment. The primary goal of this environment is to offer a space where software tests, both automatic and manual, can be run. The only possible variations between the QA and actual production environment (the one used by customers) may pertain to its capacity or resource size. This scaled-down capacity, whether in processing, memory, storage, or database size, is typically a cost-saving measure.\nIf system and acceptance tests are successful in the QA environment, the next phase is to deploy the artifact in a staging environment. This environment should be an exact replica of the production setting. Its purpose is to facilitate performance and load testing on the system, effectively putting it under stress to validate its functionality under high loads and assess its processing and response times.\nWhen the previous tests are satisfactory, the artifact is ready to be deployed in a production environment. This space is also referred to as the live environment, where users interact with the system.\nAs evident, the product deployment method is exercised at least twice before the final production deployment, considerably reducing risks associated with potential errors as the final delivery approaches.\nCore principles and practices # One of CD\u0026rsquo;s primary objectives is to boost delivery frequency. This naturally means that each release should minimize its size. A smaller delivery not only implies fewer potential errors but also facilitates their identification and resolution2. To achieve this, the code must always be in a deploy-ready state.\nRapid automated testing is crucial for today\u0026rsquo;s software development3. In the context of CD, automated tests are of utmost importance as they must ensure comprehensive system quality without hampering the delivery cycle\u0026rsquo;s speed4. Lengthy test runs force the team to await results, leading to wasted time3. If these tests aren\u0026rsquo;t parallelized and optimized, developers may start sidelining them5. To ensure test optimization, it\u0026rsquo;s recommended to fail tests that exceed a reasonable limit6.\nThe software should always be potentially deliverable. It\u0026rsquo;s essential for the software\u0026rsquo;s build status to remain \u0026lsquo;green\u0026rsquo; consistently. This means if a new repository commit breaks the build, this error must be rectified before any new commit is made. Adhering to this practice simplifies error tracing, while deviating may condition developers to overlook a broken or \u0026lsquo;red\u0026rsquo; build6. Broken builds signify product flaws and render it undeliverable.\nIn using CD, the aim is to ensure each commit results in a production-ready artifact. If this artifact is rebuilt at every process stage, there\u0026rsquo;s no guarantee of their identical nature, and validation and verification test results from one artifact cannot be applied to others. This could lead to deploying untested artifacts6. Hence, artifacts should be produced only once and undergo all tests on that single artifact before deploying that very software piece to production.\nSoftware should always be deployed identically across all environments. Otherwise, there\u0026rsquo;s no assurance of the deployment process\u0026rsquo;s efficacy. If environment differences exist, they should be managed using configuration files, but the deployment process should remain consistent6.\nDeployment should be achievable with a mere button press. The ability to deploy the latest product version anytime with a single button press is a robust indicator of CD implementation2. This not only requires the aforementioned steps but also mandates version-controlled software deployment scripts that are regularly checked and validated6.\nAs mentioned earlier, CD\u0026rsquo;s main objective is to ascertain the product\u0026rsquo;s readiness post each commit2. For this, aside from ensuring a swift compilation and testing process, process outcomes should be visible and shared with the team. Display screens showcasing the current status, build times, test coverage, and more, offer a way to maintain constant visibility6. Presenting these results not only supports CD but, as some authors suggest, also bolsters team motivation4.\nBenefits of Continuous Delivery # With the rise of Continuous Delivery (CD) practices, businesses are realizing numerous advantages:\nSwift value delivery: the adoption of CD practices facilitates a faster rollout of features and error rectifications to end users7. This speed is attributed to the code becoming potentially deployable to users as it traverses through the Continuous Integration (CI) pipeline4.\nDiminished delivery failures: frequent releases lead to fewer delivery risks since each release embodies fewer changes. This, in turn, means there\u0026rsquo;s a reduced margin for errors2. Even if an error emerges, its origin is easier to trace and correct. Plus, reverting to a previous version in the face of complications becomes straightforward8. A delightful by-product of this streamlined process is the diminished stress levels amongst stakeholders7 5. Furthermore, the consistency and quality in the delivery process cement trust between the development team and clients7.\nProductivity amplification: Chen\u0026rsquo;s study reveals that, in the absence of CD practices, teams spent nearly \\(20%\\) of their time setting up and maintaining environments7. The introduction of CD automates this ordeal, which translates to heightened productivity by phasing out manual, non-value-add tasks6.\nPrompt feedback: a consensus among experts highlights the value of early feedback during the development phase2 7 4. Regular releases not only fetch this feedback promptly but also ensure that the developed product aligns seamlessly with customer requirements2. The agility to swiftly address customer needs, fix reported bugs, and introduce demanded features can significantly elevate customer satisfaction4.\nEnhanced software quality: the rigorous automation of software tests (unit, integration, and system), essential for implementing CD, combined with more frequent software deliveries encapsulating fewer changes, culminates in a notable boost in software quality4.\nTransparency in progress: thanks to frequent releases, clients find it easier to stay abreast of the latest product updates, embracing novel features and bug fixes with open arms.\nChallenges in adopting Continuous Delivery # The journey to incorporate Continuous Delivery (CD) isn’t without its hurdles. Here\u0026rsquo;s a look at some of the key challenges faced by businesses:\nProduct complexity: certain products consist of myriad interconnected modules or possess dependencies with other projects. This can create bottlenecks when automating CD pipelines4. Such complexities might frustrate teams, pushing them to retain manual processes or longer integration procedures.\nTest suite creation: crafting a comprehensive test suite to ensure product quality is labour-intensive. All team members must allocate significant time to pen tests, which might require extra training. Besides, tests can be time-consuming, so the trick lies in devising effective yet swift tests4.\nLegacy code: systems that have been in development for an extended period and weren\u0026rsquo;t designed with automated testing in mind can pose a significant challenge. Transitioning such systems to CD is not only a technical endeavour but also a social and cultural shift4.\nEnvironmental discrepancies: all environments in the CI pipeline should mirror the production setting (\u0026lsquo;production-like\u0026rsquo;)6. If not, unforeseen errors can arise, demanding valuable time on non-value-add tasks4. Ensuring multiple deployment stages in similar environments means that the deployment process is tested repetitively.\nClient restrictions: not every client might desire or require a shortened product delivery cycle4. Such client limitations aren\u0026rsquo;t direct obstacles to CD implementation but play a pivotal role when aiming for Continuous Deployment. This could potentially sideline some CD benefits, like swift client feedback or minimal change deliveries. Moreover, the domain itself can act as a bottleneck. Software related to heavily-regulated sectors like healthcare and defence may find CD implementation challenging, if not nearly impossible4.\nTransparency and reporting: a successful CD adoption hinges on collaboration and transparency, introducing challenges tied to providing effective status reports to stakeholders9. This encompasses technical hurdles around automated report generation and analytics challenges to pinpoint essential information.\nResistance to change: any transformative change, like adopting CD, faces the innate human trait of resistance. Convincing the team to adapt to new practices and modify their workflow is a task. On a higher level, management might also be hesitant to experiment with fresh processes.\nContinuous Deployment # The notion of Continuous Deployment was popularized by Fitz10. The standout distinction between this method and Continuous Delivery (CD) is that, once the product is deemed ready for release, there\u0026rsquo;s no waiting for manual intervention to launch it into production11 6. If CD is properly executed, the step towards Continuous Deployment should demand no extra efforts from the development perspective8. In essence, the core difference lies in decision-making: with CD, releasing the product to production remains a business decision, whereas with Continuous Deployment, the launch is automated.\nIt\u0026rsquo;s worth noting that when we discuss CD, it inherently includes Continuous Delivery but may or may not encompass Continuous Deployment.\nReferences # Beck, Kent, Mike Beedle, Arie van Bennekum, Alistair Cockburn, Ward Cunningham, Martin Fowler, James Grenning, Jim Highsmith, Andrew Hunt, Ron Jeffries, Jon Kern, Brian Marick, Robert C. Martin, Steve Mellor, Ken Schwaber, Jeff Sutherland, and Dave Thomas. Manifesto for Agile Software Development, 2001.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, Martin. Continuous Delivery, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUdd, Raoul. Adopting Continuous Delivery: A Case Study, 2016.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLeppanen, Marko, Simo Makinen, Max Pagels, Veli-Pekka Eloranta, Juha Itkonen, Mika V. Mantyla, and Tomi Mannisto. The highways and country roads to continuous deployment. IEEE Software, 32(2):64-72, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNeely, Steve, and Steve Stolt. Continuous delivery? Easy! Just change everything (well, maybe it is not that easy). Proceedings - AGILE 2013, pp.121-128, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez, and David Farley. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChen, Lianping. Continuous Delivery: Huge Benefits, but Challenges Too. IEEE Software, 32(2):50-54, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez. Continuous Delivery vs Continuous Deployment, 2010.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOlsson, Helena Holmstrom, Hiva Alahyari, and Jan Bosch. Climbing the \u0026ldquo;Stairway to Heaven\u0026rdquo; \u0026ndash; A Multiple-Case Study Exploring Barriers in the Transition from Agile Development towards Continuous Deployment of Software. 2012 38th Euromicro Conference on Software Engineering and Advanced Applications, pp.392-399, 2012.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFitz, Timothy. Continuous Deployment, 2009.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPulkkinen, Ville. Continuous Deployment of Software. Proceedings of Cloud-Based Software Engineering, pp.46-52, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"02 September 2023","externalUrl":null,"permalink":"/en/blog/continuous-delivery/","section":"Blog","summary":"","title":"Continuous Delivery","type":"blog"},{"content":"","date":"02 September 2023","externalUrl":null,"permalink":"/en/tags/continuous-delivery/","section":"Tags","summary":"","title":"Continuous Delivery","type":"tags"},{"content":"","date":"02 September 2023","externalUrl":null,"permalink":"/en/tags/continuous-deployment/","section":"Tags","summary":"","title":"Continuous Deployment","type":"tags"},{"content":"","date":"02 September 2023","externalUrl":null,"permalink":"/en/tags/cpu/","section":"Tags","summary":"","title":"CPU","type":"tags"},{"content":"","date":"02 September 2023","externalUrl":null,"permalink":"/en/tags/hardware/","section":"Tags","summary":"","title":"Hardware","type":"tags"},{"content":"","date":"02 September 2023","externalUrl":null,"permalink":"/tags/memoria/","section":"Etiquetas","summary":"","title":"Memoria","type":"tags"},{"content":"","date":"02 September 2023","externalUrl":null,"permalink":"/en/tags/memory/","section":"Tags","summary":"","title":"Memory","type":"tags"},{"content":"","date":"02 September 2023","externalUrl":null,"permalink":"/en/tags/software/","section":"Tags","summary":"","title":"Software","type":"tags"},{"content":"","date":"19 August 2023","externalUrl":null,"permalink":"/en/tags/ci/","section":"Tags","summary":"","title":"CI","type":"tags"},{"content":"One of the most pivotal challenges in the realm of software development is effectively integrating changes 1. In a small-scale project steered by a single developer, this challenge might appear to be trivial. However, as the magnitude of the project escalates and more individuals join the development fold, the significance of seamless integration becomes paramount.\nHistorically, integration was often an afterthought, relegated to the tail end of the software development process 2. Postponing it to such a late stage not only amplifies the risk of complex, undetected errors but also heightens the tension as delivery dates loom.\nHowever, the paradigm shifted around the turn of the millennium. Continuous Integration (CI) was formally introduced in 2000 by Kent Beck as an intrinsic part of the \u0026lsquo;Extreme Programming\u0026rsquo; methodology 3. CI emphasizes the frequent and early-stage integration of code. By continuously amalgamating new code into the system, developers can gauge its impact promptly. This approach streamlines error detection, enabling developers to tackle issues as they emerge 2. The ability to tie an error to a specific code change reduces error complexity and promotes efficient troubleshooting. Today, CI has become an indispensable practice in software development projects 4.\nMartin Fowler, a luminary in the field, eloquently defined CI as:\nContinuous Integration is a software development practice where team members integrate their work frequently, typically multiple times a day. Each integration is verified by an automated build system that runs test suites to swiftly detect any integration anomalies. Teams adopting this methodology often witness a significant reduction in integration hiccups, empowering them to produce cohesive software at an accelerated pace2.\nBuilding upon Fowler’s definition, Duvall 5 underscored several vital facets:\nDevelopers must maintain a conducive local environment for code construction and testing, ensuring their updates do not disrupt the established integration. Team members should commit their code to the Version Control System (VCS) daily. The integration process must be undertaken on a distinct machine, aptly termed the CI server. Only builds that pass all tests can be deemed deliverable. Error resolution is of paramount importance. A central repository displaying build and test results—often a website—is essential. Most CI tools readily offer such platforms. Furthermore, Patrick Cauldwell 6 advocates for frequent and early integration. The rationale? The more regular the integration, the less overhead for the team down the line. He distilled the primary goals of CI into:\nEnsuring a consistently available, tested version of the product with the latest modifications. Keeping the team abreast of any integration issues as early as possible. The impetus behind CI is to maintain an error-free, tested product throughout the development life cycle. This avoids the pitfalls of a last-minute integration phase, which is often fraught with errors and consumes both time and resources. More crucially, if project components aren\u0026rsquo;t integrated during their development, there\u0026rsquo;s no guarantee they\u0026rsquo;ll gel cohesively in the final product 7.\nTechnical implementation of CI revolves around two core components: process automation and a system to showcase results, thereby fuelling the developmental feedback loop 7.\nIn summing up the tenets of CI, Martin Fowler 1 emphasizes:\nRetaining code in a singular repository. Streamlining software construction through automation. Implementing automated testing processes. Ensuring new code additions undergo integration and construction on the CI system\u0026rsquo;s machine. Keeping the build process agile and swift. Providing easy access to the product\u0026rsquo;s latest executable version. Ensuring product status transparency for all stakeholders. Elements of a CI system # A basic Continuous Integration (CI) pipeline initiates when a new code change is pushed to the repository. The CI server, linked to the repository, gets notified of every new change, subsequently downloading the latest version to initiate the integration process, which will be elaborated on in the subsequent section. Once completed, it communicates the system\u0026rsquo;s status to the team members.\nIn computer science, a \u0026ldquo;pipeline\u0026rdquo; refers to a sequence of processes or tasks linked such that the output of one becomes the input for the next.\nFigure 1: Basic elements of CI The system\u0026rsquo;s primary component consists of the developers. After making code modifications, they run tests locally and compile the code to ensure that they haven\u0026rsquo;t introduced new errors.\nAn essential part of every CI system is the Version Control System (VCS). It oversees the changes made to the code and other significant elements. This system establishes a unified access point for all source code, enabling the CI system to fetch the most recent version for integration. Most software development projects utilize a VCS even if they don\u0026rsquo;t implement CI processes.\nThe CI Server is responsible for initiating a new build (comprising both compilation and tests) every time a change is added to the repository. They offer configurations to simplify the creation of integration pipelines. Additionally, most come with a web interface to display the build status and previous results. Currently, numerous powerful options are available, both free and paid. It\u0026rsquo;s worth noting that the CI server should operate on a dedicated machine and not on team members\u0026rsquo; computers.\nThe CI server must automatically conduct software tests, source code analysis, and compile to produce the deliverable product. Therefore, build and test execution scripts are vital. These scripts outline the necessary steps to be executed. Popular tools for this purpose include Make, Ant, Maven, Gradle, among others.\nEvery CI system should have a notification mechanism to relay results to the team. This mechanism ensures that in the event of an error, the team becomes aware as soon as possible, enabling them to address the issue. While most CI tools offer a web interface to view results, they also support other notification methods like emails, messaging applications, etc.\nThe integration process # The figure below broadly illustrates the stages of the integration process taking place within the Continuous Integration (CI) system.\nFigure 2: CI process flowchart Initially, the system must retrieve the latest source code version each time a new change is pushed to the Version Control System (VCS). Two mechanisms facilitate this. The first involves setting up the CI server to periodically check the VCS for updates. The alternative is to establish a commit hook within the VCS, ensuring that the CI server receives notifications whenever changes are made.\nAfter obtaining the code, the CI server can be configured to scrutinize the source code for potential undetected errors, be they syntactic, logical, or patterns that might lead to faults. Various tools aid this process. For instance, Java boasts utilities like FindBugs, CheckStyle, and PMD, while Python has Pylint. JavaScript can be analysed with tools like JSLint or JSHint. An example of a code analysis criterion could be ensuring every developed method has a cyclomatic complexity8 under 10. By employing automated source code inspection, one can assess code correctness, spot duplicate portions, and expedite the time between error detection and rectification. While automated inspection might not catch every error, the results can approximate those of peer reviews, thereby lightening the team\u0026rsquo;s review load.\nThe subsequent step revolves around automated test execution on the product. This automation is paramount to successfully implementing a CI system. Thus, developers can confidently make alterations, knowing a robust testing framework safeguards against compromising existing functionalities. Some popular tools in this domain include Junit, JBehave, and Selenium, which not only facilitate test drafting but also generate comprehensive reports, often as visualizations or web pages. Several software testing levels exist, such as unit tests, integration tests, and system tests. In the CI pipeline context, the focus rests on automating unit and integration tests, with system tests\u0026rsquo; automation being recommended but not mandatory.\nOnce the tests pass, the CI pipeline advances to compiling the source code. During this phase, the source code morphs into one or multiple files or packages, ready for distribution and user execution. This process\u0026rsquo;s specifics hinge on the employed programming language. For instance, languages like Java necessitate code compilation, resulting in an executable. Conversely, languages like Python might involve stricter code structure checks without generating any binary files.\nThroughout this integration journey, the team should steadfastly adhere to three fundamental rules:\nLocally run tests and compile software before integrating it into the VCS to minimize error introduction chances (avoiding \u0026ldquo;breaking the build\u0026rdquo;). Avoid pushing new code to the VCS if the CI server flags errors (indicative of a \u0026ldquo;broken build\u0026rdquo;). Should the CI server report faults, code modifications should exclusively aim at rectifying them. Core principles and practices # Martin Fowler2 identifies a set of foundational elements intrinsic to every Continuous Integration (CI) system. While some of these have been touched upon earlier in this chapter, we will succinctly encapsulate them here for clarity:\nCentralized Code Repository: Retain all code within a singular, unified repository. Streamlined Compilation and Build Process: Entirely automate the compilation and construction workflows, negating manual intervention. Full-Spectrum Automated Testing: Ensure all software tests are automated, driving efficiency and precision. Daily Commitment: Encourage the team to consistently merge their changes to the repository on a daily basis. Stringent Integration Checks: Each alteration made to the Version Control System (VCS) undergoes rigorous integration processes within the CI system. Prompt Error Rectification: Should the CI system flag any issues (indicative of a \u0026ldquo;broken build\u0026rdquo;), immediate action is imperative. Either rectify the flaw or reverse the change to ensure the repository\u0026rsquo;s latest version remains operational. Swift CI Procedures: Aim to complete the CI process rapidly—ideally within 15 minutes or less. This approach ensures timely integration and facilitates the expedited delivery of results. Universal Access to Latest Executables: Always provide the team with access to the most recent executable or deliverable package, promoting transparency. Real-time Product Status Visibility: Grant every team member the ability to monitor the product\u0026rsquo;s status at any given moment, fostering informed decision-making. Benefits # The overarching consensus within the software community is that the implementation of a Continuous Integration (CI) process yields an array of substantial advantages. Duvall5 outlines these core benefits in his publication.\nRisk Mitigation: Adopting frequent integration minimizes project risks. It facilitates early detection of issues and offers a continuous snapshot of the product\u0026rsquo;s health. By identifying these issues early in the development cycle, there\u0026rsquo;s a consequent reduction in both the cost of fixes and the risk of releasing a subpar product. Furthermore, automated inspections provide real-time insights into the product\u0026rsquo;s size, code complexity, and other metrics. This automation diminishes the chance of human-induced errors.\nMinimization of Manual Repetitive Tasks: Automation curtails the need for recurring manual tasks such as compilation, inspection, test execution, and report generation. This efficiency not only leads to significant time and cost savings but also allows teams to focus on activities that directly enhance product value. It liberates team members to dedicate more time to addressing new requirements or rectifying existing product issues.\nOn-Demand Availability of a Functional Product: A hallmark of CI is its ability to deliver a functional software product at any given moment. This is invaluable for stakeholders, offering them a rapid glance into product development progress. By leveraging CI, errors can be swiftly detected and remedied soon after a new change is introduced. This is far more efficient than uncovering them close to the release date when they are more expensive and challenging to amend. Such issues, if left unchecked, can lead to delivery delays, unsatisfied clients, escalated costs, and more. This ties back to the concept of the \u0026ldquo;Broken Window Theory\u0026rdquo;9, which, in essence, postulates that a product marred by numerous issues or perceived disorder can demotivate teams from addressing them.\nEnhanced Project Transparency: Implementing CI augments visibility into the project, rendering the development process more transparent. It aids project management with up-to-the-minute information, making it straightforward to gauge product quality, error trends, and more.\nElevated Product Confidence: The CI environment bolsters confidence in the product. Team members gain immediate insights into the ramifications of their changes, enabling them to promptly rectify any emergent issues.\nChallenges # While Duvall5 has extolled the virtues of Continuous Integration (CI) in his works, he also highlights potential challenges that might deter development teams from embracing it fully or realizing its benefits.\nBias: A widespread misconception is that CI system implementation is exorbitant and would escalate development costs due to its prolonged setup and maintenance. Contrarily, most software development projects already involve phases like inspection, testing, compilation, and integration, even if they don’t explicitly use a CI system. A common refrain is that there\u0026rsquo;s insufficient time or funds for CI system implementation, but the reality is that far more resources are spent performing redundant manual tasks throughout the development cycle. Furthermore, an automated CI system is infinitely more manageable and consistent compared to disparate manual processes.\nDisruption Fears: Projects in advanced development stages often fret that integrating a CI system would overhaul their established workflows, spawning significant delays. It’s pivotal to recognize that CI system implementation can be incremental. Teams can address one integration stage at a time, gradually ramping up the integration frequency as confidence builds.\nOverwhelming Failed Integrations: When CI practices aren’t diligently applied, there\u0026rsquo;s a risk of encountering an excessive number of failed integrations or \u0026ldquo;broken builds.\u0026rdquo; This could stem from developers bypassing local tests before uploading their changes to the Version Control System (VCS). A surge in failed integrations can erode trust in the CI system, reminiscent of the \u0026ldquo;Broken Window Theory\u0026rdquo;9.\nPerceived Additional Costs: There\u0026rsquo;s an apprehension among organizations about incurring extra expenses either for procuring CI product licenses or securing hardware to support these systems. However, this expenditure pales in comparison to the latent costs of late-stage integrations, where issues are discovered near the release date, far removed from their inception. On a brighter note, the current landscape is rife with a myriad of free and open-source alternatives, obviating any additional costs.\nReferences # Continuous integration. ThoughtWorks, 2018.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, Martin. Continuous Integration. 2006.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBeck, Kent. Embrace Change with Extreme Programming. IEEE Computer Magazine, (c), 70-77. 1999.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRodriguez Pilar, Markkula, Jouni, Oivo, Markku, \u0026amp; Turula, Kimmo. Survey on agile and lean usage in Finnish software industry. In Proceedings of the ACM-IEEE international symposium on Empirical software engineering and measurement - ESEM \u0026lsquo;12 (p. 139). ACM Press. DOI: 10.1145/2372251.2372275. 2012.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDuvall, Paul M., Matyas, Steve, \u0026amp; Glover, Andrew. Continuous integration: improving software quality and reducing risk. Pearson Education, Inc., 2007.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCauldwell, Patrick. Code Leader: Using people, tools and processes to build successful software. Wiley Publishing, Inc., 2008.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez \u0026amp; Farley, David. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCyclomatic Complexity Explanation\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe Broken Window Theory in Software Development\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"19 August 2023","externalUrl":null,"permalink":"/en/blog/continuous-integration/","section":"Blog","summary":"","title":"Continuous Integration","type":"blog"},{"content":"","date":"19 August 2023","externalUrl":null,"permalink":"/en/tags/continuous-integration/","section":"Tags","summary":"","title":"Continuous Integration","type":"tags"},{"content":"","date":"18 August 2023","externalUrl":null,"permalink":"/en/software-engineering/","section":"Software Engineering","summary":"","title":"Software Engineering","type":"software-engineering"},{"content":"","date":"10 August 2023","externalUrl":null,"permalink":"/en/series/learning-software-engineering/","section":"Series","summary":"","title":"Learning Software Engineering","type":"series"},{"content":"","date":"10 August 2023","externalUrl":null,"permalink":"/en/tags/software-engineering/","section":"Tags","summary":"","title":"Software Engineering","type":"tags"},{"content":"","date":"18 January 2023","externalUrl":null,"permalink":"/en/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"","date":"18 January 2023","externalUrl":null,"permalink":"/en/tags/revert/","section":"Tags","summary":"","title":"Revert","type":"tags"},{"content":" Reverting a commit before pushing # When we have created a commit locally but have not published it to the remote yet, we can use git reset to undo the commit and, if we wish, discard the changes. Although there are several options for git reset the most used are:\n--soft: Does not touch the index file or the working tree at all (but resets the head to , just like all modes do). This leaves all your changed files \u0026ldquo;Changes to be committed\u0026rdquo;, as git status would put it. --hard: Resets the index and working tree. Any changes to tracked files in the working tree since are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted. Git reset documentation {: style=\u0026ldquo;text-align: right;\u0026rdquo;}\nHere there is an example about using git reset. We start by changing a file and creating a commit with the change.\nbash-3.2$ cat README.md # Index 1 bash-3.2$ bash-3.2$ cat README.md # Index 1 2 bash-3.2$ bash-3.2$ git add README.md bash-3.2$ bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md\u0026#34; [main 3734fd5] Add number 2 in README.md 1 file changed, 1 insertion(+) git status shows there is one commit pending to be published.\nbash-3.2$ git status On branch main Your branch is ahead of \u0026#39;origin/main\u0026#39; by 1 commit. (use \u0026#34;git push\u0026#34; to publish your local commits) nothing to commit, working tree clean Using git reflog to see the history.\n3734fd5 (HEAD -\u0026gt; main) HEAD@{0}: commit: Add number 2 in README.md 866bfa8 (origin/main) HEAD@{1}: revert: Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; e2f6d08 HEAD@{2}: merge feature-1: Merge made by the \u0026#39;ort\u0026#39; strategy. 23644da HEAD@{3}: checkout: moving from feature-1 to main Now we can use git reset --soft \u0026lt;COMMIT_ID\u0026gt; to undo the commit but keep the changes.\nbash-3.2$ git reset --soft 866bfa8 bash-3.2$ bash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: README.md git log after using git reset\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. We create a new commit so we can test the git reset --hard command.\nbash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: README.md bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md - NEW COMMIT\u0026#34; [main 2e7193d] Add number 2 in README.md - NEW COMMIT 1 file changed, 1 insertion(+) git log now shows the new commit.\ncommit 2e7193db650b9ba0762fe73525df599a08f8577d (HEAD -\u0026gt; main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Thu Jan 19 08:32:57 2023 -0300 Add number 2 in README.md - NEW COMMIT commit 866bfa8a952d11240707ebfc87f3266034d42443 (origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. Now we can use git reset --hard \u0026lt;COMMIT_ID\u0026gt; to undo the commit and discard all the changes.\nbash-3.2$ git reset --hard 866bfa8 HEAD is now at 866bfa8 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; bash-3.2$ bash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean git log remains as it nothing had happened.\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. Reverting a commit after it was pushed # When we realized that the last commit was a mistake but we already published it, the command to use is git revert \u0026lt;COMMIT_HASH\u0026gt;.\nFirst we need to locate the ID of the commit we want to revert, it can be done with git log or git reflog commands. Then, run the git revert \u0026lt;COMMIT_HASH\u0026gt; command using the ID obtained in the previous step. Use the options -e or --edit to edit the commit message if we like. Push our changes so the revert is available for everyone in our group. Reverting multiple commits # If we need to revert multiple commits we can revert them one by one using the --no-commit option in order to create a single revert commit at the end.\nImagine the history is like the following and we need to go back to COMMIT-3.\nCOMMIT-1 -\u0026gt; COMMIT-2 -\u0026gt; COMMIT-3 -\u0026gt; COMMIT-4 -\u0026gt; COMMIT-5 -\u0026gt; COMMIT-6 -\u0026gt; HEAD This sequence of commands will get our files to the version of COMMIT-3:\nbash-3.2$ git revert --no-commit COMMIT-6 bash-3.2$ git revert --no-commit COMMIT-5 bash-3.2$ git revert --no-commit COMMIT-4 bash-3.2$ git commit -m \u0026#34;Revert to version in COMMIT-3\u0026#34; bash-3.2$ git push Reverting a merge commit # -m parent-number, \u0026ndash;mainline parent-number\nUsually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.\nGit revert documentation {: style=\u0026ldquo;text-align: right;\u0026rdquo;}\nWhen we need to revert a merge commit git revert command needs to be run with the -m or --mainline option to indicate the parent number because a merge commit has more than one parent and Git does not know which parent was target branch and which was the branch with the changes that should be reverted.\nHere there is an example showing how to revert a merge commit.\nCreate the first commit in main branch.\nbash-3.2$ cat README.md # Index 1 bash-3.2$ bash-3.2$ git commit -m \u0026#34;Add number 1 in README.md - main branch\u0026#34; [main (root-commit) 23644da] Add number 1 in README.md - main branch 1 file changed, 3 insertions(+) create mode 100644 README.md bash-3.2$ bash-3.2$ git push -u origin main Enumerating objects: 3, done. Counting objects: 100% (3/3), done. Writing objects: 100% (3/3), 254 bytes | 254.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git * [new branch] main -\u0026gt; main branch \u0026#39;main\u0026#39; set up to track \u0026#39;origin/main\u0026#39;. bash-3.2$ The state of the README.md file in main branch.\nbash-3.2$git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 Branch feature-1 created and added one commit.\nbash-3.2$ git checkout -b feature-1 Switched to a new branch \u0026#39;feature-1\u0026#39; bash-3.2$ bash-3.2$ cat README.md # Index 1 2 bash-3.2$ bash-3.2$ git add README.md bash-3.2$ bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md - feature-1 branch\u0026#34; [feature-1 83ea1a3] Add number 2 in README.md - feature-1 branch 1 file changed, 1 insertion(+) bash-3.2$ bash-3.2$ git push --set-upstream origin feature-1 Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 292 bytes | 292.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 remote: remote: Create a pull request for \u0026#39;feature-1\u0026#39; on GitHub by visiting: remote: https://github.com/jnonino/test-repo/pull/new/feature-1 remote: To github.com:jnonino/test-repo.git * [new branch] feature-1 -\u0026gt; feature-1 branch \u0026#39;feature-1\u0026#39; set up to track \u0026#39;origin/feature-1\u0026#39;. bash-3.2$ The state of README.md in the feature-1 branch.\nbash-3.2$ git status On branch feature-1 Your branch is up to date with \u0026#39;origin/feature-1\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 2 Merge the feature-1 branch into the main branch.\nbash-3.2$ git checkout main Switched to branch \u0026#39;main\u0026#39; Your branch is up to date with \u0026#39;origin/main\u0026#39;. bash-3.2$ bash-3.2$ git merge --no-ff feature-1 Merge made by the \u0026#39;ort\u0026#39; strategy. README.md | 1 + 1 file changed, 1 insertion(+) bash-3.2$ bash-3.2$ git push Enumerating objects: 1, done. Counting objects: 100% (1/1), done. Writing objects: 100% (1/1), 233 bytes | 233.00 KiB/s, done. Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git 23644da..e2f6d08 main -\u0026gt; main bash-3.2$ Current state of README.md in main branch.\nbash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 2 git log after merging feature-1 into main branch.\ncommit e2f6d08d3b38a02a1c026cfb879f3131536757ac (HEAD -\u0026gt; main, origin/main) Merge: 23644da 83ea1a3 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:58:19 2023 -0300 Merge branch \u0026#39;feature-1\u0026#39; commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:53:38 2023 -0300 Add number 2 in README.md - feature-1 branch commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:48:37 2023 -0300 Add number 1 in README.md - main branch To revert the merge commit, as it was stated above we need to pay attention to the merge field.\nMerge: 23644da 83ea1a3 Running git revert e2f6d08 -m 1 will reinstate the tree as it was in 23644da, and git revert e2f6d08 -m 2 will set the tree as it was in 83ea1a3. In this example we would like to leave the main branch as it was before the merge commit. For doing that, we need to run git revert e2f6d08 -m 1.\nbash-3.2$ git revert e2f6d08 -m 1 [main 866bfa8] Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 1 file changed, 1 deletion(-) bash-3.2$ bash-3.2$ git status On branch main Your branch is ahead of \u0026#39;origin/main\u0026#39; by 1 commit. (use \u0026#34;git push\u0026#34; to publish your local commits) nothing to commit, working tree clean bash-3.2$ bash-3.2$ git push Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 344 bytes | 344.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git e2f6d08..866bfa8 main -\u0026gt; main git log after reverting the merge commit.\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. commit e2f6d08d3b38a02a1c026cfb879f3131536757ac Merge: 23644da 83ea1a3 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:58:19 2023 -0300 Merge branch \u0026#39;feature-1\u0026#39; commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:53:38 2023 -0300 Add number 2 in README.md - feature-1 branch commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:48:37 2023 -0300 Add number 1 in README.md - main branch Current state of README.md in main branch.\nbash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 ","date":"18 January 2023","externalUrl":null,"permalink":"/en/blog/git-revert/","section":"Blog","summary":"","title":"Reverting changes in Git","type":"blog"},{"content":"","date":"18 January 2023","externalUrl":null,"permalink":"/en/tags/vcs/","section":"Tags","summary":"","title":"VCS","type":"tags"},{"content":"","date":"18 January 2023","externalUrl":null,"permalink":"/en/tags/version-control/","section":"Tags","summary":"","title":"Version Control","type":"tags"}]