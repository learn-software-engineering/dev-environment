[{"content":"Data structures are ways of organizing and storing information in a computer program so that it can be accessed and modified efficiently. As programmers, it is essential to understand the different data structures available and know when to apply each one to optimize the performance and utility of our programs.\nA data structure is a particular way of organizing data in the computer\u0026rsquo;s memory so that it can be used efficiently. Data structures come in many forms, such as arrays, lists, stacks, queues, graphs, trees, hashes, etc.\nEach structure organizes the data according to a specific logical model and supports efficient operations to access, modify, add, and delete elements according to that model. For example, an array organizes elements sequentially in memory to facilitate random access by indices. A linked list connects elements in memory using \u0026ldquo;nodes\u0026rdquo; with references to the next node to facilitate insertion and deletion.\nBy choosing the appropriate data structure for the task to be solved, we can write more efficient programs and reduce computational complexity, using fewer resources like memory and processing.\nData structures help us:\nOrganize large amounts of data to make them easier to access and modify.\nModel complex relationships between data, such as with graphs and trees.\nAccess and modify data efficiently, optimizing performance.\nReuse existing code and data structures instead of having to rewrite solutions from scratch.\nFor example, a program that needs to store thousands of user records benefits from using a hash data structure to associate each user with data like first name, last name, email, etc. This way specific users can be found very quickly without having to iterate over the entire collection.\nAnother example are binary search trees, which allow finding elements very quickly in ordered sets of millions of elements. This is achieved by discarding halves of the tree as the desired element is searched.\nTypes of data structures # There are many types of data structures. Below are some useful categories to classify them.\nAccording to relationship between elements # Linear: Elements are organized sequentially one after the other. For example, arrays, lists, stacks, queues.\nNon-linear: Elements are organized in a hierarchy or graph. This is the case with trees and graphs.\nAccording to element type # Homogeneous: Store a single data type. For example, arrays in a language like Java.\nHeterogeneous: Allow different data types. Objects, records are examples of this classification.\nAccording to access mode # Sequential access: Elements can only be accessed in sequential order. For example, linked lists.\nDirect access: Any element can be accessed directly by its position. Arrays fall into this group.\nAssociative access: Elements are accessed by an associated key. Dictionaries, hashes fall into this category.\nAccording to functionality # Arrays: Fast access to elements by index but difficult to insert/delete.\nLists: Easy to insert/delete anywhere but sequential access is slow.\nStacks: LIFO (Last In First Out) access. Useful for undo/redo.\nQueues: FIFO (First In First Out) access. Useful for event processing.\nTrees: Allow modeling hierarchical relationships like file directories or task dependencies.\nGraphs: Allow modeling interconnectivity networks like maps, social relationships, etc.\nHashes / Dictionaries: Associate elements with unique keys for ultra fast access.\nThis classification is not exhaustive but gives an idea of the diversity of data structures and their different properties that allow us to efficiently model complex problems.\nExample # Let\u0026rsquo;s look at a Python example to see how a data structure is created and used. Suppose we want to represent a print queue where prints are processed in order of arrival (FIFO).\nFirst, we define a PrintQueue class to represent our queue:\nclass PrintQueue: def __init__(self): self.items = [] def enqueue(self, item): self.items.append(item) def dequeue(self): return self.items.pop(0) def is_empty(self): return len(self.items) == 0 Then we use it to add prints and process them in order:\nprint_queue = PrintQueue() print_queue.enqueue(\u0026#34;document1.doc\u0026#34;) print_queue.enqueue(\u0026#34;image3.jpg\u0026#34;) print_queue.enqueue(\u0026#34;presentation.ppt\u0026#34;) while not print_queue.is_empty(): next_item = print_queue.dequeue() print(f\u0026#34;Printing {next_item}\u0026#34;) This will print:\nPrinting document1.doc Printing image3.jpg Printing presentation.ppt With a data structure like the queue we implement FIFO logic in a simple, reusable way. And this is just one example, the possibilities are endless!\nConclusion # Data structures are fundamental programming tools that allow us to optimally organize information to solve complex problems. Knowing the different types of structures available, like arrays, lists, stacks, queues, hashes, graphs, and trees, allows us to build more efficient programs. I hope this introduction has given you some knowledge and tools to start mastering this exciting topic!\n","date":"04 August 2025","externalUrl":null,"permalink":"/en/programming/data-structures/introduction/","section":"Programming","summary":"","title":"Introduction","type":"programming"},{"content":"Object-Oriented Programming (OOP) is a programming paradigm that has become indispensable nowadays. This approach models real-world elements as \u0026ldquo;objects\u0026rdquo; that have properties and behaviours, which allows for more intuitive and maintainable programmes to be created. In this article we will look at the basic concepts of OOP and its advantages over other paradigms like procedural programming. Let\u0026rsquo;s get started!\nThis paradigm is based on two fundamental concepts:\nObjects: entities that combine state (data) and behaviour (operations) in a single unit. For example, a \u0026ldquo;car\u0026rdquo; object would have properties like colour, number of doors, maximum speed, etc. And behaviours like accelerate, brake, steer, etc. Classes: specifications that define the common structure and behaviour of a group of objects. The \u0026ldquo;car\u0026rdquo; class would serve as a template for creating car objects with the same characteristics. As explained by programmer Alan Kay, one of the creators of OOP:\n\u0026ldquo;The big idea is to design programmes in terms of conceptual objects and concepts from the real world. The interfaces with the real world should, therefore, be constructed in terms of these conceptual objects.\u0026rdquo;\nThat is, OOP conceptually models real-world elements to make programming more intuitive.\nProgramming paradigms # Before delving into OOP, it is worth understanding that there are different paradigms or approaches to tackle programming. The main ones are:\nProcedural programming # Ordered sequence of instructions that the programme must follow step-by-step. The focus is on procedures and functions. For example, C is a language geared towards procedural programming.\nProcedural programming is better for:\nSimple problems or sequential algorithms. Code that won\u0026rsquo;t need heavy reusing or expanding. Cases where performance and efficiency are critical. Object-Oriented programming # Model based on objects that contain data and code in cohesive units. The focus is on classes and the interaction between objects. For example, Java and Python are object-oriented languages.\nOOP allows modelling real-world elements more directly, better encapsulating data, and reusing code through inheritance between classes.\nThe main advantages of OOP over procedural programming are:\nModularity: objects group related data and operations, encapsulating internal complexity. This allows working with independent modules. Information hiding: Objects can expose a simple interface and hide internal implementation details. This reduces coupling. Reusability: Classes enable code reuse. An abstract class can inherit to multiple subclasses. Extensibility: We can extend the behaviour of parent classes by creating new subclasses. Conceptual mapping: Objects represent real-world entities, which eases the translation of requirements into code. However, OOP also has disadvantages. According to programmer Paul Graham:\n\u0026ldquo;Object-oriented programming often makes things harder than they need to be.\u0026rdquo;\nFor example, for simple problems OOP can be excessive. And in large projects there is a risk of overusing inheritance and polymorphism, making the code difficult to follow.\nUltimately, OOP is more suitable when:\nThe problem to be modelled has clear, structured entities. We want to reuse encapsulated code in modular classes. We work on systems that need to be easily extended and maintained. ","date":"04 August 2025","externalUrl":null,"permalink":"/en/programming/oop/introduction/","section":"Programming","summary":"","title":"Introduction","type":"programming"},{"content":"At its core, programming is the act of instructing a machine on how to perform a specific task. It\u0026rsquo;s like teaching your dog to fetch, but in this case, the dog is your computer, and the ball might be, let\u0026rsquo;s say, displaying a photo on your screen.\nNow, you might think that programming is just writing lines of code. Programming is actually a broader process that not only includes writing code but also problem-solving, system design, and logical thinking.\nIn the universe of programming, there are high-level and low-level languages. A low-level language, like assembly, is closer to what the machine understands, while a high-level language, such as Python or JavaScript, is more human-friendly. Picture having a conversation: high-level languages are like chatting with a friend over coffee in New York, while low-level languages are like trying to communicate with someone speaking a very specific, localized dialect.\nAdditionally, some programming languages are compiled, while others are interpreted. If a language is compiled, it means it\u0026rsquo;s translated into a machine-understandable language before being executed. On the other hand, interpreted languages are translated in real-time, as they run.\nA brief history of Programming # Programming isn\u0026rsquo;t a new concept. In fact, it\u0026rsquo;s been with us long before computers existed in the form we know today. Devices like the abacus and the astrolabe are early examples of tools we used for intricate calculations.\nHowever, it was with the advent of mechanical machines, like Charles Babbage\u0026rsquo;s Analytical Engine, that the foundation for modern programming was laid. We\u0026rsquo;re talking about the 19th century!\nOver time, landmark languages like Fortran and COBOL emerged. These languages paved the way for the technological revolutions that would follow. With the evolution of languages also came new paradigms: first Procedural, then Object-Oriented, and more recently, Functional.\nToday, we\u0026rsquo;re in a modern era dominated by web, mobile, and cloud programming. Every swipe on your phone or online purchase has lines and lines of code working behind the scenes.\nProgramming today # Programming is the engine of our modern society. From apps for ordering food to advanced artificial intelligence systems aiding medical research, programming is everywhere.\nBeyond simplifying our daily lives, programming has a profound societal impact. It has enabled progress in automation, data analysis, and entertainment. And what\u0026rsquo;s even more exhilarating is that we\u0026rsquo;re just scratching the surface. With upcoming prospects on artificial intelligence, quantum computing and the Internet of Things (IoT), who knows what marvels await us in the programming world?\n","date":"03 August 2025","externalUrl":null,"permalink":"/en/programming/intro/introduction/","section":"Programming","summary":"","title":"Introduction","type":"programming"},{"content":"","date":"03 August 2025","externalUrl":null,"permalink":"/en/programming/intro/","section":"Programming","summary":"","title":"Introduction to Programming","type":"programming"},{"content":" Variables # A variable is a container to store data in the computer\u0026rsquo;s memory. We can think of it as a box with a label. The label is the variable name and inside the box its value is stored.\nTo declare a variable in Python we just write the name and assign a value:\nage = 28 price = 19.95 student = True Variable names must start with letters or underscore, and can only contain letters, numbers and underscores. It is recommended to use meaningful names that represent the purpose of the variable.\nIn Python variables do not need to be declared with a particular type. The type is inferred automatically when assigning the value:\nage = 28 # age is integer type price = 19.95 # price is float type single = True # single is boolean type Once assigned, a variable can change its value at any time:\nage = 30 # We change age to 30 Scope and lifetime # The scope of a variable refers to the parts of the code where it is available. Variables declared outside functions are global and available throughout the file. Variables inside a function are local and only visible within it.\nThe lifetime is the period during which the variable exists in memory. Local variables exist while the function executes, then they are destroyed. Global variables exist while the program is running.\nAssignment # Assignment with the = operator allows changing or initializing a variable\u0026rsquo;s value:\nnumber = 10 number = 20 # Now number is 20 There are also compound assignment operators like += and -= that combine an operation with assignment:\nnumber += 5 # Adds 5 to number (number = number + 5) number -= 2 # Subtracts 2 from number Data types # Data types define what kind of value a variable can store. Python has several built-in types, including:\nNumerical: To store integer, float, and complex numeric values:\ninteger = 10 float = 10.5 complex = 3 + 4j Strings: To store text:\ntext = \u0026#34;Hello World\u0026#34; Boolean: For True or False logical values:\ntrue_variable = True false_variable = False Collections: To store multiple values like lists, tuples and dictionaries:\nLists: Mutable sequences of values:\nlist = [1, 2, 3] Tuples: Immutable sequences of values:\ntuple = (1, 2, 3) Dictionaries: Key-value pair structures:\ndictionary = {\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 20} It is important to choose the data type that best represents the information we want to store.\nOperators # Operators allow us to perform operations with values and variables in Python. Some common operators are:\nArithmetic: +, -, *, /, %, //, **\nComparison: ==, !=, \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;=\nLogical: and, or, not\nAssignment: =, +=, -=, *=, /=\nLet\u0026rsquo;s see concrete examples of expressions using these operators in Python:\n# Arithmetic 5 + 4 # Addition, result 9 10 - 3 # Subtraction, result 7 4 * 5 # Multiplication, result 20 # Comparison 5 \u0026gt; 4 # Greater than, result True 7 \u0026lt; 10 # Less than, result True # Logical True and False # Result False True or False # Result True not True # Result False # Assignment number = 10 number += 5 # Adds 5 to number, equivalent to number = number + 5 Each type of operator works with specific data types. We must use them consistently according to our variable data types.\nType conversions # Sometimes we need to convert one data type to another to perform certain operations. In Python we can convert explicitly or implicitly:\nExplicit: Using functions like int(), float(), str():\nfloat = 13.5 integer = int(float) # converts 13.5 to 13 text = \u0026#34;100\u0026#34; number = int(text) # converts \u0026#34;100\u0026#34; to 100 Implicit: Python automatically converts in some cases:\ninteger = 100 float = 3.5 result = integer + float # result is 103.5, integer converted to float Some conversions can generate data loss or errors:\nfloat = 13.5 integer = int(float) print(integer) # 13, decimals are lost To prevent this we must explicitly choose conversions that make sense for our data.\nConclusion # In this article we reviewed key concepts like variables, operators, data types and conversions in Python. Applying these concepts well will allow you to efficiently manipulate data in your programs. I recommend practising with your own examples to gain experience using these features. Good luck in your Python learning!\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"18 September 2023","externalUrl":null,"permalink":"/en/programming/starting-concepts/variables-data-types/","section":"Programming","summary":"","title":"Variables and Data Types","type":"programming"},{"content":" Latests news and tutorials about programming, software engineering, DevOps and much more! ","date":"02 September 2023","externalUrl":null,"permalink":"/en/blog/","section":"Blog","summary":"","title":"Blog","type":"blog"},{"content":" What is Software? # Several thought leaders in the world of computing have defined software in various ways:\nIan Sommerville1: Computer programs and associated documentation.\nRoger S. Pressman2: A collection of computer programs, procedures, rules, and associated documentation and data.\nAndrew S. Tanenbaum3: A series of instructions that tells a computer what to do.\nGrady Booch4: Set of items or objects that form a configuration that includes programs, documents, and data.\nPeter Denning5: Map of a machine, detailing its possible states, transitions, and the actions for these transitions.\nAnalysing these definitions, common themes emerge: software encompasses instructions, data, associated documentation, and serves as a guiding structure for computer operations. So we can conclude:\nSoftware is a meticulously structured collection of programs, data, and documentation that serves as a guiding blueprint, directing a computer\u0026rsquo;s operations and interactions with users and other systems.\nAlthough we can classify software in many different types, each with its specific function, we can define three primary categories:\nSystem Software: This forms the core of a computer\u0026rsquo;s operation. It includes operating systems like Windows, Linux, and macOS, which manage hardware resources and provide services for application software. Application Software: Tailored for end-users to perform specific tasks, this category ranges from word processors (like Microsoft Word) to graphic design tools (like Adobe Photoshop) and games. Embedded Software: Found within hardware devices such as washing machines, traffic lights, or digital watches, embedded software operates specific functions of these devices. Unlike general-purpose software, it\u0026rsquo;s dedicated to specific tasks or functions. What is Software Engineering? # Several prominent figures have also provided their perspectives on Software Engineering:\nIan Sommerville1: A discipline concerned with all aspects of software production.\nRoger S. Pressman2: Establishment and use of sound engineering principles to obtain economically software that is reliable and works efficiently on real machines.\nFrederick P. Brooks6: The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software.\nBarry W. Boehm7: Aims to produce quality software, software that is delivered on time, within budget, and that satisfies its requirements.\nFritz Bauer8: The establishment and use of sound engineering principles to economically obtain software that is reliable and works on real machines.\nFrom these definitions, we can discern that software engineering integrates principles of engineering, emphasizes systematic methods, seeks reliability and efficiency, and aims for the production of high-quality software that meets its specified requirements. Concluding that\nSoftware Engineering is the disciplined application of engineering principles and systematic methods to design, develop, and maintain reliable and efficient software that economically meets specified requirements and user needs.\nSoftware Engineering should not be confused with Computer Science. While the latter is a discipline that dives deep into the theoretical and mathematical aspects of computing, studying algorithms, computational theory, and more, the first one primarily focuses on designing and building large software systems. It emphasizes practical techniques and methodologies that ensure the production of high-quality, maintainable software.\nWhy it is important to develop quality software # Today, we\u0026rsquo;re surrounded by a digital ecosystem. Software runs our phones, cars, banks, hospitals, and even our homes. This ubiquity underscores its significance. That means that software flaws can have catastrophic outcomes. From banking systems to healthcare applications, the demand for faultless, efficient software is sky-high.\nSoftware Engineering, ensures this vast amount of software is reliable, efficient, and meets user needs. As technology advances at breakneck speed, the role of software engineers becomes even more pivotal, making sure innovations are safe and effective.\nWhether you\u0026rsquo;re using a social media app, making a bank transaction, or checking health diagnostics, remember there\u0026rsquo;s a meticulously engineered software system running behind the scenes, making it all possible.\nReferences # Sommerville, I., 2010. Software Engineering. 9th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPressman, R.S., 2010. Software Engineering: A Practitioner\u0026rsquo;s Approach. 7th ed. McGraw-Hill.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A.S., 2012. Structured Computer Organization. 6th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBooch, G., 2007. Object-Oriented Analysis and Design with Applications. 3rd ed. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDenning, P.J., 2009. The Profession of IT, Beyond Computational Thinking. Communications of the ACM, 52(6).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBrooks, F.P., 1995. The Mythical Man-Month: Essays on Software Engineering. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBoehm, B.W., 1988. A Spiral Model of Software Development and Enhancement. Computer, 21(5).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBauer, F.L., 1972. Software Engineering. Information Processing, 71.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"10 August 2023","externalUrl":null,"permalink":"/en/software-engineering/introduction/","section":"Software Engineering","summary":"","title":"Introduction to Software Engineering","type":"software-engineering"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/programming/","section":"Programming","summary":"","title":"Programming","type":"programming"},{"content":"An array is a data structure that represents a set of elements, which are accessed through contiguous numeric indices ranging from 0 to the size of the array minus 1. Arrays provide fast, direct access to elements based on their position.\nIn languages like Python and Ruby, arrays are known as \u0026rsquo;lists\u0026rsquo;. In Javascript they are known as \u0026lsquo;arrays\u0026rsquo;.\nArrays are typically homogeneous, storing elements of the same type like integers, strings, etc. Some languages allow heterogeneous arrays with values of different types.\nDiagram of an array Creating arrays # The way to create arrays varies according to the programming language:\nMY_ARRAY = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] # array literal my_array = list(range(5)) # array from range When creating a literal array its elements are initialized directly. When constructing an empty array its size is specified but its elements are initialized with a default value (0 for numbers, null for objects, etc).\nAccessing and modifying elements # Individual elements are quickly accessed by their index using brackets []:\nmy_array = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] print(my_array[0]) # \u0026#39;a\u0026#39; print(my_array[2]) # \u0026#39;c\u0026#39; my_array[2] = \u0026#39;z\u0026#39; print(my_array[2]) # \u0026#39;z\u0026#39; Indices start at 0, so in an array of size N, valid indices are between 0 and N-1.\nAccessing an invalid index causes an error, for example, accessing index 3 in an array of size 3. This is known as \u0026ldquo;index out of bounds\u0026rdquo;.\nTraversing an array # We can traverse all elements using a for loop:\nletters = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] for i in range(len(letters)): print(letters[i]) This prints each element in order. len() returns the total length of the array.\nAnother way is by directly iterating over the elements:\nletters = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] for letter in letters: print(letter) Searching in an array # We can search for an element in an array using a loop and comparing element by element:\nletters = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] def search_in_array(array, element): for i in range(len(array)): if array[i] == element: return i return False print(search_in_array(letters, \u0026#39;b\u0026#39;)) # 1 print(search_in_array(letters, \u0026#39;z\u0026#39;)) # False It returns the index if found or False if not found.\nMultidimensional array # Arrays can have more than one dimension, for example, 2D matrices, 3D cubes, etc.\nA 2D array can be seen as a table with rows and columns. To access an element two indices are specified, one for the row and one for the column:\nmatrix = [ [1, 2, 3], [4, 5, 6] ] print(matrix[0][2]) # 3 print(matrix[1][0]) # 4 They can have more dimensions, for example a 3D array to represent pixels in an image.\nConclusion # Arrays are fundamental data structures in programming that provide efficient access to elements in memory through numeric indices. Having a good command of arrays, matrices, and their uses is essential for any programmer.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"30 October 2023","externalUrl":null,"permalink":"/en/programming/data-structures/arrays/","section":"Programming","summary":"","title":"Arrays","type":"programming"},{"content":" Anatomy of a class # A class acts as a blueprint or mould to construct similar objects, defining their common characteristics and functionalities. It is similar to the blueprint used to construct houses in the same neighbourhood: they all share certain key attributes.\nThe typical components of a class are:\nAttributes (properties): Variables that characterise the object. For example, for a Person class, attributes like name, age, ID, etc.\nclass Person: id = \u0026#34;\u0026#34; name = \u0026#34;\u0026#34; age = 0 Methods: Functions that define behaviours. For example, a Person can walk(), talk(), eat(), etc. They access the attributes to implement said functionality.\nConstructor: Special __init__() method that executes when instantiating the class and allows initialising attributes.\nDestructor: __del__() method that executes when deleting the instance, freeing up resources. Optional in some languages.\nCreating objects # From the class we generate objects, which are specific instances with their own defined attributes. Let\u0026rsquo;s say the House class is the blueprint, and a specific house on a particular street is the object.\nIn code, we create an object by invoking the class as if it were a method:\n# Person class class Person: def __init__(self, n, a): self.name = n self.age = a # Specific Person objects john = Person(\u0026#34;John\u0026#34;, 30) mary = Person(\u0026#34;Mary\u0026#34;, 35) Each object shares the general structure and behaviour but can store different data.\nUsing properties and methods # We now have a Person class and a john object of type Person. How do we interact with the object?\nProperties: It is possible to access the value of an object attribute using the object reference (john) and the attribute name. john.name # \u0026#34;John\u0026#34; john.age # 30 Methods: Are invoked in the same way as accessing attributes but adding parentheses, and inside them, the arguments that are passed if it takes any. # Person class class Person: def __init__(self, n, a): self.name = n self.age = a def eat(self, food): print(f\u0026#34;Eating {food}\u0026#34;) # Specific Person object john = Person(\u0026#34;John\u0026#34;, 30) john.eat(\u0026#34;pizza\u0026#34;) # Prints \u0026#34;Eating pizza\u0026#34; The john object now has its own state (properties) and behaviour (methods).\nSelf vs This # An important detail in methods is how they access the object\u0026rsquo;s attributes and other methods. Here another difference between languages comes into play:\nSelf: In Python, attributes and methods are accessed within the class by prepending self. This points to the instantiated object. class Person: def __init__(self, name): self.name = name def greet(self): print(f\u0026#34;Hello! I\u0026#39;m {self.name}\u0026#34;) john = Person(\u0026#34;John\u0026#34;) john.greet() # Prints \u0026#34;Hello! I\u0026#39;m John\u0026#34; This: In Java or C#, this is used instead of self. It fulfils the same functionality of pointing to the object\u0026rsquo;s members. public class Person { private String name; public Person(String name) { this.name = name; } public void greet() { System.out.println(\u0026#34;Hello! I\u0026#39;m \u0026#34; + this.name); } } Person john = new Person(\u0026#34;John\u0026#34;); john.greet(); // Prints \u0026#34;Hello! I\u0026#39;m John\u0026#34; Conclusion # Classes and objects are the key concepts in OOP, allowing modelling real-world entities and generating modular, generic components of our system to construct more robust and easy to understand programmes.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"02 October 2023","externalUrl":null,"permalink":"/en/programming/oop/classes-objects/","section":"Programming","summary":"","title":"Classes and objects","type":"programming"},{"content":"","date":"30 September 2023","externalUrl":null,"permalink":"/en/programming/starting-concepts/","section":"Programming","summary":"","title":"Starting Concepts","type":"programming"},{"content":" Screen output # Python also provides functions to send program output to \u0026ldquo;standard output\u0026rdquo;, usually the screen or terminal.\nThe print() function displays the value passed as a parameter:\nname = \u0026#34;Eric\u0026#34; print(name) # displays \u0026#34;Eric\u0026#34; We can print multiple values separated by commas:\nprint(\u0026#34;Hello\u0026#34;, name, \u0026#34;!\u0026#34;) # displays \u0026#34;Hello Eric!\u0026#34; We can also use literal values without assigning to variables:\nprint(\u0026#34;2 + 3 =\u0026#34;, 2 + 3) # displays \u0026#34;2 + 3 = 5\u0026#34; Output formatting # Python provides various ways to format output:\nf-Strings: Allow inserting variables into a string:\nname = \u0026#34;Eric\u0026#34; print(f\u0026#34;Hello {name}\u0026#34;) # displays \u0026#34;Hello Eric\u0026#34; %s: Inserts string text into a format string:\nname = \u0026#34;Eric\u0026#34; print(\u0026#34;Hello %s\u0026#34; % name) # displays \u0026#34;Hello Eric\u0026#34; %d: Inserts integer numbers:\nvalue = 15 print(\u0026#34;The value is %d\u0026#34; % value) # displays \u0026#34;The value is 15\u0026#34; .format(): Inserts values into a format string:\nname = \u0026#34;Eric\u0026#34; print(\u0026#34;Hello {}. Welcome\u0026#34;.format(name)) # displays \u0026#34;Hello Eric. Welcome\u0026#34; These formatting options allow us to interpolate variables and values into text strings to generate custom outputs. We can combine multiple values and formats in a single output string.\nKeyboard input # Python provides built-in functions to read data entered by the user at runtime. This is known as \u0026ldquo;standard input\u0026rdquo;.\nThe input() function allows reading a value entered by the user and assigning it to a variable. For example:\nname = input(\u0026#34;Enter your name: \u0026#34;) This displays the message \u0026ldquo;Enter your name: \u0026quot; and waits for the user to enter text and press Enter. That value is assigned to the name variable.\nThe input() function always returns a string. If we want to ask for a number or other data type, we must convert it using int(), float(), etc:\nage = int(input(\u0026#34;Enter your age: \u0026#34;)) pi = float(input(\u0026#34;Enter the value of pi: \u0026#34;)) Reading multiple values # We can ask for and read multiple values on the same line separating them with commas:\nname, age = input(\u0026#34;Enter name and age: \u0026#34;).split() The split() method divides the input into parts and returns a list of strings. We then assign the list elements to separate variables.\nWe can also read multiple lines of input with a loop:\nnames = [] # empty list for x in range(3): name = input(\u0026#34;Enter a name: \u0026#34;) names.append(name) This code reads 3 names entered by the user and adds them to a list.\nOutput to a file # In addition to printing to the screen, we can write output to a file using the open() function:\nfile = open(\u0026#34;data.txt\u0026#34;, \u0026#34;w\u0026#34;) This opens data.txt for writing (\u0026ldquo;w\u0026rdquo;) and returns a file object.\nThen we use file.write() to write to that file:\nfile.write(\u0026#34;Hello World!\u0026#34;) file.write(\u0026#34;This text goes to the file\u0026#34;) We must close the file with file.close() when finished:\nfile.close() We can also use with to open and automatically close:\nwith open(\u0026#34;data.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: file.write(\u0026#34;Hello World!\u0026#34;) # no need to close, it\u0026#39;s automatic Reading files # To read a file we use open() in \u0026ldquo;r\u0026rdquo; mode and iterate over the file object:\nwith open(\u0026#34;data.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: for line in file: print(line) # prints each line of the file This prints each line, including newlines.\nWe can read all lines to a list with readlines():\nlines = file.readlines() print(lines) To read the full content to a string we use read():\ntext = file.read() print(text) We can also read a specific number of bytes or characters with read(n).\nFile handling operations # There are several built-in functions to handle files in Python:\nopen() - Opens a file and returns a file object close() - Closes the file write() - Writes data to the file read() - Reads data from the file readline() - Reads a line from the file truncate() - Empties the file seek() - Changes the reading/writing position rename() - Renames the file remove() - Deletes the file These allow us to perform advanced operations to read, write and maintain files.\nConclusion # In this article we explained Python input and output operations in detail, including reading from standard input and writing to standard output or files. Properly handling input and output is essential for many Python applications. I recommend practising with your own examples to master these functions.\nReferences # Downey, A. B. (2015). Think Python: How to think like a computer scientist. Needham, Massachusetts: Green Tea Press. McKinney, W. (2018). Python for data analysis: Data wrangling with Pandas, NumPy, and IPython. O\u0026rsquo;Reilly Media. Matthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. No Starch Press. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"19 September 2023","externalUrl":null,"permalink":"/en/programming/starting-concepts/io-operations/","section":"Programming","summary":"","title":"Input and output operations","type":"programming"},{"content":"To the uninitiated, a computer might seem like a mere box—perhaps sometimes sleek and shiny—but a box nonetheless. Yet, within this \u0026ldquo;box\u0026rdquo; lies a universe of complexity and coordination.\nHardware represents the physical components of a computer: the Central Processing Unit (CPU) which is often likened to the brain of the system, the Random Access Memory (RAM) acting as a temporary storage while tasks are underway, storage devices that retain data, and peripherals like keyboards, mice, and monitors.\nOn the other side of this duality is software, a set of instructions that guides the hardware. There are various types of software, from system software like the operating system (OS), which coordinates the myriad hardware components, to application software that allows users to perform specific tasks, such as word processing or gaming.\nThe role of the operating system is pivotal. It acts as a bridge, translating user commands into instructions that the hardware can execute. If the hardware were an orchestra, the OS would be its conductor, ensuring each instrument plays its part harmoniously.\nThe binary system: decoding the language of machines # Human civilizations have developed numerous numbering systems over the millennia, but computers, with their logical circuits, have settled on the binary system. But why binary? Simply put, at the most foundational level, a computer\u0026rsquo;s operation is based on switches (transistors) that can be either \u0026lsquo;on\u0026rsquo; or \u0026lsquo;off\u0026rsquo;, corresponding naturally to the binary digits, or \u0026lsquo;bits\u0026rsquo;, 1 and 0 respectively.\nIn this binary realm, a bit is the smallest data unit, representing a single binary value. A byte, comprising 8 bits, can represent 256 distinct values, ranging from \\(00000000\\) to \\(11111111\\). This binary encoding isn\u0026rsquo;t restricted to numbers; it extends to text, images, and virtually all forms of data. For instance, in ASCII encoding, the capital letter \u0026lsquo;A\u0026rsquo; is represented as \\(01000001\\).\nIn a following post we\u0026rsquo;ll describe in more details the binary system and introduce another system used a lot in relations to computers, the hexadecimal.\nMemory and Storage: the sanctuaries of data # The concepts of memory and storage are pivotal in understanding computer architecture. Though sometimes used interchangeably in colloquial parlance, their roles in a computer system are distinct.\nMemory, particularly RAM, is volatile, meaning information stored is lost once the computer is turned off. RAM serves as the computer\u0026rsquo;s \u0026ldquo;workspace\u0026rdquo;, temporarily storing data and instructions during operations. There are various RAM types, with DRAM and SRAM being the most prevalent.\nContrastingly, Read-Only Memory (ROM) is non-volatile, used predominantly to store firmware—software intrinsically linked to specific hardware, requiring infrequent alterations.\nIn terms of data storage, devices like hard drives, SSDs, and flash drives offer permanent data retention. These storage mechanisms are part of the memory hierarchy, which ranges from the swift but limited cache memory to the expansive but slower secondary storage.\nReferences # Patterson, D. \u0026amp; Hennessy, J. (2014). Computer Organization and Design. Elsevier. Silberschatz, A., Galvin, P. B., \u0026amp; Gagne, G. (2009). Operating System Concepts. John Wiley \u0026amp; Sons. Tanenbaum, A. (2012). Structured Computer Organization. Prentice Hall. Brookshear, J. G. (2011). Computer Science: An Overview. Addison-Wesley. Jacob, B., Ng, S. W., \u0026amp; Wang, D. T. (2007). Memory Systems: Cache, DRAM, Disk. Morgan Kaufmann. Siewiorek, D. P. \u0026amp; Swarz, R. S. (2017). Reliable Computer Systems: Design and Evaluation. A K Peters/CRC Press. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"02 September 2023","externalUrl":null,"permalink":"/en/programming/intro/computers/","section":"Programming","summary":"","title":"The Computer","type":"programming"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/programming/oop/","section":"Programming","summary":"","title":"Object-Oriented Programming","type":"programming"},{"content":"In Object-Oriented Programming, classes don\u0026rsquo;t exist in isolation. They interact and relate to each other in various ways to model complex systems and relationships. Understanding these relationships is crucial for designing effective and maintainable object-oriented systems.\nThe main types of class relationships we\u0026rsquo;ll explore in depth are:\nAssociation (\u0026ldquo;uses-a\u0026rdquo;) Aggregation (weak \u0026ldquo;has-a\u0026rdquo; relationship) Composition (strong \u0026ldquo;has-a\u0026rdquo; relationship) Inheritance (\u0026ldquo;is-a\u0026rdquo; relationship) Realisation (Implementation) Dependency Each of these relationships represents a different way that classes can be connected and interact with each other. They vary in terms of the strength of the coupling between classes, the lifecycle dependencies, and the nature of the relationship.\nBefore we dive into each type of relationship, let\u0026rsquo;s visualise them using a UML class diagram:\nclassDiagram class ClassA class ClassB class ClassC class ClassD class ClassE class ClassF class InterfaceG ClassA --\u003e ClassB : Association ClassC o-- ClassD : Aggregation ClassE *-- ClassF : Composition ClassB --|\u003e ClassA : Inheritance ClassE ..|\u003e InterfaceG : Realisation ClassA ..\u003e ClassF : Dependency end This diagram provides a high-level overview of the different types of class relationships. In the following sections, we\u0026rsquo;ll explore each of these relationships in detail, providing explanations, examples, and more specific UML diagrams.\n","date":"07 December 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-introduction/","section":"Programming","summary":"","title":"Class relations","type":"programming"},{"content":"A dictionary, or map, consists of a collection of key-value pairs. The key is used to access the associated value. Keys must be unique within a dictionary. Values can be repeated.\nDiagram of a map Main operations # Add/update: Inserts a key-value pair. If the key existed, its value is replaced. dictionary[\u0026#39;key\u0026#39;] = \u0026#39;value\u0026#39; Get value: Accesses the value given a key. value = dictionary[\u0026#39;key\u0026#39;] Delete: Removes a key-value pair from the dictionary. del dictionary[\u0026#39;key\u0026#39;] Traverse: Iterate over the keys, values or pairs of the dictionary. for key in dictionary: print(key, dictionary[key]) # key, value Creating a dictionary or map # The syntax for creating maps or dictionaries in Python is:\nempty_dictionary = {} person = { \u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;, \u0026#39;age\u0026#39;: 25 } Usage examples # Dictionaries are useful in many cases. Below are some examples.\nObjects and mappings # We can model objects and entities with key-value attributes:\nproduct = { \u0026#39;name\u0026#39;: \u0026#39;Smartphone\u0026#39;, \u0026#39;price\u0026#39;: 500, \u0026#39;brand\u0026#39;: \u0026#39;XYZ\u0026#39; } Counts and frequencies # Counting occurrences of elements in sequences:\ntext = \u0026#34;Hello world world\u0026#34; frequencies = {} for word in text.split(): if word in frequencies: frequencies[word] += 1 else: frequencies[word] = 1 print(frequencies) # {\u0026#39;Hello\u0026#39;: 1, \u0026#39;world\u0026#39;: 2} Storing and accessing data # As a high performance alternative to lists and arrays.\nConclusion # Dictionaries are versatile data structures thanks to their fast access based on unique keys. They have uses in almost all programs, so mastering dictionaries is essential in any language.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"30 October 2023","externalUrl":null,"permalink":"/en/programming/data-structures/maps/","section":"Programming","summary":"","title":"Maps (Dictionaries)","type":"programming"},{"content":" Conditions: making decisions in code # Life is full of decisions: \u0026ldquo;If it rains, I\u0026rsquo;ll take an umbrella. Otherwise, I\u0026rsquo;ll wear sunglasses.\u0026rdquo; These decisions are also present in the world of programming. Conditions are like questions the computer asks itself. They allow us to make decisions and execute specific code based on a condition. They can be as simple as \u0026ldquo;Is it raining?\u0026rdquo; or as complex as \u0026ldquo;Is it the weekend and do I have less than $100 in my bank account?\u0026rdquo;.\nif # The if structure allows us to evaluate conditions and make decisions based on the result of that evaluation.\nage = 15 if age \u0026gt;= 18: print(\u0026#34;You are an adult\u0026#34;) The code above allows executing a portion of code if a person\u0026rsquo;s age is greater than or equal to 18 years.\nif-else # When you want to execute alternative code if the condition is false, you use the if-else structure.\nage = 21 if age \u0026gt;= 18: print(\u0026#34;You are an adult\u0026#34;) else: print(\u0026#34;You are a minor\u0026#34;) In this case, it determines if the person is an adult or a minor, and the message displayed is different.\nif-elif-else # When conditions are multiple and two paths are not enough, the if-elif-else structure is used to evaluate them in a chained way.\nage = 5 if age \u0026lt;= 13: print(\u0026#34;You are a child\u0026#34;) elif age \u0026gt; 13 and age \u0026lt; 18: print(\u0026#34;You are a teenager\u0026#34;) else: print(\u0026#34;You are an adult\u0026#34;) In the code above, there are three clear paths: one for when age is less than or equal to 13, one for when age is between 13 and 18, and another for when age is greater than or equal to 18.\nAnother way to solve this problem is through the switch-case structure, which, although Python does not natively incorporate, other languages like Java or C++ do, and it is an important tool to be familiar with. This structure allows programmers to handle multiple conditions in a more organized way than a series of if-elif-else.\nIn Java, for example:\nint day = 3; switch(day) { case 1: System.out.println(\u0026#34;Monday\u0026#34;); break; case 2: System.out.println(\u0026#34;Tuesday\u0026#34;); break; case 3: System.out.println(\u0026#34;Wednesday\u0026#34;); break; // ... and so on default: System.out.println(\u0026#34;Invalid day\u0026#34;); } In the previous example, depending on the value of day, the corresponding day will be printed.\nLoops: repeating actions # Sometimes in programming we need to repeat an action several times. Instead of writing the same code many times, we can use loops. These allow repeating the execution of a block of code while a condition is met.\nwhile # The while loop is useful when we want to repeat an action based on a condition.\n# Prints 1 to 5 i = 1 while i \u0026lt;= 5: print(i) i = i + 1 do-while # Similar to while but guarantees at least one execution since the code block is executed first and then the condition is evaluated. Python does not implement this structure, but other languages like Java and C++ do.\nint i = 1; do { System.out.println(i); i++; } while(i \u0026lt;= 5); int number = 0; do { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, world!\u0026#34; \u0026lt;\u0026lt; std::endl; number++; } while (number \u0026lt; 5); for # The for loop is useful when we know how many times we want to repeat an action.\nfor i in range(5): print(\u0026#34;Hello, world!\u0026#34;) The code above will print \u0026ldquo;Hello, world!\u0026rdquo; five times.\nWe can also iterate over the elements of a list or iterable object:\nnames = [\u0026#34;Maria\u0026#34;, \u0026#34;Florencia\u0026#34;, \u0026#34;Julian\u0026#34;] for name in names: print(f\u0026#34;Hello {name}\u0026#34;) # Prints # Hello Maria # Hello Florencia # Hello Julian The break and continue statements # We can use break to terminate the loop and continue to skip to the next iteration.\nbreak is used to completely terminate the loop when a condition is met, in the following example, when i reaches 5.\n# break example i = 0 while i \u0026lt; 10: print(i) if i == 5: break i += 1 # Prints: # 0 # 1 # 2 # 3 # 4 # 5 continue is used to skip an iteration of the loop and continue with the next one when a condition is met. Here we use it to skip even numbers.\n# continue example i = 0 while i \u0026lt; 10: i += 1 if i % 2 == 0: continue print(i) # Prints: # 1 # 3 # 5 # 7 # 9 Nesting: combining structures # Control flow structures can be nested within each other. For example, we can have loops within loops or conditions within loops.\nfor i in range(5): for j in range(10): if (i % 2 == 0 and j % 3 == 0): print(f\u0026#34;i = {i}, j = {j}\u0026#34;) This code will print combinations of i and j only when i is divisible by 2 and j is divisible by 3, demonstrating how loops are nested and executed.\nCommon usage patterns # There are specific patterns to solve common needs with control flow.\nSearch # Search for a value in a collection:\nfruits = [\u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;] searching = \u0026#34;orange\u0026#34; found = False for fruit in fruits: if fruit == searching: found = True break if found: print(\u0026#34;Fruit found!\u0026#34;) Accumulation # Accumulate incremental values in a loop:\ntotal = 0 for i in range(10): total += i print(total) # Sum from 0..9 = 45 Flowcharts: the visual route to understanding code # Programmers, whether beginners or experts, often find themselves facing challenges that require detailed planning before diving into code. This is where flowcharts come into play as an essential tool. These charts are graphical representations of the processes and logic behind a program or system. In this article, we will unravel the world of flowcharts, from basic concepts to advanced techniques, and how they can benefit programmers of all levels.\nA flowchart is a graphical representation of a process. It uses specific symbols to represent different types of instructions or actions. Its main purpose is to simplify understanding of a process by showing step by step how information or decisions flow. These charts:\nFacilitate understanding of complex processes. Aid in the design and planning phase of a program. Serve as documentation and reference for future developments. Flowcharts are a powerful tool that not only benefits beginners but also experienced programmers. They provide a clear and structured view of a process or program, facilitating planning, design, and communication between team members.\nBasic elements # Flowcharts consist of several symbols, each with a specific meaning:\nOval: Represents the start or end of a process. Rectangle: Denotes an operation or instruction. Diamond: Indicates a decision based on a condition. Arrows: Show the direction of flow. graph TD; start((Start)) process[Process] decision{Decision?} final((End)) start --\u003e process; process --\u003e decision; decision --\u003e |Yes| process decision --\u003e |No| final end Examples # Let\u0026rsquo;s design a flowchart for a program that asks for a number and tells us if it\u0026rsquo;s even or odd.\ngraph TB start((Start)) input[Input number] decision{Even?} isEven[Is even] isOdd[Is odd] final((End)) start --\u003e input input --\u003e decision decision --\u003e |Yes| isEven decision --\u003e |No| isOdd isEven --\u003e final isOdd --\u003e final end As programs become more complex, you may need to incorporate loops, multiple conditions, and other advanced elements into your flowchart. For example, here we diagram a program that sums numbers from 1 to a number entered by the user.\ngraph TD start((Start)) input[Input number] setVariables[Set sum=0 and counter=1] loop_condition{counter \u003c= N?} loop_code[Add value and increment counter] result[Show sum] final((End)) start --\u003e input input --\u003e setVariables setVariables --\u003e loop_condition loop_condition --\u003e |Yes| loop_code loop_code --\u003e loop_condition loop_condition --\u003e |No| result result --\u003e final end Conclusion # Control flow is the heart of programming. Without it, programs would be linear sequences of actions without the ability to make decisions or repeat tasks. By mastering these structures not only do you improve your ability to write code, but also your ability to think logically and solve complex problems.\nReferences # Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated. Deitel, P., \u0026amp; Deitel, H. (2012). Java: How to program. Upper Saddle River, NJ: Prentice Hall. Matthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. San Francisco, CA: No Starch Press. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"27 September 2023","externalUrl":null,"permalink":"/en/programming/starting-concepts/flow-control-structures/","section":"Programming","summary":"","title":"Flow Control","type":"programming"},{"content":" The decimal system: the bedrock of our daily life # From a tender age, we\u0026rsquo;re taught to count using ten digits: 0 through 9. This system, known as the decimal system, underpins almost all our mathematical and financial activities, from basic arithmetic to calculating bank interests. Its roots trace back to our anatomy: the ten fingers on our hands, making it the most intuitive and natural system for us. Yet, its true charm emanates from its positional nature.\nTo grasp this concept, let\u0026rsquo;s dissect the number 237:\nThe rightmost digit (7) stands for the units\u0026rsquo; position. That is, \\(7 \\times 10^0\\) (any number raised to the power of 0 is 1). Therefore, its value is simply 7. The middle digit (3) represents the tens\u0026rsquo; position, translating to \\(3 \\times 10^1 = 3 \\times 10 = 30\\). The leftmost digit (2) is in the hundreds\u0026rsquo; position, decoding to \\(2 \\times 10^2 = 2 \\times 100 = 200\\). When these values are combined,\n2 \\times 10^2 + 3 \\times 10^1 + 7 \\times 10^0 = 200 + 30 + 7 = 237 The binary system: computers\u0026rsquo; coded language # While the decimal system reigns supreme in our everyday lives, the machines we use daily, from our smartphones to computers, operate in a starkly different realm: the binary world. In this system, only two digits exist: 0 and 1. It might seem restrictive at first glance, but this system is the essence of digital electronics. Digital devices, with their billions of transistors, operate using these two states: on (1) and off (0).\nDespite its apparent simplicity, the binary system can express any number or information that the decimal system can. For instance, the decimal number 5 is represented as 101 in binary.\nBinary, with its ones and zeros, operates in a manner akin to the decimal system, but instead of powers of 10, it uses powers of 2.\nConsider the binary number 1011:\nThe rightmost bit denotes \\(1 \\times 2^0 = 1\\). The subsequent bit stands for \\(1 \\times 2^1 = 2\\). Next up is \\(0 \\times 2^2 = 0\\). The leftmost bit in this number signifies \\(1 \\times 2^3 = 8\\). Thus, 1011 in binary translates to the following in the decimal system:\n1011 = 1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 = 8 + 0 + 2 + 1 = 11 Hexadecimal system: bridging humans and machines # While the binary system is perfect for machines, it can get a tad cumbersome for us, especially when dealing with lengthy binary numbers. Here is where the hexadecimal system, employing sixteen distinct digits: 0-9 and A-F, with A representing 10, B as 11, and so forth, up to F, which stands for 15 comes to help.\nHexadecimal proves invaluable as it offers a more compact way to represent binary numbers. Each hexadecimal digit corresponds precisely to four binary bits. For instance, think of the binary representation of the number 41279 and notice how the hexadecimal system achieves a more succinct representation:\n41279 = 1010 0001 0011 1111 = A13F But the hexadecimal system is more than just a compressed representation of binary numbers; it\u0026rsquo;s a positional numbering system like decimal or binary but based on 16 instead of 10 or 2. Let\u0026rsquo;s see how to derive the decimal representation of the example number (A13F):\nThe rightmost digit represents \\(F \\times 16^0 = 15 \\times 16^0 = 15\\). The subsequent one stands for \\(3 \\times 16^1 = 48\\). The next digit denotes \\(1 \\times 16^2 = 256\\). The leftmost digit in this number signifies \\(A \\times 16^3 = 10 \\times 16^3 = 40960\\). Therefore, A13F in hexadecimal translates to the following in the decimal system:\nA13F = A \\times 16^3 + 1 \\times 16^2 + 3 \\times 16^1 + F \\times 16^0 = 10 \\times 4096 + 1 \\times 256 + 3 \\times 16 + 15 \\times 1 = 40960 + 256 + 48 + 15 = 41279 Conclusion # Numbering systems are like lenses through which we perceive and understand the world of mathematics and computing. Although the decimal system may be the linchpin of our daily existence, it\u0026rsquo;s crucial to appreciate and comprehend the binary and hexadecimal systems, especially in this digital age.\nSo, the next time you\u0026rsquo;re in front of your computer or using an app on your smartphone, remember that behind that user-friendly interface, a binary world is in full swing, with the hexadecimal system acting as a translator between that realm and us.\nReferences # Ifrah, G. (2000). The Universal History of Numbers. London: Harvill Press. Tanenbaum, A. (2012). Structured Computer Organization. New Jersey: Prentice Hall. Knuth, D. (2007). The Art of Computer Programming: Seminumerical Algorithms. California: Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"05 September 2023","externalUrl":null,"permalink":"/en/programming/intro/numerical-systems/","section":"Programming","summary":"","title":"Numerical Systems","type":"programming"},{"content":"","date":"18 August 2023","externalUrl":null,"permalink":"/en/software-engineering/","section":"Software Engineering","summary":"","title":"Software Engineering","type":"software-engineering"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/programming/data-structures/","section":"Programming","summary":"","title":"Data Structures","type":"programming"},{"content":" Master AI engineering through hands-on projects that build real-world skills, with each concept introduced exactly when you need it. This project-first approach helps you create an impressive portfolio while developing the deep expertise needed to succeed as a professional AI engineer. The first module of this course is coming soon! Stay online for new updates! ","date":"11 March 2025","externalUrl":null,"permalink":"/en/artificial-intelligence/","section":"Artificial Intelligence","summary":"","title":"Artificial Intelligence","type":"artificial-intelligence"},{"content":"Key characteristics of association:\nIt represents a loose coupling between classes. The associated classes can exist independently of each other. The lifetime of one class is not tied to the lifetime of the other. It can be unidirectional or bidirectional. There are two main types of association:\nUnidirectional Association Bidirectional Association Let\u0026rsquo;s explore each of these in more detail.\nUnidirectional association # In a unidirectional association, one class knows about and can interact with another class, but not vice versa. This is a one-way relationship.\nHere\u0026rsquo;s an example in Python:\nclass Customer: def __init__(self, name): self.name = name class Order: def __init__(self, order_number, customer): self.order_number = order_number self.customer = customer # This creates an association def display_info(self): return f\u0026#34;Order {self.order_number} placed by {self.customer.name}\u0026#34; # Creating instances customer = Customer(\u0026#34;John Doe\u0026#34;) order = Order(\u0026#34;12345\u0026#34;, customer) print(order.display_info()) # Output: Order 12345 placed by John Doe In this example, the Order class has a unidirectional association with the Customer class. An Order knows about its associated Customer, but a Customer doesn\u0026rsquo;t know about its Orders.\nHere\u0026rsquo;s a UML diagram representing this relationship:\nclassDiagram class Customer { +name: string } class Order { +order_number: string +customer: Customer +display_info() } Order --\u003e Customer : places end The arrow in the diagram points from Order to Customer, indicating that Order knows about Customer, but not the other way around.\nBidirectional association # In a bidirectional association, both classes are aware of each other and can interact with each other. This is a two-way relationship.\nHere\u0026rsquo;s an example in Python:\nclass Student: def __init__(self, name): self.name = name self.courses = [] def enrol(self, course): self.courses.append(course) course.add_student(self) def display_courses(self): return f\u0026#34;{self.name} is enrolled in: {\u0026#39;, \u0026#39;.join(course.name for course in self.courses)}\u0026#34; class Course: def __init__(self, name): self.name = name self.students = [] def add_student(self, student): self.students.append(student) def display_students(self): return f\u0026#34;{self.name} has students: {\u0026#39;, \u0026#39;.join(student.name for student in self.students)}\u0026#34; # Creating instances student1 = Student(\u0026#34;Alice\u0026#34;) student2 = Student(\u0026#34;Bob\u0026#34;) math_course = Course(\u0026#34;Mathematics\u0026#34;) physics_course = Course(\u0026#34;Physics\u0026#34;) # enrolling students in courses student1.enrol(math_course) student1.enrol(physics_course) student2.enrol(math_course) print(student1.display_courses()) print(math_course.display_students()) In this example, there\u0026rsquo;s a bidirectional association between Student and Course. A Student knows about their Courses, and a Course knows about its Students.\nHere\u0026rsquo;s a UML diagram representing this relationship:\nclassDiagram class Student { +name: string +courses: list +enrol(course) +display_courses() } class Course { +name: string +students: list +add_student(student) +display_students() } Student \"0..*\" \u003c--\u003e \"0..*\" Course : enrols in \u003e end The double-headed arrow in the diagram indicates that both Student and Course are aware of each other. The \u0026ldquo;0..*\u0026rdquo; notation indicates that a Student can be enrolled in zero or more Courses, and a Course can have zero or more Students.\nAssociation is a flexible relationship that can represent many real-world connections between objects. It\u0026rsquo;s important to choose between unidirectional and bidirectional associations carefully, as bidirectional associations can introduce more complexity and potential for errors if not managed properly.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-association/","section":"Programming","summary":"","title":"Class relations: Association","type":"programming"},{"content":"A linked list is composed of nodes where each node has two parts:\nData or information Reference to the next node Nodes are organized sequentially, each pointing to the next. The last node points to null to indicate the end.\nThis dynamic structure allows efficient insertion and deletion of nodes.\nTypes of linked lists # There are several types:\nSingly linked: Each node points to the next one. Useful for queues and stacks. Diagram of a single linked list Doubly linked: Each node has reference to the next and previous ones. Allows traversing in both directions. Diagram of a doubly linked list Circular: The last node points to the first forming a cycle. Useful for circular buffers. Diagram of a circular linked list Common operations # Insert: Add nodes to the beginning, end or middle of the list.\nDelete: Remove nodes by value or position.\nSearch: Find nodes by value by traversing the list.\nTraverse: Iterate through nodes by following the references.\nImplementation # Linked lists can be implemented as follows:\nUse the ListNode class to represent nodes:\nclass ListNode: def __init__(self, value): self.value = value self.next = None Then to create and use a list define a LinkedList class with methods for the operations:\nclass LinkedList: def __init__(self): self.head = None def add_to_start(self, new_value): new_node = ListNode(new_value) new_node.next = self.head self.head = new_node def print(self): current = self.head while current != None: print(current.value) current = current.next def search(self, searched_value): current = self.head while current != None: if current.value == searched_value: return True current = current.next return False #...other methods With this LinkedList class we can create a list, add nodes, print it, search elements, etc.\nWe could add other methods like insert at end, delete by value, get by index, etc. But this gives an idea of how to encapsulate the linked list functionality in a class. As practice, feel free to try adding these methods on your own. Don\u0026rsquo;t hesitate to leave your comments and contact me if you need help!\nAdvantages and disadvantages # Advantages:\nInserting and deleting nodes is efficient. Doesn\u0026rsquo;t require defining a fixed size like arrays. Dynamic, flexible structure. Disadvantages:\nMore memory usage from having to store references. Accessing elements by index is slower since it is sequential. Usage examples # Implementing structures like stacks and queues. In doubly linked lists, traverse the list in both directions. Blockchains like Bitcoin\u0026rsquo;s. Playing elements in order like music playlists. Conclusion # Linked lists are a versatile data structure for storing dynamic sequences of elements. Having a good handle on these lists, their operations, and uses is essential for any programmer.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"01 November 2023","externalUrl":null,"permalink":"/en/programming/data-structures/linked-lists/","section":"Programming","summary":"","title":"Linked Lists","type":"programming"},{"content":" What are functions? # A function, in simple terms, is a block of code that executes only when called. You can think of it as a small program within your main program, designed to perform a specific task. A function can also be seen as a black box: we pass an input (parameters), some internal processing occurs, and it produces an output (return value).\nFunctions allow us to segment our code into logical parts where each part performs a single action. This provides several benefits:\nReusability: Once defined, we can execute (call) that code from anywhere in our program as many times as needed. Organization: It allows dividing a large program into smaller, more manageable parts. Encapsulation: Functions reduce complexity by hiding internal implementation details. Maintainability: If we need to make changes, we only have to modify the code in one place (the function) instead of tracking down all instances of that code. Procedures vs. Functions\nIt is vital to distinguish between these two concepts. While a function always returns a value, a procedure performs a task but does not return anything. In some languages, this difference is clearer than in others. Python, for example, has functions that can optionally return values.\nAnatomy of a function # In Python, a function is declared using the def keyword, followed by the function name and parentheses. The code inside the function is called the body of the function and contains the set of instructions to execute to perform its task.\ndef my_function(): print(\u0026#34;Hello from my function!\u0026#34;) To call or invoke a function, we simply use its name followed by parentheses:\nmy_function() # Output: Hello from my function! Parameters and arguments # Functions become even more powerful when we pass information to them, known as parameters. These act as \u0026ldquo;variables\u0026rdquo; inside the function, allowing the function to work with different data each time it is called.\nWhile parameters are variables defined in the function definition, arguments are the actual values passed when calling the function.\ndef greet(name): print(f\u0026#34;Hello {name}!\u0026#34;) greet(\u0026#34;Maria\u0026#34;) # Output: # Hello Maria! Python allows default parameters, which have a predetermined value, making passing those arguments optional when calling the function. It also allows named parameters which enable passing arguments in any order by specifying their name.\ndef greet(name=\u0026#34;Maria\u0026#34;, repetitions=3): repetition = 1 while repetition \u0026lt;= repetitions: print(f\u0026#34;Hello {name}!\u0026#34;) repetition += 1 greet() # Output: # Hello Maria! # Hello Maria! # Hello Maria! greet(\u0026#34;Florencia\u0026#34;, 4) # Output: # Hello Florencia! # Hello Florencia! # Hello Florencia! # Hello Florencia! greet(repetitions=2, name=\u0026#34;Julian\u0026#34;) # Output # Hello Julian! # Hello Julian! Returning values # Functions can return a result or return value using the return keyword.\ndef circle_area(radius): return 3.14 * (radius ** 2) result = circle_area(10) print(result) # Output: 314 The return value is passed back to where the function was called and can be assigned to a variable for later use.\nFunctions can also perform some task without explicitly returning anything. In Python this is known as returning None.\nLocal and global variables # Local variables are defined inside a function and only exist in that scope, while global variables are defined outside and can be accessed from anywhere in the code. It is crucial to understand their scope (where a variable is accessible) and lifetime (how long a variable lives).\nx = 10 # x is global def add(): y = 5 # y is local return x + y add() # Output: 15 print(y) # Error, y does not exist outside the function We can read global variables from a function, but if we need to modify it we must declare it global.\nx = 10 def add(): global x x = x + 5 add() print(x) # 15 ","date":"29 September 2023","externalUrl":null,"permalink":"/en/programming/starting-concepts/functions/","section":"Programming","summary":"","title":"Functions","type":"programming"},{"content":"Named in honour of George Boole, a 19th-century English mathematician, Boolean logic is a mathematical system that deals with operations resulting in one of two possible outcomes: true or false, typically represented as 1 and 0, respectively. In his groundbreaking work, \u0026ldquo;An Investigation of the Laws of Thought,\u0026rdquo; Boole laid the foundations for this logic, introducing an algebraic system that could be employed to depict logical structures.\nBoolean operations # Within Boolean logic, several fundamental operations allow for the manipulation and combination of these binary expressions:\nAND: This operation yields true (1) only if both inputs are true. For instance, if you have two switches, both need to be in the on position for a light to illuminate.\nOR: It returns true if at least one of the inputs is true. Using the switch analogy, as long as one of them is in the on position, the light will shine.\nNOT: This unary operation (accepting only one input) simply inverts the input value. Provide it with a 1, and you\u0026rsquo;ll get a 0, and vice versa.\nNAND (NOT AND): It\u0026rsquo;s the negation of AND. It only returns false if both inputs are true.\nNOR (NOT OR): The negation of OR. It yields true only if both inputs are false.\nXOR (Exclusive OR): It returns true if the inputs differ. If both are the same, it returns false.\nXNOR (Exclusive NOR): The inverse of XOR. It yields true if both inputs are the same.\nWhy is this logic important in computing and programming? # Modern computing, at its core, is all about bit manipulation (those 1s and 0s we\u0026rsquo;ve mentioned). Every operation a computer undertakes, from basic arithmetic to rendering intricate graphics, involves Boolean operations at some level.\nIn programming, Boolean logic is used in control structures, such as conditional statements (if, else) and loops, allowing programs to make decisions based on specific conditions.\nTruth Tables: mapping Boolean logic # A truth table graphically represents a Boolean operation. It lists every possible input combination and displays the operation\u0026rsquo;s result for each combination.\nFor instance:\nA B A AND B A OR B A XOR B A NOR B A NAND B NOT A A NXOR B 1 1 1 1 0 0 0 0 1 1 0 0 1 1 0 1 0 0 0 1 0 1 1 0 1 1 0 0 0 0 0 0 1 1 1 1 Concluding thoughts # Boolean logic is more than a set of abstract mathematical rules. It\u0026rsquo;s the foundational language of machines, the code underpinning the digital age in which we live. By understanding its principles, not only do we become more proficient in working with technology, but we also gain a deeper appreciation of the structures supporting our digital world.\nReferences # Boole, G. (1854). An Investigation of the Laws of Thought. London: Walton and Maberly. Tanenbaum, A. (2012). Structured Computer Organization. New Jersey: Prentice Hall. Minsky, M. (1967). Computation: Finite and Infinite Machines. New Jersey: Prentice-Hall. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"09 September 2023","externalUrl":null,"permalink":"/en/programming/intro/boolean-logic/","section":"Programming","summary":"","title":"Boolean Logic","type":"programming"},{"content":"Key characteristics of aggregation:\nIt\u0026rsquo;s a stronger relationship than a simple association, but weaker than composition. The \u0026ldquo;part\u0026rdquo; object can exist independently of the \u0026ldquo;whole\u0026rdquo; object. Multiple \u0026ldquo;whole\u0026rdquo; objects can share the same \u0026ldquo;part\u0026rdquo; object. If the \u0026ldquo;whole\u0026rdquo; object is destroyed, the \u0026ldquo;part\u0026rdquo; object continues to exist. Let\u0026rsquo;s look at an example to illustrate aggregation:\nclass Department: def __init__(self, name): self.name = name self.employees = [] def add_employee(self, employee): self.employees.append(employee) def remove_employee(self, employee): self.employees.remove(employee) def list_employees(self): return f\u0026#34;Department {self.name} has employees: {\u0026#39;, \u0026#39;.join(emp.name for emp in self.employees)}\u0026#34; class Employee: def __init__(self, name, id): self.name = name self.id = id def __str__(self): return f\u0026#34;Employee(name={self.name}, id={self.id})\u0026#34; # Creating instances hr_dept = Department(\u0026#34;Human Resources\u0026#34;) it_dept = Department(\u0026#34;Information Technology\u0026#34;) emp1 = Employee(\u0026#34;Alice\u0026#34;, \u0026#34;E001\u0026#34;) emp2 = Employee(\u0026#34;Bob\u0026#34;, \u0026#34;E002\u0026#34;) emp3 = Employee(\u0026#34;Charlie\u0026#34;, \u0026#34;E003\u0026#34;) # Adding employees to departments hr_dept.add_employee(emp1) hr_dept.add_employee(emp2) it_dept.add_employee(emp2) # Note: Bob works in both HR and IT it_dept.add_employee(emp3) print(hr_dept.list_employees()) print(it_dept.list_employees()) # If we remove the HR department, the employees still exist del hr_dept print(emp1) # Employee still exists In this example, we have an aggregation relationship between Department and Employee. A Department has Employees, but Employees can exist independently of any particular Department. Also, an Employee can belong to multiple Departments (as we see with Bob).\nHere\u0026rsquo;s a UML diagram representing this aggregation relationship:\nclassDiagram class Department { +name: string +employees: list +add_employee(employee) +remove_employee(employee) +list_employees() } class Employee { +name: string +id: string +__str__() } Department o-- Employee : has end In this diagram, the open diamond on the Department side of the relationship indicates aggregation. This shows that Department is the \u0026ldquo;whole\u0026rdquo; and Employee is the \u0026ldquo;part\u0026rdquo; in this relationship.\nIt\u0026rsquo;s important to note that while aggregation implies a whole-part relationship, the \u0026ldquo;part\u0026rdquo; (in this case, Employee) can exist independently and can even be part of multiple \u0026ldquo;wholes\u0026rdquo; (multiple Departments).\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-aggregation/","section":"Programming","summary":"","title":"Class relations: Aggregation","type":"programming"},{"content":"The LIFO nature of stacks is due to the fact that only the top element can be accessed and manipulated. The operation of placing an element on the stack is known as \u0026ldquo;push\u0026rdquo;, while removing an element from the stack is a \u0026ldquo;pop\u0026rdquo;. The LIFO operation causes the last element placed in a stack to be the first to be removed.\nDiagram of a stack Main operations # The primary operations supported by a stack structure are:\nPush: adds an element to the top of the stack. Pop: removes the element at the top of the stack. Peek: allows accessing the top element without removing it from the stack. isEmpty: checks if the stack is empty. Most languages like Python and Java provide stack implementations in their standard libraries.\nImplementation # A stack can be implemented using a linked list so that each node points to the previous node.\nclass Node: def __init__(self, value): self.value = value self.previous = None class Stack: def __init__(self): self.top = None self.size = 0 def push(self, value): new_node = Node(value) if self.top is None: self.top = new_node else: new_node.previous = self.top self.top = new_node self.size += 1 def pop(self): if self.top is None: return None top_node = self.top self.top = self.top.previous self.size -= 1 return top_node.value def peek(self): if self.top is None: return None return self.top.value def is_empty(self): return self.top is None # Returns true if top is None def __len__(self): return self.size def __str__(self): values = [] current = self.top while current: values.append(str(current.value)) current = current.previous return \u0026#34;\\n\u0026#34;.join(values) print(\u0026#34;Creating a new stack\u0026#34;) stack = Stack() print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if stack is empty\u0026#34;) print(f\u0026#34;Is stack empty? {stack.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Push first element\u0026#34;) print(\u0026#34; stack.push(\\\u0026#34;First\\\u0026#34;)\u0026#34;) stack.push(\u0026#34;First\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print stack:\u0026#34;) print(stack) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print top element using peek\u0026#34;) print(f\u0026#34;stack.peek() =\u0026gt; {stack.peek()}\u0026#34;) print(\u0026#34;Add two more elements: stack.push(\\\u0026#34;\\\u0026#34;):\u0026#34;) print(\u0026#34; stack.push(\\\u0026#34;Second\\\u0026#34;)\u0026#34;) print(\u0026#34; stack.push(\\\u0026#34;Third\\\u0026#34;)\u0026#34;) stack.push(\u0026#34;Second\u0026#34;) stack.push(\u0026#34;Third\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print stack:\u0026#34;) print(stack) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print top element using peek\u0026#34;) print(f\u0026#34;stack.peek() =\u0026gt; {stack.peek()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if stack is empty\u0026#34;) print(f\u0026#34;Is stack empty? {stack.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get top element using pop\u0026#34;) print(f\u0026#34;stack.pop() =\u0026gt; {stack.pop()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print top element using peek\u0026#34;) print(f\u0026#34;stack.peek() =\u0026gt; {stack.peek()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get top element using pop\u0026#34;) print(f\u0026#34;stack.pop() =\u0026gt; {stack.pop()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get top element using pop\u0026#34;) print(f\u0026#34;stack.pop() =\u0026gt; {stack.pop()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if stack is empty\u0026#34;) print(f\u0026#34;Is stack empty? {stack.is_empty()}\u0026#34;) Usage examples # Stacks have many uses in programming:\nExecution stack (call stack): records pending function calls to resolve. Implements expected LIFO behaviour.\nBrowser stack: allows going back (undo) in the browser history similarly to a LIFO stack.\nMath expression execution: stacks can verify parentheses, brackets, braces, etc.\nAlgorithms and data structures: like in the quicksort algorithm and in data path implementations.\nConclusion # Stacks are versatile data structures thanks to their LIFO operation principle. Having a good command of stacks, their uses and applications is essential in computer science.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"02 November 2023","externalUrl":null,"permalink":"/en/programming/data-structures/stacks/","section":"Programming","summary":"","title":"Stacks","type":"programming"},{"content":" Recursion: the art of calling yourself # Imagine a box of mirrors where each mirror reflects what it sees in the next, creating an infinite series of reflections. Recursion in programming is something similar. It is a technique where a function calls itself directly or indirectly. This creates a cycle where the function solves a problem by dividing it into smaller instances of the same problem, until reaching a simple base case that can be solved directly.\nFor example, let\u0026rsquo;s imagine a function that prints a countdown:\ndef countdown(number): if number \u0026gt; 0: print(number) countdown(number - 1) else: print(\u0026#34;Blastoff!\u0026#34;) countdown(5) This function calls itself recursively decrementing the number each time until reaching 0, and then prints the blastoff message.\nRecursion is a declarative approach that focuses on dividing a problem into recursive cases without needing to explicitly control the loop using iterators or counters like in imperative programming.\nThe structure of a recursive function # The power of recursion lies in its simplicity. However, it is essential to understand its structure to avoid common pitfalls. A typical recursive function has two main parts:\nBase case: The simplest case with a known solution that doesn\u0026rsquo;t require recursion. It is the stopping condition that halts the recursion. Without a base case, we would fall into infinite recursion which eventually overflows the call stack. Recursive case: This is where the magical recursive call occurs. At this point, the function calls itself with a modified argument, usually a reduced version of the original problem. Classic recursion examples # Factorial # The factorial of a positive integer \\(n\\) is the product of all positive integers less than or equal to \\(n\\). For example:\n\\(5! = 5 * 4 * 3 * 2 * 1 = 120\\) \\(4! = 4 * 3 * 2 * 1 = 24\\) \\(3! = 3 * 2 * 1 = 6\\) Here is the Python code for calculating factorial using recursion:\ndef factorial(n): if n == 1: return 1 # Base case return n * factorial(n-1) # Recursive case Base case: The base case is the simplest, smallest instance of the problem that can be answered directly. For factorial, when \\(n = 1\\), the result is \\(1\\). Recursive case: If \\(n\\) is greater than \\(1\\), the function calls itself with \\(n-1\\), and multiplies the result by \\(n\\). Let\u0026rsquo;s say you want to calculate the factorial of \\(5\\), so you call factorial(5).\nHere is what happens:\nStep 1: Since \\(n = 5\\) is not \\(1\\), the function calls factorial(4), then multiplies the result by \\(5\\). Step 2: Now, inside factorial(4), \\(n = 4\\), so the function calls factorial(3), then multiplies the result by \\(4\\). Step 3: Inside factorial(3), \\(n = 3\\), so it calls factorial(2), then multiplies the result by \\(3\\). Step 4: Inside factorial(2), \\(n = 2\\), so it calls factorial(1), then multiplies the result by \\(2\\). Step 5: Finally, factorial(1) reaches the base case, where \\(n = 1\\), so it returns \\(1\\). Now the results unwind:\nfactorial(2) returns \\(2 * 1 = 2\\) factorial(3) returns \\(3 * 2 = 6\\) factorial(4) returns \\(4 * 6 = 24\\) factorial(5) returns \\(5 * 24 = 120\\) The final result is \\(120\\), which is the value of \\(5!\\).\nHere is a visual representation of the call stack:\nfactorial(5) -\u0026gt; factorial(4) -\u0026gt; factorial(3) -\u0026gt; factorial(2) -\u0026gt; factorial(1) return 1 return 2 return 6 return 24 return 120 Fibonacci sequence # The Fibonacci sequence is a series of numbers where each number is the sum of the previous two. It starts with \\(0\\) and \\(1\\), and each subsequent number is the sum of the two numbers before it. The beginning of the sequence is: \\(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \u0026hellip;\\)\nHere is the Python code for calculating the \\(n^th\\) Fibonacci number using tail recursion:\ndef fibonacci(n, a=0, b=1): if n == 0: return a return fibonacci(n-1, b, a+b) The function takes three parameters:\n\\(n\\): The position of the desired number in the sequence. \\(a\\) and \\(b\\): Two numbers that aid in the sequence calculation. Here is a breakdown of how the function works:\nBase case: If \\(n\\) is \\(0\\), the function returns \\(a\\). This is the value of the \\(n^th\\) number in the sequence. Recursive case: If \\(n\\) is not \\(0\\), the function calls itself with \\(n-1\\), \\(b\\), and \\(a+b\\). These parameters change the position in the sequence and prepare the next numbers for summation. Suppose we want to find the \\(5^th\\) number in the Fibonacci sequence by calling fibonacci(5).\nHere is what happens:\nStep 1: Since \\(n = 5\\), it calls fibonacci(4, 1, 1) (because \\(a = 0\\), \\(b = 1\\), \\(a + b = 1\\)). Step 2: Since \\(n = 4\\), it calls fibonacci(3, 1, 2) (because \\(a = 1\\), \\(b = 1\\), \\(a + b = 2\\)). Step 3: Since \\(n = 3\\), it calls fibonacci(2, 2, 3) (because \\(a = 1\\), \\(b = 2\\), \\(a + b = 3\\)). Step 4: Since \\(n = 2\\), it calls fibonacci(1, 3, 5) (because \\(a = 2\\), \\(b = 3\\), \\(a + b = 5\\)). Step 5: Since \\(n = 1\\), it calls fibonacci(0, 5, 8) (because \\(a = 3\\), \\(b = 5\\), \\(a + b = 8\\)). Step 6: Since \\(n = 0\\), it returns \\(a\\), which is \\(5\\). The result is \\(5\\), which is the \\(5^th\\) number in the Fibonacci sequence.\nHere is a visual representation of the call stack:\nfibonacci(5, 0, 1) -\u0026gt; fibonacci(4, 1, 1) -\u0026gt; fibonacci(3, 1, 2) -\u0026gt; fibonacci(2, 2, 3) -\u0026gt; fibonacci(1, 3, 5) -\u0026gt; fibonacci(0, 5, 8) return 5 Advantages and Disadvantages # Recursion has certain advantages:\nIt can result in simple, elegant solutions for problems that easily break down into subproblems. It eliminates the need for explicit loop control. It mirrors the mathematical structure of a recursive definition. The disadvantages include:\nIt can be less efficient (high memory consumption) than iteration due to repeated function calls and stack frame creation. Too much recursion can overflow the call stack and cause crashes. It can be harder to debug and analyze than iteration. Therefore, recursion is a powerful tool that should be used judiciously in appropriate cases.\nRecursion vs Iteration # Recursion and iteration (using loops) are parallel tools and we can use either one to solve many problems. Both techniques have the potential to solve the same problems, but their implementation and efficiency may vary. Let\u0026rsquo;s take the factorial example:\nIterative\ndef factorial_iterative(n): result = 1 for i in range(1, n+1): result *= i return result Recursive\ndef factorial_recursive(n): if n == 1: return 1 return n * factorial(n-1) The iterative version is more efficient in terms of space, but the recursive is cleaner and easier to understand. The choice between recursion and iteration often depends on the specific problem, memory constraints, and programmer preferences.\nConclusion # Recursion is a key technique that allows writing elegant, natural, and efficient algorithms when properly leveraged. Understanding how to break down a problem into recursive cases is essential to master this skill. Recursion provides a unique declarative alternative to solve complex problems without managing explicit loops. However, it is crucial to always remember to define an adequate base case and be aware of recursion limitations in terms of efficiency and memory usage. Knowing how to combine recursion and iteration gives flexibility when creating optimal solutions.\nAs always, the key lies in finding the right balance and using the right tool for the right job.\nReferences # Cormen, T.H., Leiserson, C.E., Rivest, R.L., \u0026amp; Stein, C. (2009). Introduction to Algorithms. MIT Press. Kindler, E., \u0026amp; Krivy, I. (2011). Object-Oriented Simulation of systems with Java: A working introduction. BoD–Books on Demand. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"30 September 2023","externalUrl":null,"permalink":"/en/programming/starting-concepts/recursive-functions/","section":"Programming","summary":"","title":"Recursive Functions","type":"programming"},{"content":" Choosing a programming language # Choosing a programming language is the first and perhaps the most crucial step in the learning process. Several factors to consider when selecting a language include:\nPurpose: What do you want to code for? If it\u0026rsquo;s web development, JavaScript or PHP might be good options. If you\u0026rsquo;re into data science, R or Python might be more appropriate. Community: A language with an active community can be vital for beginners. A vibrant community usually means more resources, tutorials, and solutions available online. Learning curve: Some languages are easier to pick up than others. It\u0026rsquo;s essential to pick one that matches your experience level and patience. Job opportunities: If you\u0026rsquo;re eyeing a career in programming, researching the job market demand for various languages can be insightful. While there are many valuable and potent languages, for the purpose of this course, we\u0026rsquo;ve chosen Python. This language is renowned for its simplicity and readability, making it ideal for those just starting out. Moreover, Python boasts an active community and a wide range of applications, from web development to artificial intelligence.\nInstalling Python # For Windows users: # Download the installer: Visit the official Python website at https://www.python.org/downloads/windows/ Click on the download link for the latest version of Python 3.x. Run the installer: Once the download is complete, locate and run the installer .exe file. Make sure to check the box that says \u0026ldquo;Add Python to PATH\u0026rdquo; during installation. This step is crucial for making Python accessible from the Command Prompt. Follow the installation prompts. Verify installation: Open the Command Prompt and type: python --version This should display the version of Python you just installed. For Mac users: # Download the installer: Visit the official Python website at https://www.python.org/downloads/mac-osx/ Click on the download link for the latest version of Python 3.x. Run the installer: Once the download is complete, locate and run the .pkg file. Follow the installation prompts. Verify installation: Open the Terminal and type: python3 --version This should display the version of Python you just installed. For Linux (Ubuntu/Debian) users: # Update packages: sudo apt update Install Python: sudo apt install python3 Verify installation: After installation, you can check the version of Python installed by typing: python3 --version Integrated Development Environments (IDEs) # An IDE is a tool that streamlines application development by combining commonly-used functionalities into a single software package: code editor, compiler, debugger, and more. Choosing the right IDE can make the programming process more fluid and efficient.\nWhen evaluating IDEs, consider:\nLanguage compatibility: Not all IDEs are compatible with every programming language. Features: Some IDEs offer features like auto-completion, syntax highlighting, and debugging tools. Extensions and plugins: Being able to customize and extend your IDE through plugins can be extremely beneficial. Price: There are free and paid IDEs. Evaluate whether the additional features of a paid IDE justify its cost. For this course, we\u0026rsquo;ve selected Visual Studio Code (VS Code). It\u0026rsquo;s a popular IDE that\u0026rsquo;s free and open-source. It\u0026rsquo;s known for its straightforward interface, a vast array of plugins, and its capability to handle multiple programming languages. Its active community ensures regular updates and a plethora of learning resources.\nInstalling Visual Studio Code # For Windows users: # Download the installer: Visit the official VS Code website at https://code.visualstudio.com/ Click on the \u0026ldquo;Download for Windows\u0026rdquo; button. Run the installer: Once the download is complete, locate and run the installer .exe file. Follow the installation prompts, including accepting the license agreement and choosing the installation location. Launch VS Code: After installation, you can find VS Code in your Start menu. Launch it, and you\u0026rsquo;re ready to start coding! For Mac users: # Download the installer: Visit the official VS Code website at https://code.visualstudio.com/ Click on the \u0026ldquo;Download for Mac\u0026rdquo; button. Install VS Code: Once the download is complete, open the downloaded .zip file. Drag the Visual Studio Code .app to the Applications folder, making it available in the Launchpad. Launch VS Code: Use Spotlight search or navigate to your Applications folder to launch VS Code. For Linux (Ubuntu/Debian) users: # Update packages and install dependencies: sudo apt update sudo apt install software-properties-common apt-transport-https wget Download and install the key: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Add the VS Code repository: sudo add-apt-repository \u0026#34;deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main\u0026#34; Install Visual Studio Code: sudo apt update sudo apt install code Launch VS Code: You can start VS Code from the terminal by typing code or find it in your list of installed applications. Write and execute your first program # Once you\u0026rsquo;ve set up your programming environment, it\u0026rsquo;s time to dive into coding.\nHello, World! # This is arguably the most iconic program for beginners. It\u0026rsquo;s simple, but it introduces you to the process of writing and executing code.\nprint(\u0026#34;Hello, World!\u0026#34;) Running the Hello World program Triangle area and perimeter calculation # This program is a tad more intricate. It doesn\u0026rsquo;t just print out a message; it also performs mathematical calculations.\n############ # User input ############ side1 = float(input(\u0026#34;Enter the length of the first side: \u0026#34;)) side2 = float(input(\u0026#34;Enter the length of the second side: \u0026#34;)) side3 = float(input(\u0026#34;Enter the length of the third side: \u0026#34;)) ####################### # Perimeter calculation ####################### perimeter = side1 + side2 + side3 print(f\u0026#34;The triangle\u0026#39;s perimeter is: {perimeter}\u0026#34;) ######################################## # Area calculation using Heron\u0026#39;s formula ######################################## s = perimeter / 2 area = (s*(s-side1)*(s-side2)*(s-side3)) ** 0.5 print(f\u0026#34;The triangle\u0026#39;s area is: {area:.2f}\u0026#34;) Running the Triangle program Conclusion # Setting up a programming environment might appear daunting at first, but with the right tools and resources, it becomes a manageable and rewarding task. We hope this article provided you with a solid foundation to kickstart your programming journey. Happy coding!\nReferences # Lutz, M. (2013). Learning Python. O\u0026rsquo;Reilly Media. Microsoft. (2020). Visual Studio Code Documentation. Microsoft Docs. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"10 September 2023","externalUrl":null,"permalink":"/en/programming/intro/setup-dev-environment/","section":"Programming","summary":"","title":"Set Up your Development Environment","type":"programming"},{"content":"Key characteristics of composition:\nIt represents a strong \u0026ldquo;has-a\u0026rdquo; relationship. The \u0026ldquo;part\u0026rdquo; object cannot exist independently of the \u0026ldquo;whole\u0026rdquo; object. When the \u0026ldquo;whole\u0026rdquo; object is destroyed, all its \u0026ldquo;part\u0026rdquo; objects are also destroyed. A \u0026ldquo;part\u0026rdquo; object belongs to only one \u0026ldquo;whole\u0026rdquo; object at a time. Let\u0026rsquo;s look at an example to illustrate composition:\nclass Engine: def __init__(self, horsepower): self.horsepower = horsepower def start(self): return \u0026#34;Engine started\u0026#34; class Car: def __init__(self, make, model, horsepower): self.make = make self.model = model self.engine = Engine(horsepower) # Composition: Car creates its own Engine def start_car(self): return f\u0026#34;{self.make} {self.model}: {self.engine.start()}\u0026#34; def __del__(self): print(f\u0026#34;{self.make} {self.model} is being destroyed, and so is its engine.\u0026#34;) # Creating a Car instance my_car = Car(\u0026#34;Toyota\u0026#34;, \u0026#34;Corolla\u0026#34;, 150) print(my_car.start_car()) # Output: Toyota Corolla: Engine started # When we delete the Car, its Engine is also deleted del my_car # This will print: Toyota Corolla is being destroyed, and so is its engine. In this example, we have a composition relationship between Car and Engine. A Car has an Engine, and the Engine cannot exist independently of the Car. When a Car object is created, it creates its own Engine. When the Car object is destroyed, its Engine is also destroyed.\nHere\u0026rsquo;s a UML diagram representing this composition relationship:\nclassDiagram class Car { +make: string +model: string -engine: Engine +start_car() +__del__() } class Engine { -horsepower: int +start() } Car *-- Engine : has end In this diagram, the filled diamond on the Car side of the relationship indicates composition. This shows that Car is the \u0026ldquo;whole\u0026rdquo; and Engine is the \u0026ldquo;part\u0026rdquo; in this relationship, and that the Engine\u0026rsquo;s lifetime is tied to the Car\u0026rsquo;s lifetime.\nThe key difference between aggregation and composition is the strength of the relationship and the lifecycle dependency. In aggregation, the \u0026ldquo;part\u0026rdquo; can exist independently of the \u0026ldquo;whole\u0026rdquo;, while in composition, the \u0026ldquo;part\u0026rdquo; cannot exist without the \u0026ldquo;whole\u0026rdquo;.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-composition/","section":"Programming","summary":"","title":"Class relations: Composition","type":"programming"},{"content":"The FIFO (first in, first out) nature of queues is because only the initial element can be accessed and manipulated. When an element is added to the queue it is known as \u0026ldquo;enqueue\u0026rdquo;, while removing an element is called \u0026ldquo;dequeue\u0026rdquo;.\nThis causes the first element to be added to the queue to also be the first to be removed, hence its FIFO behaviour.\nDiagram of a queue Main operations # The basic queue operations are:\nEnqueue: Adds an element to the end of the queue. Dequeue: Removes the element from the front of the queue. Peek: Gets the front element without removing it. isEmpty: Checks if the queue is empty. Implementation # Like stacks, queues can be implemented using linked lists. Elements are added at the end and removed from the front by keeping references to both ends.\nclass Node: def __init__(self, value): self.value = value self.next = None class Queue: def __init__(self): self.front = None self.end = None self.size = 0 def enqueue(self, value): new_node = Node(value) if self.end is None: self.end = new_node self.front = new_node return self.end.next = new_node self.end = new_node self.size += 1 def dequeue(self): if self.is_empty(): return None value = self.front.value self.front = self.front.next if self.front is None: self.end = None self.size -= 1 return value def peek(self): if self.is_empty(): return None return self.front.value def is_empty(self): return self.front is None # Returns true if front is None def __len__(self): return self.size def __str__(self): values = [] current = self.front while current: values.append(str(current.value)) current = current.next return \u0026#34;\\n\u0026#34;.join(values) print(\u0026#34;Creating a new queue\u0026#34;) queue = Queue() print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if queue is empty\u0026#34;) print(f\u0026#34;Is queue empty? {queue.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Enqueue three elements\u0026#34;) queue.enqueue(\u0026#34;ABC\u0026#34;) queue.enqueue(\u0026#34;DEF\u0026#34;) queue.enqueue(\u0026#34;GHI\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after enqueuing elements:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get front element using dequeue\u0026#34;) print(f\u0026#34;queue.dequeue() =\u0026gt; {queue.dequeue()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after dequeue element:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print front element using peek\u0026#34;) print(f\u0026#34;queue.peek() =\u0026gt; {queue.peek()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after peek:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get front element using dequeue\u0026#34;) print(f\u0026#34;queue.dequeue() =\u0026gt; {queue.dequeue()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after dequeue element:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if queue is empty\u0026#34;) print(f\u0026#34;Is queue empty? {queue.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get front element using dequeue\u0026#34;) print(f\u0026#34;queue.dequeue() =\u0026gt; {queue.dequeue()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after dequeue element:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if queue is empty\u0026#34;) print(f\u0026#34;Is queue empty? {queue.is_empty()}\u0026#34;) Usage examples # Some common uses of queues:\nPrint queues where first in, first printed. Task queues in operating systems for execution order. Simulations where arrival order must be respected like in banks. Message queues like RabbitMQ or Kafka. Circular buffers in audio for streaming. Conclusion # Queues are versatile structures thanks to their FIFO principle. Having a good handle on queues, implementation, and applications will reinforce your skills as a programmer.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"03 November 2023","externalUrl":null,"permalink":"/en/programming/data-structures/queues/","section":"Programming","summary":"","title":"Queues","type":"programming"},{"content":"Key characteristics of inheritance:\nIt promotes code reuse and establishes a hierarchy between classes. The subclass inherits all public and protected members from the superclass. The subclass can add its own members and override inherited members. It supports the concept of polymorphism. Let\u0026rsquo;s look at an example to illustrate inheritance:\nclass Animal: def __init__(self, name): self.name = name def speak(self): pass class Dog(Animal): def speak(self): return f\u0026#34;{self.name} says Woof!\u0026#34; class Cat(Animal): def speak(self): return f\u0026#34;{self.name} says Meow!\u0026#34; # Creating instances dog = Dog(\u0026#34;Buddy\u0026#34;) cat = Cat(\u0026#34;Whiskers\u0026#34;) print(dog.speak()) # Output: Buddy says Woof! print(cat.speak()) # Output: Whiskers says Meow! # Demonstrating polymorphism def animal_sound(animal): print(animal.speak()) animal_sound(dog) # Output: Buddy says Woof! animal_sound(cat) # Output: Whiskers says Meow! In this example, we have a base class Animal and two derived classes Dog and Cat. Both Dog and Cat inherit from Animal and override the speak method.\nHere\u0026rsquo;s a UML diagram representing this inheritance relationship:\nclassDiagram class Animal { +name: string +speak() } class Dog { +speak() } class Cat { +speak() } Animal \u003c|-- Dog Animal \u003c|-- Cat end In this diagram, the arrows pointing from Dog and Cat to Animal indicate inheritance. This shows that Dog and Cat are subclasses of Animal.\nInheritance is a powerful feature of OOP, but it should be used judiciously. Overuse of inheritance can lead to complex class hierarchies that are difficult to understand and maintain. The principle of \u0026ldquo;composition over inheritance\u0026rdquo; suggests that it\u0026rsquo;s often better to use composition (has-a relationship) rather than inheritance (is-a relationship) when designing class relationships.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-inheritance/","section":"Programming","summary":"","title":"Class relations: Inheritance","type":"programming"},{"content":"Key characteristics of realisation:\nIt represents a contract that the implementing class must fulfil. The class must provide implementations for all methods declared in the interface. It allows for polymorphism through interfaces. Python doesn\u0026rsquo;t have a built-in interface concept like some other languages (e.g., Java), but we can simulate interfaces using abstract base classes. Here\u0026rsquo;s an example:\nfrom abc import ABC, abstractmethod class Drawable(ABC): @abstractmethod def draw(self): pass class Circle(Drawable): def draw(self): return \u0026#34;Drawing a circle\u0026#34; class Square(Drawable): def draw(self): return \u0026#34;Drawing a square\u0026#34; def draw_shape(shape: Drawable): print(shape.draw()) # Creating instances circle = Circle() square = Square() # Using polymorphism through the interface draw_shape(circle) # Output: Drawing a circle draw_shape(square) # Output: Drawing a square In this example, Drawable is an abstract base class that acts like an interface. Both Circle and Square implement the Drawable interface by providing their own implementation of the draw method.\nHere\u0026rsquo;s a UML diagram representing this realisation relationship:\nclassDiagram class Drawable { \u003c\u003e +draw() } class Circle { +draw() } class Square { +draw() } Drawable \u003c|.. Circle Drawable \u003c|.. Square end In this diagram, the dashed arrows pointing from Circle and Square to Drawable indicate realisation. This shows that Circle and Square implement the Drawable interface.\nRealisation is a powerful concept that allows for designing loosely coupled systems. By programming to interfaces rather than concrete implementations, we can create more flexible and extensible software.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-realisation/","section":"Programming","summary":"","title":"Class relations: Realisation (Implementation)","type":"programming"},{"content":"Key characteristics of dependency:\nIt represents a \u0026ldquo;uses\u0026rdquo; relationship between classes. It\u0026rsquo;s a weaker relationship compared to association, aggregation, or composition. Changes in the used class may affect the using class. Here\u0026rsquo;s an example to illustrate dependency:\nclass Printer: def print_document(self, document): return f\u0026#34;Printing: {document.get_content()}\u0026#34; class PDFDocument: def get_content(self): return \u0026#34;PDF content\u0026#34; class WordDocument: def get_content(self): return \u0026#34;Word document content\u0026#34; # Using the Printer printer = Printer() pdf = PDFDocument() word = WordDocument() print(printer.print_document(pdf)) # Output: Printing: PDF content print(printer.print_document(word)) # Output: Printing: Word document content In this example, the Printer class has a dependency on both PDFDocument and WordDocument classes. The Printer uses these classes in its print_document method, but it doesn\u0026rsquo;t maintain a long-term relationship with them.\nHere\u0026rsquo;s a UML diagram representing these dependency relationships:\nclassDiagram class Printer { +print_document(document) } class PDFDocument { +get_content() } class WordDocument { +get_content() } Printer ..\u003e PDFDocument : uses Printer ..\u003e WordDocument : uses end In this diagram, the dashed arrows pointing from Printer to PDFDocument and WordDocument indicate dependency. This shows that Printer uses these classes, but doesn\u0026rsquo;t have a stronger relationship with them.\nDependency is often used to reduce coupling between classes. By depending on abstractions (like interfaces) rather than concrete classes, we can make our code more flexible and easier to change.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-dependency/","section":"Programming","summary":"","title":"Class relations: Dependency","type":"programming"},{"content":" Comparing and contrasting relations # Now that we\u0026rsquo;ve explored the various types of class relations, let\u0026rsquo;s compare and contrast them to better understand when to use each:\nAssociation vs Aggregation vs Composition\nAssociation is the most general relationship, representing any connection between classes. Aggregation is a specialised association representing a whole-part relationship where the part can exist independently. Composition is the strongest whole-part relationship where the part cannot exist independently of the whole. Inheritance vs Composition\nInheritance represents an \u0026ldquo;is-a\u0026rdquo; relationship (e.g., a Dog is an Animal). Composition represents a \u0026ldquo;has-a\u0026rdquo; relationship (e.g., a Car has an Engine). The principle of \u0026ldquo;composition over inheritance\u0026rdquo; suggests favouring composition for more flexible designs. Realisation vs Inheritance\nRealisation is about implementing an interface, focusing on behaviour. Inheritance is about extending a class, inheriting both state and behaviour. Dependency vs Association\nDependency is a weaker, often temporary relationship (e.g., a method parameter). Association implies a more permanent relationship, often represented by a class attribute. Here\u0026rsquo;s a comparison table summarising these relationships:\nRelationship Strength Lifecycle Binding \u0026ldquo;Is-a\u0026rdquo; or \u0026ldquo;Has-a\u0026rdquo; Symbol in UML Dependency Weakest None Uses - - - - \u0026gt; Association Weak Independent Has-a (loose) ———\u0026gt; Aggregation Medium Independent Has-a ◇———\u0026gt; Composition Strong Dependent Has-a (strong) ♦———\u0026gt; Inheritance Strong N/A Is-a ——— Realisation Medium N/A Behaves-as - - - Common pitfalls # While class relationships are powerful tools in OOP, they can also lead to common pitfalls if not used carefully. Here are some common issues and how to avoid them:\nOveruse of inheritance\nProblem: Creating deep inheritance hierarchies that are hard to understand and maintain. Solution: Prefer composition over inheritance. Use inheritance only for genuine \u0026ldquo;is-a\u0026rdquo; relationships. Tight coupling\nProblem: Creating strong dependencies between classes, making the system rigid and hard to change. Solution: Use interfaces and dependency injection to reduce coupling. Depend on abstractions rather than concrete classes. God objects\nProblem: Creating classes that try to do too much, violating the Single Responsibility Principle. Solution: Break large classes into smaller, more focused classes. Use composition to bring functionality together. Circular dependencies\nProblem: Creating mutual dependencies between classes, leading to complex and hard-to-maintain code. Solution: Refactor to remove circular dependencies. Consider using interfaces or introducing a new class to break the cycle. Leaky abstractions\nProblem: Exposing implementation details through interfaces or base classes. Solution: Design interfaces and base classes carefully. Hide implementation details and expose only what\u0026rsquo;s necessary. Inappropriate intimacy\nProblem: Classes that know too much about each other\u0026rsquo;s internal details. Solution: Encapsulate data and behaviour. Use public interfaces to interact between classes. Brittle base classes\nProblem: Changes to base classes breaking derived classes in unexpected ways. Solution: Design base classes for extension. Document how derived classes should interact with base classes. Diamond problem in multiple inheritance\nProblem: Ambiguity in method resolution when a class inherits from two classes with a common ancestor. Solution: Avoid multiple inheritance if possible. Use interfaces or mixins instead. Overuse of getters and setters\nProblem: Breaking encapsulation by providing unrestricted access to internal state. Solution: Use meaningful methods that represent behaviors rather than exposing internal data directly. Violation of Liskov Substitution Principle\nProblem: Derived classes that can\u0026rsquo;t be used interchangeably with their base classes. Solution: Ensure that derived classes truly represent specialisations of their base classes. Use composition if the \u0026ldquo;is-a\u0026rdquo; relationship doesn\u0026rsquo;t hold. By being aware of these pitfalls and following best practices, you can create more robust and maintainable object-oriented designs.\nConclusion # Key takeaways:\nAssociation is a general relationship between classes. Aggregation represents a whole-part relationship where parts can exist independently. Composition is a stronger whole-part relationship where parts cannot exist independently. Inheritance represents an \u0026ldquo;is-a\u0026rdquo; relationship and promotes code reuse. Realisation is about implementing interfaces and focusing on behaviour. Dependency is a weak, often temporary relationship between classes. Remember that good object-oriented design is not just about using these relationships, but about using them appropriately. Always consider the SOLID principles and the \u0026ldquo;composition over inheritance\u0026rdquo; guideline.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-conclusion/","section":"Programming","summary":"","title":"Class relations: Conclusion","type":"programming"},{"content":"At the heart of OOP lie four fundamental concepts: Encapsulation, Inheritance, Polymorphism, and Abstraction. These concepts, often referred to as the \u0026ldquo;four pillars\u0026rdquo; of OOP, form the foundation upon which complex software systems are built. In this guide, we will delve deep into each of these concepts, exploring their definitions, implementations, and practical applications. We\u0026rsquo;ll use Python, a language known for its clarity and versatility, to demonstrate these concepts in action. Whether you\u0026rsquo;re a beginner just starting your programming journey or a seasoned professional looking to refresh your knowledge, this article aims to provide valuable insights and a deeper understanding of OOP principles.\nEncapsulation allows us to bundle data and methods together, hiding internal details and protecting data integrity. Inheritance enables code reuse and the creation of hierarchical relationships between classes. Polymorphism provides a way to use objects of different types through a common interface, enhancing flexibility and extensibility. Abstraction allows us to create simplified models of complex systems, focusing on essential features and hiding unnecessary details. As you continue your journey in software development, you\u0026rsquo;ll find that mastering these concepts opens up new ways of thinking about and solving problems. Remember that OOP is not just about syntax or language features, it\u0026rsquo;s a mindset for modeling complex systems and managing complexity in software.\n","date":"07 December 2024","externalUrl":null,"permalink":"/en/programming/oop/the-four-pillars-introduction/","section":"Programming","summary":"","title":"The Four Pillars","type":"programming"},{"content":"The importance of encapsulation lies in several key aspects:\nData protection: By controlling access to object data through methods, we can ensure that the data remains consistent and valid. Modularity: Encapsulation allows objects to be self-contained, making it easier to understand and maintain code. Flexibility: The internal implementation can be changed without affecting other parts of the code that use the object. Reduced complexity: By hiding the details of internal workings, encapsulation reduces the complexity of the overall system from an external perspective. Implementation in Python # Python provides several mechanisms to implement encapsulation. Let\u0026rsquo;s explore these with examples:\n1. Using private attributes # In Python, we can create private attributes by prefixing the attribute name with double underscores (__). This triggers name mangling, which makes the attribute harder to access from outside the class.\nclass BankAccount: def __init__(self, account_number, balance): self.__account_number = account_number # Private attribute self.__balance = balance # Private attribute def deposit(self, amount): if amount \u0026gt; 0: self.__balance += amount return True return False def withdraw(self, amount): if 0 \u0026lt; amount \u0026lt;= self.__balance: self.__balance -= amount return True return False def get_balance(self): return self.__balance # Usage account = BankAccount(\u0026#34;1234567890\u0026#34;, 1000) print(account.get_balance()) # Output: 1000 account.deposit(500) print(account.get_balance()) # Output: 1500 account.withdraw(200) print(account.get_balance()) # Output: 1300 # This will raise an AttributeError # print(account.__balance) In this example:\n__account_number and __balance are private attributes. We provide public methods (deposit, withdraw, get_balance) to interact with these private attributes. Direct access to __balance from outside the class will raise an AttributeError exception. 2. Using properties # Python\u0026rsquo;s @property decorator allows us to define methods that can be accessed like attributes, providing a more Pythonic way of implementing getters and setters.\nclass Circle: def __init__(self, radius): self._radius = radius @property def radius(self): return self._radius @radius.setter def radius(self, value): if value \u0026gt; 0: self._radius = value else: raise ValueError(\u0026#34;Radius must be positive\u0026#34;) @property def area(self): return 3.14159 * self._radius ** 2 # Usage circle = Circle(5) print(circle.radius) # Output: 5 print(circle.area) # Output: 78.53975 circle.radius = 7 print(circle.radius) # Output: 7 print(circle.area) # Output: 153.93791 # This will raise a ValueError # circle.radius = -1 In this example:\n_radius is a protected attribute (single underscore is a convention for protected attributes in Python). The radius property provides get and set access to _radius with validation. The area property is read-only and calculated on-the-fly. Benefits and best practices # The benefits of encapsulation are numerous:\nImproved maintainability: Changes to the internal implementation don\u0026rsquo;t affect external code that uses the class. Enhanced security: Private attributes can\u0026rsquo;t be accidentally modified from outside the class. Flexibility in implementation: You can change how data is stored or calculated without changing the public interface. Better abstraction: Users of the class don\u0026rsquo;t need to know about its internal workings. Best practices for encapsulation in Python include:\nUse private attributes (double underscore prefix) for data that should not be accessed directly from outside the class. Provide public methods or properties for controlled access to internal data. Use properties instead of get/set methods for a more Pythonic approach. Document the public interface clearly, including any side effects of methods. Let\u0026rsquo;s look at a more complex example that demonstrates these practices:\nclass Employee: def __init__(self, name, salary): self.__name = name self.__salary = salary self.__projects = [] @property def name(self): return self.__name @property def salary(self): return self.__salary @salary.setter def salary(self, value): if value \u0026gt; 0: self.__salary = value else: raise ValueError(\u0026#34;Salary must be positive\u0026#34;) def add_project(self, project): \u0026#34;\u0026#34;\u0026#34; Add a project to the employee\u0026#39;s project list. :param project: string representing the project name \u0026#34;\u0026#34;\u0026#34; self.__projects.append(project) def remove_project(self, project): \u0026#34;\u0026#34;\u0026#34; Remove a project from the employee\u0026#39;s project list. :param project: string representing the project name :return: True if project was removed, False if not found \u0026#34;\u0026#34;\u0026#34; if project in self.__projects: self.__projects.remove(project) return True return False @property def project_count(self): return len(self.__projects) def __str__(self): return f\u0026#34;Employee: {self.__name}, Salary: ${self.__salary}, Projects: {self.project_count}\u0026#34; # Usage emp = Employee(\u0026#34;John Doe\u0026#34;, 50000) print(emp.name) # Output: John Doe print(emp.salary) # Output: 50000 emp.add_project(\u0026#34;Project A\u0026#34;) emp.add_project(\u0026#34;Project B\u0026#34;) print(emp.project_count) # Output: 2 emp.salary = 55000 print(emp) # Output: Employee: John Doe, Salary: $55000, Projects: 2 emp.remove_project(\u0026#34;Project A\u0026#34;) print(emp.project_count) # Output: 1 # This will raise an AttributeError # print(emp.__projects) This example demonstrates:\nPrivate attributes (__name, __salary, __projects) Properties for controlled access (name, salary, project_count) Public methods for manipulating private data (add_project, remove_project) Clear documentation of method behaviour A custom __str__ method for a nice string representation of the object By following these practices, we create a class that is both flexible and robust, embodying the principle of encapsulation.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/the-four-pillars-encapsulation/","section":"Programming","summary":"","title":"The Four Pillars: Encapsulation","type":"programming"},{"content":"Key aspects of inheritance include:\nCode reusability: Inheritance allows us to reuse code from existing classes, reducing redundancy and promoting efficient development. Hierarchical classification: It enables the creation of class hierarchies, representing relationships and commonalities among objects. Extensibility: New functionality can be added to existing classes without modifying them, following the open-closed principle. Polymorphism: Inheritance is a prerequisite for runtime polymorphism (which we\u0026rsquo;ll discuss in detail later). Types of inheritance # There are several types of inheritance, though not all programming languages support all types. The main types are:\nSingle inheritance: A derived class inherits from a single base class. Multiple inheritance: A derived class inherits from multiple base classes. Multilevel inheritance: A derived class inherits from another derived class. Hierarchical inheritance: Multiple derived classes inherit from a single base class. Hybrid inheritance: A combination of two or more types of inheritance. Python supports all these types of inheritance. Let\u0026rsquo;s explore each with examples.\nSingle inheritance # Single inheritance is the simplest form of inheritance, where a class inherits from one base class.\nclass Animal: def __init__(self, species): self.species = species def make_sound(self): pass class Dog(Animal): def __init__(self, name): super().__init__(\u0026#34;Canine\u0026#34;) self.name = name def make_sound(self): return \u0026#34;Woof!\u0026#34; # Usage dog = Dog(\u0026#34;Buddy\u0026#34;) print(f\u0026#34;{dog.name} is a {dog.species}\u0026#34;) # Output: Buddy is a Canine print(dog.make_sound()) # Output: Woof! In this example:\nAnimal is the base class with a generic make_sound method. Dog is derived from Animal, inheriting its attributes and methods. Dog overrides the make_sound method with its own implementation. We use super().__init__() to call the initialiser of the base class. Multiple inheritance # Multiple inheritance allows a class to inherit from multiple base classes.\nclass Flyer: def fly(self): return \u0026#34;I can fly!\u0026#34; class Swimmer: def swim(self): return \u0026#34;I can swim!\u0026#34; class Duck(Animal, Flyer, Swimmer): def __init__(self, name): Animal.__init__(self, \u0026#34;Aves\u0026#34;) self.name = name def make_sound(self): return \u0026#34;Quack!\u0026#34; # Usage duck = Duck(\u0026#34;Donald\u0026#34;) print(f\u0026#34;{duck.name} is a {duck.species}\u0026#34;) # Output: Donald is a Aves print(duck.make_sound()) # Output: Quack! print(duck.fly()) # Output: I can fly! print(duck.swim()) # Output: I can swim! Here, Duck inherits from Animal, Flyer, and Swimmer, combining attributes and methods from all three.\nMultilevel inheritance # In multilevel inheritance, a derived class inherits from another derived class.\nclass Mammal(Animal): def __init__(self, species, is_warm_blooded=True): super().__init__(species) self.is_warm_blooded = is_warm_blooded def give_birth(self): return \u0026#34;Giving birth to live young\u0026#34; class Cat(Mammal): def __init__(self, name): super().__init__(\u0026#34;Feline\u0026#34;) self.name = name def make_sound(self): return \u0026#34;Meow!\u0026#34; # Usage cat = Cat(\u0026#34;Whiskers\u0026#34;) print(f\u0026#34;{cat.name} is a {cat.species}\u0026#34;) # Output: Whiskers is a Feline print(cat.make_sound()) # Output: Meow! print(cat.give_birth()) # Output: Giving birth to live young print(f\u0026#34;Is warm-blooded: {cat.is_warm_blooded}\u0026#34;) # Output: Is warm-blooded: True In this example, Cat inherits from Mammal, which in turn inherits from Animal, forming a multilevel inheritance chain.\nHierarchical inheritance # Hierarchical inheritance involves multiple derived classes inheriting from a single base class.\nclass Bird(Animal): def __init__(self, species, can_fly=True): super().__init__(species) self.can_fly = can_fly class Parrot(Bird): def __init__(self, name): super().__init__(\u0026#34;Psittacine\u0026#34;, can_fly=True) self.name = name def make_sound(self): return \u0026#34;Squawk!\u0026#34; class Penguin(Bird): def __init__(self, name): super().__init__(\u0026#34;Spheniscidae\u0026#34;, can_fly=False) self.name = name def make_sound(self): return \u0026#34;Honk!\u0026#34; # Usage parrot = Parrot(\u0026#34;Polly\u0026#34;) penguin = Penguin(\u0026#34;Pingu\u0026#34;) print(f\u0026#34;{parrot.name} can fly: {parrot.can_fly}\u0026#34;) # Output: Polly can fly: True print(f\u0026#34;{penguin.name} can fly: {penguin.can_fly}\u0026#34;) # Output: Pingu can fly: False Here, both Parrot and Penguin inherit from Bird, which demonstrates hierarchical inheritance.\nHybrid inheritance # Hybrid inheritance is a combination of multiple inheritance types. Let\u0026rsquo;s create a more complex example to illustrate this:\nclass Terrestrial: def walk(self): return \u0026#34;Walking on land\u0026#34; class Aquatic: def swim(self): return \u0026#34;Swimming in water\u0026#34; class Amphibian(Animal, Terrestrial, Aquatic): def __init__(self, species): Animal.__init__(self, species) def adapt(self): return \u0026#34;Can survive both on land and in water\u0026#34; class Frog(Amphibian): def __init__(self, name): super().__init__(\u0026#34;Anura\u0026#34;) self.name = name def make_sound(self): return \u0026#34;Ribbit!\u0026#34; # Usage frog = Frog(\u0026#34;Kermit\u0026#34;) print(f\u0026#34;{frog.name} is a {frog.species}\u0026#34;) # Output: Kermit is a Anura print(frog.make_sound()) # Output: Ribbit! print(frog.walk()) # Output: Walking on land print(frog.swim()) # Output: Swimming in water print(frog.adapt()) # Output: Can survive both on land and in water This example demonstrates hybrid inheritance:\nFrog inherits from Amphibian Amphibian inherits from Animal, Terrestrial, and Aquatic This creates a combination of multilevel and multiple inheritance Considerations # Inheritance offers several advantages. However, there are also important considerations:\nComplexity: Deep inheritance hierarchies can become difficult to understand and maintain. Tight coupling: Inheritance creates a tight coupling between base and derived classes. Fragile base class problem: Changes in the base class can unexpectedly affect derived classes. Diamond problem: In multiple inheritance, conflicts can arise if two base classes have methods with the same name. To address these considerations:\nPrefer composition over inheritance when possible. Keep inheritance hierarchies shallow and focused. Use abstract base classes to define clear interfaces. Be cautious with multiple inheritance and resolve conflicts explicitly. Let\u0026rsquo;s visualise the inheritance relationships we\u0026rsquo;ve discussed using an UML class diagram:\nclassDiagram Animal \u003c|-- Mammal Animal \u003c|-- Bird Mammal \u003c|-- Dog Mammal \u003c|-- Cat Bird \u003c|-- Parrot Bird \u003c|-- Penguin Animal \u003c|-- Amphibian Terrestrial \u003c|-- Amphibian Aquatic \u003c|-- Amphibian Amphibian \u003c|-- Frog class Animal { +species: str +make_sound() } class Mammal { +is_warm_blooded: bool +give_birth() } class Bird { +can_fly: bool } class Amphibian { +adapt() } class Terrestrial { +walk() } class Aquatic { +swim() } end This diagram illustrates the inheritance relationships between the classes we\u0026rsquo;ve discussed, showing both single and multiple inheritance.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/the-four-pillars-inheritance/","section":"Programming","summary":"","title":"The Four Pillars: Inheritance","type":"programming"},{"content":"Polymorphism enables writing flexible and reusable code by allowing us to work with objects at a more abstract level, without needing to know their specific types.\nThere are two main types of polymorphism in object-oriented programming:\nCompile-time polymorphism (Static polymorphism)\nAchieved through method overloading. Resolved at compile time. Runtime polymorphism (Dynamic polymorphism)\nAchieved through method overriding. Resolved at runtime. Python primarily supports runtime polymorphism, as it is a dynamically typed language. However, we can demonstrate concepts similar to compile-time polymorphism as well.\nLet\u0026rsquo;s explore different aspects of polymorphism in Python:\nDuck typing # Python uses duck typing, which is a form of polymorphism. The idea is: \u0026ldquo;If it walks like a duck and quacks like a duck, then it must be a duck.\u0026rdquo; In other words, Python cares more about the methods an object has than the type of the object itself.\nclass Duck: def speak(self): return \u0026#34;Quack quack!\u0026#34; class Dog: def speak(self): return \u0026#34;Woof woof!\u0026#34; class Cat: def speak(self): return \u0026#34;Meow meow!\u0026#34; def animal_sound(animal): return animal.speak() # Usage duck = Duck() dog = Dog() cat = Cat() print(animal_sound(duck)) # Output: Quack quack! print(animal_sound(dog)) # Output: Woof woof! print(animal_sound(cat)) # Output: Meow meow! In this example, animal_sound() works with any object that has a speak() method, regardless of its class.\nMethod overriding # Method overriding is a key aspect of runtime polymorphism. It occurs when a derived class defines a method with the same name as a method in its base class.\nclass Shape: def area(self): pass class Rectangle(Shape): def __init__(self, width, height): self.width = width self.height = height def area(self): return self.width * self.height class Circle(Shape): def __init__(self, radius): self.radius = radius def area(self): return 3.14159 * self.radius ** 2 # Usage shapes = [Rectangle(5, 4), Circle(3)] for shape in shapes: print(f\u0026#34;Area: {shape.area()}\u0026#34;) # Output: # Area: 20 # Area: 28.27431 Here, Rectangle and Circle both override the area() method of the Shape class.\nOperator overloading # Python allows operator overloading, which is a form of compile-time polymorphism. It allows the same operator to have different meanings depending on the operands.\nclass Vector: def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): return Vector(self.x + other.x, self.y + other.y) def __str__(self): return f\u0026#34;Vector({self.x}, {self.y})\u0026#34; # Usage v1 = Vector(2, 3) v2 = Vector(3, 4) v3 = v1 + v2 print(v3) # Output: Vector(5, 7) Here, we\u0026rsquo;ve overloaded the + operator for our Vector class.\nAbstract base classes # Python\u0026rsquo;s abc module provides infrastructure for defining abstract base classes, which are a powerful way to define interfaces in Python.\nfrom abc import ABC, abstractmethod class Animal(ABC): @abstractmethod def make_sound(self): pass class Dog(Animal): def make_sound(self): return \u0026#34;Woof!\u0026#34; class Cat(Animal): def make_sound(self): return \u0026#34;Meow!\u0026#34; # Usage def animal_sound(animal): return animal.make_sound() dog = Dog() cat = Cat() print(animal_sound(dog)) # Output: Woof! print(animal_sound(cat)) # Output: Meow! # This will raise a TypeError # animal = Animal() Abstract base classes cannot be instantiated and force derived classes to implement certain methods, ensuring a consistent interface.\nReal-world Applications # Polymorphism is widely used in real-world applications:\nGUI frameworks: Different widgets (buttons, text boxes) can respond to common events (click, hover) in their own ways. Database interfaces: Different database systems can implement a common interface for querying, allowing applications to work with various databases without changing code. Plugin systems: Applications can work with plugins through a common interface, regardless of the specific implementation of each plugin. Game development: Different game entities can share common behaviors (move, collide) but implement them differently. Here\u0026rsquo;s a simple example of a plugin system:\nclass Plugin(ABC): @abstractmethod def process(self, data): pass class UppercasePlugin(Plugin): def process(self, data): return data.upper() class ReversePlugin(Plugin): def process(self, data): return data[::-1] class Application: def __init__(self): self.plugins = [] def add_plugin(self, plugin): self.plugins.append(plugin) def process_data(self, data): for plugin in self.plugins: data = plugin.process(data) return data # Usage app = Application() app.add_plugin(UppercasePlugin()) app.add_plugin(ReversePlugin()) result = app.process_data(\u0026#34;Hello, World!\u0026#34;) print(result) # Output: !DLROW ,OLLEH This example demonstrates how polymorphism allows the Application class to work with different plugins through a common interface.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/the-four-pillars-polymorphism/","section":"Programming","summary":"","title":"The Four Pillars: Polymorphism","type":"programming"},{"content":"Key aspects of abstraction include:\nSimplification: Abstraction reduces complexity by hiding unnecessary details. Focusing on essential features: It emphasises what an object does rather than how it does it. Separation of concerns: It allows separating the interface of a class from its implementation. Modularity: Abstraction promotes modular design by defining clear boundaries between components. Abstract classes and interfaces # In many object-oriented languages, abstraction is implemented through abstract classes and interfaces. While Python doesn\u0026rsquo;t have a built-in interface concept, we can achieve similar functionality using abstract base classes. Python\u0026rsquo;s abc module provides infrastructure for defining abstract base classes:\nfrom abc import ABC, abstractmethod class Shape(ABC): @abstractmethod def area(self): pass @abstractmethod def perimeter(self): pass class Rectangle(Shape): def __init__(self, width, height): self.width = width self.height = height def area(self): return self.width * self.height def perimeter(self): return 2 * (self.width + self.height) class Circle(Shape): def __init__(self, radius): self.radius = radius def area(self): return 3.14159 * self.radius ** 2 def perimeter(self): return 2 * 3.14159 * self.radius # Usage # shapes = [Shape()] # This would raise TypeError shapes = [Rectangle(5, 4), Circle(3)] for shape in shapes: print(f\u0026#34;Area: {shape.area()}, Perimeter: {shape.perimeter()}\u0026#34;) # Output: # Area: 20, Perimeter: 18 # Area: 28.27431, Perimeter: 18.84954 In this example:\nShape is an abstract base class that defines the interface for all shapes. Rectangle and Circle are concrete classes that implement the Shape interface. We can\u0026rsquo;t instantiate Shape directly, but we can use it as a common type for all shapes. Implementing abstraction in Python # While abstract base classes provide a formal way to define interfaces in Python, abstraction can also be achieved through convention and documentation. Here\u0026rsquo;s an example of abstraction without using ABC:\nclass Database: def connect(self): raise NotImplementedError(\u0026#34;Subclass must implement abstract method\u0026#34;) def execute(self, query): raise NotImplementedError(\u0026#34;Subclass must implement abstract method\u0026#34;) class MySQLDatabase(Database): def connect(self): print(\u0026#34;Connecting to MySQL database...\u0026#34;) def execute(self, query): print(f\u0026#34;Executing MySQL query: {query}\u0026#34;) class PostgreSQLDatabase(Database): def connect(self): print(\u0026#34;Connecting to PostgreSQL database...\u0026#34;) def execute(self, query): print(f\u0026#34;Executing PostgreSQL query: {query}\u0026#34;) def perform_database_operation(database): database.connect() database.execute(\u0026#34;SELECT * FROM users\u0026#34;) # Usage mysql_db = MySQLDatabase() postgres_db = PostgreSQLDatabase() perform_database_operation(mysql_db) perform_database_operation(postgres_db) # Output: # Connecting to MySQL database... # Executing MySQL query: SELECT * FROM users # Connecting to PostgreSQL database... # Executing PostgreSQL query: SELECT * FROM users In this example:\nDatabase is an abstract base class (though not using ABC) that defines the interface for all database types. MySQLDatabase and PostgreSQLDatabase are concrete implementations. perform_database_operation works with any object that adheres to the Database interface. Design principles and patterns # Abstraction is a key component of several important design principles and patterns:\nSOLID Principles:\nSingle Responsibility Principle (SRP). Open/Closed Principle (OCP). Liskov Substitution Principle (LSP). Interface Segregation Principle (ISP). Dependency Inversion Principle (DIP). Design Patterns:\nFactory method pattern. Abstract factory pattern. Strategy pattern. Template method pattern. Let\u0026rsquo;s implement the Strategy Pattern as an example:\nfrom abc import ABC, abstractmethod class SortStrategy(ABC): @abstractmethod def sort(self, data): pass class BubbleSort(SortStrategy): def sort(self, data): print(\u0026#34;Performing bubble sort\u0026#34;) return sorted(data) # Using Python\u0026#39;s built-in sort for simplicity class QuickSort(SortStrategy): def sort(self, data): print(\u0026#34;Performing quick sort\u0026#34;) return sorted(data) # Using Python\u0026#39;s built-in sort for simplicity class Sorter: def __init__(self, strategy): self.strategy = strategy def sort(self, data): return self.strategy.sort(data) # Usage data = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] bubble_sorter = Sorter(BubbleSort()) print(bubble_sorter.sort(data)) quick_sorter = Sorter(QuickSort()) print(quick_sorter.sort(data)) # Output: # Performing bubble sort # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Performing quick sort # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] This Strategy Pattern example demonstrates how abstraction allows us to define a family of algorithms, encapsulate each one, and make them interchangeable. The Sorter class doesn\u0026rsquo;t need to know the details of how each sorting algorithm works; it just knows that it can call the sort method on any SortStrategy object.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 October 2024","externalUrl":null,"permalink":"/en/programming/oop/the-four-pillars-abstraction/","section":"Programming","summary":"","title":"The Four Pillars: Abstraction","type":"programming"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/series/data-structures/","section":"Series","summary":"","title":"Data Structures","type":"series"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/series/estructuras-de-datos/","section":"Series","summary":"","title":"Estructuras De Datos","type":"series"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/authors/jnonino/","section":"Authors","summary":"","title":"Jnonino","type":"authors"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/","section":"Learn-Software.com","summary":"","title":"Learn-Software.com","type":"page"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/series/object-oriented-programming/","section":"Series","summary":"","title":"Object-Oriented Programming","type":"series"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/series/programaci%C3%B3n/","section":"Series","summary":"","title":"Programación","type":"series"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/series/programaci%C3%B3n-orientada-a-objetos/","section":"Series","summary":"","title":"Programación Orientada a Objetos","type":"series"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/series/programming/","section":"Series","summary":"","title":"Programming","type":"series"},{"content":"","date":"04 August 2025","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"03 August 2025","externalUrl":null,"permalink":"/series/introducci%C3%B3n-a-la-programaci%C3%B3n/","section":"Series","summary":"","title":"Introducción a La Programación","type":"series"},{"content":"","date":"03 August 2025","externalUrl":null,"permalink":"/en/series/introduction-to-programming/","section":"Series","summary":"","title":"Introduction to Programming","type":"series"},{"content":"","date":"30 September 2023","externalUrl":null,"permalink":"/series/conceptos-iniciales/","section":"Series","summary":"","title":"Conceptos Iniciales","type":"series"},{"content":"","date":"30 September 2023","externalUrl":null,"permalink":"/en/series/starting-concepts/","section":"Series","summary":"","title":"Starting Concepts","type":"series"},{"content":"Continuous Delivery (CD) is deeply rooted in the first principle of the Agile Manifesto posted in 20011:\nOur highest priority is to satisfy the customer through early and continuous delivery of valuable software.\nAccording to Martin Fowler2, a project is truly embracing Continuous Delivery when:\nThe software can be deployed at any stage of its lifecycle. The team values keeping the software deployment-ready over adding new features. Any software version can be deployed to any environment on-demand. In many ways, Continuous Delivery is the next step from Continuous Integration, seamlessly automating processes all the way to the software\u0026rsquo;s end user.\nMuch like in Continuous Integration, the pipeline stands as the cornerstone of Continuous Delivery. However, it\u0026rsquo;s not just about integrating code, testing it, and generating a deliverable artifact. With CD, this artifact progresses through a series of test phases in environments that increasingly resemble production settings. After passing through the Continuous Integration pipeline, what emerges is a potentially deployable artifact. CD then takes this artifact and puts it through the necessary tests, ensuring it\u0026rsquo;s primed for a live deployment.\nThe delivery process # The following figure illustrates the fundamental steps of a Continuous Delivery (CD) process. It\u0026rsquo;s vital to note that an effective CD process presupposes a well-oiled Continuous Integration (CI) system as its foundation.\nFigure 1: CD process flowchart The CD process adds two distinct phases to the CI system: deployment stages and system validation and verification testing. A critical premise is that the deployment process is paramount to product delivery. Thus, automating and frequently testing it is essential. Ideally, testing should also be automated to facilitate execution, especially if you aim for Continuous Deployment. However, it\u0026rsquo;s not imperative to automate all tests, especially at the beginning of the CD process implementation.\nUpon creating a potentially deliverable artifact in the CI pipeline, the initial step is to deploy it in a testing or QA environment. The primary goal of this environment is to offer a space where software tests, both automatic and manual, can be run. The only possible variations between the QA and actual production environment (the one used by customers) may pertain to its capacity or resource size. This scaled-down capacity, whether in processing, memory, storage, or database size, is typically a cost-saving measure.\nIf system and acceptance tests are successful in the QA environment, the next phase is to deploy the artifact in a staging environment. This environment should be an exact replica of the production setting. Its purpose is to facilitate performance and load testing on the system, effectively putting it under stress to validate its functionality under high loads and assess its processing and response times.\nWhen the previous tests are satisfactory, the artifact is ready to be deployed in a production environment. This space is also referred to as the live environment, where users interact with the system.\nAs evident, the product deployment method is exercised at least twice before the final production deployment, considerably reducing risks associated with potential errors as the final delivery approaches.\nCore principles and practices # One of CD\u0026rsquo;s primary objectives is to boost delivery frequency. This naturally means that each release should minimize its size. A smaller delivery not only implies fewer potential errors but also facilitates their identification and resolution2. To achieve this, the code must always be in a deploy-ready state.\nRapid automated testing is crucial for today\u0026rsquo;s software development3. In the context of CD, automated tests are of utmost importance as they must ensure comprehensive system quality without hampering the delivery cycle\u0026rsquo;s speed4. Lengthy test runs force the team to await results, leading to wasted time3. If these tests aren\u0026rsquo;t parallelized and optimized, developers may start sidelining them5. To ensure test optimization, it\u0026rsquo;s recommended to fail tests that exceed a reasonable limit6.\nThe software should always be potentially deliverable. It\u0026rsquo;s essential for the software\u0026rsquo;s build status to remain \u0026lsquo;green\u0026rsquo; consistently. This means if a new repository commit breaks the build, this error must be rectified before any new commit is made. Adhering to this practice simplifies error tracing, while deviating may condition developers to overlook a broken or \u0026lsquo;red\u0026rsquo; build6. Broken builds signify product flaws and render it undeliverable.\nIn using CD, the aim is to ensure each commit results in a production-ready artifact. If this artifact is rebuilt at every process stage, there\u0026rsquo;s no guarantee of their identical nature, and validation and verification test results from one artifact cannot be applied to others. This could lead to deploying untested artifacts6. Hence, artifacts should be produced only once and undergo all tests on that single artifact before deploying that very software piece to production.\nSoftware should always be deployed identically across all environments. Otherwise, there\u0026rsquo;s no assurance of the deployment process\u0026rsquo;s efficacy. If environment differences exist, they should be managed using configuration files, but the deployment process should remain consistent6.\nDeployment should be achievable with a mere button press. The ability to deploy the latest product version anytime with a single button press is a robust indicator of CD implementation2. This not only requires the aforementioned steps but also mandates version-controlled software deployment scripts that are regularly checked and validated6.\nAs mentioned earlier, CD\u0026rsquo;s main objective is to ascertain the product\u0026rsquo;s readiness post each commit2. For this, aside from ensuring a swift compilation and testing process, process outcomes should be visible and shared with the team. Display screens showcasing the current status, build times, test coverage, and more, offer a way to maintain constant visibility6. Presenting these results not only supports CD but, as some authors suggest, also bolsters team motivation4.\nBenefits of Continuous Delivery # With the rise of Continuous Delivery (CD) practices, businesses are realizing numerous advantages:\nSwift value delivery: the adoption of CD practices facilitates a faster rollout of features and error rectifications to end users7. This speed is attributed to the code becoming potentially deployable to users as it traverses through the Continuous Integration (CI) pipeline4.\nDiminished delivery failures: frequent releases lead to fewer delivery risks since each release embodies fewer changes. This, in turn, means there\u0026rsquo;s a reduced margin for errors2. Even if an error emerges, its origin is easier to trace and correct. Plus, reverting to a previous version in the face of complications becomes straightforward8. A delightful by-product of this streamlined process is the diminished stress levels amongst stakeholders7 5. Furthermore, the consistency and quality in the delivery process cement trust between the development team and clients7.\nProductivity amplification: Chen\u0026rsquo;s study reveals that, in the absence of CD practices, teams spent nearly \\(20%\\) of their time setting up and maintaining environments7. The introduction of CD automates this ordeal, which translates to heightened productivity by phasing out manual, non-value-add tasks6.\nPrompt feedback: a consensus among experts highlights the value of early feedback during the development phase2 7 4. Regular releases not only fetch this feedback promptly but also ensure that the developed product aligns seamlessly with customer requirements2. The agility to swiftly address customer needs, fix reported bugs, and introduce demanded features can significantly elevate customer satisfaction4.\nEnhanced software quality: the rigorous automation of software tests (unit, integration, and system), essential for implementing CD, combined with more frequent software deliveries encapsulating fewer changes, culminates in a notable boost in software quality4.\nTransparency in progress: thanks to frequent releases, clients find it easier to stay abreast of the latest product updates, embracing novel features and bug fixes with open arms.\nChallenges in adopting Continuous Delivery # The journey to incorporate Continuous Delivery (CD) isn’t without its hurdles. Here\u0026rsquo;s a look at some of the key challenges faced by businesses:\nProduct complexity: certain products consist of myriad interconnected modules or possess dependencies with other projects. This can create bottlenecks when automating CD pipelines4. Such complexities might frustrate teams, pushing them to retain manual processes or longer integration procedures.\nTest suite creation: crafting a comprehensive test suite to ensure product quality is labour-intensive. All team members must allocate significant time to pen tests, which might require extra training. Besides, tests can be time-consuming, so the trick lies in devising effective yet swift tests4.\nLegacy code: systems that have been in development for an extended period and weren\u0026rsquo;t designed with automated testing in mind can pose a significant challenge. Transitioning such systems to CD is not only a technical endeavour but also a social and cultural shift4.\nEnvironmental discrepancies: all environments in the CI pipeline should mirror the production setting (\u0026lsquo;production-like\u0026rsquo;)6. If not, unforeseen errors can arise, demanding valuable time on non-value-add tasks4. Ensuring multiple deployment stages in similar environments means that the deployment process is tested repetitively.\nClient restrictions: not every client might desire or require a shortened product delivery cycle4. Such client limitations aren\u0026rsquo;t direct obstacles to CD implementation but play a pivotal role when aiming for Continuous Deployment. This could potentially sideline some CD benefits, like swift client feedback or minimal change deliveries. Moreover, the domain itself can act as a bottleneck. Software related to heavily-regulated sectors like healthcare and defence may find CD implementation challenging, if not nearly impossible4.\nTransparency and reporting: a successful CD adoption hinges on collaboration and transparency, introducing challenges tied to providing effective status reports to stakeholders9. This encompasses technical hurdles around automated report generation and analytics challenges to pinpoint essential information.\nResistance to change: any transformative change, like adopting CD, faces the innate human trait of resistance. Convincing the team to adapt to new practices and modify their workflow is a task. On a higher level, management might also be hesitant to experiment with fresh processes.\nContinuous Deployment # The notion of Continuous Deployment was popularized by Fitz10. The standout distinction between this method and Continuous Delivery (CD) is that, once the product is deemed ready for release, there\u0026rsquo;s no waiting for manual intervention to launch it into production11 6. If CD is properly executed, the step towards Continuous Deployment should demand no extra efforts from the development perspective8. In essence, the core difference lies in decision-making: with CD, releasing the product to production remains a business decision, whereas with Continuous Deployment, the launch is automated.\nIt\u0026rsquo;s worth noting that when we discuss CD, it inherently includes Continuous Delivery but may or may not encompass Continuous Deployment.\nReferences # ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIBbKWwWQESzQtuMvqa/V0GFc4I5fo/4xYPinLdLeCot/\nBeck, Kent, Mike Beedle, Arie van Bennekum, Alistair Cockburn, Ward Cunningham, Martin Fowler, James Grenning, Jim Highsmith, Andrew Hunt, Ron Jeffries, Jon Kern, Brian Marick, Robert C. Martin, Steve Mellor, Ken Schwaber, Jeff Sutherland, and Dave Thomas. Manifesto for Agile Software Development, 2001.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, Martin. Continuous Delivery, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUdd, Raoul. Adopting Continuous Delivery: A Case Study, 2016.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLeppanen, Marko, Simo Makinen, Max Pagels, Veli-Pekka Eloranta, Juha Itkonen, Mika V. Mantyla, and Tomi Mannisto. The highways and country roads to continuous deployment. IEEE Software, 32(2):64-72, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNeely, Steve, and Steve Stolt. Continuous delivery? Easy! Just change everything (well, maybe it is not that easy). Proceedings - AGILE 2013, pp.121-128, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez, and David Farley. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChen, Lianping. Continuous Delivery: Huge Benefits, but Challenges Too. IEEE Software, 32(2):50-54, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez. Continuous Delivery vs Continuous Deployment, 2010.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOlsson, Helena Holmstrom, Hiva Alahyari, and Jan Bosch. Climbing the \u0026ldquo;Stairway to Heaven\u0026rdquo; \u0026ndash; A Multiple-Case Study Exploring Barriers in the Transition from Agile Development towards Continuous Deployment of Software. 2012 38th Euromicro Conference on Software Engineering and Advanced Applications, pp.392-399, 2012.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFitz, Timothy. Continuous Deployment, 2009.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPulkkinen, Ville. Continuous Deployment of Software. Proceedings of Cloud-Based Software Engineering, pp.46-52, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"02 September 2023","externalUrl":null,"permalink":"/en/blog/continuous-delivery/","section":"Blog","summary":"","title":"Continuous Delivery","type":"blog"},{"content":"One of the most pivotal challenges in the realm of software development is effectively integrating changes 1. In a small-scale project steered by a single developer, this challenge might appear to be trivial. However, as the magnitude of the project escalates and more individuals join the development fold, the significance of seamless integration becomes paramount.\nHistorically, integration was often an afterthought, relegated to the tail end of the software development process 2. Postponing it to such a late stage not only amplifies the risk of complex, undetected errors but also heightens the tension as delivery dates loom.\nHowever, the paradigm shifted around the turn of the millennium. Continuous Integration (CI) was formally introduced in 2000 by Kent Beck as an intrinsic part of the \u0026lsquo;Extreme Programming\u0026rsquo; methodology 3. CI emphasizes the frequent and early-stage integration of code. By continuously amalgamating new code into the system, developers can gauge its impact promptly. This approach streamlines error detection, enabling developers to tackle issues as they emerge 2. The ability to tie an error to a specific code change reduces error complexity and promotes efficient troubleshooting. Today, CI has become an indispensable practice in software development projects 4.\nMartin Fowler, a luminary in the field, eloquently defined CI as:\nContinuous Integration is a software development practice where team members integrate their work frequently, typically multiple times a day. Each integration is verified by an automated build system that runs test suites to swiftly detect any integration anomalies. Teams adopting this methodology often witness a significant reduction in integration hiccups, empowering them to produce cohesive software at an accelerated pace2.\nBuilding upon Fowler’s definition, Duvall 5 underscored several vital facets:\nDevelopers must maintain a conducive local environment for code construction and testing, ensuring their updates do not disrupt the established integration. Team members should commit their code to the Version Control System (VCS) daily. The integration process must be undertaken on a distinct machine, aptly termed the CI server. Only builds that pass all tests can be deemed deliverable. Error resolution is of paramount importance. A central repository displaying build and test results—often a website—is essential. Most CI tools readily offer such platforms. Furthermore, Patrick Cauldwell 6 advocates for frequent and early integration. The rationale? The more regular the integration, the less overhead for the team down the line. He distilled the primary goals of CI into:\nEnsuring a consistently available, tested version of the product with the latest modifications. Keeping the team abreast of any integration issues as early as possible. The impetus behind CI is to maintain an error-free, tested product throughout the development life cycle. This avoids the pitfalls of a last-minute integration phase, which is often fraught with errors and consumes both time and resources. More crucially, if project components aren\u0026rsquo;t integrated during their development, there\u0026rsquo;s no guarantee they\u0026rsquo;ll gel cohesively in the final product 7.\nTechnical implementation of CI revolves around two core components: process automation and a system to showcase results, thereby fuelling the developmental feedback loop 7.\nIn summing up the tenets of CI, Martin Fowler 1 emphasizes:\nRetaining code in a singular repository. Streamlining software construction through automation. Implementing automated testing processes. Ensuring new code additions undergo integration and construction on the CI system\u0026rsquo;s machine. Keeping the build process agile and swift. Providing easy access to the product\u0026rsquo;s latest executable version. Ensuring product status transparency for all stakeholders. Elements of a CI system # A basic Continuous Integration (CI) pipeline initiates when a new code change is pushed to the repository. The CI server, linked to the repository, gets notified of every new change, subsequently downloading the latest version to initiate the integration process, which will be elaborated on in the subsequent section. Once completed, it communicates the system\u0026rsquo;s status to the team members.\nIn computer science, a \u0026ldquo;pipeline\u0026rdquo; refers to a sequence of processes or tasks linked such that the output of one becomes the input for the next.\nFigure 1: Basic elements of CI The system\u0026rsquo;s primary component consists of the developers. After making code modifications, they run tests locally and compile the code to ensure that they haven\u0026rsquo;t introduced new errors.\nAn essential part of every CI system is the Version Control System (VCS). It oversees the changes made to the code and other significant elements. This system establishes a unified access point for all source code, enabling the CI system to fetch the most recent version for integration. Most software development projects utilize a VCS even if they don\u0026rsquo;t implement CI processes.\nThe CI Server is responsible for initiating a new build (comprising both compilation and tests) every time a change is added to the repository. They offer configurations to simplify the creation of integration pipelines. Additionally, most come with a web interface to display the build status and previous results. Currently, numerous powerful options are available, both free and paid. It\u0026rsquo;s worth noting that the CI server should operate on a dedicated machine and not on team members\u0026rsquo; computers.\nThe CI server must automatically conduct software tests, source code analysis, and compile to produce the deliverable product. Therefore, build and test execution scripts are vital. These scripts outline the necessary steps to be executed. Popular tools for this purpose include Make, Ant, Maven, Gradle, among others.\nEvery CI system should have a notification mechanism to relay results to the team. This mechanism ensures that in the event of an error, the team becomes aware as soon as possible, enabling them to address the issue. While most CI tools offer a web interface to view results, they also support other notification methods like emails, messaging applications, etc.\nThe integration process # The figure below broadly illustrates the stages of the integration process taking place within the Continuous Integration (CI) system.\nFigure 2: CI process flowchart Initially, the system must retrieve the latest source code version each time a new change is pushed to the Version Control System (VCS). Two mechanisms facilitate this. The first involves setting up the CI server to periodically check the VCS for updates. The alternative is to establish a commit hook within the VCS, ensuring that the CI server receives notifications whenever changes are made.\nAfter obtaining the code, the CI server can be configured to scrutinize the source code for potential undetected errors, be they syntactic, logical, or patterns that might lead to faults. Various tools aid this process. For instance, Java boasts utilities like FindBugs, CheckStyle, and PMD, while Python has Pylint. JavaScript can be analysed with tools like JSLint or JSHint. An example of a code analysis criterion could be ensuring every developed method has a cyclomatic complexity8 under 10. By employing automated source code inspection, one can assess code correctness, spot duplicate portions, and expedite the time between error detection and rectification. While automated inspection might not catch every error, the results can approximate those of peer reviews, thereby lightening the team\u0026rsquo;s review load.\nThe subsequent step revolves around automated test execution on the product. This automation is paramount to successfully implementing a CI system. Thus, developers can confidently make alterations, knowing a robust testing framework safeguards against compromising existing functionalities. Some popular tools in this domain include Junit, JBehave, and Selenium, which not only facilitate test drafting but also generate comprehensive reports, often as visualizations or web pages. Several software testing levels exist, such as unit tests, integration tests, and system tests. In the CI pipeline context, the focus rests on automating unit and integration tests, with system tests\u0026rsquo; automation being recommended but not mandatory.\nOnce the tests pass, the CI pipeline advances to compiling the source code. During this phase, the source code morphs into one or multiple files or packages, ready for distribution and user execution. This process\u0026rsquo;s specifics hinge on the employed programming language. For instance, languages like Java necessitate code compilation, resulting in an executable. Conversely, languages like Python might involve stricter code structure checks without generating any binary files.\nThroughout this integration journey, the team should steadfastly adhere to three fundamental rules:\nLocally run tests and compile software before integrating it into the VCS to minimize error introduction chances (avoiding \u0026ldquo;breaking the build\u0026rdquo;). Avoid pushing new code to the VCS if the CI server flags errors (indicative of a \u0026ldquo;broken build\u0026rdquo;). Should the CI server report faults, code modifications should exclusively aim at rectifying them. Core principles and practices # Martin Fowler2 identifies a set of foundational elements intrinsic to every Continuous Integration (CI) system. While some of these have been touched upon earlier in this chapter, we will succinctly encapsulate them here for clarity:\nCentralized Code Repository: Retain all code within a singular, unified repository. Streamlined Compilation and Build Process: Entirely automate the compilation and construction workflows, negating manual intervention. Full-Spectrum Automated Testing: Ensure all software tests are automated, driving efficiency and precision. Daily Commitment: Encourage the team to consistently merge their changes to the repository on a daily basis. Stringent Integration Checks: Each alteration made to the Version Control System (VCS) undergoes rigorous integration processes within the CI system. Prompt Error Rectification: Should the CI system flag any issues (indicative of a \u0026ldquo;broken build\u0026rdquo;), immediate action is imperative. Either rectify the flaw or reverse the change to ensure the repository\u0026rsquo;s latest version remains operational. Swift CI Procedures: Aim to complete the CI process rapidly—ideally within 15 minutes or less. This approach ensures timely integration and facilitates the expedited delivery of results. Universal Access to Latest Executables: Always provide the team with access to the most recent executable or deliverable package, promoting transparency. Real-time Product Status Visibility: Grant every team member the ability to monitor the product\u0026rsquo;s status at any given moment, fostering informed decision-making. Benefits # The overarching consensus within the software community is that the implementation of a Continuous Integration (CI) process yields an array of substantial advantages. Duvall5 outlines these core benefits in his publication.\nRisk Mitigation: Adopting frequent integration minimizes project risks. It facilitates early detection of issues and offers a continuous snapshot of the product\u0026rsquo;s health. By identifying these issues early in the development cycle, there\u0026rsquo;s a consequent reduction in both the cost of fixes and the risk of releasing a subpar product. Furthermore, automated inspections provide real-time insights into the product\u0026rsquo;s size, code complexity, and other metrics. This automation diminishes the chance of human-induced errors.\nMinimization of Manual Repetitive Tasks: Automation curtails the need for recurring manual tasks such as compilation, inspection, test execution, and report generation. This efficiency not only leads to significant time and cost savings but also allows teams to focus on activities that directly enhance product value. It liberates team members to dedicate more time to addressing new requirements or rectifying existing product issues.\nOn-Demand Availability of a Functional Product: A hallmark of CI is its ability to deliver a functional software product at any given moment. This is invaluable for stakeholders, offering them a rapid glance into product development progress. By leveraging CI, errors can be swiftly detected and remedied soon after a new change is introduced. This is far more efficient than uncovering them close to the release date when they are more expensive and challenging to amend. Such issues, if left unchecked, can lead to delivery delays, unsatisfied clients, escalated costs, and more. This ties back to the concept of the \u0026ldquo;Broken Window Theory\u0026rdquo;9, which, in essence, postulates that a product marred by numerous issues or perceived disorder can demotivate teams from addressing them.\nEnhanced Project Transparency: Implementing CI augments visibility into the project, rendering the development process more transparent. It aids project management with up-to-the-minute information, making it straightforward to gauge product quality, error trends, and more.\nElevated Product Confidence: The CI environment bolsters confidence in the product. Team members gain immediate insights into the ramifications of their changes, enabling them to promptly rectify any emergent issues.\nChallenges # While Duvall5 has extolled the virtues of Continuous Integration (CI) in his works, he also highlights potential challenges that might deter development teams from embracing it fully or realizing its benefits.\nBias: A widespread misconception is that CI system implementation is exorbitant and would escalate development costs due to its prolonged setup and maintenance. Contrarily, most software development projects already involve phases like inspection, testing, compilation, and integration, even if they don’t explicitly use a CI system. A common refrain is that there\u0026rsquo;s insufficient time or funds for CI system implementation, but the reality is that far more resources are spent performing redundant manual tasks throughout the development cycle. Furthermore, an automated CI system is infinitely more manageable and consistent compared to disparate manual processes.\nDisruption Fears: Projects in advanced development stages often fret that integrating a CI system would overhaul their established workflows, spawning significant delays. It’s pivotal to recognize that CI system implementation can be incremental. Teams can address one integration stage at a time, gradually ramping up the integration frequency as confidence builds.\nOverwhelming Failed Integrations: When CI practices aren’t diligently applied, there\u0026rsquo;s a risk of encountering an excessive number of failed integrations or \u0026ldquo;broken builds.\u0026rdquo; This could stem from developers bypassing local tests before uploading their changes to the Version Control System (VCS). A surge in failed integrations can erode trust in the CI system, reminiscent of the \u0026ldquo;Broken Window Theory\u0026rdquo;9.\nPerceived Additional Costs: There\u0026rsquo;s an apprehension among organizations about incurring extra expenses either for procuring CI product licenses or securing hardware to support these systems. However, this expenditure pales in comparison to the latent costs of late-stage integrations, where issues are discovered near the release date, far removed from their inception. On a brighter note, the current landscape is rife with a myriad of free and open-source alternatives, obviating any additional costs.\nReferences # Continuous integration. ThoughtWorks, 2018.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, Martin. Continuous Integration. 2006.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBeck, Kent. Embrace Change with Extreme Programming. IEEE Computer Magazine, (c), 70-77. 1999.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRodriguez Pilar, Markkula, Jouni, Oivo, Markku, \u0026amp; Turula, Kimmo. Survey on agile and lean usage in Finnish software industry. In Proceedings of the ACM-IEEE international symposium on Empirical software engineering and measurement - ESEM \u0026lsquo;12 (p. 139). ACM Press. DOI: 10.1145/2372251.2372275. 2012.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDuvall, Paul M., Matyas, Steve, \u0026amp; Glover, Andrew. Continuous integration: improving software quality and reducing risk. Pearson Education, Inc., 2007.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCauldwell, Patrick. Code Leader: Using people, tools and processes to build successful software. Wiley Publishing, Inc., 2008.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez \u0026amp; Farley, David. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCyclomatic Complexity Explanation\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe Broken Window Theory in Software Development\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"19 August 2023","externalUrl":null,"permalink":"/en/blog/continuous-integration/","section":"Blog","summary":"","title":"Continuous Integration","type":"blog"},{"content":"","date":"10 August 2023","externalUrl":null,"permalink":"/en/series/software-engineering/","section":"Series","summary":"","title":"Software Engineering","type":"series"},{"content":"When we have created a commit locally but have not published it to the remote yet, we can use git reset to undo the commit and, if we wish, discard the changes. Although there are several options for git reset the most used are:\n--soft: Does not touch the index file or the working tree at all (but resets the head to , just like all modes do). This leaves all your changed files \u0026ldquo;Changes to be committed\u0026rdquo;, as git status would put it. --hard: Resets the index and working tree. Any changes to tracked files in the working tree since are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted. Git reset documentation {: style=\u0026ldquo;text-align: right;\u0026rdquo;}\nHere there is an example about using git reset. We start by changing a file and creating a commit with the change.\nbash-3.2$ cat README.md # Index 1 bash-3.2$ bash-3.2$ cat README.md # Index 1 2 bash-3.2$ bash-3.2$ git add README.md bash-3.2$ bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md\u0026#34; [main 3734fd5] Add number 2 in README.md 1 file changed, 1 insertion(+) git status shows there is one commit pending to be published.\nbash-3.2$ git status On branch main Your branch is ahead of \u0026#39;origin/main\u0026#39; by 1 commit. (use \u0026#34;git push\u0026#34; to publish your local commits) nothing to commit, working tree clean Using git reflog to see the history.\n3734fd5 (HEAD -\u0026gt; main) HEAD@{0}: commit: Add number 2 in README.md 866bfa8 (origin/main) HEAD@{1}: revert: Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; e2f6d08 HEAD@{2}: merge feature-1: Merge made by the \u0026#39;ort\u0026#39; strategy. 23644da HEAD@{3}: checkout: moving from feature-1 to main Now we can use git reset --soft \u0026lt;COMMIT_ID\u0026gt; to undo the commit but keep the changes.\nbash-3.2$ git reset --soft 866bfa8 bash-3.2$ bash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: README.md git log after using git reset\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. We create a new commit so we can test the git reset --hard command.\nbash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: README.md bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md - NEW COMMIT\u0026#34; [main 2e7193d] Add number 2 in README.md - NEW COMMIT 1 file changed, 1 insertion(+) git log now shows the new commit.\ncommit 2e7193db650b9ba0762fe73525df599a08f8577d (HEAD -\u0026gt; main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Thu Jan 19 08:32:57 2023 -0300 Add number 2 in README.md - NEW COMMIT commit 866bfa8a952d11240707ebfc87f3266034d42443 (origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. Now we can use git reset --hard \u0026lt;COMMIT_ID\u0026gt; to undo the commit and discard all the changes.\nbash-3.2$ git reset --hard 866bfa8 HEAD is now at 866bfa8 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; bash-3.2$ bash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean git log remains as it nothing had happened.\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. ","date":"18 January 2023","externalUrl":null,"permalink":"/en/blog/git-revert-local/","section":"Blog","summary":"","title":"Revert a local change in Git","type":"blog"},{"content":"When we realized that the last commit was a mistake but we already published it, the command to use is git revert \u0026lt;COMMIT_HASH\u0026gt;.\nFirst we need to locate the ID of the commit we want to revert, it can be done with git log or git reflog commands. Then, run the git revert \u0026lt;COMMIT_HASH\u0026gt; command using the ID obtained in the previous step. Use the options -e or --edit to edit the commit message if we like. Push our changes so the revert is available for everyone in our group. Reverting multiple commits # If we need to revert multiple commits we can revert them one by one using the --no-commit option in order to create a single revert commit at the end.\nImagine the history is like the following and we need to go back to COMMIT-3.\nCOMMIT-1 -\u0026gt; COMMIT-2 -\u0026gt; COMMIT-3 -\u0026gt; COMMIT-4 -\u0026gt; COMMIT-5 -\u0026gt; COMMIT-6 -\u0026gt; HEAD This sequence of commands will get our files to the version of COMMIT-3:\nbash-3.2$ git revert --no-commit COMMIT-6 bash-3.2$ git revert --no-commit COMMIT-5 bash-3.2$ git revert --no-commit COMMIT-4 bash-3.2$ git commit -m \u0026#34;Revert to version in COMMIT-3\u0026#34; bash-3.2$ git push Reverting a merge commit # -m parent-number, \u0026ndash;mainline parent-number\nUsually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.\nGit revert documentation {: style=\u0026ldquo;text-align: right;\u0026rdquo;}\nWhen we need to revert a merge commit git revert command needs to be run with the -m or --mainline option to indicate the parent number because a merge commit has more than one parent and Git does not know which parent was target branch and which was the branch with the changes that should be reverted.\nHere there is an example showing how to revert a merge commit.\nCreate the first commit in main branch.\nbash-3.2$ cat README.md # Index 1 bash-3.2$ bash-3.2$ git commit -m \u0026#34;Add number 1 in README.md - main branch\u0026#34; [main (root-commit) 23644da] Add number 1 in README.md - main branch 1 file changed, 3 insertions(+) create mode 100644 README.md bash-3.2$ bash-3.2$ git push -u origin main Enumerating objects: 3, done. Counting objects: 100% (3/3), done. Writing objects: 100% (3/3), 254 bytes | 254.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git * [new branch] main -\u0026gt; main branch \u0026#39;main\u0026#39; set up to track \u0026#39;origin/main\u0026#39;. bash-3.2$ The state of the README.md file in main branch.\nbash-3.2$git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 Branch feature-1 created and added one commit.\nbash-3.2$ git checkout -b feature-1 Switched to a new branch \u0026#39;feature-1\u0026#39; bash-3.2$ bash-3.2$ cat README.md # Index 1 2 bash-3.2$ bash-3.2$ git add README.md bash-3.2$ bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md - feature-1 branch\u0026#34; [feature-1 83ea1a3] Add number 2 in README.md - feature-1 branch 1 file changed, 1 insertion(+) bash-3.2$ bash-3.2$ git push --set-upstream origin feature-1 Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 292 bytes | 292.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 remote: remote: Create a pull request for \u0026#39;feature-1\u0026#39; on GitHub by visiting: remote: https://github.com/jnonino/test-repo/pull/new/feature-1 remote: To github.com:jnonino/test-repo.git * [new branch] feature-1 -\u0026gt; feature-1 branch \u0026#39;feature-1\u0026#39; set up to track \u0026#39;origin/feature-1\u0026#39;. bash-3.2$ The state of README.md in the feature-1 branch.\nbash-3.2$ git status On branch feature-1 Your branch is up to date with \u0026#39;origin/feature-1\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 2 Merge the feature-1 branch into the main branch.\nbash-3.2$ git checkout main Switched to branch \u0026#39;main\u0026#39; Your branch is up to date with \u0026#39;origin/main\u0026#39;. bash-3.2$ bash-3.2$ git merge --no-ff feature-1 Merge made by the \u0026#39;ort\u0026#39; strategy. README.md | 1 + 1 file changed, 1 insertion(+) bash-3.2$ bash-3.2$ git push Enumerating objects: 1, done. Counting objects: 100% (1/1), done. Writing objects: 100% (1/1), 233 bytes | 233.00 KiB/s, done. Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git 23644da..e2f6d08 main -\u0026gt; main bash-3.2$ Current state of README.md in main branch.\nbash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 2 git log after merging feature-1 into main branch.\ncommit e2f6d08d3b38a02a1c026cfb879f3131536757ac (HEAD -\u0026gt; main, origin/main) Merge: 23644da 83ea1a3 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:58:19 2023 -0300 Merge branch \u0026#39;feature-1\u0026#39; commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:53:38 2023 -0300 Add number 2 in README.md - feature-1 branch commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:48:37 2023 -0300 Add number 1 in README.md - main branch To revert the merge commit, as it was stated above we need to pay attention to the merge field.\nMerge: 23644da 83ea1a3 Running git revert e2f6d08 -m 1 will reinstate the tree as it was in 23644da, and git revert e2f6d08 -m 2 will set the tree as it was in 83ea1a3. In this example we would like to leave the main branch as it was before the merge commit. For doing that, we need to run git revert e2f6d08 -m 1.\nbash-3.2$ git revert e2f6d08 -m 1 [main 866bfa8] Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 1 file changed, 1 deletion(-) bash-3.2$ bash-3.2$ git status On branch main Your branch is ahead of \u0026#39;origin/main\u0026#39; by 1 commit. (use \u0026#34;git push\u0026#34; to publish your local commits) nothing to commit, working tree clean bash-3.2$ bash-3.2$ git push Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 344 bytes | 344.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git e2f6d08..866bfa8 main -\u0026gt; main git log after reverting the merge commit.\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. commit e2f6d08d3b38a02a1c026cfb879f3131536757ac Merge: 23644da 83ea1a3 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:58:19 2023 -0300 Merge branch \u0026#39;feature-1\u0026#39; commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:53:38 2023 -0300 Add number 2 in README.md - feature-1 branch commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:48:37 2023 -0300 Add number 1 in README.md - main branch Current state of README.md in main branch.\nbash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 ","date":"18 January 2023","externalUrl":null,"permalink":"/en/blog/git-revert-pushed/","section":"Blog","summary":"","title":"Revert a pushed change in Git","type":"blog"}]