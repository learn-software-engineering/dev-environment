[{"content":"","date":1693612800,"headings":[],"kind":"taxonomy","lang":"en","summary":"","title":"Authors","url":"/en/authors/","year":"2023"},{"content":"","date":1693612800,"headings":[],"kind":"section","lang":"en","summary":"","title":"Blog","url":"/en/blog/","year":"2023"},{"content":"","date":1693612800,"headings":[],"kind":"term","lang":"en","summary":"","title":"cd","url":"/en/tags/cd/","year":"2023"},{"authors":["Julián Nonino"],"content":"Continuous Delivery (CD) is deeply rooted in the first principle of the Agile Manifesto posted in 20011:\nOur highest priority is to satisfy the customer through early and continuous delivery of valuable software.\nAccording to Martin Fowler2, a project is truly embracing Continuous Delivery when:\nThe software can be deployed at any stage of its lifecycle. The team values keeping the software deployment-ready over adding new features. Any software version can be deployed to any environment on-demand. In many ways, Continuous Delivery is the next step from Continuous Integration, seamlessly automating processes all the way to the software\u0026rsquo;s end user.\nMuch like in Continuous Integration, the pipeline stands as the cornerstone of Continuous Delivery. However, it\u0026rsquo;s not just about integrating code, testing it, and generating a deliverable artifact. With CD, this artifact progresses through a series of test phases in environments that increasingly resemble production settings. After passing through the Continuous Integration pipeline, what emerges is a potentially deployable artifact. CD then takes this artifact and puts it through the necessary tests, ensuring it\u0026rsquo;s primed for a live deployment.\nThe delivery process The following figure illustrates the fundamental steps of a Continuous Delivery (CD) process. It\u0026rsquo;s vital to note that an effective CD process presupposes a well-oiled Continuous Integration (CI) system as its foundation.\nFigure 1: CD process flowchart\nThe CD process adds two distinct phases to the CI system: deployment stages and system validation and verification testing. A critical premise is that the deployment process is paramount to product delivery. Thus, automating and frequently testing it is essential. Ideally, testing should also be automated to facilitate execution, especially if you aim for Continuous Deployment. However, it\u0026rsquo;s not imperative to automate all tests, especially at the beginning of the CD process implementation.\nUpon creating a potentially deliverable artifact in the CI pipeline, the initial step is to deploy it in a testing or QA environment. The primary goal of this environment is to offer a space where software tests, both automatic and manual, can be run. The only possible variations between the QA and actual production environment (the one used by customers) may pertain to its capacity or resource size. This scaled-down capacity, whether in processing, memory, storage, or database size, is typically a cost-saving measure.\nIf system and acceptance tests are successful in the QA environment, the next phase is to deploy the artifact in a staging environment. This environment should be an exact replica of the production setting. Its purpose is to facilitate performance and load testing on the system, effectively putting it under stress to validate its functionality under high loads and assess its processing and response times.\nWhen the previous tests are satisfactory, the artifact is ready to be deployed in a production environment. This space is also referred to as the live environment, where users interact with the system.\nAs evident, the product deployment method is exercised at least twice before the final production deployment, considerably reducing risks associated with potential errors as the final delivery approaches.\nCore principles and practices One of CD\u0026rsquo;s primary objectives is to boost delivery frequency. This naturally means that each release should minimize its size. A smaller delivery not only implies fewer potential errors but also facilitates their identification and resolution2. To achieve this, the code must always be in a deploy-ready state.\nRapid automated testing is crucial for today\u0026rsquo;s software development3. In the context of CD, automated tests are of utmost importance as they must ensure comprehensive system quality without hampering the delivery cycle\u0026rsquo;s speed4. Lengthy test runs force the team to await results, leading to wasted time3. If these tests aren\u0026rsquo;t parallelized and optimized, developers may start sidelining them5. To ensure test optimization, it\u0026rsquo;s recommended to fail tests that exceed a reasonable limit6.\nThe software should always be potentially deliverable. It\u0026rsquo;s essential for the software\u0026rsquo;s build status to remain \u0026lsquo;green\u0026rsquo; consistently. This means if a new repository commit breaks the build, this error must be rectified before any new commit is made. Adhering to this practice simplifies error tracing, while deviating may condition developers to overlook a broken or \u0026lsquo;red\u0026rsquo; build6. Broken builds signify product flaws and render it undeliverable.\nIn using CD, the aim is to ensure each commit results in a production-ready artifact. If this artifact is rebuilt at every process stage, there\u0026rsquo;s no guarantee of their identical nature, and validation and verification test results from one artifact cannot be applied to others. This could lead to deploying untested artifacts6. Hence, artifacts should be produced only once and undergo all tests on that single artifact before deploying that very software piece to production.\nSoftware should always be deployed identically across all environments. Otherwise, there\u0026rsquo;s no assurance of the deployment process\u0026rsquo;s efficacy. If environment differences exist, they should be managed using configuration files, but the deployment process should remain consistent6.\nDeployment should be achievable with a mere button press. The ability to deploy the latest product version anytime with a single button press is a robust indicator of CD implementation2. This not only requires the aforementioned steps but also mandates version-controlled software deployment scripts that are regularly checked and validated6.\nAs mentioned earlier, CD\u0026rsquo;s main objective is to ascertain the product\u0026rsquo;s readiness post each commit2. For this, aside from ensuring a swift compilation and testing process, process outcomes should be visible and shared with the team. Display screens showcasing the current status, build times, test coverage, and more, offer a way to maintain constant visibility6. Presenting these results not only supports CD but, as some authors suggest, also bolsters team motivation4.\nBenefits of Continuous Delivery With the rise of Continuous Delivery (CD) practices, businesses are realizing numerous advantages:\nSwift value delivery: the adoption of CD practices facilitates a faster rollout of features and error rectifications to end users7. This speed is attributed to the code becoming potentially deployable to users as it traverses through the Continuous Integration (CI) pipeline4.\nDiminished delivery failures: frequent releases lead to fewer delivery risks since each release embodies fewer changes. This, in turn, means there\u0026rsquo;s a reduced margin for errors2. Even if an error emerges, its origin is easier to trace and correct. Plus, reverting to a previous version in the face of complications becomes straightforward8. A delightful byproduct of this streamlined process is the diminished stress levels amongst stakeholders7 5. Furthermore, the consistency and quality in the delivery process cement trust between the development team and clients7.\nProductivity amplification: Chen\u0026rsquo;s study reveals that, in the absence of CD practices, teams spent nearly \\(20%\\) of their time setting up and maintaining environments7. The introduction of CD automates this ordeal, which translates to heightened productivity by phasing out manual, non-value-add tasks6.\nPrompt feedback: a consensus among experts highlights the value of early feedback during the development phase2 7 4. Regular releases not only fetch this feedback promptly but also ensure that the developed product aligns seamlessly with customer requirements2. The agility to swiftly address customer needs, fix reported bugs, and introduce demanded features can significantly elevate customer satisfaction4.\nEnhanced software quality: the rigorous automation of software tests (unit, integration, and system), essential for implementing CD, combined with more frequent software deliveries encapsulating fewer changes, culminates in a notable boost in software quality4.\nTransparency in progress: thanks to frequent releases, clients find it easier to stay abreast of the latest product updates, embracing novel features and bug fixes with open arms.\nChallenges in adopting Continuous Delivery The journey to incorporate Continuous Delivery (CD) isn’t without its hurdles. Here\u0026rsquo;s a look at some of the key challenges faced by businesses:\nProduct complexity: certain products consist of myriad interconnected modules or possess dependencies with other projects. This can create bottlenecks when automating CD pipelines4. Such complexities might frustrate teams, pushing them to retain manual processes or longer integration procedures.\nTest suite creation: crafting a comprehensive test suite to ensure product quality is labor-intensive. All team members must allocate significant time to pen tests, which might require extra training. Besides, tests can be time-consuming, so the trick lies in devising effective yet swift tests4.\nLegacy code: systems that have been in development for an extended period and weren\u0026rsquo;t designed with automated testing in mind can pose a significant challenge. Transitioning such systems to CD is not only a technical endeavor but also a social and cultural shift4.\nEnvironmental discrepancies: all environments in the CI pipeline should mirror the production setting (\u0026lsquo;production-like\u0026rsquo;)6. If not, unforeseen errors can arise, demanding valuable time on non-value-add tasks4. Ensuring multiple deployment stages in similar environments means that the deployment process is tested repetitively.\nClient restrictions: not every client might desire or require a shortened product delivery cycle4. Such client limitations aren\u0026rsquo;t direct obstacles to CD implementation but play a pivotal role when aiming for Continuous Deployment. This could potentially sideline some CD benefits, like swift client feedback or minimal change deliveries. Moreover, the domain itself can act as a bottleneck. Software related to heavily-regulated sectors like healthcare and defense may find CD implementation challenging, if not nearly impossible4.\nTransparency and reporting: a successful CD adoption hinges on collaboration and transparency, introducing challenges tied to providing effective status reports to stakeholders9. This encompasses technical hurdles around automated report generation and analytics challenges to pinpoint essential information.\nResistance to change: any transformative change, like adopting CD, faces the innate human trait of resistance. Convincing the team to adapt to new practices and modify their workflow is a task. On a higher level, management might also be hesitant to experiment with fresh processes.\nContinuous Deployment The notion of Continuous Deployment was popularized by Fitz10. The standout distinction between this method and Continuous Delivery (CD) is that, once the product is deemed ready for release, there\u0026rsquo;s no waiting for manual intervention to launch it into production11 6. If CD is properly executed, the step towards Continuous Deployment should demand no extra efforts from the development perspective8. In essence, the core difference lies in decision-making: with CD, releasing the product to production remains a business decision, whereas with Continuous Deployment, the launch is automated.\nIt\u0026rsquo;s worth noting that when we discuss CD, it inherently includes Continuous Delivery but may or may not encompass Continuous Deployment.\nReferences Beck, Kent, Mike Beedle, Arie van Bennekum, Alistair Cockburn, Ward Cunningham, Martin Fowler, James Grenning, Jim Highsmith, Andrew Hunt, Ron Jeffries, Jon Kern, Brian Marick, Robert C. Martin, Steve Mellor, Ken Schwaber, Jeff Sutherland, and Dave Thomas. Manifesto for Agile Software Development, 2001.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, Martin. Continuous Delivery, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUdd, Raoul. Adopting Continuous Delivery: A Case Study, 2016.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLeppanen, Marko, Simo Makinen, Max Pagels, Veli-Pekka Eloranta, Juha Itkonen, Mika V. Mantyla, and Tomi Mannisto. The highways and country roads to continuous deployment. IEEE Software, 32(2):64-72, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNeely, Steve, and Steve Stolt. Continuous delivery? Easy! Just change everything (well, maybe it is not that easy). Proceedings - AGILE 2013, pp.121-128, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez, and David Farley. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChen, Lianping. Continuous Delivery: Huge Benefits, but Challenges Too. IEEE Software, 32(2):50-54, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez. Continuous Delivery vs Continuous Deployment, 2010.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOlsson, Helena Holmstrom, Hiva Alahyari, and Jan Bosch. Climbing the \u0026ldquo;Stairway to Heaven\u0026rdquo; \u0026ndash; A Multiple-Case Study Exploring Barriers in the Transition from Agile Development towards Continuous Deployment of Software. 2012 38th Euromicro Conference on Software Engineering and Advanced Applications, pp.392-399, 2012.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFitz, Timothy. Continuous Deployment, 2009.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPulkkinen, Ville. Continuous Deployment of Software. Proceedings of Cloud-Based Software Engineering, pp.46-52, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1693612800,"headings":[{"anchor":"benefits-of-continuous-delivery","title":"Benefits of Continuous Delivery"},{"anchor":"challenges-in-adopting-continuous-delivery","title":"Challenges in adopting Continuous Delivery"},{"anchor":"continuous-deployment","title":"Continuous Deployment"},{"anchor":"core-principles-and-practices","title":"Core principles and practices"},{"anchor":"references","title":"References"},{"anchor":"the-delivery-process","title":"The delivery process"}],"kind":"page","lang":"en","summary":"Here you can find information about Continuous Delivery, what is it, which benefits can you expect from it, the challenges you might face trying to adopted and so on.","tags":["cd","continuous-delivery","continuous-deployment"],"title":"Continuous Delivery","url":"/en/blog/2023/09/continuous-delivery/","year":"2023"},{"content":"","date":1693612800,"headings":[],"kind":"term","lang":"en","summary":"","title":"continuous-delivery","url":"/en/tags/continuous-delivery/","year":"2023"},{"content":"","date":1693612800,"headings":[],"kind":"term","lang":"en","summary":"","title":"continuous-deployment","url":"/en/tags/continuous-deployment/","year":"2023"},{"content":"I\u0026rsquo;m a computer engineer who has been thriving in the software industry since 2013. My entire career has been driven by an insatiable curiosity for software engineering practices and a relentless pursuit of ways to refine the development process. My journey has seen me wear many hats, including those of a Software Developer, Configuration Manager, Scrum Master, DevOps Engineer, DevOps Consultant, and Platform Engineer.\nWhat truly fuels my passion is not just the act of learning, but also the joy of sharing knowledge. This passion led me to the halls of academia, where I began my teaching journey with assistant positions in Physics courses during my early years at the university. My commitment to education did not stop there. After serving as a teacher\u0026rsquo;s assistant for several years, I eagerly applied for and secured a position as an adjunct professor in the specialized courses of Software Engineering and Software Quality Management.\nHowever, life is a journey filled with twists and opportunities. In 2020, I made the bittersweet decision to resign from my cherished adjunct professor role, as an exciting new chapter unfolded. A move to London beckoned, offering fresh horizons and the chance to immerse myself in a vibrant and innovative tech hub. Though I left a part of my heart in academia, the pursuit of excellence continues, and my passion for software engineering remains as strong as ever.\nJoin me as we explore the fascinating world of software engineering, a field that continues to evolve, inspire, and shape our future.\n","date":1693612800,"headings":[],"kind":"term","lang":"en","summary":"I’m a computer engineer who has been thriving in the software industry since 2013. My entire career has been driven by an insatiable curiosity for software engineering practices and a relentless pursuit of ways to refine the development process. My journey has seen me wear many hats, including those of a Software Developer, Configuration Manager, Scrum Master, DevOps Engineer, DevOps Consultant, and Platform Engineer.\nWhat truly fuels my passion is not just the act of learning, but also the joy of sharing knowledge.","title":"Julián Nonino","url":"/en/authors/jnonino/","year":"2023"},{"content":"","date":1693612800,"headings":[],"kind":"taxonomy","lang":"en","summary":"","title":"Tags","url":"/en/tags/","year":"2023"},{"content":"","date":1692403200,"headings":[],"kind":"term","lang":"en","summary":"","title":"ci","url":"/en/tags/ci/","year":"2023"},{"authors":["Julián Nonino"],"content":"One of the most pivotal challenges in the realm of software development is effectively integrating changes 1. In a small-scale project steered by a single developer, this challenge might appear to be trivial. However, as the magnitude of the project escalates and more individuals join the development fold, the significance of seamless integration becomes paramount.\nHistorically, integration was often an afterthought, relegated to the tail end of the software development process 2. Postponing it to such a late stage not only amplifies the risk of complex, undetected errors but also heightens the tension as delivery dates loom.\nHowever, the paradigm shifted around the turn of the millennium. Continuous Integration (CI) was formally introduced in 2000 by Kent Beck as an intrinsic part of the \u0026lsquo;Extreme Programming\u0026rsquo; methodology 3. CI emphasizes the frequent and early-stage integration of code. By continuously amalgamating new code into the system, developers can gauge its impact promptly. This approach streamlines error detection, enabling developers to tackle issues as they emerge 2. The ability to tie an error to a specific code change reduces error complexity and promotes efficient troubleshooting. Today, CI has become an indispensable practice in software development projects 4.\nMartin Fowler, a luminary in the field, eloquently defined CI as:\nContinuous Integration is a software development practice where team members integrate their work frequently, typically multiple times a day. Each integration is verified by an automated build system that runs test suites to swiftly detect any integration anomalies. Teams adopting this methodology often witness a significant reduction in integration hiccups, empowering them to produce cohesive software at an accelerated pace2.\nBuilding upon Fowler’s definition, Duvall 5 underscored several vital facets:\nDevelopers must maintain a conducive local environment for code construction and testing, ensuring their updates do not disrupt the established integration. Team members should commit their code to the Version Control System (VCS) daily. The integration process must be undertaken on a distinct machine, aptly termed the CI server. Only builds that pass all tests can be deemed deliverable. Error resolution is of paramount importance. A central repository displaying build and test results—often a website—is essential. Most CI tools readily offer such platforms. Furthermore, Patrick Cauldwell 6 advocates for frequent and early integration. The rationale? The more regular the integration, the less overhead for the team down the line. He distilled the primary goals of CI into:\nEnsuring a consistently available, tested version of the product with the latest modifications. Keeping the team abreast of any integration issues as early as possible. The impetus behind CI is to maintain an error-free, tested product throughout the development life cycle. This avoids the pitfalls of a last-minute integration phase, which is often fraught with errors and consumes both time and resources. More crucially, if project components aren\u0026rsquo;t integrated during their development, there\u0026rsquo;s no guarantee they\u0026rsquo;ll gel cohesively in the final product 7.\nTechnical implementation of CI revolves around two core components: process automation and a system to showcase results, thereby fueling the developmental feedback loop 7.\nIn summing up the tenets of CI, Martin Fowler 1 emphasizes:\nRetaining code in a singular repository. Streamlining software construction through automation. Implementing automated testing processes. Ensuring new code additions undergo integration and construction on the CI system\u0026rsquo;s machine. Keeping the build process agile and swift. Providing easy access to the product\u0026rsquo;s latest executable version. Ensuring product status transparency for all stakeholders. Elements of a CI system A basic Continuous Integration (CI) pipeline initiates when a new code change is pushed to the repository. The CI server, linked to the repository, gets notified of every new change, subsequently downloading the latest version to initiate the integration process, which will be elaborated on in the subsequent section. Once completed, it communicates the system\u0026rsquo;s status to the team members.\nIn computer science, a \u0026ldquo;pipeline\u0026rdquo; refers to a sequence of processes or tasks linked such that the output of one becomes the input for the next.\nFigure 1: Basic elements of CI (Duvall5)\nThe system\u0026rsquo;s primary component consists of the developers. After making code modifications, they run tests locally and compile the code to ensure that they haven\u0026rsquo;t introduced new errors.\nAn essential part of every CI system is the Version Control System (VCS). It oversees the changes made to the code and other significant elements. This system establishes a unified access point for all source code, enabling the CI system to fetch the most recent version for integration. Most software development projects utilize a VCS even if they don\u0026rsquo;t implement CI processes.\nThe CI Server is responsible for initiating a new build (comprising both compilation and tests) every time a change is added to the repository. They offer configurations to simplify the creation of integration pipelines. Additionally, most come with a web interface to display the build status and previous results. Currently, numerous powerful options are available, both free and paid. It\u0026rsquo;s worth noting that the CI server should operate on a dedicated machine and not on team members\u0026rsquo; computers.\nThe CI server must automatically conduct software tests, source code analysis, and compile to produce the deliverable product. Therefore, build and test execution scripts are vital. These scripts outline the necessary steps to be executed. Popular tools for this purpose include Make, Ant, Maven, Gradle, among others.\nEvery CI system should have a notification mechanism to relay results to the team. This mechanism ensures that in the event of an error, the team becomes aware as soon as possible, enabling them to address the issue. While most CI tools offer a web interface to view results, they also support other notification methods like emails, messaging applications, etc.\nThe integration process The figure below broadly illustrates the stages of the integration process taking place within the Continuous Integration (CI) system.\nFigure 2: CI process flowchart\nInitially, the system must retrieve the latest source code version each time a new change is pushed to the Version Control System (VCS). Two mechanisms facilitate this. The first involves setting up the CI server to periodically check the VCS for updates. The alternative is to establish a commit hook within the VCS, ensuring that the CI server receives notifications whenever changes are made.\nAfter obtaining the code, the CI server can be configured to scrutinize the source code for potential undetected errors, be they syntactic, logical, or patterns that might lead to faults. Various tools aid this process. For instance, Java boasts utilities like FindBugs, CheckStyle, and PMD, while Python has Pylint. JavaScript can be analyzed with tools like JSLint or JSHint. An example of a code analysis criterion could be ensuring every developed method has a cyclomatic complexity8 under 10. By employing automated source code inspection, one can assess code correctness, spot duplicate portions, and expedite the time between error detection and rectification. While automated inspection might not catch every error, the results can approximate those of peer reviews, thereby lightening the team\u0026rsquo;s review load.\nThe subsequent step revolves around automated test execution on the product. This automation is paramount to successfully implementing a CI system. Thus, developers can confidently make alterations, knowing a robust testing framework safeguards against compromising existing functionalities. Some popular tools in this domain include Junit, JBehave, and Selenium, which not only facilitate test drafting but also generate comprehensive reports, often as visualizations or web pages. Several software testing levels exist, such as unit tests, integration tests, and system tests. In the CI pipeline context, the focus rests on automating unit and integration tests, with system tests\u0026rsquo; automation being recommended but not mandatory.\nOnce the tests pass, the CI pipeline advances to compiling the source code. During this phase, the source code morphs into one or multiple files or packages, ready for distribution and user execution. This process\u0026rsquo;s specifics hinge on the employed programming language. For instance, languages like Java necessitate code compilation, resulting in an executable. Conversely, languages like Python might involve stricter code structure checks without generating any binary files.\nThroughout this integration journey, the team should steadfastly adhere to three fundamental rules:\nLocally run tests and compile software before integrating it into the VCS to minimize error introduction chances (avoiding \u0026ldquo;breaking the build\u0026rdquo;). Avoid pushing new code to the VCS if the CI server flags errors (indicative of a \u0026ldquo;broken build\u0026rdquo;). Should the CI server report faults, code modifications should exclusively aim at rectifying them. Core principles and practices Martin Fowler2 identifies a set of foundational elements intrinsic to every Continuous Integration (CI) system. While some of these have been touched upon earlier in this chapter, we will succinctly encapsulate them here for clarity:\nCentralized Code Repository: Retain all code within a singular, unified repository. Streamlined Compilation and Build Process: Entirely automate the compilation and construction workflows, negating manual intervention. Full-Spectrum Automated Testing: Ensure all software tests are automated, driving efficiency and precision. Daily Commitment: Encourage the team to consistently merge their changes to the repository on a daily basis. Stringent Integration Checks: Each alteration made to the Version Control System (VCS) undergoes rigorous integration processes within the CI system. Prompt Error Rectification: Should the CI system flag any issues (indicative of a \u0026ldquo;broken build\u0026rdquo;), immediate action is imperative. Either rectify the flaw or reverse the change to ensure the repository\u0026rsquo;s latest version remains operational. Swift CI Procedures: Aim to complete the CI process rapidly—ideally within 15 minutes or less. This approach ensures timely integration and facilitates the expedited delivery of results. Universal Access to Latest Executables: Always provide the team with access to the most recent executable or deliverable package, promoting transparency. Real-time Product Status Visibility: Grant every team member the ability to monitor the product\u0026rsquo;s status at any given moment, fostering informed decision-making. Benefits The overarching consensus within the software community is that the implementation of a Continuous Integration (CI) process yields an array of substantial advantages. Duvall5 outlines these core benefits in his publication.\nRisk Mitigation: Adopting frequent integration minimizes project risks. It facilitates early detection of issues and offers a continuous snapshot of the product\u0026rsquo;s health. By identifying these issues early in the development cycle, there\u0026rsquo;s a consequent reduction in both the cost of fixes and the risk of releasing a subpar product. Furthermore, automated inspections provide real-time insights into the product\u0026rsquo;s size, code complexity, and other metrics. This automation diminishes the chance of human-induced errors.\nMinimization of Manual Repetitive Tasks: Automation curtails the need for recurring manual tasks such as compilation, inspection, test execution, and report generation. This efficiency not only leads to significant time and cost savings but also allows teams to focus on activities that directly enhance product value. It liberates team members to dedicate more time to addressing new requirements or rectifying existing product issues.\nOn-Demand Availability of a Functional Product: A hallmark of CI is its ability to deliver a functional software product at any given moment. This is invaluable for stakeholders, offering them a rapid glance into product development progress. By leveraging CI, errors can be swiftly detected and remedied soon after a new change is introduced. This is far more efficient than uncovering them close to the release date when they are more expensive and challenging to amend. Such issues, if left unchecked, can lead to delivery delays, unsatisfied clients, escalated costs, and more. This ties back to the concept of the \u0026ldquo;Broken Window Theory\u0026rdquo;9, which, in essence, postulates that a product marred by numerous issues or perceived disorder can demotivate teams from addressing them.\nEnhanced Project Transparency: Implementing CI augments visibility into the project, rendering the development process more transparent. It aids project management with up-to-the-minute information, making it straightforward to gauge product quality, error trends, and more.\nElevated Product Confidence: The CI environment bolsters confidence in the product. Team members gain immediate insights into the ramifications of their changes, enabling them to promptly rectify any emergent issues.\nChallenges While Duvall5 has extolled the virtues of Continuous Integration (CI) in his works, he also highlights potential challenges that might deter development teams from embracing it fully or realizing its benefits.\nBias: A widespread misconception is that CI system implementation is exorbitant and would esecalate development costs due to its prolonged setup and maintenance. Contrarily, most software development projects already involve phases like inspection, testing, compilation, and integration, even if they don’t explicitly use a CI system. A common refrain is that there\u0026rsquo;s insufficient time or funds for CI system implementation, but the reality is that far more resources are spent performing redundant manual tasks throughout the development cycle. Furthermore, an automated CI system is infinitely more manageable and consistent compared to disparate manual processes.\nDisruption Fears: Projects in advanced development stages often fret that integrating a CI system would overhaul their established workflows, spawning significant delays. It’s pivotal to recognize that CI system implementation can be incremental. Teams can address one integration stage at a time, gradually ramping up the integration frequency as confidence builds.\nOverwhelming Failed Integrations: When CI practices aren’t diligently applied, there\u0026rsquo;s a risk of encountering an excessive number of failed integrations or \u0026ldquo;broken builds.\u0026rdquo; This could stem from developers bypassing local tests before uploading their changes to the Version Control System (VCS). A surge in failed integrations can erode trust in the CI system, reminiscent of the \u0026ldquo;Broken Window Theory\u0026rdquo;9.\nPerceived Additional Costs: There\u0026rsquo;s an apprehension among organizations about incurring extra expenses either for procuring CI product licenses or securing hardware to support these systems. However, this expenditure pales in comparison to the latent costs of late-stage integrations, where issues are discovered near the release date, far removed from their inception. On a brighter note, the current landscape is rife with a myriad of free and open-source alternatives, obviating any additional costs.\nReferences Continuous integration. ThoughtWorks, 2018.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, Martin. Continuous Integration. 2006.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBeck, Kent. Embrace Change with Extreme Programming. IEEE Computer Magazine, (c), 70-77. 1999.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRodriguez Pilar, Markkula, Jouni, Oivo, Markku, \u0026amp; Turula, Kimmo. Survey on agile and lean usage in Finnish software industry. In Proceedings of the ACM-IEEE international symposium on Empirical software engineering and measurement - ESEM \u0026lsquo;12 (p. 139). ACM Press. DOI: 10.1145/2372251.2372275. 2012.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDuvall, Paul M., Matyas, Steve, \u0026amp; Glover, Andrew. Continuous integration: improving software quality and reducing risk. Pearson Education, Inc., 2007.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCauldwell, Patrick. Code Leader: Using people, tools and processes to build successful software. Wiley Publishing, Inc., 2008.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez \u0026amp; Farley, David. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCyclomatic Complexity Explanation\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe Broken Window Theory in Software Development\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1692403200,"headings":[{"anchor":"benefits","title":"Benefits"},{"anchor":"challenges","title":"Challenges"},{"anchor":"core-principles-and-practices","title":"Core principles and practices"},{"anchor":"elements-of-a-ci-system","title":"Elements of a CI system"},{"anchor":"references","title":"References"},{"anchor":"the-integration-process","title":"The integration process"}],"kind":"page","lang":"en","summary":"What is Continuous Integration? Which benefits it provides? In this article you can find answers to those questions and many more.","tags":["ci","continuous-integration"],"title":"Continuous Integration","url":"/en/blog/2023/08/continuous-integration/","year":"2023"},{"content":"","date":1692403200,"headings":[],"kind":"term","lang":"en","summary":"","title":"continuous-integration","url":"/en/tags/continuous-integration/","year":"2023"},{"content":"","date":1692316800,"headings":[],"kind":"term","lang":"en","summary":"","title":"requirements","url":"/en/tags/requirements/","year":"2023"},{"authors":["Julián Nonino"],"content":"According to Sommerville and Sawyer, a requirement is a statement about an intended product that specifies what it should do or how it should perform1.\nRequirements identify the goals, needs and constraints that the software must address in order to deliver value. They are a form of specification that serve as the foundation for all subsequent software engineering activities.\nSome key definitions of requirements are:\nDescription of how the system should behave. Features that the software needs to deliver. Functionalities that users expect from the software. Statements of business rules that software must comply with. Constraints on development of the software. Requirements convey the intended purpose, context and environment in which the software will operate. They express the underlying motivations for why the software needs to be built by identifying problems faced by users or organization.\nAs Wiegers puts it, requirements describe the inner and outer capabilities, characteristics, and qualities that the product must have or perform well to satisfy all aspects of the product vision2.\nWhat should requirements define? Good requirements provide a complete description of what the software will do, without dealing with how it will be implemented.\nSome key aspects that requirements should define are:\nUser capabilities: what can users do with the system? e.g. login, search, make payment etc. Operational workflows: how does system interact with users and external systems? e.g. order processing workflow. Business rules: what policies and rules does system need to comply with? e.g. credit limits. Integration touch points: how does system integrate with other systems? e.g. payment gateway APIs. Quality attributes: what non-functional qualities are important? e.g. security, availability. External interfaces: how does system interact with external actors? e.g. device interfaces. Environment conditions: what environmental constraints are present? e.g. operating system. Design/architectural constraints: are there constraints on design choices? e.g. use cloud infrastructure. Documenting these aspects ensures requirements provide a good view into the problem space and what the software solution needs to achieve.\nProperties of good requirements High quality requirements exhibit certain desired characteristics:\nComplete: requirements capture the full capabilities needed without any gaps. Correct: requirements precisely represent genuine user needs. Feasible: requirements can be reasonably implemented within constraints. Unambiguous: requirements have clear meaning that is open to only one interpretation. Consistent: there are no conflicts or contradictions between requirements. Prioritized: importance and urgency is indicated to guide implementation. Verifiable: requirements can be validated via concrete acceptance criteria. Traceable: origin of each requirement is clear for analysis. Atomic: requirements define one need instead of multiple combined needs. Implementation free: requirements avoid implementation choices or design details. Adhering to these qualities results in a strong set of requirements that serve as a solid foundation for the software design and development.\nLevels of requirements Requirements are defined at different levels of abstraction and detail. Requirements evolve from high-level needs to detailed specifications through this hierarchical breakdown.\nBusiness requirements These capture high-level needs related to business objectives, problems and outcomes the software should achieve. They are written using terminology familiar to business users. Examples include:\nImprove customer retention by 10%. Reduce operational costs by optimizing order processing. Enable omni-channel order fulfillment. User requirements These describe the needs and wishes of end-users related to functionality and quality. They capture who, what, where, when and why of user interactions. Examples:\nUser shall be able to place orders 24/7 via website. System shall provide real-time order status tracking. User shall be able to save payment information securely. System requirements These describe the detailed behaviors, operations, capabilities and business rules the system needs to implement. Or, impose quality constraints, performance needs and other attributes on the system. Examples:\nSystem shall verify customer identity before accepting order. User shall be able to filter orders by date, status, amount, etc. System shall interface with the inventory system to validate product availability. System must have a uptime of 99.95%. Page response time must be under 100 ms for 90% of requests. System must store customer data encrypted at rest. Types of requirements There are two main types of requirements:\nFunctional requirements These describe the specific behaviors and operations that the system needs to perform in order to accomplish the intended purpose. Functional requirements depend heavily on the type of software being developed. Some examples of functional requirements are:\nThe system shall allow users to sign in using their email address and password. The system shall allow admins to add new user accounts. The system shall allow managers to generate sales reports by region. The system shall integrate with PayPal to accept payments. Non-functional requirements Non-functional requirements specify quality attributes and constraints that software must meet. They impose restrictions on how the system performs its functions. Examples of non-functional requirements:\nThe system shall have an uptime of 99.95%. The system shall support up to 100 concurrent active users. User passwords must be stored in encrypted format. The website shall work on mobile and desktop browsers. In turn, non-functional requirements can be divided into the following categories. Covering relevant categories of non-functional needs results in a comprehensive set of quality requirements.\nProduct Requirements These relate to quality characteristics of the software itself. Types include:\nUsability: how easy is it for users to learn and operate the system? Performance: response times, throughput, resource usage, scalability targets, etc. Security: access control, encryption, vulnerability prevention, etc. Availability: uptime, reliability, disaster recovery needs, etc. Maintainability: ability to make changes, add new features, repair defects, etc. Portability: ability to work across different environments and platforms. Organizational Requirements These relate to business, process and compliance needs of the organization. Types include:\nDelivery: schedule, release planning, milestones to be met. Legal: regulations, policies, standards that must be complied with. Data: data formats, retention periods, reporting needs, etc. Process: integration with organizational workflows, change management, etc. Operational: server environments, infrastructure standards, monitoring needs, etc. External Requirements These relate to integration with external systems and end user environments. Types include:\nInterfaces: protocols, APIs, formats for exchanging data. Interoperability: ability to integrate with other systems as needed. Hardware: support for client hardware like scanners, handhelds, etc. Platform: compatibility with end user operating systems. Software Requirements Specification (SRS) The Software Requirements Specification (SRS) is the official document that captures the complete set of requirements for the system in detail. It is treated as the contract between customers and developers.\nAccording to IEEE, the SRS can be defined as a document that describes all data, functional and behavioral requirements; analyzes, specifies, and validates the system requirements3.\nSome key purposes that the SRS serves are:\nFormally documents the requirements agreed upon by stakeholders. Serves as reference for planning, estimating and tracking the project. Reduces ambiguity by recording details about requirements. Serves as basis for design, development and testing activities. Facilitates communication and consensus between teams. Becomes basis for verification and validation. Evolves into system tests, user manuals, etc. The main users of the SRS document are:\nCustomers: clarify needs, review and approve requirements. Managers: estimate effort, plan activities, track progress. Architects: analyze requirements to design solutions. Developers: understand detailed needs to implement. Testers: derive test conditions and test cases. Technical Writers: use it as foundation for user manuals. A typical SRS is organized into the following sections:\nIntroduction: purpose, scope, definitions, acronyms, references. User Requirements: capabilities, user characteristics, constraints. Functional Requirements: functionalities, operations, business rules. Non-functional Requirements: qualities, performance, attributes. External Interface Requirements: interactions with other systems, devices, etc. Other Requirements: licensing, compliance, platform, deliverables. Appendix: diagrams, analysis models, schema definitions. The SRS maintains traceability between stakeholder needs, requirements specification and system design. This enables tracking of requirements throughout the product lifecycle.\nNotations for documenting requirements Textual description is the most common way of documenting requirements in the SRS. However, visual models and formal notations can also be used to express specific aspects precisely. Here there are different ways of expressing software requirements.\nUser stories: used in agile methods to capture user requirements. Written as \u0026ldquo;As a , I want so that \u0026rdquo;. Use cases: describe interactions between users and the system to achieve a goal. Data models: express structure of data as entities, attributes, relationships etc. e.g. ER diagrams. Behavior models: represent dynamic behavior and workflows e.g. state machine diagrams, activity diagrams. Interface models: specify external interfaces using API blueprints, protocol specs, etc. Supplementary specifications: detailed non-functional specs e.g. security standards, compliance rules. Choosing appropriate techniques allows capturing complete details in an unambiguous manner. The textual SRS can reference these as needed.\nEliciting and analyzing requirements Requirements come from analyzing the needs of various stakeholders. Typical steps are:\nStakeholder identification: identify various stakeholders - end users, business managers, operations team, etc. Requirements gathering: gather needs via interviews, observation, focus groups, workshops, surveys, etc. Requirements gathering relies heavily on techniques like prototyping, scenario analysis, domain modeling and qualitative user research. Requirements analysis: analyze requirements for clarity, conflicts and prioritization. Requirements documentation: document requirements, review with stakeholders and baseline. Requirements validation: validate requirements to ensure consistency, completeness, technical feasibility, etc. Requirements management: manage changes through proper change control processes. According to Davis, requirements management is critical for aligning software capabilities with business objectives throughout the product lifecycle4. Challenges Some key challenges faced in requirements engineering are:\nIncomplete, unclear and ambiguous requirements. Infeasible requirements beyond project constraints. Conflicting stakeholder needs and priorities. Frequent requirement changes leading to scope creep. Missing key details and assumptions. Lack of customer availability and engagement. Users not knowing what they need. Weak change management discipline. Communication gaps across customer and development teams. According to Christel and Kang, requirements elicitation is a complex activity due to factors like vague customer needs, lack of user involvement and staggered feedback5. Using proven elicitation techniques, sound documentation practices, rigorous analysis and reviews, and disciplined change management helps tackle these challenges.\nEmerging Trends Some key trends shaping the future of requirements engineering:\nIncreased end user involvement through prototyping and crowdsourcing. Growing use of iterative approaches to allow for emergent requirements. Greater reliance on product managers as customer proxies. Increased adoption of agile user stories over traditional SRS docs. Enhanced traceability through modeling and automation. Integration with design models and testing to realize \u0026ldquo;single source of truth\u0026rdquo;. Introducing requirements management tools for collaboration. Leveraging AI techniques for analyzing and deriving complex requirements. Focus on continuously capturing and refining requirements throughout product lifecycle. According to Nuseibeh and Easterbrook, requirements engineering will need to adapt to factors like faster delivery cycles, evolving design approaches and increased automation6.\nConclusion Defining complete, correct requirements that accurately capture end user and business needs is essential to delivering effective software solutions. Requirements engineering done right lays the foundation for developing a product that delivers maximum value. Applying sound specification techniques, following collaborative elicitation processes, documenting requirements clearly, and managing changing needs systematically are key disciplines that lead to high quality software products that meet customer expectations.\nReferences Sommerville, Ian, and Pete Sawyer. Requirements engineering: a good practice guide. John Wiley \u0026amp; Sons, Inc., 1997.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKarl E. Wiegers, and Joy Beatty. Software requirements. Pearson Education, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIEEE. IEEE Guide for Developing System Requirements Specifications. IEEE Std 1233, 1998 edition.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nA. M. Davis. Just enough requirements management: where software development meets marketing. Dorset House Publishing Co., Inc., 2005.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChristel, Michael G., and Kyo C. Kang. Issues in requirements elicitation. Carnegie Mellon University, 1992.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNuseibeh, Bashar, and Steve Easterbrook. \u0026ldquo;Requirements engineering: a roadmap.\u0026rdquo; Proceedings of the Conference on the Future of Software Engineering. 2000.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1692316800,"headings":[{"anchor":"business-requirements","title":"Business requirements"},{"anchor":"challenges","title":"Challenges"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"eliciting-and-analyzing-requirements","title":"Eliciting and analyzing requirements"},{"anchor":"emerging-trends","title":"Emerging Trends"},{"anchor":"external-requirements","title":"External Requirements"},{"anchor":"functional-requirements","title":"Functional requirements"},{"anchor":"levels-of-requirements","title":"Levels of requirements"},{"anchor":"non-functional-requirements","title":"Non-functional requirements"},{"anchor":"notations-for-documenting-requirements","title":"Notations for documenting requirements"},{"anchor":"organizational-requirements","title":"Organizational Requirements"},{"anchor":"product-requirements","title":"Product Requirements"},{"anchor":"properties-of-good-requirements","title":"Properties of good requirements"},{"anchor":"references","title":"References"},{"anchor":"software-requirements-specification-srs","title":"Software Requirements Specification (SRS)"},{"anchor":"system-requirements","title":"System requirements"},{"anchor":"types-of-requirements","title":"Types of requirements"},{"anchor":"user-requirements","title":"User requirements"},{"anchor":"what-should-requirements-define","title":"What should requirements define?"}],"kind":"page","lang":"en","series":["Software Engineering"],"summary":"Requirements engineering is the process of defining, documenting and maintaining requirements for a software system. It is the first and foundational stage in the software development lifecycle. Requirements express the needs and constraints that the software must satisfy in order to solve problems and provide value to users and the business. Let's get started understanding the basics of requirements in software projects.","tags":["software-engineering","requirements","srs"],"title":"Requirements Engineering","url":"/en/software-engineering/0300-requirements-engineering/01-requirements-engineering/","year":"2023"},{"content":"","date":1692316800,"headings":[],"kind":"taxonomy","lang":"en","summary":"","title":"Series","url":"/en/series/","year":"2023"},{"content":"","date":1692316800,"headings":[],"kind":"term","lang":"en","summary":"","title":"Software Engineering","url":"/en/series/software-engineering/","year":"2023"},{"content":"Welcome to this exclusive series of articles that make up a comprehensive course on Software Engineering. From theoretical roots to contemporary practices, this collection has been meticulously crafted to provide readers with a deep and practical understanding of the various facets of Software Engineering.\nWhether you\u0026rsquo;re a student eager to dive into the fundamentals, a professional looking to refresh your knowledge, or simply someone curious about the magic behind software development, this collection will guide you step by step. Through each article, we will explore key concepts, emerging techniques, essential tools, and best practices that define our industry today.\nWe invite you to embark on this educational journey. Each article is a lesson in itself, designed to offer you a rich learning experience applicable in the real world. Prepare to immerse yourself in the captivating discipline of Software Engineering and discover the methodologies and tools that shape the digital world around us.\n","date":1692316800,"headings":[],"kind":"section","lang":"en","summary":"Welcome to this exclusive series of articles that make up a comprehensive course on Software Engineering. From theoretical roots to contemporary practices, this collection has been meticulously crafted to provide readers with a deep and practical understanding of the various facets of Software Engineering.\nWhether you’re a student eager to dive into the fundamentals, a professional looking to refresh your knowledge, or simply someone curious about the magic behind software development, this collection will guide you step by step.","title":"Software Engineering","url":"/en/software-engineering/","year":"2023"},{"content":"","date":1692316800,"headings":[],"kind":"term","lang":"en","summary":"","title":"software-engineering","url":"/en/tags/software-engineering/","year":"2023"},{"content":"","date":1692316800,"headings":[],"kind":"term","lang":"en","summary":"","title":"srs","url":"/en/tags/srs/","year":"2023"},{"content":"","date":1692144e3,"headings":[],"kind":"term","lang":"en","summary":"","title":"deployment","url":"/en/tags/deployment/","year":"2023"},{"content":"","date":1692144e3,"headings":[],"kind":"term","lang":"en","summary":"","title":"intro","url":"/en/tags/intro/","year":"2023"},{"content":"","date":1692144e3,"headings":[],"kind":"term","lang":"en","summary":"","title":"maintenance","url":"/en/tags/maintenance/","year":"2023"},{"content":"","date":1692144e3,"headings":[],"kind":"term","lang":"en","summary":"","title":"sdlc","url":"/en/tags/sdlc/","year":"2023"},{"content":"","date":1692144e3,"headings":[],"kind":"section","lang":"en","summary":"","title":"Software Development Life Cycle (SDLC)","url":"/en/software-engineering/0200-sdlc/","year":"2023"},{"authors":["Julián Nonino"],"content":"The main goals of the deployment stage are:\nInstall and configure the software on production infrastructure. Migrate data from old systems if needed. Run integration, performance, and security tests. Release the software for use by end users. Proper deployment is critical for delivering high quality software that meets customer needs. This article provides a comprehensive overview of the deployment stage, best practices, challenges, and key steps involved.\nThe deployment environment is usually separate from the development environment and mirrors the actual production infrastructure as closely as possible. Thorough testing in this stage helps minimize issues when releasing to production.\nAs Jez Humble and David Farley explain in their book Continuous Delivery, the goal of the deployment pipeline is to make the transition from development into production as fast, smooth, and automated as possible 1.\nThe deployment stage is considered one of the most critical stages of the SDLC. High quality deployment is important for several reasons:\nEnsures software works correctly before release. Thorough testing during deployment can detect bugs and issues missed during development. Reduces risk of failure or downtime in production. Rigorous testing in a production-like environment minimizes surprises post-release. Improves user experience. Smooth deployments prevent disruptions to business operations and end user workflows. Builds confidence in the software. Quality deployments instill trust that the software is reliable and ready for use. Minimizes cost of fixes post-release. It\u0026rsquo;s exponentially cheaper to detect and fix issues during deployment than after production release. Enables quicker time to market. Automated deployments allow new features to be released to customers faster. Facilitates continuous delivery. Automated deployment capabilities allow for frequent releases of incremental updates. As Liraz Siri notes, The cost of fixing bugs dramatically rises the closer you get to production. By investing energy in deploying safely, you save time and money down the road 2.\nOverall, proper execution of the deployment stage results in software that meets business and user needs, prevents disruptions, and enables faster delivery of value.\nChallenges While critical, the deployment stage also poses some unique challenges:\nEnvironment differences: Differences between test and production environments can cause unexpected issues. Missing dependencies, incorrect configurations, and environment consistency issues are common pitfalls. Testing complexities: Testing an integrated system and large datasets requires significant effort and expertise. Corner cases and errors can easily be missed. Release coordination: Release timing and coordination across teams can be complex, especially for large rollouts spanning multiple applications, databases, servers etc. Downtime management: Planned downtime needs to be carefully scheduled to minimize business impact. Rollback strategies also need to be in place. Training and support: Admins and support staff need proper training to be equipped to run the software post deployment. Lack of knowledge transfer can cause issues. Unanticipated factors: Real world variables like unreliable networks, component failures, or human errors can derail otherwise smooth deployments. Configuration sprawl: A proliferation of configuration files, scripts, and variables across environments makes deployments brittle and error-prone. Manual processes: Reliance on manual deployments and testing increases effort and risk of human error. As Gene Kim et al. highlight, the deployment pipeline is one of the highest leverage points in modern software delivery\u0026hellip; it is fraught with risk if not done properly 3. Adopting best practices around planning, automation, testing rigor, and collaboration helps mitigate these deployment risks.\nBest practices Here are some proven best practices for improving deployment processes:\nAutomate deployments: Automated scripts or tools should be used to install, configure, and release software predictably and reliably. Infrastructure as code: Manage infrastructure configurations, environments, and dependencies as versioned code for consistency. Continuous testing: Testing should be integrated at every stage rather than just during deployment. Unit, integration, and end-to-end testing ensures code quality. Zero downtime releases: Use release techniques like blue-green, canary, and rolling deployments to minimize downtime. Communication: Collaboration between developers, operations, QA, and business teams ensures smooth deployments. Monitoring and logging: Extensive logging and monitoring provides visibility into application performance and rapidly detects problems. Rollback planning: Automated rollback capabilities quickly revert failed changes and restore working versions. Defense in depth: Use multiple defensive strategies like input validation, threat modeling, and redundancy to minimize risk. Frequent smaller releases: Incremental releases reduce change scope and roll back complexity. As Jez Humble recommends, the key to managing change is incrementality, both in terms of what you deliver, and how you deliver it\u0026hellip; With small, frequent changes, managing change becomes routine rather than traumatic 4.\nAdopting these practices requires upfront investment but pays long term dividends in the form of faster, robust, and resilient deployment capabilities.\nKey steps in the deployment process While each organization follows a slightly different deployment process, these are the typical key steps:\nProvision infrastructure: the necessary servers, databases, storage, networking, security layers, and other infrastructure components are provisioned and configured to install and run the software. Create environments: separate environments are created for deployment testing and production implementation. These environments closely resemble the actual production environment. Migrate code: the latest version of the software code is migrated from the source code repository or build server into the deployment environment. Migrate data: any required data is migrated from legacy systems to the new databases. Data integrity checks are performed. Configure environments: software and infrastructure configurations like database connections, file directories, web server settings are appropriately set in the deployment environment. Install software: the code packages or executables are installed and registered within servers, databases, application servers, and other technology layers. Integrate components: individual software components are integrated with each other and checked for interoperability. End-to-end integration tests are executed. Performance and load testing: the system is load tested with production-level concurrent users and data to gauge performance and stability. Security testing: in-depth security reviews, vulnerability scanning, and penetration testing are performed to identify and resolve security holes. Train support staff: IT operations and support staff are trained on administering, monitoring, troubleshooting and supporting the software post deployment. Release software: following approval after testing, the software is deployed into production and made available for use by end users. Monitor operations: logs and operations are closely monitored post-release to detect and fix any issues quickly. Software runs are continually optimized. Following these systematic steps minimizes risk and enables smooth transition of software from development into live production use.\nAs Erik Boersma states, the road to production sets the tone for the level of agility, reliability, and security your company can expect from its software 5.\nDeployment methods There are several strategies that can be used for deploying software. Choosing the right strategy depends on multiple factors like type of application, risks involved, frequency of releases etc. Here are some popular deployment methods:\nBig Bang deployment: all components of the software are deployed together in one go. This is suitable for smaller software with less complexity. The advantage is simplicity but has high risk and downtime. Phased deployment: the application is broken down into logical phases which get deployed one by one sequentially. This reduces risk and makes rollbacks easier if issues arise. Incremental deployment: small enhancements and fixes get deployed frequently in stages. After testing each increment thoroughly in staging, it gets deployed to production. This minimizes risk and downtime. Blue-Green deployment: two identical production environments are maintained, Blue and Green. Green is the active environment while Blue contains the new release. After final testing, user traffic is routed from Green to Blue. Rollback just requires switching routes back. Canary deployment: the new version is deployed to a small subset of users first. After testing and validation, it is progressively rolled out to more users. Helps reduce risk for large user base applications. Dark launch: involves deploying the application but keeping it invisible to users until ready for launch. This verifies proper working before publicly launching it. Choosing the right strategy suitable to the system, risk appetite and business needs is key to smooth trouble-free deployments.\nTools for deployment automation Automating deployments is essential for reducing errors and speeding up release cycles. Here are some popular open source and commercial tools:\nAnsible: Ansible is an open source automation platform that covers configuration management, application deployment, and orchestration capabilities. Puppet: Puppet automates infrastructure provisioning and configuration management using a custom declarative language. Chef: Chef uses the Ruby language to automate infrastructure provisioning and deployment. Terraform: Terraform provides infrastructure as code capabilities to provision cloud and data center resources. Jenkins: Jenkins is a continuous integration server that facilitates automated builds and deployments. CircleCI: CircleCI provides hosted automation capabilities for builds, testing and deployments via integration with GitHub etc. Kubernetes: Kubernetes enables declarative infrastructure automation and deployment of containerized applications. Docker: Docker packages software into standardized containers that can run reliably across environments. As Kim et al. explain, automation is key to performing deployments repeatedly and reliably. The deployment pipeline codifies these steps into an automated process 3.\nThese tools help implement deployment best practices like continuous delivery, infrastructure as code, and reduced reliance on manual processes. Combining multiple solutions can provide comprehensive deployment automation capabilities.\nHigh performing organizations use significantly more automation, with elite performers automating significantly more of their deployment processes 6.\nWhile deployment will grow more complex due to factors like cloud and containers, automation and new architectures will pave the way for rapid and reliable deployments.\nConclusion The deployment stage is complex but critical to delivering customer value reliably and rapidly. Using proven strategies around automation, testing rigor, collaboration, and incremental delivery enables high quality deployments. Leveraging deployment tools and evolving DevOps practices will be key for accelerating deployments. With robust deployment capabilities in place, organizations can focus on faster innovation and take software from ideation to customer use efficiently.\nReferences Humble, Jez, and David Farley. Continuous delivery: reliable software releases through build, test, and deployment automation. Pearson Education, 2010.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSiri, Liraz. Deploy to Production: A Practical Guide to Automation in Web Development. Leanpub, 2021.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKim, Gene, et al. The DevOps Handbook: How to Create World-Class Agility, Reliability, and Security in Technology Organizations. IT Revolution Press, 2016.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez. The Deployment Age. IT Revolution Press, 2021.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBoersma, Erik. The Road to Production: Standard Practices for Simpler Software Delivery. O\u0026rsquo;Reilly Media, 2021.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nForsgren, Nicole, et al. Accelerate: The Science of Lean Software and DevOps: Building and Scaling High Performing Technology Organizations. IT Revolution Press, 2018.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1692144e3,"headings":[{"anchor":"best-practices","title":"Best practices"},{"anchor":"challenges","title":"Challenges"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"deployment-methods","title":"Deployment methods"},{"anchor":"key-steps-in-the-deployment-process","title":"Key steps in the deployment process"},{"anchor":"references","title":"References"},{"anchor":"tools-for-deployment-automation","title":"Tools for deployment automation"}],"kind":"page","lang":"en","series":["Software Engineering"],"summary":"The deployment stage involves releasing the software into production and making it available for end users.","tags":["intro","software-engineering","sdlc","deployment"],"title":"The Deployment phase","url":"/en/software-engineering/0200-sdlc/06-deployment/","year":"2023"},{"authors":["Julián Nonino"],"content":"This phase ensures that software remains robust, relevant, and valuable throughout its lifecycle1.\nSoftware maintenance encompasses all activities post-deployment that are not categorized as software evolution2. It\u0026rsquo;s about refining, enhancing, and optimizing software, as well as fixing errors that surface over time.\nWhile creating software is challenging, maintaining it is often even more demanding. With changing user needs, technology advancements, and the inevitable emergence of bugs, ongoing maintenance is essential for software\u0026rsquo;s continued relevance and efficiency1.\nTypes of software maintenance Corrective maintenance: This involves identifying and fixing bugs or defects in the software. It\u0026rsquo;s a reactive approach, often prompted by user feedback or system monitoring1. Adaptive maintenance: As external factors like OS updates, hardware changes, or new regulations come into play, software needs to adapt. This type of maintenance ensures the software remains compatible with its changing environment3. Perfective maintenance: Driven by the need to enhance software functionality or performance, this is about adding new features or improving existing ones based on user feedback and evolving market needs1. Preventive maintenance: Proactively looking into the future, this type of maintenance is focused on foreseeing and preventing future issues, often by restructuring or optimizing the code4. The Process of maintenance Request initiation: it starts with recognizing the need for maintenance. This can come from user feedback, system alerts, or regular system checks1. Impact analysis: before making any changes, it\u0026rsquo;s essential to assess the potential impact of the modification on the entire system5. Design and implementation: with a clear understanding of the task at hand, developers design the solution and implement the necessary changes1. System testing: post-implementation, rigorous testing is essential to ensure that the changes work as intended and haven’t inadvertently introduced new issues2. Release: once satisfied, the updated software is released to users, either as patches, updates, or new versions1. Challenges Understanding legacy code: as software evolves, understanding older parts of the codebase, especially if original developers have moved on, can be challenging6. Maintaining documentation: over time, ensuring that documentation stays up-to-date and accurately reflects the software\u0026rsquo;s current state is a continuous challenge7. Balancing new development with maintenance: allocating resources between developing new features and maintaining existing ones is a tightrope walk many teams grapple with8. The economic aspects It\u0026rsquo;s often quoted in software engineering literature that maintenance costs can account for over 60% of all SDLC costs9. Hence, budgeting, resource allocation, and cost optimization become integral parts of the maintenance stage.\nConclusion Maintenance is not merely an afterthought; it\u0026rsquo;s the pulse that keeps software alive and relevant in an ever-changing digital landscape. By understanding and embracing the nuances of this SDLC stage, software engineers can ensure the longevity and success of their creations1.\nReferences Sommerville, I., 2010. Software Engineering. 9th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPressman, R.S., 2010. Software Engineering: A Practitioner\u0026rsquo;s Approach. 7th ed. McGraw-Hill.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A.S., 2014. Modern Operating Systems. 4th ed. Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nParnas, D.L., 1994. Software Aging. Proceedings of the 16th international conference on Software engineering. IEEE.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLehman, M.M., 1980. Programs, life cycles, and laws of software evolution. Proceedings of the IEEE, 68(9), pp.1060-1076.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBowman, I.T., Holt, R.C., and Brewster, N.V., 1999. Linux as a case study: Its extracted software architecture. Proceedings of the 21st international conference on Software engineering. ACM.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLethbridge, T.C., Singer, J., and Forward, A., 2003. How software engineers use documentation: The state of the practice. IEEE Software, 20(6), pp.35-39.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBoehm, B.W., and Basili, V.R., 2001. Software defect reduction top 10 list. Computer, 34(1), pp.135-137.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nErlikh, L., 2000. Leveraging legacy system dollars for e-business. IT professional, 2(3), pp.17-23.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1692144e3,"headings":[{"anchor":"challenges","title":"Challenges"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"references","title":"References"},{"anchor":"the-economic-aspects","title":"The economic aspects"},{"anchor":"the-process-of-maintenance","title":"The Process of maintenance"},{"anchor":"types-of-software-maintenance","title":"Types of software maintenance"}],"kind":"page","lang":"en","series":["Software Engineering"],"summary":"Once a software application is deployed and begins its life in the hands of users, its journey is far from over. The maintenance stage, often overlooked by novices, plays a pivotal role in the Software Development Life Cycle (SDLC).","tags":["intro","software-engineering","sdlc","maintenance"],"title":"The Maintenance phase","url":"/en/software-engineering/0200-sdlc/07-maintenance/","year":"2023"},{"content":"","date":1692057600,"headings":[],"kind":"term","lang":"en","summary":"","title":"testing","url":"/en/tags/testing/","year":"2023"},{"authors":["Julián Nonino"],"content":"Software testing, at its core, is an activity where software undergoes various forms of evaluation. It’s conducted to ensure that the software adheres to specified requirements and doesn\u0026rsquo;t demonstrate unwanted behaviors1. It is a meticulous blend of logic and creativity: logic to methodically navigate predefined paths and creativity to anticipate unexpected scenarios and user behaviors.\nBefore diving into its components, let\u0026rsquo;s recognize the non-negotiable importance of testing in the SDLC.\nRisk mitigation: Flawless software is a myth. Testing identifies defects, ensuring they are addressed before they become critical vulnerabilities. User trust and satisfaction: Users demand perfection. Rigorous testing ensures that their interactions with the software are seamless, building trust and guaranteeing satisfaction2. Cost efficiency: Unearthing defects early is cost-effective. Addressing them post-deployment can be exponentially more expensive. Regulatory adherence: In many sectors, comprehensive software testing is not a choice but a mandatory requirement, ensuring safety, security, and compliance. Levels of Testing Delving deeper into the software testing landscape, there are multiple layers or levels, each serving a unique purpose:\nLevel Description Unit testing Focusing on the smallest testable parts of the software, unit testing evaluates individual units or components in isolation. It\u0026rsquo;s the foundational level of testing, ensuring that each building block performs as intended3. Integration testing Once individual units pass their tests, integration testing takes over. Here, multiple units are combined and tested as a group. The primary aim is to detect interface defects between integrated components4. System testing This is a holistic testing phase where the entire software is evaluated. System testing verifies that the finished product meets the specified requirements and functions correctly in environments that mirror real-world conditions5. Key components Test planning\nStrategic vision: Testing, like every pivotal activity in software development, mandates planning. Test planning chalks out the scope, approach, resources, and schedule of testing activities6. Resource allocation: Relevant tools, team members, and infrastructure for testing are identified and readied. Risk analysis: Anticipating potential hurdles, and charting out mitigation plans is vital to navigate any unforeseen challenges. Test design\nTest conditions to test cases: Requirements are translated into tangible test conditions and expected results. This stage turns abstract needs into specific, testable items7. Data creation and scripting: Appropriate test data and automated test scripts are crafted, simulating real-world scenarios and automating repetitive tasks. Test execution\nExecuting the planned tests, outcomes are gauged against expected results. Discrepancies, or defects, are logged for rectification. This stage may employ manual or automated testing techniques, depending on the nature of the test cases8.\nDefect reporting and tracking\nEach defect is meticulously documented, detailing its nature, steps to reproduce, and potential impact. Testers collaborate with developers to address these defects, ensuring every discrepancy is resolved before software deployment9.\nRegression testing\nAs defects are rectified and the software undergoes modifications, regression testing ensures that new changes haven\u0026rsquo;t adversely affected existing functionalities10.\nTesting types While the aforementioned levels offer a vertical depth, various testing types provide a horizontal expanse, ensuring every facet of software quality is evaluated:\nType Description Functional testing Verifying if the software performs its intended functions. Performance testing Gauging software behavior under different conditions, including stress, load, and scalability scenarios. Usability testing Assessing the software\u0026rsquo;s user-friendliness and intuitiveness. Security testing Ensuring resilience against malicious threats and breaches. Compatibility testing Confirming software compatibility across devices, OSs, and browsers. Conclusion Perceiving the testing stage as merely a filter for defects is an oversimplified perspective. In essence, testing is a robust pillar in the SDLC, ensuring that the end product is not just functional, but optimal. For budding software engineers and developers, understanding the intricacies of this phase is non-negotiable, given its pivotal role in dictating software quality and user satisfaction.\nReferences Myers, G. J., Sandler, C., \u0026amp; Badgett, T., 2011. The Art of Software Testing. 3rd ed. Wiley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDustin, E., Rashka, J., \u0026amp; Paul, J., 1999. Automated Software Testing: Introduction, Management, and Performance. Addison-Wesley Professional.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nGraham, D., \u0026amp; Fewster, M., 2008. Experiences of Test Automation: Case Studies of Software Test Automation. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKaner, C., Falk, J., \u0026amp; Nguyen, H. Q., 1999. Testing Computer Software. 2nd ed. Wiley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKit, E., 1995. Software Testing in the Real World: Improving the Process. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBlack, R., 2001. Critical Testing Processes: Plan, Prepare, Perform, Perfect. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCraig, R. D., \u0026amp; Jaskiel, S. P., 2002. Systematic Software Testing. Artech House.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPerry, W. E., 2006. Effective Methods for Software Testing. 3rd ed. Wiley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nJorgensen, P.C., 2002. Software Testing: A Craftsman\u0026rsquo;s Approach. CRC Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPatton, R., 2005. Software Testing. 2nd ed. Sams Publishing.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1692057600,"headings":[{"anchor":"conclusion","title":"Conclusion"},{"anchor":"key-components","title":"Key components"},{"anchor":"levels-of-testing","title":"Levels of Testing"},{"anchor":"references","title":"References"},{"anchor":"testing-types","title":"Testing types"}],"kind":"page","lang":"en","series":["Software Engineering"],"summary":"In the rapidly-evolving domain of software development, delivering a product isn't the endpoint, it's a milestone. However, before that milestone can be reached, a rigorous evaluation must ensure the software is robust, user-friendly, and aligns with specified requirements. The torchbearer of this assessment? The testing stage of the Software Development Life Cycle (SDLC). Dive with me into this crucial phase and fathom its depth and expanse.","tags":["intro","software-engineering","sdlc","testing"],"title":"The Testing phase","url":"/en/software-engineering/0200-sdlc/05-testing/","year":"2023"},{"content":"","date":1691971200,"headings":[],"kind":"term","lang":"en","summary":"","title":"coding","url":"/en/tags/coding/","year":"2023"},{"content":"","date":1691971200,"headings":[],"kind":"term","lang":"en","summary":"","title":"implementation","url":"/en/tags/implementation/","year":"2023"},{"content":"","date":1691971200,"headings":[],"kind":"term","lang":"en","summary":"","title":"programming","url":"/en/tags/programming/","year":"2023"},{"authors":["Julián Nonino"],"content":"The implementation stage holds special significance as it transitions the project from concept to reality1. At its core, it involves the actual coding of the software. After meticulous planning and thorough design, this phase breathes life into the application, constructing the features and functionalities the end-users will eventually interact with2.\nKey components The implementation phase is an intricate mesh of various components, each playing a pivotal role in ensuring the resulting software is robust, efficient, and meets user requirements.\nChoosing the right programming language The choice of programming language sets the tone for the entire implementation. The decision should account for the software\u0026rsquo;s requirements, scalability needs, and the development team\u0026rsquo;s expertise. Whether it\u0026rsquo;s the versatility of Python, the robustness of Java, or the web-centric attributes of JavaScript, the language forms the backbone of the software3.\nThe selection of a programming language isn\u0026rsquo;t merely a developer\u0026rsquo;s whim; it\u0026rsquo;s a decisive factor that influences the software\u0026rsquo;s architecture, performance, and scalability3. Some languages are better suited for data-intensive tasks, others shine in GUI development, and some are ideal for web-based applications.\nThe nature of the project is paramount. For instance, a real-time system might benefit from a language known for speed, such as C or C++. On the other hand, web applications might lean towards JavaScript, Python, or Ruby. The chosen language should complement the software\u0026rsquo;s objectives, ensuring seamless integration, robust performance, and future scalability.\nBeyond the software\u0026rsquo;s requirements, the development team\u0026rsquo;s familiarity with a language plays a role. A language that the team is adept in will likely result in quicker development, fewer bugs, and a more optimized codebase.\nOften, the availability of robust libraries and frameworks can tip the scales in favor of a language. These tools can drastically speed up development by providing pre-built modules and functions, reducing the need to \u0026ldquo;reinvent the wheel.\u0026rdquo;\nCoding standards and best practices A codebase should be readable, maintainable, and scalable4. Adhering to coding standards ensures a uniform coding style, making it easier for team members to understand, modify, and enhance the code. Proper documentation, meaningful variable names, and a modular approach are some practices that maintain code quality.\nCode is more than just instructions for a computer; it\u0026rsquo;s a medium of communication among developers4. In a collaborative environment, code readability is essential. Consistent coding standards ensure that every team member, present or future, can understand, modify, and extend the code with relative ease.\nAdopting best practices isn\u0026rsquo;t about being pedantic; it\u0026rsquo;s about ensuring the software\u0026rsquo;s longevity. Practices like modular programming, where code is divided into reusable chunks (or modules), make it easier to maintain and upgrade the software in the future.\nWhile often overlooked, proper documentation serves as a roadmap for anyone revisiting the code. It offers insights into why certain decisions were made, clarifies complex code segments, and provides a high-level overview, making the onboarding process for new developers much smoother.\nAs software evolves, initial code implementations might become obsolete or inefficient. Regularly revisiting and refining code (a process known as refactoring) ensures the software remains optimized and up-to-date with current best practices.\nVersion control Version control systems like Git ensure that multiple developers can collaborate without overriding each other\u0026rsquo;s work5. They provide a history of code changes, allowing developers to revert to previous versions if necessary. Features like branching offer isolated environments for feature development and testing.\nAs software projects grow in scale, collaboration becomes a challenge5. Multiple developers working simultaneously can lead to code conflicts. Version Control Systems (VCS) like Git act as a safety net, allowing seamless collaboration while preserving the integrity of the codebase.\nOne of the key features of modern VCS is branching. Developers can create branches to work on new features or fixes without disturbing the main codebase. Once complete, these branches can be merged back, ensuring a systematic and conflict-free integration of new code.\nVersion control also acts as a historical record. Every change, big or small, is logged. This allows developers to track when a change was made, by whom, and why. In cases of unintended consequences, having this ability to revert to a previous \u0026ldquo;known-good\u0026rdquo; state can be a lifesaver.\nPlatforms like GitHub, GitLab or Bitbucket leverage VCS to facilitate pull requests (PRs). PRs act as a code review mechanism, where peers can review, comment on, and suggest changes before the new code is merged. This collaborative review ensures higher code quality and fewer bugs.\nContinuous Integration (CI) and Continuous Deployment (CD) CI/CD pipelines automate the process of code integration, testing, and deployment6. This ensures quicker delivery of features and fixes, with the software always in a deployable state. Automation reduces human errors, boosts development speed, and enhances code quality.\nIn the modern agile world, speed and efficiency are of the essence6. CI/CD pipelines automate code integration and deployment, reducing manual intervention, speeding up the release process, and ensuring that the software is always in a deployable state.\nCI emphasizes the continuous merging of code changes into a central repository. After integration, automated tests are run to ensure the new changes haven\u0026rsquo;t introduced bugs. This ensures consistent code quality and timely detection of issues.\nOn the other side of the spectrum, CD focuses on ensuring that code changes are automatically deployed to the production environment (or a staging environment first, if preferred). This ensures that new features, fixes, and updates reach end-users swiftly.\nOne of the less-talked-about benefits of CI/CD is the feedback loop it offers. Developers receive immediate feedback on their changes, allowing for quicker iterations and ensuring that bugs or issues are addressed as they arise, rather than piling up.\nChallenges and solutions Software development is rarely without challenges. However, understanding potential roadblocks and knowing how to navigate them can make the process smoother.\nTechnical debt: In a bid to speed up development, teams might resort to quick fixes or bypass standard coding practices7. While this might seem beneficial short-term, it accrues technical debt. Over time, this can make the software difficult to maintain and scale. Regular code reviews and refactoring can help manage and reduce this debt.\nInefficient code: Performance bottlenecks can emerge if code isn\u0026rsquo;t optimized. Resource-hungry functions or redundant operations can slow down the software. Profiling tools can help pinpoint these inefficiencies, enabling developers to refactor problematic areas8.\nSecurity vulnerabilities: With increasing cyber threats, secure coding is paramount9. Implementation should consider potential security vulnerabilities, ensuring the software is robust against attacks. Regular security audits and adhering to security best practices can help safeguard the application.\nImportance of testing in the implementation stage The implementation phase goes hand-in-hand with testing. As features are developed, unit tests ensure individual modules work as intended10. Integration tests confirm that different software components interact seamlessly. Regular testing catches issues early, ensuring a stable and reliable software build.\nConclusion The implementation phase is, without a doubt, the heartbeat of the SDLC. It\u0026rsquo;s where abstract ideas take concrete form, and user needs are addressed through functional code. By understanding and meticulously executing each component of this stage, software engineers can craft applications that not only work but thrive in the real world.\nFrom the choice of a programming language to the intricate dance of CI/CD, the implementation stage is a blend of art and science. With a profound understanding of its components, software engineers stand better equipped to navigate the complexities and ensure the delivery of exceptional software products.\nReferences Sommerville, I., 2010. Software Engineering. 9th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPressman, R.S., 2010. Software Engineering: A Practitioner\u0026rsquo;s Approach. 7th ed. McGraw-Hill.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSebesta, R.W., 2012. Concepts of Programming Languages. 10th ed. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMcConnell, S., 2004. Code Complete: A Practical Handbook of Software Construction. 2nd ed. Microsoft Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChacon, S., \u0026amp; Straub, B., 2014. Pro Git. 2nd ed. Apress.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, M., \u0026amp; Humble, J., 2010. Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCunningham, W., 1992. The WyCash Portfolio Management System. OOPSLA’92 Experience Report.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nZelkowitz, M.V., 1978. Advances in Computers. 17th ed. Academic Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMcGraw, G., 2006. Software Security: Building Security In. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMyers, G.J., Sandler, C., \u0026amp; Badgett, T., 2011. The Art of Software Testing. 3rd ed. Wiley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1691971200,"headings":[{"anchor":"challenges-and-solutions","title":"Challenges and solutions"},{"anchor":"choosing-the-right-programming-language","title":"Choosing the right programming language"},{"anchor":"coding-standards-and-best-practices","title":"Coding standards and best practices"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"continuous-integration-ci-and-continuous-deployment-cd","title":"Continuous Integration (CI) and Continuous Deployment (CD)"},{"anchor":"importance-of-testing-in-the-implementation-stage","title":"Importance of testing in the implementation stage"},{"anchor":"key-components","title":"Key components"},{"anchor":"references","title":"References"},{"anchor":"version-control","title":"Version control"}],"kind":"page","lang":"en","series":["Software Engineering"],"summary":"The Software Development Life Cycle (SDLC) guides software engineers through the steps of creating quality software. In the implementation stage, abstract designs materialize into tangible lines of code, giving birth to the software's functional attributes.","tags":["intro","software-engineering","sdlc","implementation","coding","programming"],"title":"The Implementation phase","url":"/en/software-engineering/0200-sdlc/04-implementation/","year":"2023"},{"content":"","date":1691884800,"headings":[],"kind":"term","lang":"en","summary":"","title":"design","url":"/en/tags/design/","year":"2023"},{"authors":["Julián Nonino"],"content":"It\u0026rsquo;s the stage where we transition from understanding what the software should do (requirements) to how it will achieve this1. It provides the architectural blueprints for the software, establishing the foundation upon which code is written, databases are structured, and systems communicate. It\u0026rsquo;s a vital roadmap for developers, ensuring everyone understands and aligns on how the system will operate.\nSystem design typically breaks down into two sub-categories:\nHigh-Level design (HLD): think of this as the macro view. It focuses on system architecture, representing the main components, their relationships, and interactions2. It’s where we decide on the software\u0026rsquo;s major structural elements.\nLow-Level design (LLD): now, zooming into the micro view. LLD delves into each module\u0026rsquo;s intricacies, defining attributes, methods, and detailing how they\u0026rsquo;ll function together3. This stage translates broader system architecture into actionable tasks and modules.\nComponents The holistic approach to system design is built upon several pillars:\nData design Data is often the lifeblood of systems. Whether it\u0026rsquo;s user profiles on a social media platform or transaction records in a banking system, data shapes software function. In data design:\nWe determine the data structures, deciding whether to use arrays, linked lists, trees, or graphs4. We outline data storage, choosing between relational databases, NoSQL stores, or hybrid solutions. Data flow is mapped out, ensuring smooth data movement through the software components. Architecture design This is where the system\u0026rsquo;s high-level structure comes to life. Several decisions and considerations form this design:\nChoosing the right software architectural pattern, such as client-server, three-tier, or microservices5. Factoring in scalability, flexibility, and responsiveness. For instance, should the system be designed to handle spikes in user requests? Deciding on the interaction between software components, which can be synchronous or asynchronous. Interface design In today\u0026rsquo;s interconnected digital world, few systems operate in isolation. Interface design ensures our software communicates effectively with other entities:\nIt defines API endpoints, standardizing how external systems request data or operations6. Details the format of data interchange, whether it\u0026rsquo;s JSON, XML, or other formats. Ensures error handling in interactions, gracefully managing failed data requests or system operations. Procedural design While the architecture offers a structural view, procedural design dives into operational specifics:\nIt maps out the system\u0026rsquo;s logic, defining algorithms and methodologies7. We detail the sequence of operations, ensuring the system processes flow effectively. Considers potential system bottlenecks and ensures efficiency in execution. Tools and techniques Several tools aid software engineers in crafting and visualizing system design:\nUnified Modeling Language (UML)\nA universally recognized notation, UML offers varied diagrams from showcasing system interactions (use-case diagrams) to detailing structure (class diagrams)8.\nEntity-Relationship Diagrams (ERD)\nPrimarily for data design, ERDs visually represent database logical structures9.\nFlowcharts\nFor procedural design, flowcharts offer a graphical representation of processes, making complex algorithms more digestible.\nWhy it is important A robust system design is pivotal for several reasons:\nIt provides clarity, ensuring developers understand the roadmap ahead10. Helps in early detection of system flaws or bottlenecks. Establishes a foundation that can adapt to evolving requirements or technological shifts. Conclusion In conclusion, system design stands as the bridge between conceptual requirements and tangible software. As aspirant software engineers, investing time to grasp and master this phase can be the difference between crafting software that merely works and software that excels.\nReferences Sommerville, I., 2010. Software Engineering. 9th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBooch, G., 2007. Object-Oriented Analysis and Design with Applications. 3rd ed. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPressman, R.S., 2010. Software Engineering: A Practitioner\u0026rsquo;s Approach. 7th ed. McGraw-Hill.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A.S., 2012. Structured Computer Organization. 6th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBass, L., Clements, P., \u0026amp; Kazman, R., 2012. Software Architecture in Practice. 3rd ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFielding, R.T., 2000. Architectural Styles and the Design of Network-based Software Architectures. Doctoral dissertation, University of California, Irvine.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPage-Jones, M., 1988. The Practical Guide to Structured Systems Design. 2nd ed. Yourdon Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, M., 2004. UML Distilled: A Brief Guide to the Standard Object Modeling Language. 3rd ed. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChen, P.P., 1976. The Entity-Relationship Model: Toward a Unified View of Data. ACM Transactions on Database Systems, 1(1).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRoyce, W.W., 1987. Managing the Development of Large Software Systems. Proceedings of IEEE WESCON.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1691884800,"headings":[{"anchor":"architecture-design","title":"Architecture design"},{"anchor":"components","title":"Components"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"data-design","title":"Data design"},{"anchor":"interface-design","title":"Interface design"},{"anchor":"procedural-design","title":"Procedural design"},{"anchor":"references","title":"References"},{"anchor":"tools-and-techniques","title":"Tools and techniques"},{"anchor":"why-it-is-important","title":"Why it is important"}],"kind":"page","lang":"en","series":["Software Engineering"],"summary":"System design is an essential part of the Software Development Life Cycle (SDLC). In many ways, this phase sets the stage for the eventual construction of the software system.","tags":["intro","software-engineering","sdlc","design"],"title":"The System Design phase","url":"/en/software-engineering/0200-sdlc/03-system-design/","year":"2023"},{"content":"","date":1691798400,"headings":[],"kind":"term","lang":"en","summary":"","title":"planning","url":"/en/tags/planning/","year":"2023"},{"authors":["Julián Nonino"],"content":"At its core, planning in software development is about establishing a clear vision for the software project, determining what you want to achieve, and figuring out how best to achieve it1. It\u0026rsquo;s akin to mapping out a journey before embarking on it, ensuring you have all the necessary tools and knowledge to navigate through the challenges ahead.\nKey components Requirement gathering and analysis When we talk about requirements, we\u0026rsquo;re essentially discussing the needs, desires, and constraints of the software project1. Requirement gathering is the act of deeply engaging with stakeholders, from potential users to business experts, to compile a comprehensive list of what the software must accomplish. This dialogue can take various forms: interviews, surveys, user workshops, or even observation.\nThe subsequent step, requirement analysis, involves sifting through this amassed data to create a structured and prioritized list. The primary aim here is to delineate functional requirements (what the software should do) from non-functional requirements (how the software should behave, e.g., performance, security, usability standards)2. At the heart of this component is the creation of a clear, concise, and comprehensive requirements document. This document becomes the blueprint for the entire project, guiding subsequent phases of the SDLC.\nThis topic will be studied in detail later. Please check the article Requirements Engineering on this blog.\nFeasibility study Imagine embarking on a grand venture without checking if it\u0026rsquo;s achievable. A feasibility study plays this crucial role in the planning phase3. It\u0026rsquo;s a rigorous analysis to ascertain if the project is viable in various aspects:\nTechnical feasibility: can we build it with our current tech stack and expertise? Economic feasibility: does it make financial sense to undertake this project? Operational feasibility: once developed, will the software integrate seamlessly into its intended environment? Legal feasibility: are there any regulatory or compliance factors we need to consider? This systematic study not only ensures that the project is grounded in reality but also preemptively identifies potential pitfalls, enabling the team to either address them or reconsider the project\u0026rsquo;s scope.\nProject scheduling Time, as they say, waits for no one. Especially in software development, where delays can mean cost overruns or missed market opportunities4. Project scheduling is the act of plotting out the journey ahead. It\u0026rsquo;s not just about setting a launch date; it\u0026rsquo;s about understanding and allocating time for each intricate step of the SDLC.\nKey tools, like Gantt charts, offer visual representations of project timelines, mapping out tasks against time. Critical Path Method (CPM) can help identify the most important sequence of tasks, ensuring focus is placed where it\u0026rsquo;s most crucial5. This meticulous breakdown of timelines helps teams remain synchronized and stakeholders aligned, offering a clear picture of expected progress.\nResource allocation Every craftsperson needs their tools, and in software development, these tools range from the tangible to the intangible6. Resource allocation is about identifying and procuring these necessary tools. This component deals with:\nHuman resources: which skills do we need, and do we have them in-house or need to hire? Technological resources: what software, hardware, and platforms are essential for development? Financial resources: budgeting for the project, ensuring that funds are available and wisely distributed. Effective resource allocation ensures that the development team isn\u0026rsquo;t hamstrung by lack of tools or personnel, promoting a smoother flow through subsequent SDLC stages.\nRisk assessment In any venture, risks lurk. But in software development, with its myriad components and dependencies, risks are especially abundant7. Risk assessment is the act of identifying, analyzing, and planning for these potential pitfalls.\nBy identifying risks early, from shifting user requirements to technological challenges, teams can develop strategies to either mitigate or avoid them. Tools like SWOT analysis (evaluating Strengths, Weaknesses, Opportunities, Threats) can offer structured frameworks for this process. As a core part of the planning phase, risk assessment ensures that the team isn\u0026rsquo;t blindsided, but rather, is always a step ahead of potential challenges.\nWhy planning matters Vision alignment\nThe planning phase ensures that all stakeholders share a unified vision of the project\u0026rsquo;s objectives and outcomes8.\nCost and time efficiency\nA well-laid plan can help prevent costly overruns and delays, ensuring the project remains within budget and on schedule.\nFoundation for subsequent phases\nThink of planning as laying the groundwork. A solid plan paves the way for smoother design, development, testing, and deployment phases9.\nConclusion Embarking on a software project without comprehensive planning is like setting sail on turbulent seas without a compass. As you journey deeper into the realm of software development, always remember the sage words of Benjamin Franklin: \u0026ldquo;By failing to prepare, you are preparing to fail.\u0026rdquo;\nReferences Sommerville, I., 2010. Software Engineering. 9th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPressman, R.S., 2010. Software Engineering: A Practitioner\u0026rsquo;s Approach. 7th ed. McGraw-Hill.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBoehm, B.W., 1988. A Spiral Model of Software Development and Enhancement. Computer, 21(5).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKerzner, H., 2009. Project Management: A Systems Approach to Planning, Scheduling, and Controlling. 10th ed. Wiley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLewis, J.P., 2007. Fundamentals of Project Management. 3rd ed. AMACOM.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPfleeger, S.L., 2009. Software Engineering: Theory and Practice. 4th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCharette, R.N., 1989. Software Engineering Risk Analysis and Management. McGraw-Hill.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBrooks, F.P., 1995. The Mythical Man-Month: Essays on Software Engineering. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nJalote, P., 2005. An Integrated Approach to Software Engineering. 3rd ed. Springer.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1691798400,"headings":[{"anchor":"conclusion","title":"Conclusion"},{"anchor":"feasibility-study","title":"Feasibility study"},{"anchor":"key-components","title":"Key components"},{"anchor":"project-scheduling","title":"Project scheduling"},{"anchor":"references","title":"References"},{"anchor":"requirement-gathering-and-analysis","title":"Requirement gathering and analysis"},{"anchor":"resource-allocation","title":"Resource allocation"},{"anchor":"risk-assessment","title":"Risk assessment"},{"anchor":"why-planning-matters","title":"Why planning matters"}],"kind":"page","lang":"en","series":["Software Engineering"],"summary":"Stepping into the vast world of software development, one quickly realizes that building successful software isn't just about writing code. It requires foresight, strategy, and, above all, meticulous planning. The planning phase of the SDLC serves as the foundation upon which all subsequent stages are built. Here, we'll unpack this critical phase, understanding its nuances and appreciating its central role in software engineering.","tags":["intro","software-engineering","sdlc","planning"],"title":"The Planning phase","url":"/en/software-engineering/0200-sdlc/02-planning/","year":"2023"},{"authors":["Julián Nonino"],"content":"The SDLC is a framework encompassing the tasks required for the entire software development process. It serves as a structured guide used by professionals to design, develop, and test high-quality software, ensuring the final product aligns with customer expectations, is delivered timely, and remains within budget1. It\u0026rsquo;s essential to note that while the SDLC provides a foundational structure, its actual implementation can vary based on the chosen development methodology, be it Waterfall, Agile, or others.\nPhases Each stage of the SDLC is pivotal in software development. Let\u0026rsquo;s delve deeper into these phases:\nPlanning: This phase focuses on understanding what the software aims to achieve and how. It involves resource allocation, timelines, and more2.\nSystem Design: Post planning, the software\u0026rsquo;s architecture is sketched out. This blueprint details components, interfaces, and data interactions.\nImplementation: Armed with a design, developers begin the coding process. The software starts to materialize as individual components are integrated3.\nTesting: This phase ensures the software\u0026rsquo;s optimal functionality, identifying and rectifying bugs and errors4.\nDeployment: Once tested, the software is made available to users. Depending on feedback, this could be a beta release or a full-scale launch.\nMaintenance: After deployment, the software undergoes updates and tweaks to stay updated and functional in a dynamic tech environment5.\nWhy it is important? The SDLC is important because it offers:\nSystematic Approach: The SDLC offers a consistent, methodical framework, championing top-tier software quality and minimal glitches6. Efficiency: Embracing the SDLC promotes efficient software production. Its structured nature ensures a balance in all phases, minimizing costly mistakes7. Client Satisfaction: The SDLC\u0026rsquo;s client-centric approach guarantees that the software aligns with user needs, boosting satisfaction8. Versatility in Implementation: While the SDLC provides a core structure, its flexibility allows adaptation to various development methodologies, from the linear approach of Waterfall to the iterative cycles of Agile. References Pressman, R.S., 2010. Software Engineering: A Practitioner\u0026rsquo;s Approach. 7th ed. McGraw-Hill.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSommerville, I., 2010. Software Engineering. 9th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBooch, G., 2007. Object-Oriented Analysis and Design with Applications. 3rd ed. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMyers, G. J., 1979. The Art of Software Testing. Wiley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPfleeger, S.L., 2009. Software Engineering: Theory and Practice. 4th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBrooks, F.P., 1995. The Mythical Man-Month: Essays on Software Engineering. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBoehm, B.W., 1988. A Spiral Model of Software Development and Enhancement. Computer, 21(5).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nJalote, P., 2005. An Integrated Approach to Software Engineering. 3rd ed. Springer.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1691712e3,"headings":[{"anchor":"phases","title":"Phases"},{"anchor":"references","title":"References"},{"anchor":"why-it-is-important","title":"Why it is important?"}],"kind":"page","lang":"en","series":["Software Engineering"],"summary":"In the realm of software and technology, a predictable and structured approach to software development is pivotal. The Software Development Life Cycle (SDLC) offers just that. As we delve into the SDLC, you'll understand its integral role in the world of software engineering and how it manifests in various development methodologies.","tags":["intro","software-engineering","sdlc"],"title":"Introduction","url":"/en/software-engineering/0200-sdlc/01-introduction/","year":"2023"},{"authors":["Julián Nonino"],"content":"What is Software? Several thought leaders in the world of computing have defined software in various ways:\nIan Sommerville1: Computer programs and associated documentation.\nRoger S. Pressman2: A collection of computer programs, procedures, rules, and associated documentation and data.\nAndrew S. Tanenbaum3: A series of instructions that tells a computer what to do.\nGrady Booch4: Set of items or objects that form a configuration that includes programs, documents, and data.\nPeter Denning5: Map of a machine, detailing its possible states, transitions, and the actions for these transitions.\nAnalyzing these definitions, common themes emerge: software encompasses instructions, data, associated documentation, and serves as a guiding structure for computer operations. So we can conclude:\nSoftware is a meticulously structured collection of programs, data, and documentation that serves as a guiding blueprint, directing a computer\u0026rsquo;s operations and interactions with users and other systems.\nAlthough we can classify software in many different types, each with its specific function, we can define three primary categories:\nSystem Software: This forms the core of a computer\u0026rsquo;s operation. It includes operating systems like Windows, Linux, and macOS, which manage hardware resources and provide services for application software. Application Software: Tailored for end-users to perform specific tasks, this category ranges from word processors (like Microsoft Word) to graphic design tools (like Adobe Photoshop) and games. Embedded Software: Found within hardware devices such as washing machines, traffic lights, or digital watches, embedded software operates specific functions of these devices. Unlike general-purpose software, it\u0026rsquo;s dedicated to specific tasks or functions. What is Software Engineering? Several prominent figures have also provided their perspectives on Software Engineering:\nIan Sommerville1: A discipline concerned with all aspects of software production.\nRoger S. Pressman2: Establishment and use of sound engineering principles to obtain economically software that is reliable and works efficiently on real machines.\nFrederick P. Brooks6: The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software.\nBarry W. Boehm7: Aims to produce quality software, software that is delivered on time, within budget, and that satisfies its requirements.\nFritz Bauer8: The establishment and use of sound engineering principles to economically obtain software that is reliable and works on real machines.\nFrom these definitions, we can discern that software engineering integrates principles of engineering, emphasizes systematic methods, seeks reliability and efficiency, and aims for the production of high-quality software that meets its specified requirements. Concluding that\nSoftware Engineering is the disciplined application of engineering principles and systematic methods to design, develop, and maintain reliable and efficient software that economically meets specified requirements and user needs.\nSoftware Engineering should not be confused with Computer Science. While the latter is a discipline that dives deep into the theoretical and mathematical aspects of computing, studying algorithms, computational theory, and more, the first one primarily focuses on designing and building large software systems. It emphasizes practical techniques and methodologies that ensure the production of high-quality, maintainable software.\nWhy it is important to develop quality software Today, we\u0026rsquo;re surrounded by a digital ecosystem. Software runs our phones, cars, banks, hospitals, and even our homes. This ubiquity underscores its significance. That means that software flaws can have catastrophic outcomes. From banking systems to healthcare applications, the demand for faultless, efficient software is sky-high.\nSoftware Engineering, ensures this vast amount of software is reliable, efficient, and meets user needs. As technology advances at breakneck speed, the role of software engineers becomes even more pivotal, making sure innovations are safe and effective.\nWhether you\u0026rsquo;re using a social media app, making a bank transaction, or checking health diagnostics, remember there\u0026rsquo;s a meticulously engineered software system running behind the scenes, making it all possible.\nReferences Sommerville, I., 2010. Software Engineering. 9th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPressman, R.S., 2010. Software Engineering: A Practitioner\u0026rsquo;s Approach. 7th ed. McGraw-Hill.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A.S., 2012. Structured Computer Organization. 6th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBooch, G., 2007. Object-Oriented Analysis and Design with Applications. 3rd ed. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDenning, P.J., 2009. The Profession of IT, Beyond Computational Thinking. Communications of the ACM, 52(6).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBrooks, F.P., 1995. The Mythical Man-Month: Essays on Software Engineering. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBoehm, B.W., 1988. A Spiral Model of Software Development and Enhancement. Computer, 21(5).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBauer, F.L., 1972. Software Engineering. Information Processing, 71.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1691625600,"headings":[{"anchor":"references","title":"References"},{"anchor":"what-is-software","title":"What is Software?"},{"anchor":"what-is-software-engineering","title":"What is Software Engineering?"},{"anchor":"why-it-is-important-to-develop-quality-software","title":"Why it is important to develop quality software"}],"kind":"page","lang":"en","series":["Software Engineering"],"summary":"In today's digital age, it's impossible to imagine a world without software. From the apps we use daily to sophisticated systems that run entire cities, software is an intricate part of our lives. If you're at the beginning of your journey into the world of software, this article will provide a foundational understanding of what software is, what software engineering entails, and the paramount significance of both in today's world.","tags":["intro","software-engineering"],"title":"Introduction","url":"/en/software-engineering/0100-intro/01-intro/","year":"2023"},{"content":"","date":1691452800,"headings":[],"kind":"term","lang":"en","summary":"","title":"factorial","url":"/en/tags/factorial/","year":"2023"},{"content":"","date":1691452800,"headings":[],"kind":"term","lang":"en","summary":"","title":"fibonacci\"","url":"/en/tags/fibonacci/","year":"2023"},{"content":"","date":1691452800,"headings":[],"kind":"term","lang":"en","summary":"","title":"python","url":"/en/tags/python/","year":"2023"},{"content":"","date":1691452800,"headings":[],"kind":"term","lang":"en","summary":"","title":"recursion","url":"/en/tags/recursion/","year":"2023"},{"authors":["Julián Nonino"],"content":"A recursive function breaks down a problem into smaller, more manageable subproblems. These subproblems are solved by the same function, which continues to call itself until it reaches a base case.\nThe factorial function is a great example to demonstrate recursion. Let\u0026rsquo;s break it down step by step.\nThe factorial of a positive integer \\(n\\) is the product of all positive integers less than or equal to \\(n\\) . For example:\n\\(5! = 5 * 4 * 3 * 2 * 1 = 120\\) \\(4! = 4 * 3 * 2 * 1 = 24\\) \\(3! = 3 * 2 * 1 = 6\\) Here\u0026rsquo;s the Python code for calculating factorial using recursion:\n1def factorial(n): 2 if n == 1: 3 return 1 4 return n * factorial(n-1) Base Case: The base case is the simplest, smallest instance of the problem that can be answered directly. For the factorial, when \\(n = 1\\) , the result is \\(1\\) .\nRecursive Case: If \\(n\\) is greater than \\(1\\) , the function calls itself with \\(n-1\\) , and multiplies the result by \\(n\\) .\nLet\u0026rsquo;s say you want to calculate the factorial of \\(5\\) , so you call factorial(5).\nHere\u0026rsquo;s what happens:\nStep 1: Since \\(n = 5\\) is not \\(1\\) , the function calls factorial(4), then multiplies the result by \\(5\\) . Step 2: Now, within factorial(4), \\(n = 4\\) , so the function calls factorial(3), then multiplies the result by \\(4\\) . Step 3: Inside factorial(3), \\(n = 3\\) , so it calls factorial(2), then multiplies the result by \\(3\\) . Step 4: Within factorial(2), \\(n = 2\\) , so it calls factorial(1), then multiplies the result by \\(2\\) . Step 5: Finally, factorial(1) reaches the base case, where \\(n = 1\\) , so it returns \\(1\\) . Now the results unwind:\nfactorial(2) returns \\(2 * 1 = 2\\) factorial(3) returns \\(3 * 2 = 6\\) factorial(4) returns \\(4 * 6 = 24\\) factorial(5) returns \\(5 * 24 = 120\\) The final result is \\(120\\) , which is the value of \\(5!\\) .\nHere\u0026rsquo;s a visual representation of the call stack:\n1factorial(5) 2 -\u0026gt; factorial(4) 3 -\u0026gt; factorial(3) 4 -\u0026gt; factorial(2) 5 -\u0026gt; factorial(1) 6 return 1 7 return 2 8 return 6 9 return 24 10 return 120 Tail Recursion Tail recursion is a special form of recursion where the recursive call is the last operation in the function. This can be more efficient, as some compilers and interpreters can optimize it into a loop.\nThe Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones. The sequence begins with \\(0\\) and \\(1\\) , and every number thereafter is the sum of the two preceding numbers. The first few numbers in the sequence are: \\(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\\) Here\u0026rsquo;s the Python code for calculating the \\(n^th\\) Fibonacci number using tail recursion:\n1def fibonacci(n, a=0, b=1): 2 if n == 0: 3 return a 4 return fibonacci(n-1, b, a+b) The function takes three parameters:\n\\(n\\) : The position of the desired number in the sequence. \\(a\\) and \\(b\\) : Two numbers that help in computing the sequence. Here\u0026rsquo;s a breakdown of how the function works:\nBase Case: If \\(n\\) is \\(0\\) , the function returns \\(a\\) . This is the value of the \\(n^th\\) number in the sequence.\nRecursive Case: If \\(n\\) is not \\(0\\) , the function calls itself with \\(n-1\\) , \\(b\\) , and \\(a\u0026#43;b\\) . These parameters shift the position in the sequence and set up the next numbers for addition.\nSuppose we want to find the \\(5^th\\) number in the Fibonacci sequence by calling fibonacci(5).\nHere\u0026rsquo;s what happens:\nStep 1: Since \\(n = 5\\) , call fibonacci(4, 1, 1) (because \\(a = 0\\) , \\(b = 1\\) , \\(a \u0026#43; b = 1\\) ). Step 2: Since \\(n = 4\\) , call fibonacci(3, 1, 2) (because \\(a = 1\\) , \\(b = 1\\) , \\(a \u0026#43; b = 2\\) ). Step 3: Since \\(n = 3\\) , call fibonacci(2, 2, 3) (because \\(a = 1\\) , \\(b = 2\\) , \\(a \u0026#43; b = 3\\) ). Step 4: Since \\(n = 2\\) , call fibonacci(1, 3, 5) (because \\(a = 2\\) , \\(b = 3\\) , \\(a \u0026#43; b = 5\\) ). Step 5: Since \\(n = 1\\) , call fibonacci(0, 5, 8) (because \\(a = 3\\) , \\(b = 5\\) , \\(a \u0026#43; b = 8\\) ). Step 6: Since \\(n = 0\\) , return \\(a\\) , which is \\(5\\) . The result is \\(5\\) , which is the \\(5^th\\) number in the Fibonacci sequence.\nHere\u0026rsquo;s a visual representation of the call stack:\n1fibonacci(5, 0, 1) 2 -\u0026gt; fibonacci(4, 1, 1) 3 -\u0026gt; fibonacci(3, 1, 2) 4 -\u0026gt; fibonacci(2, 2, 3) 5 -\u0026gt; fibonacci(1, 3, 5) 6 -\u0026gt; fibonacci(0, 5, 8) 7 return 5 Advantages and disadvantages Advantages\nConciseness: Recursive functions can be more concise and elegant. Problem Decomposition: Recursive functions break down a problem into smaller subproblems, often making them easier to understand. Disadvantages\nEfficiency: Recursive functions can be less efficient due to function call overhead. Debugging: Debugging recursive functions can be challenging, especially if they lead to stack overflows. Conclusion Recursive functions are a powerful tool in programming, providing elegant solutions to complex problems. However, they should be used with care, as they can lead to performance issues or make debugging more challenging.\nUnderstanding the base cases, implementing tail recursion when possible, and carefully designing the recursive structure can lead to effective and efficient recursive solutions.\n","date":1691452800,"headings":[{"anchor":"advantages-and-disadvantages","title":"Advantages and disadvantages"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"tail-recursion","title":"Tail Recursion"}],"kind":"page","lang":"en","summary":"A recursive function is a function that calls itself in order to solve a problem. This self-referential nature can lead to elegant and concise solutions, but it also requires careful design to prevent infinite loops and stack overflows. In this article, we'll explore the concept of recursion, learn how to write recursive functions in Python, and discuss their pros and cons.","tags":["recursion","factorial","fibonacci\"","python"],"title":"Recursive functions","url":"/en/blog/2023/08/recursive-functions/","year":"2023"},{"authors":["Julián Nonino"],"content":"Object-Oriented Programming (OOP) has many advanced concepts that take the programming paradigm to a higher level. These concepts enable developers to write code that is more efficient, flexible, and maintainable. In this article, we will delve into some of these advanced concepts, including multithreading, generics/templates, reflection, serialization and deserialization, and dependency injection. Though we\u0026rsquo;ll provide Python examples where applicable, it\u0026rsquo;s worth noting that some of these concepts might be more prevalent in other programming languages.\na. Multithreading Multithreading is the concurrent execution of two or more threads. A thread is the smallest unit of a CPU\u0026rsquo;s execution, and multithreading allows multiple threads to run in parallel, enhancing performance.\nPython’s threading module can be used to create and manage threads.\n1import threading 2 3def print_numbers(): 4 for i in range(1, 6): 5 print(i) 6 7def print_letters(): 8 for letter in \u0026#39;abcde\u0026#39;: 9 print(letter) 10 11thread1 = threading.Thread(target=print_numbers) 12thread2 = threading.Thread(target=print_letters) 13 14thread1.start() 15thread2.start() 16 17thread1.join() 18thread2.join() 19 20print(\u0026#34;Threads completed\u0026#34;) b. Generics/Templates Generics, also known as templates in some languages, allow classes, interfaces, and methods to operate on typed objects, enhancing code reusability and type safety.\nPython is dynamically typed, so generics are less rigid. However, type hints can be used to achieve similar results.\n1from typing import List 2 3def display_numbers(numbers: List[int]) -\u0026gt; None: 4 for number in numbers: 5 print(number) 6 7display_numbers([1, 2, 3]) c. Reflection Reflection is the ability of a program to examine and modify its own structure and behavior at runtime.\nPython allows for reflection through functions like getattr, setattr, and type.\n1class Example: 2 def __init__(self, value): 3 self.value = value 4 5obj = Example(\u0026#34;hello\u0026#34;) 6attr_value = getattr(obj, \u0026#39;value\u0026#39;) 7print(attr_value) # Output: hello d. Serialization and deserialization Serialization is the process of converting an object into a format that can be easily stored or transmitted. Deserialization is the reverse process.\nPython’s pickle module can be used for serialization and deserialization.\n1import pickle 2 3data = {\u0026#34;key\u0026#34;: \u0026#34;value\u0026#34;} 4serialized_data = pickle.dumps(data) 5deserialized_data = pickle.loads(serialized_data) e. Dependency injection Dependency Injection (DI) is a design pattern where objects are passed as dependencies rather than created within the class. It promotes code modularity and testability.\nUsing DI in Python might look like this:\n1class Engine: 2 pass 3 4class Car: 5 def __init__(self, engine: Engine): 6 self.engine = engine 7 8engine = Engine() 9car = Car(engine) Conclusion Advanced OOP concepts offer techniques to develop more efficient, maintainable, and scalable code. Understanding these concepts can greatly improve your ability to write high-quality code in various programming languages, not just Python.\nBy leveraging multithreading, generics, reflection, serialization/deserialization, and dependency injection, you can write code that is more adaptive to changes, easier to test, and optimized for performance. The mastery of these concepts opens up new horizons in software development, allowing you to tackle complex problems with confidence and finesse.\n","date":1681603200,"headings":[{"anchor":"a-multithreading","title":"a. Multithreading"},{"anchor":"b-genericstemplates","title":"b. Generics/Templates"},{"anchor":"c-reflection","title":"c. Reflection"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"d-serialization-and-deserialization","title":"d. Serialization and deserialization"},{"anchor":"e-dependency-injection","title":"e. Dependency injection"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Object-Oriented Programming (OOP) has many advanced concepts that take the programming paradigm to a higher level. These concepts enable developers to write code that is more efficient, flexible, and maintainable. In this article, we will delve into some of these advanced concepts, including multithreading, generics/templates, reflection, serialization and deserialization, and dependency injection. Though we’ll provide Python examples where applicable, it’s worth noting that some of these concepts might be more prevalent in other programming languages.","tags":["oop","object-oriented","multithreading","generics","templates","reflections","serialization"],"title":"Advanced concepts","url":"/en/programming/0300-oop/08-advanced-concepts/","year":"2023"},{"content":"","date":1681603200,"headings":[],"kind":"term","lang":"en","summary":"","title":"generics","url":"/en/tags/generics/","year":"2023"},{"content":"","date":1681603200,"headings":[],"kind":"term","lang":"en","summary":"","title":"multithreading","url":"/en/tags/multithreading/","year":"2023"},{"content":"","date":1681603200,"headings":[],"kind":"term","lang":"en","summary":"","title":"object-oriented","url":"/en/tags/object-oriented/","year":"2023"},{"content":"Object-Oriented Programming (OOP) is a programming paradigm that uses objects and classes to structure code in a way that models real-world entities and their relationships. OOP enables programmers to write reusable, maintainable, and organized code. In this section, we\u0026rsquo;ll explore the core concepts of OOP using Python, though these principles are applicable across various programming languages.\n","date":1681603200,"headings":[],"kind":"section","lang":"en","summary":"Object-Oriented Programming (OOP) is a programming paradigm that uses objects and classes to structure code in a way that models real-world entities and their relationships. OOP enables programmers to write reusable, maintainable, and organized code. In this section, we’ll explore the core concepts of OOP using Python, though these principles are applicable across various programming languages.","title":"Object-Oriented Programming","url":"/en/programming/0300-oop/","year":"2023"},{"content":"","date":1681603200,"headings":[],"kind":"term","lang":"en","summary":"","title":"oop","url":"/en/tags/oop/","year":"2023"},{"content":"","date":1681603200,"headings":[],"kind":"term","lang":"en","summary":"","title":"Programming","url":"/en/series/programming/","year":"2023"},{"content":"Welcome to our comprehensive series on beginning your journey with programming. Crafted for those new to the coding world, this collection of articles offers a step-by-step approach to understanding the fundamentals of programming. Starting from the basics, like understanding variables, data types, and control structures, to gradually exploring more complex topics such as algorithms, data structures, and software design principles, this series is designed to be your guide into the exciting world of code.\nWhether you have never written a line of code or are looking for a structured refresher, this series promises to be an enlightening experience. Our hands-on tutorials, clear explanations, and practical examples aim to make the learning process both engaging and intuitive. Embark on this coding adventure with us, and by the end, you\u0026rsquo;ll be equipped with the skills and knowledge to tackle real-world programming challenges.\n","date":1681603200,"headings":[],"kind":"section","lang":"en","summary":"Welcome to our comprehensive series on beginning your journey with programming. Crafted for those new to the coding world, this collection of articles offers a step-by-step approach to understanding the fundamentals of programming. Starting from the basics, like understanding variables, data types, and control structures, to gradually exploring more complex topics such as algorithms, data structures, and software design principles, this series is designed to be your guide into the exciting world of code.","title":"Programming","url":"/en/programming/","year":"2023"},{"content":"","date":1681603200,"headings":[],"kind":"term","lang":"en","summary":"","title":"reflections","url":"/en/tags/reflections/","year":"2023"},{"content":"","date":1681603200,"headings":[],"kind":"term","lang":"en","summary":"","title":"serialization","url":"/en/tags/serialization/","year":"2023"},{"content":"","date":1681603200,"headings":[],"kind":"term","lang":"en","summary":"","title":"templates","url":"/en/tags/templates/","year":"2023"},{"content":"","date":1681430400,"headings":[],"kind":"term","lang":"en","summary":"","title":"aggregation","url":"/en/tags/aggregation/","year":"2023"},{"content":"","date":1681430400,"headings":[],"kind":"term","lang":"en","summary":"","title":"associations","url":"/en/tags/associations/","year":"2023"},{"authors":["Julián Nonino"],"content":"Understanding relationships between classes is vital for designing robust and maintainable systems. This article, will explore three types of relationships: Associations, Aggregations, and Compositions. We\u0026rsquo;ll look into their definitions, differences, and applications, providing examples in Python and using UML diagrams.\nDefinitions Association An association represents a “using” relationship between two or more objects. It indicates that objects of one class are somehow connected or utilize objects of another class.\nAggregation Aggregation is a specialized form of association where one class is a part of another class but both exist independently. It represents a \u0026ldquo;whole-part\u0026rdquo; relationship, but the lifetime of the part does not depend on the whole.\nComposition Composition is a more restrictive form of aggregation where the part\u0026rsquo;s life cycle is closely tied to the whole\u0026rsquo;s life cycle. If the whole is destroyed, the part will also be destroyed. It represents a stronger \u0026ldquo;whole-part\u0026rdquo; relationship.\n\u0026ldquo;has-a\u0026rdquo; relationship Both aggregation and composition represent a \u0026ldquo;has-a\u0026rdquo; relationship. For example, a Car class has an Engine class, but the connection between them could be either aggregation or composition depending on how tightly they are linked.\nUML Diagrams Unified Modeling Language (UML) diagrams can represent these relationships visually:\nAssociation: A simple line between classes. Aggregation: A line with a hollow diamond on the whole side. Composition: A line with a filled diamond on the whole side. Real-world Examples and Python Code Association A Driver class that operates a Car class.\n1class Car: 2 pass 3 4class Driver: 5 def drive(self, car): 6 print(\u0026#34;Driving the car\u0026#34;) 7 8car = Car() 9driver = Driver() 10driver.drive(car) # Output: Driving the car Aggregation A Library class containing a collection of Book objects.\n1class Book: 2 pass 3 4class Library: 5 def __init__(self): 6 self.books = [] 7 8 def add_book(self, book): 9 self.books.append(book) 10 11book = Book() 12library = Library() 13library.add_book(book) Composition A Computer class containing a CPU class, where the CPU cannot exist without the Computer.\n1class CPU: 2 pass 3 4class Computer: 5 def __init__(self): 6 self.cpu = CPU() # CPU is created when the Computer is created 7 8computer = Computer() Conclusion Associations, aggregations, and compositions are foundational concepts that describe different types of relationships between classes in OOP. Understanding these relationships helps in modeling and building real-world systems. While the examples in this article are implemented in Python, these concepts apply across various OOP languages.\nBy grasping these relationships and knowing when to use them, you\u0026rsquo;ll be better equipped to design and implement effective and efficient systems. They allow you to create code that accurately represents the real world, fostering clearer thinking and stronger design skills.\n","date":1681430400,"headings":[{"anchor":"aggregation","title":"Aggregation"},{"anchor":"aggregation-1","title":"Aggregation"},{"anchor":"association","title":"Association"},{"anchor":"association-1","title":"Association"},{"anchor":"composition","title":"Composition"},{"anchor":"composition-1","title":"Composition"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"definitions","title":"Definitions"},{"anchor":"has-a-relationship","title":"\u0026ldquo;has-a\u0026rdquo; relationship"},{"anchor":"real-world-examples-and-python-code","title":"Real-world Examples and Python Code"},{"anchor":"uml-diagrams","title":"UML Diagrams"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Understanding relationships between classes is vital for designing robust and maintainable systems. This article, will explore three types of relationships: Associations, Aggregations, and Compositions. We’ll look into their definitions, differences, and applications, providing examples in Python and using UML diagrams.\nDefinitions Association An association represents a “using” relationship between two or more objects. It indicates that objects of one class are somehow connected or utilize objects of another class.\nAggregation Aggregation is a specialized form of association where one class is a part of another class but both exist independently.","tags":["oop","object-oriented","associations","aggregation","composition","uml"],"title":"Associations, aggregations, and compositions","url":"/en/programming/0300-oop/07-associations/","year":"2023"},{"content":"","date":1681430400,"headings":[],"kind":"term","lang":"en","summary":"","title":"composition","url":"/en/tags/composition/","year":"2023"},{"content":"","date":1681430400,"headings":[],"kind":"term","lang":"en","summary":"","title":"uml","url":"/en/tags/uml/","year":"2023"},{"authors":["Julián Nonino"],"content":"Abstraction is one of the key principles in Object-Oriented Programming (OOP). It plays a vital role in managing complexity by hiding unnecessary details and exposing only what\u0026rsquo;s essential. This article, will explore the concept of abstraction, its purpose, abstract classes, interfaces, and implementation in Python.\nAbstraction refers to the practice of hiding the complex reality while exposing only the essential parts. It\u0026rsquo;s like viewing something at a high level without delving into the details.\nThe main purposes of abstraction are:\nSimplifying Complexity: By hiding unnecessary details, abstraction makes the code more manageable. Increasing Reusability: Encapsulating complexity leads to more reusable code. Enhancing Security: By exposing only what\u0026rsquo;s needed, abstraction protects the internal workings of a class or module. Abstract classes and interfaces Abstract classes: is a class that cannot be instantiated on its own and must be subclassed by another class. It may contain abstract methods, which have no implementation in the abstract class and must be implemented by any non-abstract subclass. Interfaces: defines a contract for what methods a class must implement but doesn\u0026rsquo;t provide implementations for those methods. In some languages, interfaces are explicitly defined, but in Python, this concept is handled using abstract classes with only abstract methods. Implementing abstraction in Python In Python, abstraction can be implemented using the abc module. Here\u0026rsquo;s how you can create an abstract class:\n1from abc import ABC, abstractmethod 2 3class Shape(ABC): 4 @abstractmethod 5 def area(self): 6 pass 7 8class Circle(Shape): 9 def __init__(self, radius): 10 self.radius = radius 11 12 def area(self): # Implementing the abstract method 13 return 3.14 * self.radius ** 2 14 15shape = Shape() # TypeError: Can\u0026#39;t instantiate abstract class Shape with abstract methods area 16circle = Circle(5) 17print(circle.area()) # Output: 78.5 In this example, Shape is an abstract class with an abstract method area. Any subclass of Shape must provide an implementation of this method.\nImplementing abstraction in Java Using abstract classes 1abstract class Shape { 2 abstract double area(); 3} 4 5class Circle extends Shape { 6 double radius; 7 8 Circle(double radius) { 9 this.radius = radius; 10 } 11 12 double area() { 13 return 3.14 * radius * radius; 14 } 15} In Java, you define an abstract class using the abstract keyword, and any method without a body must also be marked as abstract.\nUsing interfaces In Java, an interface can be used to define a contract that classes must adhere to. Here\u0026rsquo;s an example:\n1interface Shape { 2 double area(); 3} 4 5class Circle implements Shape { 6 double radius; 7 8 Circle(double radius) { 9 this.radius = radius; 10 } 11 12 public double area() { 13 return 3.14 * radius * radius; 14 } 15} In this example, the Shape interface defines an area method that must be implemented by any class that implements the interface. The Circle class implements the Shape interface and provides an implementation for the area method.\nWhen to use abstract classes and interfaces in Java When designing a system in Java, choosing between abstract classes and interfaces depends on various factors. Here\u0026rsquo;s a guide to help you decide:\nUse Abstract Classes when:\nYou want to share code among several closely related classes: Abstract classes allow you to define some default behavior (concrete methods) and force subclasses to provide specific implementations for other parts (abstract methods). You want to control the inheritance hierarchy: Abstract classes can have constructors and can also have access modifiers (public, protected, private) applied to their methods. This provides more control over how a class is inherited. You need to maintain state: If you want to have common state and behavior among several classes, then using an abstract class is appropriate. You want to allow only a single inheritance: Java doesn’t support multiple inheritances for classes, so if a class is already extending another class, it can’t extend another abstract class. Use Interfaces when:\nYou want to define a contract for several unrelated classes*: Interfaces allow unrelated classes to implement the same set of methods, thus ensuring that the classes adhere to certain behavior. This helps in achieving a clean architecture where you can easily swap one implementation with another. You need to support multiple inheritance: A class can implement multiple interfaces in Java, so if you want a class to adhere to multiple contracts, you would use interfaces. You want to separate the method declaration from implementation completely: Interfaces in Java (prior to Java 8) allow only abstract method declarations. Starting from Java 8, you can have default methods with implementation in interfaces, but the primary purpose remains defining a contract. You want strong encapsulation: Interfaces enable you to hide the implementation details of the classes completely, exposing only the methods that should be accessible. This is aligned with the principle of strong encapsulation. You need to implement a standard API across different objects: If you want various objects to expose the same method signatures, thus allowing them to be used interchangeably, interfaces provide a clear way to enforce this. Conclusion Abstraction is a powerful concept that enables developers to hide complexity and provide a cleaner, higher-level interface to users of the code. By understanding and applying abstract classes and interfaces, you can write code that is easier to maintain, understand, and extend.\nAs you continue to explore OOP, leveraging abstraction will become an essential tool in your toolkit, allowing you to design more efficient and effective software systems. Whether you\u0026rsquo;re working in Python or another OOP language, the principle of abstraction transcends specific technologies, making it a foundational concept in modern software development.\n","date":1681257600,"headings":[{"anchor":"abstract-classes-and-interfaces","title":"Abstract classes and interfaces"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"implementing-abstraction-in-java","title":"Implementing abstraction in Java"},{"anchor":"implementing-abstraction-in-python","title":"Implementing abstraction in Python"},{"anchor":"using-abstract-classes","title":"Using abstract classes"},{"anchor":"using-interfaces","title":"Using interfaces"},{"anchor":"when-to-use-abstract-classes-and-interfaces-in-java","title":"When to use abstract classes and interfaces in Java"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Abstraction is one of the key principles in Object-Oriented Programming (OOP). It plays a vital role in managing complexity by hiding unnecessary details and exposing only what’s essential. This article, will explore the concept of abstraction, its purpose, abstract classes, interfaces, and implementation in Python.\nAbstraction refers to the practice of hiding the complex reality while exposing only the essential parts. It’s like viewing something at a high level without delving into the details.","tags":["oop","object-oriented","abstractions","interfaces"],"title":"Abstraction","url":"/en/programming/0300-oop/06-abstraction/","year":"2023"},{"content":"","date":1681257600,"headings":[],"kind":"term","lang":"en","summary":"","title":"abstractions","url":"/en/tags/abstractions/","year":"2023"},{"content":"","date":1681257600,"headings":[],"kind":"term","lang":"en","summary":"","title":"interfaces","url":"/en/tags/interfaces/","year":"2023"},{"content":"","date":1681084800,"headings":[],"kind":"term","lang":"en","summary":"","title":"polymorphism","url":"/en/tags/polymorphism/","year":"2023"},{"authors":["Julián Nonino"],"content":"Polymorphism is a Greek word that means \u0026ldquo;many-shaped.\u0026rdquo; In Object-Oriented Programming (OOP), it\u0026rsquo;s a principle that allows objects of different classes to be treated as objects of a common base class. This principle enables greater flexibility and more dynamic behavior in code. This article, will delve into the concept of polymorphism, discussing its types, overloading, overriding, virtual functions, and providing examples in Python.\nPolymorphism allows different objects to respond to the same method call in a way that\u0026rsquo;s specific to their individual types. It promotes code reusability and can be used to implement elegant software design.\nThere are two main types of polymorphism:\nCompile-Time Polymorphism (Static Polymorphism): This occurs at compile-time, where the method that needs to be executed is determined during the compilation of the code. Method overloading is an example of compile-time polymorphism.\nRun-Time Polymorphism (Dynamic Polymorphism): This occurs at run-time, where the method to be executed is determined during the execution of the program. Method overriding and virtual functions are examples of run-time polymorphism.\nMethod overloading Method overloading occurs when multiple methods in the same class have the same name but different parameters. This is a form of compile-time polymorphism.\nIn Python, method overloading is handled differently, as you can define a method with optional parameters.\n1class Math: 2 def add(self, a, b, c=0): 3 return a + b + c 4 5math = Math() 6print(math.add(2, 3)) # Output: 5 7print(math.add(2, 3, 4)) # Output: 9 Method overriding Method overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass. This is a form of run-time polymorphism.\n1class Animal: 2 def sound(self): 3 print(\u0026#34;Some generic animal sound\u0026#34;) 4 5class Dog(Animal): 6 def sound(self): # Overrides the sound method of Animal 7 print(\u0026#34;Woof!\u0026#34;) 8 9dog = Dog() 10dog.sound() # Output: Woof! Virtual functions In some languages like C++, a virtual function is used to override a function in the base class. In Python, all methods are virtual by default, meaning that they can be overridden in a subclass. Therefore, the concept of virtual functions doesn\u0026rsquo;t explicitly apply in Python as it does in some other languages.\nExample Here\u0026rsquo;s a comprehensive example demonstrating polymorphism in Python:\n1class Bird: 2 def sound(self): 3 print(\u0026#34;Tweet\u0026#34;) 4 5class Cat: 6 def sound(self): 7 print(\u0026#34;Meow\u0026#34;) 8 9def animal_sound(animal): 10 animal.sound() 11 12bird = Bird() 13cat = Cat() 14 15animal_sound(bird) # Output: Tweet 16animal_sound(cat) # Output: Meow In this example, the animal_sound function is capable of taking any object that has a sound method, demonstrating the polymorphic nature of the code.\nConclusion Polymorphism is a vital concept in OOP, enhancing flexibility and enabling objects of different classes to be handled uniformly. Understanding overloading, overriding, and the differences between compile-time and run-time polymorphism will strengthen your ability to write more efficient, maintainable, and scalable code.\nAs you continue to explore OOP, these principles will serve as the building blocks for creating more complex and well-designed software applications.\n","date":1681084800,"headings":[{"anchor":"conclusion","title":"Conclusion"},{"anchor":"example","title":"Example"},{"anchor":"method-overloading","title":"Method overloading"},{"anchor":"method-overriding","title":"Method overriding"},{"anchor":"virtual-functions","title":"Virtual functions"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Polymorphism is a Greek word that means “many-shaped.” In Object-Oriented Programming (OOP), it’s a principle that allows objects of different classes to be treated as objects of a common base class. This principle enables greater flexibility and more dynamic behavior in code. This article, will delve into the concept of polymorphism, discussing its types, overloading, overriding, virtual functions, and providing examples in Python.\nPolymorphism allows different objects to respond to the same method call in a way that’s specific to their individual types.","tags":["oop","object-oriented","polymorphism"],"title":"Polymorphism","url":"/en/programming/0300-oop/05-polymorphism/","year":"2023"},{"content":"","date":1680912e3,"headings":[],"kind":"term","lang":"en","summary":"","title":"inheritance","url":"/en/tags/inheritance/","year":"2023"},{"authors":["Julián Nonino"],"content":"Inheritance is another fundamental concept in Object-Oriented Programming (OOP), allowing for the creation of a new class based on an existing class. This concept helps in reusing code, creating relationships between classes, and building hierarchical structures. This article will explore inheritance in detail, focusing on examples in Python.\nInheritance is a mechanism that allows a class (derived or subclass) to inherit attributes and methods from another class (base or superclass). The derived class can extend or modify the features of the base class.\nThere are several types of inheritance:\nSingle inheritance: One subclass inherits from one superclass. Multiple inheritance: A subclass inherits from multiple superclasses. Multilevel inheritance: A subclass inherits from a superclass, and then another class inherits from that subclass, creating multiple levels. Hierarchical inheritance: Multiple subclasses inherit from a single superclass. Hybrid inheritance: A combination of two or more types of inheritance. Base and derived classes A base class, also known as the parent class, is the class whose properties are inherited by another class.\nA derived class, or child class, inherits properties from the base class. It may also have additional properties or modify the inherited ones.\nHere\u0026rsquo;s a simple example in Python:\n1class Animal: # Base class 2 def eat(self): 3 print(\u0026#34;Eating...\u0026#34;) 4 5class Dog(Animal): # Derived class 6 def bark(self): 7 print(\u0026#34;Barking...\u0026#34;) Dog is a derived class that inherits the eat method from the base class Animal.\nOverriding methods In OOP, a subclass can provide a specific implementation of a method that is already defined in its superclass. This is known as overriding.\nExample in Python:\n1class Bird(Animal): 2 def eat(self): 3 print(\u0026#34;Pecking seeds...\u0026#34;) # This overrides the eat method in Animal \u0026ldquo;is-a\u0026rdquo; relationship Inheritance establishes an \u0026ldquo;is-a\u0026rdquo; relationship between the base and derived classes. For example, if there is a base class Vehicle and a derived class Car, then a Car is a type of Vehicle.\nExample Here\u0026rsquo;s a more comprehensive example in Python demonstrating multiple aspects of inheritance:\n1class Person: # Base class 2 def __init__(self, name): 3 self.name = name 4 5 def display(self): 6 print(f\u0026#34;I am {self.name}.\u0026#34;) 7 8class Student(Person): # Derived class 9 def __init__(self, name, roll_number): 10 super().__init__(name) # Calling constructor of base class 11 self.roll_number = roll_number 12 13 def display(self): # Overriding method 14 print(f\u0026#34;I am {self.name}, and my roll number is {self.roll_number}.\u0026#34;) 15 16student = Student(\u0026#34;Alice\u0026#34;, 42) 17student.display() # Output: I am Alice, and my roll number is 42. In this example, Student is a derived class that inherits from the Person base class. It overrides the display method and calls the constructor of the base class using super().\nConclusion Inheritance is a powerful feature in OOP, enabling reusability, organization, and establishing natural relationships between classes. Understanding and implementing inheritance can lead to more efficient and readable code.\nWith the insights gained from this article, you\u0026rsquo;re well-equipped to explore more complex aspects of OOP, such as polymorphism and abstract classes, which build upon the principles of inheritance.\n","date":1680912e3,"headings":[{"anchor":"base-and-derived-classes","title":"Base and derived classes"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"example","title":"Example"},{"anchor":"is-a-relationship","title":"\u0026ldquo;is-a\u0026rdquo; relationship"},{"anchor":"overriding-methods","title":"Overriding methods"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Inheritance is another fundamental concept in Object-Oriented Programming (OOP), allowing for the creation of a new class based on an existing class. This concept helps in reusing code, creating relationships between classes, and building hierarchical structures. This article will explore inheritance in detail, focusing on examples in Python.\nInheritance is a mechanism that allows a class (derived or subclass) to inherit attributes and methods from another class (base or superclass). The derived class can extend or modify the features of the base class.","tags":["oop","object-oriented","inheritance"],"title":"Inheritance","url":"/en/programming/0300-oop/04-inheritance/","year":"2023"},{"content":"","date":1680739200,"headings":[],"kind":"term","lang":"en","summary":"","title":"encapsulation","url":"/en/tags/encapsulation/","year":"2023"},{"authors":["Julián Nonino"],"content":"Encapsulation is one of the four foundational principles of Object-Oriented Programming (OOP). It plays a crucial role in protecting the integrity of an object by controlling how its data can be accessed and modified. This article, will explore the concept of encapsulation, explain modifiers, and demonstrate how to use getters and setters in Python.\nEncapsulation refers to the bundling of data (attributes) and the methods (functions) that operate on the data into a single unit, restricting direct access to some of an object\u0026rsquo;s components. It acts like a protective barrier that prevents the code outside the class from accidentally modifying the internal state of an object.\nThe primary purposes of encapsulation are:\nMaintaining Integrity: By controlling access, encapsulation ensures that the object\u0026rsquo;s state cannot be changed arbitrarily. Enhancing Security: It hides the implementation details, exposing only what is necessary. Improving Maintainability: Encapsulation makes code more modular and easier to modify without affecting other parts of the program. Public, Private, and Protected modifiers In Python, you can define attributes and methods as public, private, or protected using the following conventions:\nPublic: Accessible from anywhere. No specific notation is required. Private: Denoted by a double underscore prefix (e.g., __attribute). Only accessible within the class. Protected: Denoted by a single underscore prefix (e.g., _attribute). It\u0026rsquo;s a convention that these attributes shouldn\u0026rsquo;t be accessed outside the class, but they are still technically accessible. 1class Account: 2 public_data = \u0026#34;Public\u0026#34; 3 _protected_data = \u0026#34;Protected\u0026#34; 4 __private_data = \u0026#34;Private\u0026#34; Getters and setters In encapsulation, getters and setters are used to access and modify private attributes.\nGetters are methods used to retrieve the value of private attributes. Setters are methods used to set or modify the value of private attributes. Here\u0026rsquo;s how you can define getters and setters in Python:\n1class Person: 2 def __init__(self, name, age): 3 self.__name = name 4 self.__age = age 5 6 # Getter for name 7 def get_name(self): 8 return self.__name 9 10 # Setter for name 11 def set_name(self, name): 12 self.__name = name Example Let\u0026rsquo;s take a look at a complete example that demonstrates encapsulation:\n1class Student: 2 def __init__(self, name, grade): 3 self.__name = name 4 self.__grade = grade 5 6 # Getter for name 7 def get_name(self): 8 return self.__name 9 10 # Setter for grade 11 def set_grade(self, grade): 12 if 0 \u0026lt;= grade \u0026lt;= 100: 13 self.__grade = grade 14 else: 15 print(\u0026#34;Grade must be between 0 and 100.\u0026#34;) 16 17 # Method to display student information 18 def display_info(self): 19 print(f\u0026#34;{self.__name} has a grade of {self.__grade}.\u0026#34;) 20 21student = Student(\u0026#34;Alice\u0026#34;, 90) 22student.display_info() # Output: Alice has a grade of 90. 23student.set_grade(95) 24student.display_info() # Output: Alice has a grade of 95. Conclusion Encapsulation is a powerful concept in OOP that promotes code integrity, security, and maintainability. By understanding and implementing public, private, and protected modifiers along with getters and setters, you can write more robust and well-organized code.\nAs you continue your journey into OOP, the knowledge of encapsulation will serve as a strong foundation for exploring more advanced topics and best practices.\n","date":1680739200,"headings":[{"anchor":"conclusion","title":"Conclusion"},{"anchor":"example","title":"Example"},{"anchor":"getters-and-setters","title":"Getters and setters"},{"anchor":"public-private-and-protected-modifiers","title":"Public, Private, and Protected modifiers"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Encapsulation is one of the four foundational principles of Object-Oriented Programming (OOP). It plays a crucial role in protecting the integrity of an object by controlling how its data can be accessed and modified. This article, will explore the concept of encapsulation, explain modifiers, and demonstrate how to use getters and setters in Python.\nEncapsulation refers to the bundling of data (attributes) and the methods (functions) that operate on the data into a single unit, restricting direct access to some of an object’s components.","tags":["oop","object-oriented","encapsulation"],"title":"Encapsulation","url":"/en/programming/0300-oop/03-encapsulation/","year":"2023"},{"content":"","date":1680566400,"headings":[],"kind":"term","lang":"en","summary":"","title":"classes","url":"/en/tags/classes/","year":"2023"},{"authors":["Julián Nonino"],"content":"Building on our previous introduction to Object-Oriented Programming (OOP), this post will dive deeper into the core concepts of classes and objects. We\u0026rsquo;ll explore their definitions, how to create and use them, and discuss constructors and destructors, with examples in Python.\nDefinitions Classes A class is a blueprint that defines the structure and behavior of an object. It encapsulates data (attributes) and functions (methods) that operate on the data.\n1class Dog: 2 def bark(self): 3 print(\u0026#34;Woof!\u0026#34;) Here, Dog is a class with a method bark.\nObjects Objects are individual instances created from a class. They contain the data defined in the class and can execute the class\u0026rsquo;s methods.\n1my_dog = Dog() 2my_dog.bark() # Output: Woof! my_dog is an object of the class Dog, and it can use the bark method.\nCreating and instantiating classes In Python, you can define a class using the class keyword followed by the class name and a colon.\n1class Person: 2 pass This creates an empty class named Person.\nInstantiating a class Instantiating a class means creating an object from that class. You can do this by calling the class as if it were a function.\n1person = Person() Now, person is an instance of the Person class.\nConstructor A constructor is a special method that gets called when you create an object. In Python, it\u0026rsquo;s defined using the __init__ method.\n1class Cat: 2 def __init__(self, name, color): 3 self.name = name 4 self.color = color This constructor initializes a Cat object with a name and color.\nDestructor A destructor is a method that gets called when an object is destroyed. In Python, it\u0026rsquo;s defined using the __del__ method.\n1class Cat: 2 def __del__(self): 3 print(f\u0026#34;{self.name} has been deleted.\u0026#34;) This destructor prints a message when a Cat object is deleted.\nExamples Creating and using a class 1class Bike: 2 def __init__(self, brand, model): 3 self.brand = brand 4 self.model = model 5 6 def display_info(self): 7 print(f\u0026#34;This bike is a {self.brand} {self.model}.\u0026#34;) 8 9my_bike = Bike(\u0026#34;Yamaha\u0026#34;, \u0026#34;MT-07\u0026#34;) 10my_bike.display_info() # Output: This bike is a Yamaha MT-07. Deleting an object 1del my_bike # This will call the destructor if defined. Conclusion Classes and objects are foundational concepts in OOP, allowing you to structure code in a way that mirrors real-world entities. Constructors and destructors further add to the lifecycle management of objects. With this understanding, you\u0026rsquo;re now prepared to delve into more advanced OOP concepts.\nIn our next article, we will explore encapsulation, one of the key principles of OOP, and see how it contributes to code organization and security.\n","date":1680566400,"headings":[{"anchor":"classes","title":"Classes"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"constructor","title":"Constructor"},{"anchor":"creating-and-instantiating-classes","title":"Creating and instantiating classes"},{"anchor":"creating-and-using-a-class","title":"Creating and using a class"},{"anchor":"definitions","title":"Definitions"},{"anchor":"deleting-an-object","title":"Deleting an object"},{"anchor":"destructor","title":"Destructor"},{"anchor":"examples","title":"Examples"},{"anchor":"instantiating-a-class","title":"Instantiating a class"},{"anchor":"objects","title":"Objects"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Building on our previous introduction to Object-Oriented Programming (OOP), this post will dive deeper into the core concepts of classes and objects. We’ll explore their definitions, how to create and use them, and discuss constructors and destructors, with examples in Python.\nDefinitions Classes A class is a blueprint that defines the structure and behavior of an object. It encapsulates data (attributes) and functions (methods) that operate on the data.\n1class Dog: 2 def bark(self): 3 print(\"Woof!","tags":["oop","object-oriented","classes","objects"],"title":"Classes and objects","url":"/en/programming/0300-oop/02-classes-objects/","year":"2023"},{"content":"","date":1680566400,"headings":[],"kind":"term","lang":"en","summary":"","title":"objects","url":"/en/tags/objects/","year":"2023"},{"authors":["Julián Nonino"],"content":"Object-Oriented Programming (OOP) is a paradigm that helps organize code using real-world concepts, making it more readable, reusable, and maintainable. It\u0026rsquo;s built around the idea that everything can be represented as objects.\nOOP emerged in the 1960s with the programming language Simula, but it gained prominence in the 1980s with languages like C++ and Smalltalk. At its core, OOP models the code as \u0026ldquo;objects\u0026rdquo; that bundle both state (attributes) and behaviors (methods).\nPrinciples There are four key principles of OOP:\nEncapsulation: Packaging attributes and methods within a class, controlling access to the information. Inheritance: Allowing a class to inherit attributes and methods from another class. Polymorphism: Enabling a class to be treated like another class, using different methods interchangeably. Abstraction: Hiding complex realities while exposing only essential parts. Advantages Modularity: Breaking down complex problems into smaller, manageable parts. Reusability: Using the same code across different parts of an application or different projects. Maintainability: Making it easier to update, modify, and debug code. Scalability: Building larger and more complex applications with ease. OOP vs. Procedural Programming In contrast to procedural programming, where the focus is on writing functions or procedures, OOP emphasizes creating objects containing both data and functions.\nProcedural: Functions operate on data, often leading to code repetition. OOP: Encapsulates data and functions into objects, promoting reusability and organization. Real-World analogy Think of a class as a blueprint for a house, defining the structure and features. Objects are individual houses built from that blueprint. Each house (object) can have different colors, sizes, or number of rooms (attributes), but they all follow the same basic design (class).\nExample Now, let\u0026rsquo;s dive into a simple Python example to understand classes and objects.\nThis is an example of a class definition.\n1class Car: 2 def __init__(self, brand, model): 3 self.brand = brand 4 self.model = model 5 6 def display_info(self): 7 print(f\u0026#34;This car is a {self.brand} {self.model}.\u0026#34;) Here, Car is a class with attributes brand and model, and a method display_info.\nfrom that class, we can create objects as follows.\n1my_car = Car(\u0026#34;Toyota\u0026#34;, \u0026#34;Camry\u0026#34;) 2my_car.display_info() # Output: This car is a Toyota Camry. In this example, my_car is an object created from the Car class, with attributes set to \u0026ldquo;Toyota\u0026rdquo; and \u0026ldquo;Camry\u0026rdquo;.\nConclusion Object-Oriented Programming offers a powerful and intuitive way to structure code. By understanding the core principles and applying them, even beginners can start building robust and flexible software. This post has provided an overview, and future articles will delve into specific concepts like encapsulation, inheritance, and more.\n","date":1680393600,"headings":[{"anchor":"advantages","title":"Advantages"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"example","title":"Example"},{"anchor":"oop-vs-procedural-programming","title":"OOP vs. Procedural Programming"},{"anchor":"principles","title":"Principles"},{"anchor":"real-world-analogy","title":"Real-World analogy"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Object-Oriented Programming (OOP) is a paradigm that helps organize code using real-world concepts, making it more readable, reusable, and maintainable. It’s built around the idea that everything can be represented as objects.\nOOP emerged in the 1960s with the programming language Simula, but it gained prominence in the 1980s with languages like C++ and Smalltalk. At its core, OOP models the code as “objects” that bundle both state (attributes) and behaviors (methods).","tags":["intro","oop","object-oriented","oop-principles"],"title":"Introduction","url":"/en/programming/0300-oop/01-intro/","year":"2023"},{"content":"","date":1680393600,"headings":[],"kind":"term","lang":"en","summary":"","title":"oop-principles","url":"/en/tags/oop-principles/","year":"2023"},{"content":"","date":1679875200,"headings":[],"kind":"term","lang":"en","summary":"","title":"adapter","url":"/en/tags/adapter/","year":"2023"},{"content":"","date":1679875200,"headings":[],"kind":"section","lang":"en","summary":"","title":"Design patterns","url":"/en/programming/0500-design-patterns/","year":"2023"},{"content":"","date":1679875200,"headings":[],"kind":"term","lang":"en","summary":"","title":"design-patters","url":"/en/tags/design-patters/","year":"2023"},{"authors":["Julián Nonino"],"content":"Types of design patterns Creational patterns: are focused on the process of object creation, abstracting the instantiation process.\nStructural patterns: are concerned with the composition of classes or objects, simplifying the structure and identifying relationships between objects.\nBehavioral patterns: define ways for objects to communicate and interact, standardizing how objects cooperate.\nExamples of design patterns Below are examples of three common design patterns implemented in Python.\nSingleton pattern The Singleton pattern ensures that a class has only one instance and provides a global point of access to that instance.\n1class Singleton: 2 _instance = None 3 4 @staticmethod 5 def getInstance(): 6 if Singleton._instance == None: 7 Singleton() 8 return Singleton._instance 9 10 def __init__(self): 11 if Singleton._instance != None: 12 raise Exception(\u0026#34;This class is a singleton!\u0026#34;) 13 else: 14 Singleton._instance = self Adapter pattern The Adapter pattern allows incompatible interfaces to work together, wrapping one class with another that has the expected interface.\n1class OldSystem: 2 def old_method(self): 3 return \u0026#34;Old system method\u0026#34; 4 5class Adapter: 6 def __init__(self, old_system): 7 self.old_system = old_system 8 9 def new_method(self): 10 return self.old_system.old_method() Observer pattern The Observer pattern defines a one-to-many dependency between objects, allowing multiple observers to respond to changes in a subject.\n1class Subject: 2 def __init__(self): 3 self._observers = [] 4 5 def add_observer(self, observer): 6 self._observers.append(observer) 7 8 def notify_observers(self): 9 for observer in self._observers: 10 observer.update(self) 11 12class Observer: 13 def update(self, subject): 14 pass Conclusion Design patterns are essential tools that guide software developers in creating efficient, maintainable, and scalable code. By understanding and applying these patterns, developers can avoid common pitfalls and build robust software systems.\nFurther reading and exploration of design patterns in various programming languages are highly recommended. A classic reference on this topic is the book \u0026ldquo;Design Patterns: Elements of Reusable Object-Oriented Software\u0026rdquo; by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.\n","date":1679875200,"headings":[{"anchor":"adapter-pattern","title":"Adapter pattern"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"examples-of-design-patterns","title":"Examples of design patterns"},{"anchor":"observer-pattern","title":"Observer pattern"},{"anchor":"singleton-pattern","title":"Singleton pattern"},{"anchor":"types-of-design-patterns","title":"Types of design patterns"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Design patterns are tried-and-true solutions to common problems that arise in software development. They represent best practices and are used to create organized, clean, and scalable code. This article covers various design patterns with examples in Python.","tags":["intro","programming","design-patters","singleton","adapter","observer"],"title":"Introduction","url":"/en/programming/0500-design-patterns/01-introduction/","year":"2023"},{"content":"","date":1679875200,"headings":[],"kind":"term","lang":"en","summary":"","title":"observer","url":"/en/tags/observer/","year":"2023"},{"content":"","date":1679875200,"headings":[],"kind":"term","lang":"en","summary":"","title":"singleton","url":"/en/tags/singleton/","year":"2023"},{"content":"","date":1679702400,"headings":[],"kind":"section","lang":"en","summary":"","title":"Software testing","url":"/en/programming/0400-testing/","year":"2023"},{"content":"","date":1679702400,"headings":[],"kind":"term","lang":"en","summary":"","title":"tdd","url":"/en/tags/tdd/","year":"2023"},{"authors":["Julián Nonino"],"content":"Why testing matters? Error Detection: Tests help identify errors and inconsistencies in code. Quality Assurance: Tests ensure that code meets certain quality standards. Refactoring Support: Tests provide a safety net for making changes to existing code. Documentation: Tests can serve as examples, illustrating how code is intended to be used. Types of testing Unit testing Unit testing focuses on testing individual components (or \u0026ldquo;units\u0026rdquo;) of code, like functions or methods.\nIntegration testing Integration testing examines how different parts of the software work together, testing interactions between modules or subsystems.\nFunctional testing Functional testing evaluates how software functions in accordance with specified requirements, focusing on overall behavior rather than specific parts.\nWriting tests in Python Python provides several frameworks for writing and running tests, with unittest being one of the most popular.\nunittest is a built-in Python module for creating test cases. Here\u0026rsquo;s an example that tests a simple function for adding two numbers:\n1import unittest 2 3def add(x, y): 4 return x + y 5 6class TestAddition(unittest.TestCase): 7 def test_addition(self): 8 self.assertEqual(add(3, 4), 7) 9 10if __name__ == \u0026#39;__main__\u0026#39;: 11 unittest.main() This code defines a test case that checks if the add function returns 7 when called with the arguments 3 and 4.\nYou can run the tests using the following command:\n1python test_filename.py Test-Driven Development (TDD) Test-Driven Development is a methodology where tests are written before the code they test. The TDD cycle includes:\nWrite a failing test. Write the minimum amount of code to make the test pass. Refactor the code, ensuring that the tests still pass. Conclusion Testing is an essential aspect of software development that contributes to code quality, maintainability, and reliability. By employing different types of tests and embracing methodologies like TDD, developers can build robust software with confidence.\nFor further learning, consider exploring Python\u0026rsquo;s rich ecosystem of testing libraries, such as pytest, and reading Python\u0026rsquo;s documentation on testing.\n","date":1679702400,"headings":[{"anchor":"conclusion","title":"Conclusion"},{"anchor":"functional-testing","title":"Functional testing"},{"anchor":"integration-testing","title":"Integration testing"},{"anchor":"test-driven-development-tdd","title":"Test-Driven Development (TDD)"},{"anchor":"types-of-testing","title":"Types of testing"},{"anchor":"unit-testing","title":"Unit testing"},{"anchor":"why-testing-matters","title":"Why testing matters?"},{"anchor":"writing-tests-in-python","title":"Writing tests in Python"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Testing is the practice of running code to check if it behaves as expected. It helps find errors, ensures reliability, and maintains code quality. This article provides an introduction to testing, focusing on examples in Python but also describing general principles applicable to other programming languages.","tags":["intro","programming","testing","tdd"],"title":"Testing","url":"/en/programming/0400-testing/02-testing/","year":"2023"},{"content":"","date":1679529600,"headings":[],"kind":"term","lang":"en","summary":"","title":"debug","url":"/en/tags/debug/","year":"2023"},{"content":"","date":1679529600,"headings":[],"kind":"term","lang":"en","summary":"","title":"error","url":"/en/tags/error/","year":"2023"},{"authors":["Julián Nonino"],"content":"Understanding errors In programming, errors are problems in the code that prevent it from running as intended. They can be categorized into:\nSyntax Errors: Mistakes in the code\u0026rsquo;s structure, such as missing parentheses or incorrect indentation. Runtime Errors: Errors that occur during execution, such as dividing by zero or accessing an element that does not exist. Logical Errors: Errors in the program\u0026rsquo;s logic that lead to unexpected results. Error handling Error handling is the process of detecting and managing errors in a program. In Python, this is commonly done using try-except blocks.\nThe Try-Except block A try block contains code that might cause an error, and an except block contains code that handles the error.\n1try: 2 result = 10 / 0 3except ZeroDivisionError: 4 print(\u0026#34;Cannot divide by zero.\u0026#34;) You can handle multiple exceptions by using multiple except blocks.\n1try: 2 result = 10 / \u0026#39;a\u0026#39; 3except ZeroDivisionError: 4 print(\u0026#34;Cannot divide by zero.\u0026#34;) 5except TypeError: 6 print(\u0026#34;Unsupported operation.\u0026#34;) The Finally block A finally block contains code that runs whether an error occurred or not.\n1try: 2 result = 10 / 5 3except ZeroDivisionError: 4 print(\u0026#34;Cannot divide by zero.\u0026#34;) 5finally: 6 print(\u0026#34;This will always run.\u0026#34;) Debugging techniques Debugging is the process of finding and fixing errors in code.\nInserting print statements at various points in your code can help you track the flow of execution and the values of variables.\n1def divide(a, b): 2 print(f\u0026#34;Dividing {a} by {b}\u0026#34;) 3 return a / b Modern IDEs provide debuggers that allow you to step through your code, inspect variables, and set breakpoints.\nCommon Python errors IndentationError: Caused by inconsistent indentation. NameError: Raised when a variable is used before being defined. TypeError: Occurs when an operation is performed on an incompatible data type. Conclusion Understanding error handling and debugging is vital for writing robust, maintainable code. By learning how to handle errors gracefully and efficiently debug your code, you\u0026rsquo;ll be well-equipped to develop complex programs with confidence.\nFor further information, consider referring to the Python documentation on errors and exceptions.\n","date":1679529600,"headings":[{"anchor":"common-python-errors","title":"Common Python errors"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"debugging-techniques","title":"Debugging techniques"},{"anchor":"error-handling","title":"Error handling"},{"anchor":"the-finally-block","title":"The Finally block"},{"anchor":"the-try-except-block","title":"The Try-Except block"},{"anchor":"understanding-errors","title":"Understanding errors"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Error handling and debugging are essential skills for any programmer. They help ensure that your code runs smoothly and allow you to identify and fix issues when they arise. This article will cover the fundamental concepts of error handling and debugging, with examples in Python.","tags":["intro","programming","error","try-catch","try-excerpt","debug"],"title":"Error Handling and Debugging","url":"/en/programming/0400-testing/01-error-handling-debugging/","year":"2023"},{"content":"","date":1679529600,"headings":[],"kind":"term","lang":"en","summary":"","title":"try-catch","url":"/en/tags/try-catch/","year":"2023"},{"content":"","date":1679529600,"headings":[],"kind":"term","lang":"en","summary":"","title":"try-excerpt","url":"/en/tags/try-excerpt/","year":"2023"},{"content":"","date":1679184e3,"headings":[],"kind":"term","lang":"en","summary":"","title":"algorithms","url":"/en/tags/algorithms/","year":"2023"},{"authors":["Julián Nonino"],"content":"What is an algorithm? An algorithm is a precise sequence of instructions for processes that can be implemented in a programming language and executed by a computer. Algorithms are used for calculation, data processing, and automated reasoning tasks.\nHere\u0026rsquo;s a simple example of an algorithm to find the largest number in a list.\n1def find_largest(numbers): 2 largest = numbers[0] 3 for number in numbers: 4 if number \u0026gt; largest: 5 largest = number 6 return largest 7 8numbers = [34, 76, 23, 89, 12] 9print(find_largest(numbers)) # Output: 89 Types of algorithms Algorithms can be classified into various types, based on their structure, complexity, and purpose. Two of the most common types are sort and search.\nSorting algorithms Sorting algorithms arrange elements in a particular order, typically numerical or lexicographical. There are various sorting algorithms, each with its characteristics and use cases. Here, we\u0026rsquo;ll look at one popular example: Bubble Sort.\nBubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The process is repeated until no swaps are needed, indicating that the list is sorted.\nHere\u0026rsquo;s a Python code snippet for Bubble Sort:\n1def bubble_sort(arr): 2 n = len(arr) 3 for i in range(n): 4 for j in range(0, n-i-1): # Last i elements are already sorted 5 if arr[j] \u0026gt; arr[j+1]: # If the element is greater than the next element 6 arr[j], arr[j+1] = arr[j+1], arr[j] # Swap the elements 7 8numbers = [64, 34, 25, 12, 22] 9bubble_sort(numbers) 10print(\u0026#34;Sorted array:\u0026#34;, numbers) # Output: Sorted array: [12, 22, 25, 34, 64] In the code above, the outer loop runs n times, where n is the length of the array. The inner loop compares adjacent elements and swaps them if they are out of order. After each iteration of the outer loop, the largest unsorted element bubbles up to its correct position, hence the name \u0026ldquo;Bubble Sort.\u0026rdquo;\nIt\u0026rsquo;s essential to note that there are many other sorting algorithms, such as Quick Sort, Merge Sort, Insertion Sort, etc., each having different performance characteristics and use cases. Understanding various sorting algorithms and their trade-offs is a vital part of computer science and software development.\nSearch algorithms Search algorithms find the location of a specific value within a data structure. There are various search algorithms, and one widely used example is Binary Search.\nBinary Search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeatedly check until the value is found or the interval is empty.\nHere\u0026rsquo;s a Python code snippet for Binary Search:\n1def binary_search(arr, x): 2 left, right = 0, len(arr) - 1 3 while left \u0026lt;= right: 4 mid = left + (right - left) // 2 5 if arr[mid] == x: 6 return mid 7 elif arr[mid] \u0026lt; x: 8 left = mid + 1 9 else: 10 right = mid - 1 11 return -1 In the code above:\nleft and right define the current interval being searched. mid is the middle index of the interval. The while loop continues until left is greater than right, meaning the interval is empty. If the middle element is equal to x, the index is returned. If x is less than the middle element, the search continues in the lower half of the interval (by setting right to mid - 1). If x is greater than the middle element, the search continues in the upper half (by setting left to mid + 1). Binary Search is efficient, with a time complexity of O(log n), but it requires that the input be sorted.\nIt\u0026rsquo;s worth mentioning that there are many other search algorithms, such as Linear Search, Interpolation Search, Exponential Search, etc., with different complexities and requirements. Understanding various search algorithms is essential for effective problem-solving in programming.\nAlgorithm complexity The efficiency of an algorithm is often measured in terms of its time complexity and space complexity, representing the amount of time and memory space required.\nTime complexity Time complexity is the measure of the amount of time an algorithm takes in terms of the length of the input.\nO(1): Constant time O(log n): Logarithmic time O(n): Linear time O(n^2): Quadratic time Space complexity Space complexity measures the amount of memory space an algorithm uses relative to the input size.\nConclusion Algorithms are essential to programming, providing systematic methods for solving problems, organizing data, and performing tasks. From sorting and searching to more complex operations on graphs and networks, algorithms enable computers to process information intelligently and efficiently. Understanding algorithms is fundamental to becoming a proficient programmer, and while this article uses Python examples, the principles can be applied across various programming languages.\n","date":1679184e3,"headings":[{"anchor":"algorithm-complexity","title":"Algorithm complexity"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"search-algorithms","title":"Search algorithms"},{"anchor":"sorting-algorithms","title":"Sorting algorithms"},{"anchor":"space-complexity","title":"Space complexity"},{"anchor":"time-complexity","title":"Time complexity"},{"anchor":"types-of-algorithms","title":"Types of algorithms"},{"anchor":"what-is-an-algorithm","title":"What is an algorithm?"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Algorithms are a set of step-by-step procedures or rules performed in a specific order to achieve a particular goal or solve a specific problem. In programming, algorithms form the backbone of effective problem-solving and efficient code execution. In this article, we will explore different aspects of algorithms, using examples in Python, while keeping the explanations as generic as possible.","tags":["intro","programming","algorithms","sort","bubble-sort","search","binary-search"],"title":"Algorithms","url":"/en/programming/0200-basic-concepts/04-algorithms/","year":"2023"},{"content":"","date":1679184e3,"headings":[],"kind":"section","lang":"en","summary":"","title":"Basic concepts","url":"/en/programming/0200-basic-concepts/","year":"2023"},{"content":"","date":1679184e3,"headings":[],"kind":"term","lang":"en","summary":"","title":"binary-search","url":"/en/tags/binary-search/","year":"2023"},{"content":"","date":1679184e3,"headings":[],"kind":"term","lang":"en","summary":"","title":"bubble-sort","url":"/en/tags/bubble-sort/","year":"2023"},{"content":"","date":1679184e3,"headings":[],"kind":"term","lang":"en","summary":"","title":"search","url":"/en/tags/search/","year":"2023"},{"content":"","date":1679184e3,"headings":[],"kind":"term","lang":"en","summary":"","title":"sort","url":"/en/tags/sort/","year":"2023"},{"content":"","date":1679011200,"headings":[],"kind":"term","lang":"en","summary":"","title":"functions","url":"/en/tags/functions/","year":"2023"},{"authors":["Julián Nonino"],"content":"What are functions? A function is a block of organized, reusable code that performs a single, related action. Functions provide better modularity for your application and enable a high degree of code reusability.\nFunction declaration In Python, you declare a function using the def keyword followed by the function name and parentheses (). Inside the parentheses, you can include parameters.\n1def greet(name): 2 print(f\u0026#34;Hello, {name}!\u0026#34;) Calling a function You can \u0026ldquo;call\u0026rdquo; or \u0026ldquo;invoke\u0026rdquo; a function by using its name followed by parentheses, passing any required arguments.\n1greet(\u0026#34;John\u0026#34;) Parameters and arguments Parameters Parameters are variables listed inside the parentheses in the function definition.\n1def add_numbers(x, y): 2 return x + y Here, x and y are parameters.\nYou can set default values for parameters. If an argument for that parameter is not provided, the default value will be used.\n1def power(base, exponent=2): 2 return base ** exponent 3 4result = power(3) # result will be 9 Arguments Arguments are the values sent to the function when it is called. They are assigned to the corresponding parameters.\n1result = add_numbers(5, 3) # 5 and 3 are arguments Variable-length arguments Sometimes, you may want to define a function that can accept any number of arguments. In Python, you can use *args and **kwargs.\n*args *args allows you to pass a variable number of non-keyword arguments to a function. Inside the function, args is a tuple containing all the arguments.\nExample:\n1def add_all(*args): 2 sum = 0 3 for num in args: 4 sum += num 5 return sum 6 7result = add_all(3, 5, 2, 1) # result will be 11 **kwargs **kwargs allows you to pass a variable number of keyword arguments to a function. Inside the function, kwargs is a dictionary containing the key-value pairs.\nExample:\n1def print_info(**kwargs): 2 for key, value in kwargs.items(): 3 print(f\u0026#34;{key}: {value}\u0026#34;) 4 5print_info(name=\u0026#34;John\u0026#34;, age=30, city=\u0026#34;New York\u0026#34;) Output:\n1name: John 2age: 30 3city: New York Combining *args and **kwargs You can use both *args and **kwargs in the same function to accept any combination of positional and keyword arguments.\n1def mixed_function(a, b, *args, **kwargs): 2 print(f\u0026#34;a: {a}, b: {b}\u0026#34;) 3 print(\u0026#34;Additional arguments:\u0026#34;) 4 for arg in args: 5 print(arg) 6 print(\u0026#34;Keyword arguments:\u0026#34;) 7 for key, value in kwargs.items(): 8 print(f\u0026#34;{key}: {value}\u0026#34;) 9 10mixed_function(1, 2, 3, 4, name=\u0026#34;John\u0026#34;, age=30) Output:\n1a: 1, b: 2 2Additional arguments: 33 44 5Keyword arguments: 6name: John 7age: 30 Return values A function can return a value using the return keyword. This value can be stored in a variable or used as part of an expression.\n1def multiply(x, y): 2 return x * y 3 4result = multiply(3, 4) # result will be 12 Scope Scope refers to the part of the code where a variable is accessible. Variables defined inside a function are local to that function, while those defined outside are global.\n1def local_example(): 2 local_var = 5 # Accessible only within this function 3 4global_var = 10 # Accessible throughout the program Recursive functions A recursive function is one that calls itself to solve a problem. This can be a powerful approach but must be handled with care to avoid infinite loops.\n1def factorial(n): 2 if n == 1: 3 return 1 4 else: 5 return n * factorial(n-1) Conclusion Functions are a core concept in programming, enabling cleaner, more organized, and reusable code. They encapsulate specific functionality, making code more readable and maintainable. While this article used Python examples, the principles of defining and using functions are consistent across many programming languages. Mastering functions is a vital step in becoming a skilled programmer.\n","date":1679011200,"headings":[{"anchor":"args","title":"*args"},{"anchor":"arguments","title":"Arguments"},{"anchor":"calling-a-function","title":"Calling a function"},{"anchor":"combining-args-and-kwargs","title":"Combining *args and **kwargs"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"function-declaration","title":"Function declaration"},{"anchor":"kwargs","title":"**kwargs"},{"anchor":"parameters","title":"Parameters"},{"anchor":"parameters-and-arguments","title":"Parameters and arguments"},{"anchor":"recursive-functions","title":"Recursive functions"},{"anchor":"return-values","title":"Return values"},{"anchor":"scope","title":"Scope"},{"anchor":"variable-length-arguments","title":"Variable-length arguments"},{"anchor":"what-are-functions","title":"What are functions?"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Functions are a fundamental concept in programming, allowing for code reusability and modular design. In this article, we'll explore what functions are, their various components, and how to use them, with examples in Python. These principles, however, are widely applicable across many programming languages.","tags":["intro","programming","functions","methods"],"title":"Functions","url":"/en/programming/0200-basic-concepts/03-functions/","year":"2023"},{"content":"","date":1679011200,"headings":[],"kind":"term","lang":"en","summary":"","title":"methods","url":"/en/tags/methods/","year":"2023"},{"content":"","date":1678838400,"headings":[],"kind":"term","lang":"en","summary":"","title":"conditionals","url":"/en/tags/conditionals/","year":"2023"},{"authors":["Julián Nonino"],"content":"Conditional statements Conditional statements are used to execute different code based on certain conditions.\nIf The if statement evaluates a condition and executes a block of code if that condition is True.\n1x = 10 2if x \u0026gt; 5: 3 print(\u0026#34;x is greater than 5\u0026#34;) Else The else statement is used with an if statement to define code that will be executed if the condition is False.\n1x = 3 2if x \u0026gt; 5: 3 print(\u0026#34;x is greater than 5\u0026#34;) 4else: 5 print(\u0026#34;x is not greater than 5\u0026#34;) Elif The elif (else if) statement allows you to check multiple conditions.\n1x = 5 2if x \u0026gt; 10: 3 print(\u0026#34;x is greater than 10\u0026#34;) 4elif x == 5: 5 print(\u0026#34;x is equal to 5\u0026#34;) 6else: 7 print(\u0026#34;x is less than 5\u0026#34;) Loops Loops allow you to execute a block of code repeatedly.\nFor The for loop is used to iterate over a sequence (e.g., a list, tuple, or string).\n1for i in range(5): 2 print(i) While The while loop continues to execute a block of code as long as a condition is True.\n1x = 0 2while x \u0026lt; 5: 3 print(x) 4 x += 1 Break and continue Break The break statement terminates the loop and transfers execution to the code that follows the loop.\n1for i in range(5): 2 if i == 3: 3 break 4 print(i) Continue The continue statement skips the current iteration and continues with the next one.\n1for i in range(5): 2 if i == 3: 3 continue 4 print(i) Functions Functions are reusable blocks of code that you can call by name. They allow for more organized, modular, and efficient code.\n1def greet(name): 2 print(f\u0026#34;Hello, {name}!\u0026#34;) 3 4greet(\u0026#34;John\u0026#34;) In the next article, we will delve deeper into functions.\nConclusion Control flow constructs such as conditional statements, loops, and functions form the backbone of programming, enabling the creation of flexible and responsive applications. By mastering these concepts, programmers can write code that responds dynamically to user input and system conditions. While the examples provided are in Python, the fundamental ideas of control flow are consistent across many programming languages, and learning them is a critical step in becoming a proficient programmer.\n","date":1678838400,"headings":[{"anchor":"break","title":"Break"},{"anchor":"break-and-continue","title":"Break and continue"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"conditional-statements","title":"Conditional statements"},{"anchor":"continue","title":"Continue"},{"anchor":"elif","title":"Elif"},{"anchor":"else","title":"Else"},{"anchor":"for","title":"For"},{"anchor":"functions","title":"Functions"},{"anchor":"if","title":"If"},{"anchor":"loops","title":"Loops"},{"anchor":"while","title":"While"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Control flow refers to the order in which the statements, instructions, or function calls of an application are executed. Understanding control flow is crucial in programming, as it enables the creation of dynamic, responsive code. This article will cover the essential aspects of control flow, using Python for examples, but the principles apply to many programming languages.","tags":["intro","programming","control-flow","conditionals","if","loops","for","while"],"title":"Control Flow","url":"/en/programming/0200-basic-concepts/02-control-flow/","year":"2023"},{"content":"","date":1678838400,"headings":[],"kind":"term","lang":"en","summary":"","title":"control-flow","url":"/en/tags/control-flow/","year":"2023"},{"content":"","date":1678838400,"headings":[],"kind":"term","lang":"en","summary":"","title":"for","url":"/en/tags/for/","year":"2023"},{"content":"","date":1678838400,"headings":[],"kind":"term","lang":"en","summary":"","title":"if","url":"/en/tags/if/","year":"2023"},{"content":"","date":1678838400,"headings":[],"kind":"term","lang":"en","summary":"","title":"loops","url":"/en/tags/loops/","year":"2023"},{"content":"","date":1678838400,"headings":[],"kind":"term","lang":"en","summary":"","title":"while","url":"/en/tags/while/","year":"2023"},{"content":"","date":1678665600,"headings":[],"kind":"term","lang":"en","summary":"","title":"data-types","url":"/en/tags/data-types/","year":"2023"},{"content":"","date":1678665600,"headings":[],"kind":"term","lang":"en","summary":"","title":"variables","url":"/en/tags/variables/","year":"2023"},{"authors":["Julián Nonino"],"content":"Variables A variable is like a container that stores a value. You can think of it as a label attached to a value, which allows you to reference that value later in your code. In Python, you can create a variable by simply assigning a value to a name using the equals sign =.\n1x = 10 Here, x is the variable name, and 10 is the value assigned to it. You can then use x anywhere in your code to refer to the value 10.\nIn Python, and many other programming languages, variables must adhere to certain naming rules:\nMust start with a letter or an underscore (_). Can contain letters, numbers, and underscores. Cannot be a reserved word (such as if, else, etc.). Names are case-sensitive (variable is different from Variable). Example:\n1my_variable = 100 2Variable1 = \u0026#34;Hello\u0026#34; Data types Data types define the type of value a variable can hold. They are important because they tell the compiler or interpreter how to handle the data stored in the variable. Python\u0026rsquo;s primary data types include:\nInteger (int)\nRepresents whole numbers, both positive and negative.\n1age = 25 Float (float)\nRepresents decimal numbers.\n1weight = 70.5 String (str)\nA sequence of characters enclosed in single or double quotes.\n1name = \u0026#34;John\u0026#34; Boolean (bool)\nRepresents true or false values.\n1is_happy = True List\nA collection of items in a specific order.\n1fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] Tuple\nSimilar to a list, but immutable (cannot be changed).\n1coordinates = (4, 5) Dictionary (dict)\nA collection of key-value pairs.\n1person = {\u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;, \u0026#39;age\u0026#39;: 30} Type conversion Sometimes, you may need to convert one data type to another. Python provides built-in functions for this, such as int(), float(), and str().\n1x = \u0026#34;10\u0026#34; 2y = int(x) # Converts the string \u0026#34;10\u0026#34; to an integer Conclusion Understanding variables and data types is a foundational step in learning programming. While this article used Python for illustration, these concepts are universal across many programming languages. Experimenting with these concepts in your code will solidify your understanding and equip you with the tools to create versatile and efficient programs.\n","date":1678665600,"headings":[{"anchor":"conclusion","title":"Conclusion"},{"anchor":"data-types","title":"Data types"},{"anchor":"type-conversion","title":"Type conversion"},{"anchor":"variables","title":"Variables"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Variables and data types are fundamental concepts in programming. They play an essential role in storing and managing data within a program. In this article, we'll explore what variables and data types are, using Python as an example, but the concepts are applicable across most programming languages.","tags":["intro","programming","variables","data-types"],"title":"Variables and Data Types","url":"/en/programming/0200-basic-concepts/01-variables-data-types/","year":"2023"},{"content":"","date":1678492800,"headings":[],"kind":"term","lang":"en","summary":"","title":"binary","url":"/en/tags/binary/","year":"2023"},{"content":"","date":1678492800,"headings":[],"kind":"term","lang":"en","summary":"","title":"boolean-logic","url":"/en/tags/boolean-logic/","year":"2023"},{"content":"","date":1678492800,"headings":[],"kind":"term","lang":"en","summary":"","title":"decimal","url":"/en/tags/decimal/","year":"2023"},{"content":"","date":1678492800,"headings":[],"kind":"term","lang":"en","summary":"","title":"hexadecimal","url":"/en/tags/hexadecimal/","year":"2023"},{"content":"","date":1678492800,"headings":[],"kind":"section","lang":"en","summary":"","title":"Introduction","url":"/en/programming/0100-intro/","year":"2023"},{"authors":["Julián Nonino"],"content":"Binary numerical system The Binary system is a base-2 numerical system that uses only two symbols: \\(0\\) and \\(1\\) . It\u0026rsquo;s the fundamental language of computers and is used to represent all types of data.\nIn the Binary system, each digit represents a power of \\(2\\) , with the rightmost digit representing \\(2^0\\) , the next representing \\(2^1\\) , and so on.\nBinary number \\(1011\\) can be represented in Decimal as:\n$$1 \\times 2^3 \u0026#43; 0 \\times 2^2 \u0026#43; 1 \\times 2^1 \u0026#43; 1 \\times 2^0 = 8 \u0026#43; 0 \u0026#43; 2 \u0026#43; 1 = 11$$ Binary is used in programming to understand how data is stored and manipulated at the hardware level. It’s essential for low-level programming like creating device drivers or embedded systems.\nHexadecimal numerical system The Hexadecimal system is a base-16 numerical system, using sixteen distinct symbols. The first ten are the same as the decimal system, and the next six are represented as \\(A\\) for ten, \\(B\\) for eleven, \\(C\\) for twelve, \\(D\\) for thirteen, \\(E\\) for fourteen, and \\(F\\) for fifteen.\nLike Binary, each digit in Hexadecimal represents a power, but this time of \\(16\\) .\nHexadecimal number \\(2A3\\) can be represented in Decimal as:\n$$2 \\times 16^2 \u0026#43; 10 \\times 16^1 \u0026#43; 3 \\times 16^0 = 512 \u0026#43; 160 \u0026#43; 3 = 675$$ Hexadecimal is often used in programming for defining colors in web development, memory addresses, or displaying binary-coded values in a more human-readable form.\nBoolean logic Boolean logic is a branch of algebra that deals with true or false values. It\u0026rsquo;s named after George Boole and is foundational in computer science and electrical engineering.\nBoolean logic typically consists of five fundamental operators:\nAND (Conjunction): Returns true if both operands are true. OR (Disjunction): Returns true if at least one operand is true. NOT (Negation): Returns true if the operand is false. XOR (Exclusive OR): Returns true if exactly one of the operands is true. NOR (Logical NOR): Returns true if neither of the operands is true. NAND (Logical NAND): Returns true if at least one of the operands is false. Different programming languages and systems might utilize these operators in various ways or under different names, but these are the core logical operators found in Boolean algebra.\nBoolean logic is fundamental in programming for control structures, decision-making processes, and complex algorithms.\nTruth tables A truth table is a mathematical table used in logic to compute and visualize the output values of logical functions, given all possible combinations of input values (true and false). Truth tables are used to describe how the output of a logic gate or expression changes based on the values of the inputs. Here there is a truth table for all the operators mentioned above.\nA B A AND B A OR B A XOR B A NOR B A NAND B NOT A T T T T F F F F T F F T T F T F F T F T T F T T F F F F F T T T Conclusion The Binary and Hexadecimal numerical systems, along with Boolean logic, are key concepts for anyone starting in programming. Understanding these foundational elements can provide deeper insights into how computers operate and how software interacts with hardware.\nBy grasping these concepts, you are not only laying down a solid foundation for further studies in programming but also developing a rigorous and analytical mindset that will serve you well in all aspects of computer science and software development.\n","date":1678492800,"headings":[{"anchor":"binary-numerical-system","title":"Binary numerical system"},{"anchor":"boolean-logic","title":"Boolean logic"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"hexadecimal-numerical-system","title":"Hexadecimal numerical system"},{"anchor":"truth-tables","title":"Truth tables"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Programming, at its core, involves manipulating numbers and logic. In this article, we will explore two essential numerical systems (Binary and Hexadecimal) and delve into the fundamental principles of Boolean logic. These concepts are vital for anyone beginning their journey in programming.","tags":["intro","programming","decimal","binary","hexadecimal","numerical-systems","boolean-logic"],"title":"Numerical systems and Boolean logic","url":"/en/programming/0100-intro/03-numerical-systems-boolean-logic/","year":"2023"},{"content":"","date":1678492800,"headings":[],"kind":"term","lang":"en","summary":"","title":"numerical-systems","url":"/en/tags/numerical-systems/","year":"2023"},{"content":"","date":167832e4,"headings":[],"kind":"term","lang":"en","summary":"","title":"install","url":"/en/tags/install/","year":"2023"},{"authors":["Julián Nonino"],"content":"Linux Check Existing Version: Many Linux distributions come with Python pre-installed. To check the existing version, open the terminal and run:\n1python --version or 1python3 --version\nInstalling Python 3 on Ubuntu: If Python 3 is not installed, you can run the following commands:\n1sudo apt update 2sudo apt install python3 Installing on Other Linux Distributions: For other distributions, you can refer to the package manager specific to your distribution, such as yum for CentOS or zypper for openSUSE.\nMac Check Existing Version: MacOS usually comes with Python 2.7. To check the version, open Terminal and run:\n1python --version Installing Python 3 with Homebrew: You can install Python 3 using Homebrew by running:\n1brew install python3 Downloading from the Official Website: You can also download Python from the official Python website, then follow the instructions to install it.\nWindows Downloading from the Official Website:\nVisit the Python download page. Download the latest version for Windows. Run the installer. Make sure to check the box next to \u0026ldquo;Add Python to PATH\u0026rdquo; during the installation process. Follow the instructions to complete the installation. Verify Installation: Open the Command Prompt and run:\n1python --version ","date":167832e4,"headings":[{"anchor":"linux","title":"Linux"},{"anchor":"mac","title":"Mac"},{"anchor":"windows","title":"Windows"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Python is a widely-used programming language for web development, data analysis, scientific computing, and much more. In this article, we'll guide you through the installation process of Python on three major operating systems: Linux, Mac, and Windows. Since Python is often pre-installed on many Linux and Mac systems, this guide also covers checking your existing version and upgrading if necessary.","tags":["intro","programming","python","install","tools"],"title":"Installing Python","url":"/en/programming/0100-intro/02-installing-python/","year":"2023"},{"content":"","date":167832e4,"headings":[],"kind":"term","lang":"en","summary":"","title":"tools","url":"/en/tags/tools/","year":"2023"},{"authors":["Julián Nonino"],"content":"Before diving into programming, it is important to understand some basic concepts about how computers work. A computer consists of a central processing unit (CPU) and memory. The CPU is responsible for executing instructions, while memory stores data and instructions. Programs are a set of instructions that are stored in memory and executed by the CPU. These instructions tell the computer what to do, such as performing calculations, displaying information on a screen, or interacting with other devices.\nProgramming languages are used to write instructions that can be understood by the computer. There are many different programming languages, each with its own set of rules, syntax, and capabilities. Some popular programming languages include Python, JavaScript, C++, Java, and C#. Each language has its own strengths and weaknesses, and is suited for different types of tasks.\nOne of the most important concepts in programming is algorithm. An algorithm is a set of steps that can be followed to solve a problem or accomplish a task. Algorithms are the building blocks of programs and are used to perform calculations, sort data, and make decisions.\nAnother important concept in programming is data types. Data types are categories of data that have specific characteristics and can be used in different ways. Some common data types include integers, floating-point numbers, strings, and Boolean values.\nControl flow is the order in which the computer executes instructions. It allows you to create logic and make decisions in your program. Control flow statements, such as if-else statements and loops, allow you to control the flow of execution and change the behavior of your program based on certain conditions.\nHere is an example of a simple program written in Python that demonstrates some of these concepts:\n1# This program calculates the area of a rectangle 2 3# Get the length of the rectangle from the user 4length = float(input(\u0026#34;Enter the length of the rectangle: \u0026#34;)) 5 6# Get the width of the rectangle from the user 7width = float(input(\u0026#34;Enter the width of the rectangle: \u0026#34;)) 8 9# Calculate the area of the rectangle 10area = length * width 11 12# Print the result 13print(\u0026#34;The area of the rectangle is\u0026#34;, area) In this example, we use the input function to get the length and width of the rectangle from the user, and then use these values to calculate the area using a simple mathematical formula. The result is then printed using the print function.\nThis is just a simple example of what you can do with programming. With the right knowledge and tools, you can create much more complex and powerful programs. As you learn more about programming, you will discover new concepts, such as functions, classes, and modules, and learn how to use them to structure your code and solve more complex problems.\nThere are many resources available for learning programming, including online tutorials, interactive coding environments, and programming bootcamps. Start with the basics and gradually increase complexity as you gain more confidence and understanding.\nOn this guidelines we will be using Python as the language to demonstrate concepts and make test, please check the following steps to install Python on your computer.\nIn conclusion, programming is a powerful tool that can be used to solve problems and create new technologies. Understanding the basic concepts of computer architecture, programming languages, algorithms, data types, and control flow is essential for becoming a successful programmer. With time, patience and practice, you will be able to master the art of programming and create your own powerful applications.\n","date":1678147200,"headings":[],"kind":"page","lang":"en","series":["Programming"],"summary":"Programming is the process of creating instructions that a computer can understand and execute. It is the backbone of modern technology and is used in a wide range of fields, from finance and healthcare to gaming and entertainment. Whether you are building a website, an app, or a complex piece of software, programming is at the core of it all.","tags":["intro","programming"],"title":"Introduction to Programming","url":"/en/programming/0100-intro/01-intro/","year":"2023"},{"content":"","date":1674e6,"headings":[],"kind":"term","lang":"en","summary":"","title":"git","url":"/en/tags/git/","year":"2023"},{"content":"","date":1674e6,"headings":[],"kind":"term","lang":"en","summary":"","title":"revert","url":"/en/tags/revert/","year":"2023"},{"authors":["Julián Nonino"],"content":"When we have created a commit locally but have not published it to the remote yet, we can use git reset to undo the commit and, if we wish, discard the changes. Although there are several options for git reset the most used are:\n--soft: Does not touch the index file or the working tree at all (but resets the head to , just like all modes do). This leaves all your changed files \u0026ldquo;Changes to be committed\u0026rdquo;, as git status would put it. --hard: Resets the index and working tree. Any changes to tracked files in the working tree since are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted. Git reset documentation {: style=\u0026ldquo;text-align: right;\u0026rdquo;}\nHere there is an example about using git reset. We start by changing a file and creating a commit with the change.\n1bash-3.2$ cat README.md 2# Index 3 41 5bash-3.2$ 6bash-3.2$ cat README.md 7# Index 8 91 102 11bash-3.2$ 12bash-3.2$ git add README.md 13bash-3.2$ 14bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md\u0026#34; 15[main 3734fd5] Add number 2 in README.md 16 1 file changed, 1 insertion(+) git status shows there is one commit pending to be published.\n1bash-3.2$ git status 2On branch main 3Your branch is ahead of \u0026#39;origin/main\u0026#39; by 1 commit. 4 (use \u0026#34;git push\u0026#34; to publish your local commits) 5 6nothing to commit, working tree clean Using git reflog to see the history.\n13734fd5 (HEAD -\u0026gt; main) HEAD@{0}: commit: Add number 2 in README.md 2866bfa8 (origin/main) HEAD@{1}: revert: Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 3e2f6d08 HEAD@{2}: merge feature-1: Merge made by the \u0026#39;ort\u0026#39; strategy. 423644da HEAD@{3}: checkout: moving from feature-1 to main Now we can use git reset --soft \u0026lt;COMMIT_ID\u0026gt; to undo the commit but keep the changes.\n1bash-3.2$ git reset --soft 866bfa8 2bash-3.2$ 3bash-3.2$ git status 4On branch main 5Your branch is up to date with \u0026#39;origin/main\u0026#39;. 6 7Changes to be committed: 8 (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) 9 modified: README.md git log after using git reset\n1commit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) 2Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 3Date: Wed Jan 18 20:06:40 2023 -0300 4 5 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 6 7 This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing 8 changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. We create a new commit so we can test the git reset --hard command.\n1bash-3.2$ git status 2On branch main 3Your branch is up to date with \u0026#39;origin/main\u0026#39;. 4 5Changes to be committed: 6 (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) 7 modified: README.md 8 9bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md - NEW COMMIT\u0026#34; 10[main 2e7193d] Add number 2 in README.md - NEW COMMIT 11 1 file changed, 1 insertion(+) git log now shows the new commit.\n1commit 2e7193db650b9ba0762fe73525df599a08f8577d (HEAD -\u0026gt; main) 2Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 3Date: Thu Jan 19 08:32:57 2023 -0300 4 5 Add number 2 in README.md - NEW COMMIT 6 7commit 866bfa8a952d11240707ebfc87f3266034d42443 (origin/main) 8Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 9Date: Wed Jan 18 20:06:40 2023 -0300 10 11 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 12 13 This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing 14 changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. Now we can use git reset --hard \u0026lt;COMMIT_ID\u0026gt; to undo the commit and discard all the changes.\n1bash-3.2$ git reset --hard 866bfa8 2HEAD is now at 866bfa8 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 3bash-3.2$ 4bash-3.2$ git status 5On branch main 6Your branch is up to date with \u0026#39;origin/main\u0026#39;. 7 8nothing to commit, working tree clean git log remains as it nothing had happened.\n1commit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) 2Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 3Date: Wed Jan 18 20:06:40 2023 -0300 4 5 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 6 7 This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing 8 changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. ","date":1674e6,"headings":[],"kind":"page","lang":"en","summary":"How to discard changes in Git before pushing them.","tags":["vcs","version-control","git","revert"],"title":"Revert a local change in Git","url":"/en/blog/2023/01/revert-a-local-change-in-git/","year":"2023"},{"authors":["Julián Nonino"],"content":"When we realized that the last commit was a mistake but we already published it, the command to use is git revert \u0026lt;COMMIT_HASH\u0026gt;.\nFirst we need to locate the ID of the commit we want to revert, it can be done with git log or git reflog commands. Then, run the git revert \u0026lt;COMMIT_HASH\u0026gt; command using the ID obtained in the previous step. Use the options -e or --edit to edit the commit message if we like. Push our changes so the revert is available for everyone in our group. Reverting multiple commits If we need to revert multiple commits we can revert them one by one using the --no-commit option in order to create a single revert commit at the end.\nImagine the history is like the following and we need to go back to COMMIT-3.\n1COMMIT-1 -\u0026gt; COMMIT-2 -\u0026gt; COMMIT-3 -\u0026gt; COMMIT-4 -\u0026gt; COMMIT-5 -\u0026gt; COMMIT-6 -\u0026gt; HEAD This sequence of commands will get our files to the version of COMMIT-3:\n1bash-3.2$ git revert --no-commit COMMIT-6 2bash-3.2$ git revert --no-commit COMMIT-5 3bash-3.2$ git revert --no-commit COMMIT-4 4bash-3.2$ git commit -m \u0026#34;Revert to version in COMMIT-3\u0026#34; 5bash-3.2$ git push Reverting a merge commit -m parent-number, \u0026ndash;mainline parent-number\nUsually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.\nGit revert documentation {: style=\u0026ldquo;text-align: right;\u0026rdquo;}\nWhen we need to revert a merge commit git revert command needs to be run with the -m or --mainline option to indicate the parent number because a merge commit has more than one parent and Git does not know which parent was target branch and which was the branch with the changes that should be reverted.\nHere there is an example showing how to revert a merge commit.\nCreate the first commit in main branch.\n1bash-3.2$ cat README.md 2# Index 3 41 5bash-3.2$ 6bash-3.2$ git commit -m \u0026#34;Add number 1 in README.md - main branch\u0026#34; 7[main (root-commit) 23644da] Add number 1 in README.md - main branch 8 1 file changed, 3 insertions(+) 9 create mode 100644 README.md 10bash-3.2$ 11bash-3.2$ git push -u origin main 12Enumerating objects: 3, done. 13Counting objects: 100% (3/3), done. 14Writing objects: 100% (3/3), 254 bytes | 254.00 KiB/s, done. 15Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 16To github.com:jnonino/test-repo.git 17 * [new branch] main -\u0026gt; main 18branch \u0026#39;main\u0026#39; set up to track \u0026#39;origin/main\u0026#39;. 19bash-3.2$ The state of the README.md file in main branch.\n1bash-3.2$git status 2On branch main 3Your branch is up to date with \u0026#39;origin/main\u0026#39;. 4 5nothing to commit, working tree clean 6bash-3.2$ 7bash-3.2$ cat README.md 8# Index 9 101 Branch feature-1 created and added one commit.\n1bash-3.2$ git checkout -b feature-1 2Switched to a new branch \u0026#39;feature-1\u0026#39; 3bash-3.2$ 4bash-3.2$ cat README.md 5# Index 6 71 82 9bash-3.2$ 10bash-3.2$ git add README.md 11bash-3.2$ 12bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md - feature-1 branch\u0026#34; 13[feature-1 83ea1a3] Add number 2 in README.md - feature-1 branch 14 1 file changed, 1 insertion(+) 15bash-3.2$ 16bash-3.2$ git push --set-upstream origin feature-1 17Enumerating objects: 5, done. 18Counting objects: 100% (5/5), done. 19Writing objects: 100% (3/3), 292 bytes | 292.00 KiB/s, done. 20Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 21remote: 22remote: Create a pull request for \u0026#39;feature-1\u0026#39; on GitHub by visiting: 23remote: https://github.com/jnonino/test-repo/pull/new/feature-1 24remote: 25To github.com:jnonino/test-repo.git 26 * [new branch] feature-1 -\u0026gt; feature-1 27branch \u0026#39;feature-1\u0026#39; set up to track \u0026#39;origin/feature-1\u0026#39;. 28bash-3.2$ The state of README.md in the feature-1 branch.\n1bash-3.2$ git status 2On branch feature-1 3Your branch is up to date with \u0026#39;origin/feature-1\u0026#39;. 4 5nothing to commit, working tree clean 6bash-3.2$ 7bash-3.2$ cat README.md 8# Index 9 101 112 Merge the feature-1 branch into the main branch.\n1bash-3.2$ git checkout main 2Switched to branch \u0026#39;main\u0026#39; 3Your branch is up to date with \u0026#39;origin/main\u0026#39;. 4bash-3.2$ 5bash-3.2$ git merge --no-ff feature-1 6Merge made by the \u0026#39;ort\u0026#39; strategy. 7 README.md | 1 + 8 1 file changed, 1 insertion(+) 9bash-3.2$ 10bash-3.2$ git push 11Enumerating objects: 1, done. 12Counting objects: 100% (1/1), done. 13Writing objects: 100% (1/1), 233 bytes | 233.00 KiB/s, done. 14Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 15To github.com:jnonino/test-repo.git 16 23644da..e2f6d08 main -\u0026gt; main 17bash-3.2$ Current state of README.md in main branch.\n1bash-3.2$ git status 2On branch main 3Your branch is up to date with \u0026#39;origin/main\u0026#39;. 4 5nothing to commit, working tree clean 6bash-3.2$ 7bash-3.2$ cat README.md 8# Index 9 101 112 git log after merging feature-1 into main branch.\n1commit e2f6d08d3b38a02a1c026cfb879f3131536757ac (HEAD -\u0026gt; main, origin/main) 2Merge: 23644da 83ea1a3 3Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 4Date: Wed Jan 18 19:58:19 2023 -0300 5 6 Merge branch \u0026#39;feature-1\u0026#39; 7 8commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) 9Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 10Date: Wed Jan 18 19:53:38 2023 -0300 11 12 Add number 2 in README.md - feature-1 branch 13 14commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 15Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 16Date: Wed Jan 18 19:48:37 2023 -0300 17 18 Add number 1 in README.md - main branch To revert the merge commit, as it was stated above we need to pay attention to the merge field.\n1Merge: 23644da 83ea1a3 Running git revert e2f6d08 -m 1 will reinstate the tree as it was in 23644da, and git revert e2f6d08 -m 2 will set the tree as it was in 83ea1a3. In this example we would like to leave the main branch as it was before the merge commit. For doing that, we need to run git revert e2f6d08 -m 1.\n1bash-3.2$ git revert e2f6d08 -m 1 2[main 866bfa8] Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 3 1 file changed, 1 deletion(-) 4bash-3.2$ 5bash-3.2$ git status 6On branch main 7Your branch is ahead of \u0026#39;origin/main\u0026#39; by 1 commit. 8 (use \u0026#34;git push\u0026#34; to publish your local commits) 9 10nothing to commit, working tree clean 11bash-3.2$ 12bash-3.2$ git push 13Enumerating objects: 5, done. 14Counting objects: 100% (5/5), done. 15Writing objects: 100% (3/3), 344 bytes | 344.00 KiB/s, done. 16Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 17To github.com:jnonino/test-repo.git 18 e2f6d08..866bfa8 main -\u0026gt; main git log after reverting the merge commit.\n1commit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) 2Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 3Date: Wed Jan 18 20:06:40 2023 -0300 4 5 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 6 7 This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing 8 changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. 9 10commit e2f6d08d3b38a02a1c026cfb879f3131536757ac 11Merge: 23644da 83ea1a3 12Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 13Date: Wed Jan 18 19:58:19 2023 -0300 14 15 Merge branch \u0026#39;feature-1\u0026#39; 16 17commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) 18Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 19Date: Wed Jan 18 19:53:38 2023 -0300 20 21 Add number 2 in README.md - feature-1 branch 22 23commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 24Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 25Date: Wed Jan 18 19:48:37 2023 -0300 26 27 Add number 1 in README.md - main branch Current state of README.md in main branch.\n1bash-3.2$ git status 2On branch main 3Your branch is up to date with \u0026#39;origin/main\u0026#39;. 4 5nothing to commit, working tree clean 6bash-3.2$ 7bash-3.2$ cat README.md 8# Index 9 101 ","date":1674e6,"headings":[{"anchor":"reverting-a-merge-commit","title":"Reverting a merge commit"},{"anchor":"reverting-multiple-commits","title":"Reverting multiple commits"}],"kind":"page","lang":"en","summary":"Have you ever pushed a change in Git and it was wrong? Here you'll learn how to revert the change, even if the problem was with a merge commit.","tags":["vcs","version-control","git","revert"],"title":"Revert a pushed change in Git","url":"/en/blog/2023/01/revert-a-pushed-change-in-git/","year":"2023"},{"content":"","date":1674e6,"headings":[],"kind":"term","lang":"en","summary":"","title":"vcs","url":"/en/tags/vcs/","year":"2023"},{"content":"","date":1674e6,"headings":[],"kind":"term","lang":"en","summary":"","title":"version-control","url":"/en/tags/version-control/","year":"2023"},{"content":"Latest Articles Blog Sep 2, 2023 NO IMAGE Continuous Delivery Here you can find information about Continuous Delivery, what is it, which benefits can you expect from it, the... Read more Blog Aug 19, 2023 NO IMAGE Continuous Integration What is Continuous Integration? Which benefits it provides? In this article you can find answers to those questions and... Read more Software Engineering Aug 18, 2023 NO IMAGE Requirements Engineering Requirements engineering is the process of defining, documenting and maintaining requirements for a software system. It... Read more Software Engineering Aug 16, 2023 NO IMAGE The Deployment phase The deployment stage involves releasing the software into production and making it available for end users. Read more Software Engineering Aug 16, 2023 NO IMAGE The Maintenance phase Once a software application is deployed and begins its life in the hands of users, its journey is far from over. The... Read more Software Engineering Aug 15, 2023 NO IMAGE The Testing phase In the rapidly-evolving domain of software development, delivering a product isn\u0026#39;t the endpoint, it\u0026#39;s a milestone.... Read more Software Engineering Aug 14, 2023 NO IMAGE The Implementation phase The Software Development Life Cycle (SDLC) guides software engineers through the steps of creating quality software. In... Read more Software Engineering Aug 13, 2023 NO IMAGE The System Design phase System design is an essential part of the Software Development Life Cycle (SDLC). In many ways, this phase sets the... Read more Software Engineering Aug 12, 2023 NO IMAGE The Planning phase Stepping into the vast world of software development, one quickly realizes that building successful software isn\u0026#39;t just... Read more Software Engineering Aug 11, 2023 NO IMAGE Introduction In the realm of software and technology, a predictable and structured approach to software development is pivotal. The... Read more Software Engineering Aug 10, 2023 NO IMAGE Introduction In today\u0026#39;s digital age, it\u0026#39;s impossible to imagine a world without software. From the apps we use daily to sophisticated... Read more Blog Aug 8, 2023 NO IMAGE Recursive functions A recursive function is a function that calls itself in order to solve a problem. This self-referential nature can lead... Read more ","date":1664015071,"headings":[{"anchor":"latest-articles","title":"Latest Articles"}],"kind":"home","lang":"en","summary":"Latest Articles Blog Sep 2, 2023 NO IMAGE Continuous Delivery Here you can find information about Continuous Delivery, what is it, which benefits can you expect from it, the... Read more Blog Aug 19, 2023 NO IMAGE Continuous Integration What is Continuous Integration? Which benefits it provides? In this article you can find answers to those questions and... Read more Software Engineering Aug 18, 2023 NO IMAGE Requirements Engineering Requirements engineering is the process of defining, documenting and maintaining requirements for a software system.","title":"Learn-Software.com","url":"/en/","year":"2022"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"2023","url":"/en/archives/2023/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"April","url":"/en/archives/2023/04/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"Archives","url":"/en/archives/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"August","url":"/en/archives/2023/08/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"Blog","url":"/en/posts/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"taxonomy","lang":"en","summary":"","title":"Categories","url":"/en/categories/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"December","url":"/en/archives/2023/12/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"February","url":"/en/archives/2023/02/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"January","url":"/en/archives/2023/01/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"July","url":"/en/archives/2023/07/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"June","url":"/en/archives/2023/06/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"March","url":"/en/archives/2023/03/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"term","lang":"en","summary":"","title":"María Florencia Caro","url":"/en/authors/mfcaro/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"May","url":"/en/archives/2023/05/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"November","url":"/en/archives/2023/11/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"October","url":"/en/archives/2023/10/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"September","url":"/en/archives/2023/09/","year":"0001"}]