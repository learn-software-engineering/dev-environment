[{"content":"","date":1698969600,"headings":[],"kind":"taxonomy","lang":"en","summary":"","title":"Authors","url":"/en/authors/","year":"2023"},{"content":"Data structures are ways of organizing and storing information in a computer program so that it can be accessed and modified efficiently. As programmers, it is essential to understand the different data structures available and know when to apply each one to optimize the performance and utility of our programs.\nA data structure is a particular way of organizing data in the computer\u0026rsquo;s memory so that it can be used efficiently. Data structures come in many forms, such as arrays, lists, stacks, queues, graphs, trees, hashes, etc.\nEach structure organizes the data according to a specific logical model and supports efficient operations to access, modify, add, and delete elements according to that model. For example, an array organizes elements sequentially in memory to facilitate random access by indices. A linked list connects elements in memory using \u0026ldquo;nodes\u0026rdquo; with references to the next node to facilitate insertion and deletion.\nBy choosing the appropriate data structure for the task to be solved, we can write more efficient programs and reduce computational complexity, using fewer resources like memory and processing.\nData structures help us:\nOrganize large amounts of data to make them easier to access and modify.\nModel complex relationships between data, such as with graphs and trees.\nAccess and modify data efficiently, optimizing performance.\nReuse existing code and data structures instead of having to rewrite solutions from scratch.\nFor example, a program that needs to store thousands of user records benefits from using a hash data structure to associate each user with data like first name, last name, email, etc. This way specific users can be found very quickly without having to iterate over the entire collection.\nAnother example are binary search trees, which allow finding elements very quickly in ordered sets of millions of elements. This is achieved by discarding halves of the tree as the desired element is searched.\nTypes of data structures There are many types of data structures. Below are some useful categories to classify them.\nAccording to relationship between elements Linear: Elements are organized sequentially one after the other. For example, arrays, lists, stacks, queues.\nNon-linear: Elements are organized in a hierarchy or graph. This is the case with trees and graphs.\nAccording to element type Homogeneous: Store a single data type. For example, arrays in a language like Java.\nHeterogeneous: Allow different data types. Objects, records are examples of this classification.\nAccording to access mode Sequential access: Elements can only be accessed in sequential order. For example, linked lists.\nDirect access: Any element can be accessed directly by its position. Arrays fall into this group.\nAssociative access: Elements are accessed by an associated key. Dictionaries, hashes fall into this category.\nAccording to functionality Arrays: Fast access to elements by index but difficult to insert/delete.\nLists: Easy to insert/delete anywhere but sequential access is slow.\nStacks: LIFO (Last In First Out) access. Useful for undo/redo.\nQueues: FIFO (First In First Out) access. Useful for event processing.\nTrees: Allow modeling hierarchical relationships like file directories or task dependencies.\nGraphs: Allow modeling interconnectivity networks like maps, social relationships, etc.\nHashes / Dictionaries: Associate elements with unique keys for ultra fast access.\nThis classification is not exhaustive but gives an idea of the diversity of data structures and their different properties that allow us to efficiently model complex problems.\nExample Let\u0026rsquo;s look at a Python example to see how a data structure is created and used. Suppose we want to represent a print queue where prints are processed in order of arrival (FIFO).\nFirst, we define a PrintQueue class to represent our queue:\n1class PrintQueue: 2 def __init__(self): 3 self.items = [] 4 5 def enqueue(self, item): 6 self.items.append(item) 7 8 def dequeue(self): 9 return self.items.pop(0) 10 11 def is_empty(self): 12 return len(self.items) == 0 Then we use it to add prints and process them in order:\n1print_queue = PrintQueue() 2 3print_queue.enqueue(\u0026#34;document1.doc\u0026#34;) 4print_queue.enqueue(\u0026#34;image3.jpg\u0026#34;) 5print_queue.enqueue(\u0026#34;presentation.ppt\u0026#34;) 6 7while not print_queue.is_empty(): 8 next_item = print_queue.dequeue() 9 print(f\u0026#34;Printing {next_item}\u0026#34;) This will print:\nPrinting document1.doc Printing image3.jpg Printing presentation.ppt With a data structure like the queue we implement FIFO logic in a simple, reusable way. And this is just one example, the possibilities are endless!\nConclusion Data structures are fundamental programming tools that allow us to optimally organize information to solve complex problems. Knowing the different types of structures available, like arrays, lists, stacks, queues, hashes, graphs, and trees, allows us to build more efficient programs. I hope this introduction has given you some knowledge and tools to start mastering this exciting topic!\n","date":1698969600,"headings":[{"anchor":"according-to-access-mode","title":"According to access mode"},{"anchor":"according-to-element-type","title":"According to element type"},{"anchor":"according-to-functionality","title":"According to functionality"},{"anchor":"according-to-relationship-between-elements","title":"According to relationship between elements"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"example","title":"Example"},{"anchor":"types-of-data-structures","title":"Types of data structures"}],"kind":"section","lang":"en","summary":"Data structures are ways of organizing and storing information in a computer program so that it can be accessed and modified efficiently. As programmers, it is essential to understand the different data structures available and know when to apply each one to optimize the performance and utility of our programs.\nA data structure is a particular way of organizing data in the computer’s memory so that it can be used efficiently.","title":"Data Structures","url":"/en/programming/0400-data-structures-1/","year":"2023"},{"content":"","date":1698969600,"headings":[],"kind":"term","lang":"en","summary":"","title":"data-structures","url":"/en/tags/data-structures/","year":"2023"},{"content":"","date":1698969600,"headings":[],"kind":"term","lang":"en","summary":"","title":"intro","url":"/en/tags/intro/","year":"2023"},{"content":"I\u0026rsquo;m a computer engineer who has been thriving in the software industry since 2013. My entire career has been driven by an insatiable curiosity for software engineering practices and a relentless pursuit of ways to refine the development process. My journey has seen me wear many hats, including those of a Software Developer, Configuration Manager, Scrum Master, DevOps Engineer, DevOps Consultant, and Platform Engineer.\nWhat truly fuels my passion is not just the act of learning, but also the joy of sharing knowledge. This passion led me to the halls of academia, where I began my teaching journey with assistant positions in Physics courses during my early years at the university. My commitment to education did not stop there. After serving as a teacher\u0026rsquo;s assistant for several years, I eagerly applied for and secured a position as an adjunct professor in the specialized courses of Software Engineering and Software Quality Management.\nHowever, life is a journey filled with twists and opportunities. In 2020, I made the bittersweet decision to resign from my cherished adjunct professor role, as an exciting new chapter unfolded. A move to London beckoned, offering fresh horizons and the chance to immerse myself in a vibrant and innovative tech hub. Though I left a part of my heart in academia, the pursuit of excellence continues, and my passion for software engineering remains as strong as ever.\nJoin me as we explore the fascinating world of software engineering, a field that continues to evolve, inspire, and shape our future.\n","date":1698969600,"headings":[],"kind":"term","lang":"en","summary":"I’m a computer engineer who has been thriving in the software industry since 2013. My entire career has been driven by an insatiable curiosity for software engineering practices and a relentless pursuit of ways to refine the development process. My journey has seen me wear many hats, including those of a Software Developer, Configuration Manager, Scrum Master, DevOps Engineer, DevOps Consultant, and Platform Engineer.\nWhat truly fuels my passion is not just the act of learning, but also the joy of sharing knowledge.","title":"Julián Nonino","url":"/en/authors/jnonino/","year":"2023"},{"content":"","date":1698969600,"headings":[],"kind":"term","lang":"en","summary":"","title":"linked-lists","url":"/en/tags/linked-lists/","year":"2023"},{"content":"","date":1698969600,"headings":[],"kind":"term","lang":"en","summary":"","title":"programming","url":"/en/tags/programming/","year":"2023"},{"content":"","date":1698969600,"headings":[],"kind":"term","lang":"en","summary":"","title":"Programming","url":"/en/series/programming/","year":"2023"},{"content":"Welcome to our comprehensive series designed to guide you through the realm of programming. Tailored for those new to the world of coding, this collection of articles provides a step-by-step approach to understanding the fundamentals of programming. We\u0026rsquo;ll start with the basics, delving into concepts like variables, data types, and control structures, gradually advancing to more complex topics such as algorithms, data structures, and software design principles.\nWhether you\u0026rsquo;ve never penned a line of code or are seeking a structured refresher, this series offers the explanations and guidance you need to navigate the software industry. Our hands-on tutorials, lucid explanations, and practical examples aim to make the learning process both engaging and intuitive. Join us on this coding journey, and by the end, you\u0026rsquo;ll be armed with the skills and knowledge to tackle real-world programming challenges.\n","date":1698969600,"headings":[],"kind":"section","lang":"en","summary":"Welcome to our comprehensive series designed to guide you through the realm of programming. Tailored for those new to the world of coding, this collection of articles provides a step-by-step approach to understanding the fundamentals of programming. We’ll start with the basics, delving into concepts like variables, data types, and control structures, gradually advancing to more complex topics such as algorithms, data structures, and software design principles.\nWhether you’ve never penned a line of code or are seeking a structured refresher, this series offers the explanations and guidance you need to navigate the software industry.","title":"Programming","url":"/en/programming/","year":"2023"},{"content":"","date":1698969600,"headings":[],"kind":"term","lang":"en","summary":"","title":"queues","url":"/en/tags/queues/","year":"2023"},{"authors":["Julián Nonino"],"content":"The FIFO (first in, first out) nature of queues is because only the initial element can be accessed and manipulated. When an element is added to the queue it is known as \u0026ldquo;enqueue\u0026rdquo;, while removing an element is called \u0026ldquo;dequeue\u0026rdquo;.\nThis causes the first element to be added to the queue to also be the first to be removed, hence its FIFO behaviour.\nMain operations The basic queue operations are:\nEnqueue: Adds an element to the end of the queue. Dequeue: Removes the element from the front of the queue. Peek: Gets the front element without removing it. isEmpty: Checks if the queue is empty. Implementation Like stacks, queues can be implemented using linked lists. Elements are added at the end and removed from the front by keeping references to both ends.\n1class Node: 2 def __init__(self, value): 3 self.value = value 4 self.next = None 5 6 7class Queue: 8 def __init__(self): 9 self.front = None 10 self.end = None 11 self.size = 0 12 13 def enqueue(self, value): 14 new_node = Node(value) 15 if self.end is None: 16 self.end = new_node 17 self.front = new_node 18 return 19 self.end.next = new_node 20 self.end = new_node 21 self.size += 1 22 23 def dequeue(self): 24 if self.is_empty(): 25 return None 26 value = self.front.value 27 self.front = self.front.next 28 if self.front is None: 29 self.end = None 30 self.size -= 1 31 return value 32 33 def peek(self): 34 if self.is_empty(): 35 return None 36 return self.front.value 37 38 def is_empty(self): 39 return self.front is None # Returns true if front is None 40 41 def __len__(self): 42 return self.size 43 44 def __str__(self): 45 values = [] 46 current = self.front 47 while current: 48 values.append(str(current.value)) 49 current = current.next 50 return \u0026#34;\\n\u0026#34;.join(values) Usage examples Some common uses of queues:\nPrint queues where first in, first printed. Task queues in operating systems for execution order. Simulations where arrival order must be respected like in banks. Message queues like RabbitMQ or Kafka. Circular buffers in audio for streaming. Conclusion Queues are versatile structures thanks to their FIFO principle. Having a good handle on queues, implementation, and applications will reinforce your skills as a programmer.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":1698969600,"headings":[{"anchor":"conclusion","title":"Conclusion"},{"anchor":"implementation","title":"Implementation"},{"anchor":"main-operations","title":"Main operations"},{"anchor":"usage-examples","title":"Usage examples"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Queues are an abstract data structure that operates under the FIFO (first in, first out) principle, where the first element to enter is also the first to leave. Queues are used to order elements so that the first to arrive is processed first. Understanding their operation is essential for any programmer.","tags":["intro","programming","data-structures","linked-lists","queues"],"title":"Queues","url":"/en/programming/0400-data-structures-1/0405-queues/","year":"2023"},{"content":"","date":1698969600,"headings":[],"kind":"taxonomy","lang":"en","summary":"","title":"Series","url":"/en/series/","year":"2023"},{"content":"","date":1698969600,"headings":[],"kind":"taxonomy","lang":"en","summary":"","title":"Tags","url":"/en/tags/","year":"2023"},{"content":"","date":1698883200,"headings":[],"kind":"term","lang":"en","summary":"","title":"stacks","url":"/en/tags/stacks/","year":"2023"},{"authors":["Julián Nonino"],"content":"The LIFO nature of stacks is due to the fact that only the top element can be accessed and manipulated. The operation of placing an element on the stack is known as \u0026ldquo;push\u0026rdquo;, while removing an element from the stack is a \u0026ldquo;pop\u0026rdquo;. The LIFO operation causes the last element placed in a stack to be the first to be removed.\nMain operations The primary operations supported by a stack structure are:\nPush: adds an element to the top of the stack. Pop: removes the element at the top of the stack. Peek: allows accessing the top element without removing it from the stack. isEmpty: checks if the stack is empty. Most languages like Python and Java provide stack implementations in their standard libraries.\nImplementation A stack can be implemented using a linked list so that each node points to the previous node.\n1class Node: 2 def __init__(self, value): 3 self.value = value 4 self.previous = None 5 6 7class Stack: 8 def __init__(self): 9 self.top = None 10 self.size = 0 11 12 def push(self, value): 13 new_node = Node(value) 14 if self.top is None: 15 self.top = new_node 16 else: 17 new_node.previous = self.top 18 self.top = new_node 19 self.size += 1 20 21 def pop(self): 22 if self.top is None: 23 return None 24 top_node = self.top 25 self.top = self.top.previous 26 self.size -= 1 27 return top_node.value 28 29 def peek(self): 30 if self.top is None: 31 return None 32 return self.top.value 33 34 def is_empty(self): 35 return self.top is None # Returns true if top is None 36 37 def __len__(self): 38 return self.size 39 40 def __str__(self): 41 values = [] 42 current = self.top 43 while current: 44 values.append(str(current.value)) 45 current = current.previous 46 return \u0026#34;\\n\u0026#34;.join(values) Usage examples Stacks have many uses in programming:\nExecution stack (call stack): records pending function calls to resolve. Implements expected LIFO behaviour.\nBrowser stack: allows going back (undo) in the browser history similarly to a LIFO stack.\nMath expression execution: stacks can verify parentheses, brackets, braces, etc.\nAlgorithms and data structures: like in the quicksort algorithm and in data path implementations.\nConclusion Stacks are versatile data structures thanks to their LIFO operation principle. Having a good command of stacks, their uses and applications is essential in computer science.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":1698883200,"headings":[{"anchor":"conclusion","title":"Conclusion"},{"anchor":"implementation","title":"Implementation"},{"anchor":"main-operations","title":"Main operations"},{"anchor":"usage-examples","title":"Usage examples"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Stacks are an abstract data structure that operates under the LIFO (last in, first out) principle, where the last element to enter is the first to leave. ","tags":["intro","programming","data-structures","linked-lists","stacks"],"title":"Stacks","url":"/en/programming/0400-data-structures-1/0404-stacks/","year":"2023"},{"authors":["Julián Nonino"],"content":"A linked list is composed of nodes where each node has two parts:\nData or information Reference to the next node Nodes are organized sequentially, each pointing to the next. The last node points to null to indicate the end.\nThis dynamic structure allows efficient insertion and deletion of nodes.\nTypes of linked lists There are several types:\nSingly linked: Each node points to the next one. Useful for queues and stacks. Doubly linked: Each node has reference to the next and previous ones. Allows traversing in both directions. Circular: The last node points to the first forming a cycle. Useful for circular buffers. Common operations Insert: Add nodes to the beginning, end or middle of the list.\nDelete: Remove nodes by value or position.\nSearch: Find nodes by value by traversing the list.\nTraverse: Iterate through nodes by following the references.\nImplementation Linked lists can be implemented as follows:\nUse the ListNode class to represent nodes:\n1class ListNode: 2 def __init__(self, value): 3 self.value = value 4 self.next = None Then to create and use a list define a LinkedList class with methods for the operations:\n1class LinkedList: 2 def __init__(self): 3 self.head = None 4 5 def add_to_start(self, new_value): 6 new_node = ListNode(new_value) 7 new_node.next = self.head 8 self.head = new_node 9 10 def print(self): 11 current = self.head 12 while current != None: 13 print(current.value) 14 current = current.next 15 16 def search(self, searched_value): 17 current = self.head 18 while current != None: 19 if current.value == searched_value: 20 return True 21 current = current.next 22 return False 23 24 #...other methods With this LinkedList class we can create a list, add nodes, print it, search elements, etc.\nWe could add other methods like insert at end, delete by value, get by index, etc. But this gives an idea of how to encapsulate the linked list functionality in a class. As practice, feel free to try adding these methods on your own. Don\u0026rsquo;t hesitate to leave your comments and contact me if you need help!\nAdvantages and disadvantages Advantages:\nInserting and deleting nodes is efficient. Doesn\u0026rsquo;t require defining a fixed size like arrays. Dynamic, flexible structure. Disadvantages:\nMore memory usage from having to store references. Accessing elements by index is slower since it is sequential. Usage examples Implementing structures like stacks and queues. In doubly linked lists, traverse the list in both directions. Blockchains like Bitcoin\u0026rsquo;s. Playing elements in order like music playlists. Conclusion Linked lists are a versatile data structure for storing dynamic sequences of elements. Having a good handle on these lists, their operations, and uses is essential for any programmer.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":1698796800,"headings":[{"anchor":"advantages-and-disadvantages","title":"Advantages and disadvantages"},{"anchor":"common-operations","title":"Common operations"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"implementation","title":"Implementation"},{"anchor":"types-of-linked-lists","title":"Types of linked lists"},{"anchor":"usage-examples","title":"Usage examples"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Linked lists are a dynamic and flexible data structure that allows efficiently storing collections of elements. Unlike arrays, linked lists do not require reserving a fixed size in advance.","tags":["intro","programming","data-structures","linked-lists"],"title":"Linked Lists","url":"/en/programming/0400-data-structures-1/0403-linked-lists/","year":"2023"},{"content":"","date":1698710400,"headings":[],"kind":"term","lang":"en","summary":"","title":"arrays","url":"/en/tags/arrays/","year":"2023"},{"authors":["Julián Nonino"],"content":"An array is a data structure that represents a set of elements, which are accessed through contiguous numeric indices ranging from 0 to the size of the array minus 1. Arrays provide fast, direct access to elements based on their position.\nIn languages like Python and Ruby, arrays are known as \u0026rsquo;lists\u0026rsquo;. In Javascript they are known as \u0026lsquo;arrays\u0026rsquo;.\nArrays are typically homogeneous, storing elements of the same type like integers, strings, etc. Some languages allow heterogeneous arrays with values of different types.\nCreating arrays The way to create arrays varies according to the programming language:\n1MY_ARRAY = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] # array literal 2my_array = list(range(5)) # array from range When creating a literal array its elements are initialized directly. When constructing an empty array its size is specified but its elements are initialized with a default value (0 for numbers, null for objects, etc).\nAccessing and modifying elements Individual elements are quickly accessed by their index using brackets []:\n1my_array = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] 2print(my_array[0]) # \u0026#39;a\u0026#39; 3print(my_array[2]) # \u0026#39;c\u0026#39; 4my_array[2] = \u0026#39;z\u0026#39; 5print(my_array[2]) # \u0026#39;z\u0026#39; Indices start at 0, so in an array of size N, valid indices are between 0 and N-1.\nAccessing an invalid index causes an error, for example, accessing index 3 in an array of size 3. This is known as \u0026ldquo;index out of bounds\u0026rdquo;.\nTraversing an array We can traverse all elements using a for loop:\n1letters = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] 2 3for i in range(len(letters)): 4 print(letters[i]) This prints each element in order. len() returns the total length of the array.\nAnother way is by directly iterating over the elements:\n1letters = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] 2 3for letter in letters: 4 print(letter) Searching in an array We can search for an element in an array using a loop and comparing element by element:\n1letters = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] 2 3def search_in_array(array, element): 4 for i in range(len(array)): 5 if array[i] == element: 6 return i 7 return False 8 9print(search_in_array(letters, \u0026#39;b\u0026#39;)) # 1 10print(search_in_array(letters, \u0026#39;z\u0026#39;)) # False It returns the index if found or False if not found.\nMultidimensional array Arrays can have more than one dimension, for example, 2D matrices, 3D cubes, etc.\nA 2D array can be seen as a table with rows and columns. To access an element two indices are specified, one for the row and one for the column:\n1matrix = [ 2 [1, 2, 3], 3 [4, 5, 6] 4] 5 6print(matrix[0][2]) # 3 7print(matrix[1][0]) # 4 They can have more dimensions, for example a 3D array to represent pixels in an image.\nConclusion Arrays are fundamental data structures in programming that provide efficient access to elements in memory through numeric indices. Having a good command of arrays, matrices, and their uses is essential for any programmer.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":1698710400,"headings":[{"anchor":"accessing-and-modifying-elements","title":"Accessing and modifying elements"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"creating-arrays","title":"Creating arrays"},{"anchor":"multidimensional-array","title":"Multidimensional array"},{"anchor":"searching-in-an-array","title":"Searching in an array"},{"anchor":"traversing-an-array","title":"Traversing an array"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Arrays are fundamental data structures in programming that allow storing and organizing collections of data of the same type. Mastering the use of arrays is essential for any programmer.","tags":["intro","programming","data-structures","arrays"],"title":"Arrays","url":"/en/programming/0400-data-structures-1/0401-arrays/","year":"2023"},{"content":"","date":1698710400,"headings":[],"kind":"term","lang":"en","summary":"","title":"dictionaries","url":"/en/tags/dictionaries/","year":"2023"},{"content":"","date":1698710400,"headings":[],"kind":"term","lang":"en","summary":"","title":"maps","url":"/en/tags/maps/","year":"2023"},{"authors":["Julián Nonino"],"content":"A dictionary, or map, consists of a collection of key-value pairs. The key is used to access the associated value. Keys must be unique within a dictionary. Values can be repeated.\nMain operations Add/update: Inserts a key-value pair. If the key existed, its value is replaced. 1dictionary[\u0026#39;key\u0026#39;] = \u0026#39;value\u0026#39; Get value: Accesses the value given a key. 1value = dictionary[\u0026#39;key\u0026#39;] Delete: Removes a key-value pair from the dictionary. 1del dictionary[\u0026#39;key\u0026#39;] Traverse: Iterate over the keys, values or pairs of the dictionary. 1for key in dictionary: 2 print(key, dictionary[key]) # key, value Creating a dictionary or map The syntax for creating maps or dictionaries in Python is:\n1empty_dictionary = {} 2 3person = { 4 \u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;, 5 \u0026#39;age\u0026#39;: 25 6} Usage examples Dictionaries are useful in many cases. Below are some examples.\nObjects and mappings We can model objects and entities with key-value attributes:\n1product = { 2 \u0026#39;name\u0026#39;: \u0026#39;Smartphone\u0026#39;, 3 \u0026#39;price\u0026#39;: 500, 4 \u0026#39;brand\u0026#39;: \u0026#39;XYZ\u0026#39; 5} Counts and frequencies Counting occurrences of elements in sequences:\n1text = \u0026#34;Hello world world\u0026#34; 2 3frequencies = {} 4 5for word in text.split(): 6 if word in frequencies: 7 frequencies[word] += 1 8 else: 9 frequencies[word] = 1 10 11print(frequencies) 12# {\u0026#39;Hello\u0026#39;: 1, \u0026#39;world\u0026#39;: 2} Storing and accessing data As a high performance alternative to lists and arrays.\nConclusion Dictionaries are versatile data structures thanks to their fast access based on unique keys. They have uses in almost all programs, so mastering dictionaries is essential in any language.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":1698710400,"headings":[{"anchor":"conclusion","title":"Conclusion"},{"anchor":"counts-and-frequencies","title":"Counts and frequencies"},{"anchor":"creating-a-dictionary-or-map","title":"Creating a dictionary or map"},{"anchor":"main-operations","title":"Main operations"},{"anchor":"objects-and-mappings","title":"Objects and mappings"},{"anchor":"storing-and-accessing-data","title":"Storing and accessing data"},{"anchor":"usage-examples","title":"Usage examples"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Maps (also called hashes or dictionaries) are data structures that associate keys with values. They allow ultra fast access to elements through unique keys. In Python they are known as dictionaries.","tags":["intro","programming","data-structures","maps","dictionaries"],"title":"Maps (Dictionaries)","url":"/en/programming/0400-data-structures-1/0402-maps/","year":"2023"},{"content":"","date":1695859200,"headings":[],"kind":"section","lang":"en","summary":"","title":"Basic concepts","url":"/en/programming/0200-basic-concepts/","year":"2023"},{"content":"","date":1695859200,"headings":[],"kind":"term","lang":"en","summary":"","title":"factorial","url":"/en/tags/factorial/","year":"2023"},{"content":"","date":1695859200,"headings":[],"kind":"term","lang":"en","summary":"","title":"fibonacci\"","url":"/en/tags/fibonacci/","year":"2023"},{"content":"","date":1695859200,"headings":[],"kind":"term","lang":"en","summary":"","title":"functions","url":"/en/tags/functions/","year":"2023"},{"content":"","date":1695859200,"headings":[],"kind":"term","lang":"en","summary":"","title":"recursion","url":"/en/tags/recursion/","year":"2023"},{"authors":["Julián Nonino"],"content":"Recursion: the art of calling yourself Imagine a box of mirrors where each mirror reflects what it sees in the next, creating an infinite series of reflections. Recursion in programming is something similar. It is a technique where a function calls itself directly or indirectly1. This creates a cycle where the function solves a problem by dividing it into smaller instances of the same problem, until reaching a simple base case that can be solved directly.\nFor example, let\u0026rsquo;s imagine a function that prints a countdown:\n1def countdown(number): 2 3 if number \u0026gt; 0: 4 print(number) 5 countdown(number - 1) 6 else: 7 print(\u0026#34;Blastoff!\u0026#34;) 8 9countdown(5) This function calls itself recursively decrementing the number each time until reaching 0, and then prints the blastoff message.\nRecursion is a declarative approach that focuses on dividing a problem into recursive cases without needing to explicitly control the loop using iterators or counters like in imperative programming.\nThe structure of a recursive function The power of recursion lies in its simplicity. However, it is essential to understand its structure to avoid common pitfalls. A typical recursive function has two main parts2:\nBase case: The simplest case with a known solution that doesn\u0026rsquo;t require recursion. It is the stopping condition that halts the recursion. Without a base case, we would fall into infinite recursion which eventually overflows the call stack. Recursive case: This is where the magical recursive call occurs. At this point, the function calls itself with a modified argument, usually a reduced version of the original problem. Classic recursion examples Factorial The factorial of a positive integer \\(n\\) is the product of all positive integers less than or equal to \\(n\\) . For example:\n\\(5! = 5 * 4 * 3 * 2 * 1 = 120\\) \\(4! = 4 * 3 * 2 * 1 = 24\\) \\(3! = 3 * 2 * 1 = 6\\) Here is the Python code for calculating factorial using recursion:\n1def factorial(n): 2 if n == 1: 3 return 1 # Base case 4 return n * factorial(n-1) # Recursive case Base case: The base case is the simplest, smallest instance of the problem that can be answered directly. For factorial, when \\(n = 1\\) , the result is \\(1\\) . Recursive case: If \\(n\\) is greater than \\(1\\) , the function calls itself with \\(n-1\\) , and multiplies the result by \\(n\\) . Let\u0026rsquo;s say you want to calculate the factorial of \\(5\\) , so you call factorial(5).\nHere is what happens:\nStep 1: Since \\(n = 5\\) is not \\(1\\) , the function calls factorial(4), then multiplies the result by \\(5\\) . Step 2: Now, inside factorial(4), \\(n = 4\\) , so the function calls factorial(3), then multiplies the result by \\(4\\) . Step 3: Inside factorial(3), \\(n = 3\\) , so it calls factorial(2), then multiplies the result by \\(3\\) . Step 4: Inside factorial(2), \\(n = 2\\) , so it calls factorial(1), then multiplies the result by \\(2\\) . Step 5: Finally, factorial(1) reaches the base case, where \\(n = 1\\) , so it returns \\(1\\) . Now the results unwind:\nfactorial(2) returns \\(2 * 1 = 2\\) factorial(3) returns \\(3 * 2 = 6\\) factorial(4) returns \\(4 * 6 = 24\\) factorial(5) returns \\(5 * 24 = 120\\) The final result is \\(120\\) , which is the value of \\(5!\\) .\nHere is a visual representation of the call stack:\n1factorial(5) 2 -\u0026gt; factorial(4) 3 -\u0026gt; factorial(3) 4 -\u0026gt; factorial(2) 5 -\u0026gt; factorial(1) 6 return 1 7 return 2 8 return 6 9 return 24 10 return 120 Fibonacci sequence The Fibonacci sequence is a series of numbers where each number is the sum of the previous two. It starts with \\(0\\) and \\(1\\) , and each subsequent number is the sum of the two numbers before it. The beginning of the sequence is: \\(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\\) Here is the Python code for calculating the \\(n^th\\) Fibonacci number using tail recursion:\n1def fibonacci(n, a=0, b=1): 2 if n == 0: 3 return a 4 return fibonacci(n-1, b, a+b) The function takes three parameters:\n\\(n\\) : The position of the desired number in the sequence. \\(a\\) and \\(b\\) : Two numbers that aid in the sequence calculation. Here is a breakdown of how the function works:\nBase case: If \\(n\\) is \\(0\\) , the function returns \\(a\\) . This is the value of the \\(n^th\\) number in the sequence. Recursive case: If \\(n\\) is not \\(0\\) , the function calls itself with \\(n-1\\) , \\(b\\) , and \\(a\u0026#43;b\\) . These parameters change the position in the sequence and prepare the next numbers for summation. Suppose we want to find the \\(5^th\\) number in the Fibonacci sequence by calling fibonacci(5).\nHere is what happens:\nStep 1: Since \\(n = 5\\) , it calls fibonacci(4, 1, 1) (because \\(a = 0\\) , \\(b = 1\\) , \\(a \u0026#43; b = 1\\) ). Step 2: Since \\(n = 4\\) , it calls fibonacci(3, 1, 2) (because \\(a = 1\\) , \\(b = 1\\) , \\(a \u0026#43; b = 2\\) ). Step 3: Since \\(n = 3\\) , it calls fibonacci(2, 2, 3) (because \\(a = 1\\) , \\(b = 2\\) , \\(a \u0026#43; b = 3\\) ). Step 4: Since \\(n = 2\\) , it calls fibonacci(1, 3, 5) (because \\(a = 2\\) , \\(b = 3\\) , \\(a \u0026#43; b = 5\\) ). Step 5: Since \\(n = 1\\) , it calls fibonacci(0, 5, 8) (because \\(a = 3\\) , \\(b = 5\\) , \\(a \u0026#43; b = 8\\) ). Step 6: Since \\(n = 0\\) , it returns \\(a\\) , which is \\(5\\) . The result is \\(5\\) , which is the \\(5^th\\) number in the Fibonacci sequence.\nHere is a visual representation of the call stack:\n1fibonacci(5, 0, 1) 2 -\u0026gt; fibonacci(4, 1, 1) 3 -\u0026gt; fibonacci(3, 1, 2) 4 -\u0026gt; fibonacci(2, 2, 3) 5 -\u0026gt; fibonacci(1, 3, 5) 6 -\u0026gt; fibonacci(0, 5, 8) 7 return 5 Advantages and Disadvantages Recursion has certain advantages3:\nIt can result in simple, elegant solutions for problems that easily break down into subproblems. It eliminates the need for explicit loop control. It mirrors the mathematical structure of a recursive definition. The disadvantages include:\nIt can be less efficient (high memory consumption) than iteration due to repeated function calls and stack frame creation. Too much recursion can overflow the call stack and cause crashes. It can be harder to debug and analyze than iteration. Therefore, recursion is a powerful tool that should be used judiciously in appropriate cases.\nRecursion vs Iteration Recursion and iteration (using loops) are parallel tools and we can use either one to solve many problems. Both techniques have the potential to solve the same problems, but their implementation and efficiency may vary. Let\u0026rsquo;s take the factorial example:\nIterative\n1def factorial_iterative(n): 2 result = 1 3 for i in range(1, n+1): 4 result *= i 5 return result Recursive\n1def factorial_recursive(n): 2 if n == 1: 3 return 1 4 return n * factorial(n-1) The iterative version is more efficient in terms of space, but the recursive is cleaner and easier to understand. The choice between recursion and iteration often depends on the specific problem, memory constraints, and programmer preferences.\nConclusion Recursion is a key technique that allows writing elegant, natural, and efficient algorithms when properly leveraged. Understanding how to break down a problem into recursive cases is essential to master this skill. Recursion provides a unique declarative alternative to solve complex problems without managing explicit loops. However, it is crucial to always remember to define an adequate base case and be aware of recursion limitations in terms of efficiency and memory usage. Knowing how to combine recursion and iteration gives flexibility when creating optimal solutions.\nAs always, the key lies in finding the right balance and using the right tool for the right job.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences Cormen, T.H., Leiserson, C.E., Rivest, R.L., \u0026amp; Stein, C. (2009). Introduction to Algorithms. MIT Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKindler, E., \u0026amp; Krivy, I. (2011). Object-Oriented Simulation of systems with Java: A working introduction. BoD–Books on Demand.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1695859200,"headings":[{"anchor":"advantages-and-disadvantages","title":"Advantages and Disadvantages"},{"anchor":"classic-recursion-examples","title":"Classic recursion examples"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"factorial","title":"Factorial"},{"anchor":"fibonacci-sequence","title":"Fibonacci sequence"},{"anchor":"recursion-the-art-of-calling-yourself","title":"Recursion: the art of calling yourself"},{"anchor":"recursion-vs-iteration","title":"Recursion vs Iteration"},{"anchor":"references","title":"References"},{"anchor":"the-structure-of-a-recursive-function","title":"The structure of a recursive function"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Recursion is a fundamental concept in programming that allows a function to call itself. At first it may seem counterintuitive, but mastering this approach opens the door to elegant solutions for certain problems.","tags":["programming","functions","recursion","factorial","fibonacci\""],"title":"Recursive functions","url":"/en/programming/0200-basic-concepts/0205-recursive-functions/","year":"2023"},{"content":"","date":1695772800,"headings":[],"kind":"term","lang":"en","summary":"","title":"conditionals","url":"/en/tags/conditionals/","year":"2023"},{"authors":["Julián Nonino"],"content":"Conditions: making decisions in code Life is full of decisions: \u0026ldquo;If it rains, I\u0026rsquo;ll take an umbrella. Otherwise, I\u0026rsquo;ll wear sunglasses.\u0026rdquo; These decisions are also present in the world of programming. Conditions are like questions the computer asks itself. They allow us to make decisions and execute specific code based on a condition1. They can be as simple as \u0026ldquo;Is it raining?\u0026rdquo; or as complex as \u0026ldquo;Is it the weekend and do I have less than $100 in my bank account?\u0026rdquo;.\nif The if structure allows us to evaluate conditions and make decisions based on the result of that evaluation.\n1age = 15 2 3if age \u0026gt;= 18: 4 print(\u0026#34;You are an adult\u0026#34;) The code above allows executing a portion of code if a person\u0026rsquo;s age is greater than or equal to 18 years.\nif-else When you want to execute alternative code if the condition is false, you use the if-else structure.\n1age = 21 2if age \u0026gt;= 18: 3 print(\u0026#34;You are an adult\u0026#34;) 4else: 5 print(\u0026#34;You are a minor\u0026#34;) In this case, it determines if the person is an adult or a minor, and the message displayed is different.\nif-elif-else When conditions are multiple and two paths are not enough, the if-elif-else structure is used to evaluate them in a chained way.\n1age = 5 2if age \u0026lt;= 13: 3 print(\u0026#34;You are a child\u0026#34;) 4elif age \u0026gt; 13 and age \u0026lt; 18: 5 print(\u0026#34;You are a teenager\u0026#34;) 6else: 7 print(\u0026#34;You are an adult\u0026#34;) In the code above, there are three clear paths: one for when age is less than or equal to 13, one for when age is between 13 and 18, and another for when age is greater than or equal to 18.\nAnother way to solve this problem is through the switch-case structure, which, although Python does not natively incorporate, other languages like Java or C++ do, and it is an important tool to be familiar with. This structure allows programmers to handle multiple conditions in a more organized way than a series of if-elif-else.\nIn Java, for example:\n1int day = 3; 2switch(day) { 3 case 1: 4 System.out.println(\u0026#34;Monday\u0026#34;); 5 break; 6 case 2: 7 System.out.println(\u0026#34;Tuesday\u0026#34;); 8 break; 9 case 3: 10 System.out.println(\u0026#34;Wednesday\u0026#34;); 11 break; 12 // ... and so on 13 default: 14 System.out.println(\u0026#34;Invalid day\u0026#34;); 15} In the previous example, depending on the value of day, the corresponding day will be printed2.\nLoops: repeating actions Sometimes in programming we need to repeat an action several times. Instead of writing the same code many times, we can use loops. These allow repeating the execution of a block of code while a condition is met3.\nwhile The while loop is useful when we want to repeat an action based on a condition.\n1# Prints 1 to 5 2i = 1 3while i \u0026lt;= 5: 4 print(i) 5 i = i + 1 do-while Similar to while but guarantees at least one execution since the code block is executed first and then the condition is evaluated. Python does not implement this structure, but other languages like Java and C++ do.\n1int i = 1; 2 3do { 4 System.out.println(i); 5 i++; 6} while(i \u0026lt;= 5); 1int number = 0; 2do { 3 std::cout \u0026lt;\u0026lt; \u0026#34;Hello, world!\u0026#34; \u0026lt;\u0026lt; std::endl; 4 number++; 5} while (number \u0026lt; 5); for The for loop is useful when we know how many times we want to repeat an action.\n1for i in range(5): 2 print(\u0026#34;Hello, world!\u0026#34;) The code above will print \u0026ldquo;Hello, world!\u0026rdquo; five times.\nWe can also iterate over the elements of a list or iterable object:\n1names = [\u0026#34;Maria\u0026#34;, \u0026#34;Florencia\u0026#34;, \u0026#34;Julian\u0026#34;] 2for name in names: 3 print(f\u0026#34;Hello {name}\u0026#34;) 4 5# Prints 6# Hello Maria 7# Hello Florencia 8# Hello Julian The break and continue statements We can use break to terminate the loop and continue to skip to the next iteration.\nbreak is used to completely terminate the loop when a condition is met, in the following example, when i reaches 5.\n1# break example 2i = 0 3while i \u0026lt; 10: 4 print(i) 5 if i == 5: 6 break 7 i += 1 8 9# Prints: 10# 0 11# 1 12# 2 13# 3 14# 4 15# 5 continue is used to skip an iteration of the loop and continue with the next one when a condition is met. Here we use it to skip even numbers.\n1# continue example 2i = 0 3while i \u0026lt; 10: 4 i += 1 5 if i % 2 == 0: 6 continue 7 print(i) 8 9# Prints: 10# 1 11# 3 12# 5 13# 7 14# 9 Nesting: combining structures Control flow structures can be nested within each other. For example, we can have loops within loops or conditions within loops.\n1for i in range(5): 2 for j in range(10): 3 if (i % 2 == 0 and j % 3 == 0): 4 print(f\u0026#34;i = {i}, j = {j}\u0026#34;) This code will print combinations of i and j only when i is divisible by 2 and j is divisible by 3, demonstrating how loops are nested and executed3.\nCommon usage patterns There are specific patterns to solve common needs with control flow.\nSearch Search for a value in a collection:\n1fruits = [\u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;] 2 3searching = \u0026#34;orange\u0026#34; 4found = False 5 6for fruit in fruits: 7 if fruit == searching: 8 found = True 9 break 10 11if found: 12 print(\u0026#34;Fruit found!\u0026#34;) Accumulation Accumulate incremental values in a loop:\n1total = 0 2 3for i in range(10): 4 total += i 5 6print(total) # Sum from 0..9 = 45 Flowcharts: the visual route to understanding code Programmers, whether beginners or experts, often find themselves facing challenges that require detailed planning before diving into code. This is where flowcharts come into play as an essential tool. These charts are graphical representations of the processes and logic behind a program or system. In this article, we will unravel the world of flowcharts, from basic concepts to advanced techniques, and how they can benefit programmers of all levels.\nA flowchart is a graphical representation of a process. It uses specific symbols to represent different types of instructions or actions. Its main purpose is to simplify understanding of a process by showing step by step how information or decisions flow. These charts:\nFacilitate understanding of complex processes. Aid in the design and planning phase of a program. Serve as documentation and reference for future developments. Flowcharts are a powerful tool that not only benefits beginners but also experienced programmers. They provide a clear and structured view of a process or program, facilitating planning, design, and communication between team members.\nBasic elements Flowcharts consist of several symbols, each with a specific meaning:\nOval: Represents the start or end of a process. Rectangle: Denotes an operation or instruction. Diamond: Indicates a decision based on a condition. Arrows: Show the direction of flow. graph TD; start((Start)) process[Process] decision{Decision?} final((End)) start --\u003e process; process --\u003e decision; decision --\u003e |Yes| process decision --\u003e |No| final Examples Let\u0026rsquo;s design a flowchart for a program that asks for a number and tells us if it\u0026rsquo;s even or odd.\ngraph TB start((Start)) input[Input number] decision{Even?} isEven[Is even] isOdd[Is odd] final((End)) start --\u003e input input --\u003e decision decision --\u003e |Yes| isEven decision --\u003e |No| isOdd isEven --\u003e final isOdd --\u003e final As programs become more complex, you may need to incorporate loops, multiple conditions, and other advanced elements into your flowchart. For example, here we diagram a program that sums numbers from 1 to a number entered by the user.\ngraph TD start((Start)) input[Input number] setVariables[Set sum=0 and counter=1] loop_condition{counter \u003c= N?} loop_code[Add value and increment counter] result[Show sum] final((End)) start --\u003e input input --\u003e setVariables setVariables --\u003e loop_condition loop_condition --\u003e |Yes| loop_code loop_code --\u003e loop_condition loop_condition --\u003e |No| result result --\u003e final Conclusion Control flow is the heart of programming. Without it, programs would be linear sequences of actions without the ability to make decisions or repeat tasks. By mastering these structures not only do you improve your ability to write code, but also your ability to think logically and solve complex problems.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDeitel, P., \u0026amp; Deitel, H. (2012). Java: How to program. Upper Saddle River, NJ: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMatthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. San Francisco, CA: No Starch Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1695772800,"headings":[{"anchor":"accumulation","title":"Accumulation"},{"anchor":"basic-elements","title":"Basic elements"},{"anchor":"common-usage-patterns","title":"Common usage patterns"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"conditions-making-decisions-in-code","title":"Conditions: making decisions in code"},{"anchor":"do-while","title":"do-while"},{"anchor":"examples","title":"Examples"},{"anchor":"flowcharts-the-visual-route-to-understanding-code","title":"Flowcharts: the visual route to understanding code"},{"anchor":"for","title":"for"},{"anchor":"if","title":"if"},{"anchor":"if-elif-else","title":"if-elif-else"},{"anchor":"if-else","title":"if-else"},{"anchor":"loops-repeating-actions","title":"Loops: repeating actions"},{"anchor":"nesting-combining-structures","title":"Nesting: combining structures"},{"anchor":"references","title":"References"},{"anchor":"search","title":"Search"},{"anchor":"the-break-and-continue-statements","title":"The break and continue statements"},{"anchor":"while","title":"while"}],"kind":"page","lang":"en","series":["Programming"],"summary":"When we embark on the exciting journey of learning to program, we soon discover that programming is not just about writing code, but also about controlling the flow of that code. We can compare it to the flow of decisions we make in our daily lives. For example, if it’s cold outside, we put on a coat before going out. If we have no pending tasks, we go to the movies. Our actions depend on these evaluations and decisions. Control flow is, essentially, the way we decide which part of the code runs, when it runs, and how many times it does. To do this, we have a variety of structures that allow us to make decisions, repeat actions, and split our code into logical blocks.","tags":["intro","programming","control-flow","conditionals","if","loops","for","while"],"title":"Control Flow","url":"/en/programming/0200-basic-concepts/0203-control-flow/","year":"2023"},{"content":"","date":1695772800,"headings":[],"kind":"term","lang":"en","summary":"","title":"control-flow","url":"/en/tags/control-flow/","year":"2023"},{"content":"","date":1695772800,"headings":[],"kind":"term","lang":"en","summary":"","title":"for","url":"/en/tags/for/","year":"2023"},{"authors":["Julián Nonino"],"content":"What are functions? A function, in simple terms, is a block of code that executes only when called. You can think of it as a small program within your main program, designed to perform a specific task1. A function can also be seen as a black box: we pass an input (parameters), some internal processing occurs, and it produces an output (return value).\nFunctions allow us to segment our code into logical parts where each part performs a single action. This provides several benefits2:\nReusability: Once defined, we can execute (call) that code from anywhere in our program as many times as needed. Organization: It allows dividing a large program into smaller, more manageable parts. Encapsulation: Functions reduce complexity by hiding internal implementation details. Maintainability: If we need to make changes, we only have to modify the code in one place (the function) instead of tracking down all instances of that code. Procedures vs. Functions\nIt is vital to distinguish between these two concepts. While a function always returns a value, a procedure performs a task but does not return anything. In some languages, this difference is clearer than in others. Python, for example, has functions that can optionally return values.\nAnatomy of a function In Python, a function is declared using the def keyword, followed by the function name and parentheses. The code inside the function is called the body of the function3 and contains the set of instructions to execute to perform its task.\n1def my_function(): 2 print(\u0026#34;Hello from my function!\u0026#34;) To call or invoke a function, we simply use its name followed by parentheses:\n1my_function() # Output: Hello from my function! Parameters and arguments Functions become even more powerful when we pass information to them, known as parameters. These act as \u0026ldquo;variables\u0026rdquo; inside the function, allowing the function to work with different data each time it is called.\nWhile parameters are variables defined in the function definition, arguments are the actual values passed when calling the function.\n1def greet(name): 2 print(f\u0026#34;Hello {name}!\u0026#34;) 3 4greet(\u0026#34;Maria\u0026#34;) 5# Output: 6# Hello Maria! Python allows default parameters, which have a predetermined value, making passing those arguments optional when calling the function. It also allows named parameters which enable passing arguments in any order by specifying their name.\n1def greet(name=\u0026#34;Maria\u0026#34;, repetitions=3): 2 repetition = 1 3 while repetition \u0026lt;= repetitions: 4 print(f\u0026#34;Hello {name}!\u0026#34;) 5 repetition += 1 6 7greet() 8# Output: 9# Hello Maria! 10# Hello Maria! 11# Hello Maria! 12 13greet(\u0026#34;Florencia\u0026#34;, 4) 14# Output: 15# Hello Florencia! 16# Hello Florencia! 17# Hello Florencia! 18# Hello Florencia! 19 20greet(repetitions=2, name=\u0026#34;Julian\u0026#34;) 21# Output 22# Hello Julian! 23# Hello Julian! Returning values Functions can return a result or return value using the return keyword.\n1def circle_area(radius): 2 return 3.14 * (radius ** 2) 3 4result = circle_area(10) 5print(result) # Output: 314 The return value is passed back to where the function was called and can be assigned to a variable for later use.\nFunctions can also perform some task without explicitly returning anything. In Python this is known as returning None.\nLocal and global variables Local variables are defined inside a function and only exist in that scope, while global variables are defined outside and can be accessed from anywhere in the code. It is crucial to understand their scope (where a variable is accessible) and lifetime (how long a variable lives).\n1x = 10 # x is global 2 3def add(): 4 y = 5 # y is local 5 return x + y 6 7add() # Output: 15 8print(y) # Error, y does not exist outside the function We can read global variables from a function, but if we need to modify it we must declare it global.\n1x = 10 2 3def add(): 4 global x 5 x = x + 5 6 7add() 8print(x) # 15 Ideally functions should only work with local variables and parameters. Limit the use of global variables. While they can be useful, they can also make code difficult to read and maintain. Best Practices When creating functions we should follow certain principles and patterns4:\nThe name of a function should clearly indicate its purpose. Make functions small, simple, and focused on one task. A function should do one thing and do it well. Use descriptive names for functions and parameters. Avoid side effects and modifying global variables. Properly document the purpose and usage of each function. Limit the number of parameters, ideally 0 to 3 parameters. Following these best practices will help us create reusable, encapsulated, and maintainable functions.\nConclusion Functions are core components in programming, allowing us to organize, reuse, and encapsulate code. By defining functions that perform a single task we keep our programs simplified, easy to understand, and modify. By understanding and mastering this concept, you not only improve the quality of your code but also your efficiency as a developer.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences McConnell, S. (2004). Code Complete. Microsoft Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nJoyanes Aguilar, L. (2008). Fundamentos de programación: algoritmos, estructura de datos y objetos. McGraw-Hill.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPython Software Foundation. (2022). Python Official Documentation.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKindler, E., \u0026amp; Krivy, I. (2011). Object-Oriented Simulation of systems with Java: A working introduction. BoD–Books on Demand.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1695772800,"headings":[{"anchor":"anatomy-of-a-function","title":"Anatomy of a function"},{"anchor":"best-practices","title":"Best Practices"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"local-and-global-variables","title":"Local and global variables"},{"anchor":"parameters-and-arguments","title":"Parameters and arguments"},{"anchor":"references","title":"References"},{"anchor":"returning-values","title":"Returning values"},{"anchor":"what-are-functions","title":"What are functions?"}],"kind":"page","lang":"en","series":["Programming"],"summary":"In the vast and exciting world of programming, there are concepts that are fundamental pillars for any developer, regardless of their experience level. One of these concepts is functions. What are they? Why are they so crucial? Let's find out!","tags":["intro","programming","functions","methods"],"title":"Functions","url":"/en/programming/0200-basic-concepts/0204-functions/","year":"2023"},{"content":"","date":1695772800,"headings":[],"kind":"term","lang":"en","summary":"","title":"if","url":"/en/tags/if/","year":"2023"},{"content":"","date":1695772800,"headings":[],"kind":"term","lang":"en","summary":"","title":"loops","url":"/en/tags/loops/","year":"2023"},{"content":"","date":1695772800,"headings":[],"kind":"term","lang":"en","summary":"","title":"methods","url":"/en/tags/methods/","year":"2023"},{"content":"","date":1695772800,"headings":[],"kind":"term","lang":"en","summary":"","title":"while","url":"/en/tags/while/","year":"2023"},{"authors":["Julián Nonino"],"content":"Keyboard input Python provides built-in functions to read data entered by the user at runtime. This is known as \u0026ldquo;standard input\u0026rdquo;1.\nThe input() function allows reading a value entered by the user and assigning it to a variable. For example:\n1name = input(\u0026#34;Enter your name: \u0026#34;) This displays the message \u0026ldquo;Enter your name: \u0026quot; and waits for the user to enter text and press Enter. That value is assigned to the name variable2.\nThe input() function always returns a string. If we want to ask for a number or other data type, we must convert it using int(), float(), etc3:\n1age = int(input(\u0026#34;Enter your age: \u0026#34;)) 2pi = float(input(\u0026#34;Enter the value of pi: \u0026#34;)) Reading multiple values We can ask for and read multiple values on the same line separating them with commas4:\n1name, age = input(\u0026#34;Enter name and age: \u0026#34;).split() The split() method divides the input into parts and returns a list of strings. We then assign the list elements to separate variables.\nWe can also read multiple lines of input with a loop1:\n1names = [] # empty list 2 3for x in range(3): 4 name = input(\u0026#34;Enter a name: \u0026#34;) 5 names.append(name) This code reads 3 names entered by the user and adds them to a list.\nScreen output Python also provides functions to send program output to \u0026ldquo;standard output\u0026rdquo;, usually the screen or terminal3.\nThe print() function displays the value passed as a parameter:\n1name = \u0026#34;Eric\u0026#34; 2print(name) # displays \u0026#34;Eric\u0026#34; We can print multiple values separated by commas2:\n1print(\u0026#34;Hello\u0026#34;, name, \u0026#34;!\u0026#34;) # displays \u0026#34;Hello Eric!\u0026#34; We can also use literal values without assigning to variables4:\n1print(\u0026#34;2 + 3 =\u0026#34;, 2 + 3) # displays \u0026#34;2 + 3 = 5\u0026#34; Output formatting Python provides various ways to format output1:\nf-Strings: Allow inserting variables into a string:\n1name = \u0026#34;Eric\u0026#34; 2print(f\u0026#34;Hello {name}\u0026#34;) # displays \u0026#34;Hello Eric\u0026#34; %s: Inserts string text into a format string:\n1name = \u0026#34;Eric\u0026#34; 2print(\u0026#34;Hello %s\u0026#34; % name) # displays \u0026#34;Hello Eric\u0026#34; %d: Inserts integer numbers:\n1value = 15 2print(\u0026#34;The value is %d\u0026#34; % value) # displays \u0026#34;The value is 15\u0026#34; .format(): Inserts values into a format string:\n1name = \u0026#34;Eric\u0026#34; 2print(\u0026#34;Hello {}. Welcome\u0026#34;.format(name)) 3# displays \u0026#34;Hello Eric. Welcome\u0026#34; These formatting options allow us to interpolate variables and values into text strings to generate custom outputs. We can combine multiple values and formats in a single output string2.\nOutput to a file In addition to printing to the screen, we can write output to a file using the open() function3:\n1file = open(\u0026#34;data.txt\u0026#34;, \u0026#34;w\u0026#34;) This opens data.txt for writing (\u0026ldquo;w\u0026rdquo;) and returns a file object.\nThen we use file.write() to write to that file4:\n1file.write(\u0026#34;Hello World!\u0026#34;) 2file.write(\u0026#34;This text goes to the file\u0026#34;) We must close the file with file.close() when finished1:\n1file.close() We can also use with to open and automatically close:\n1with open(\u0026#34;data.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: 2 file.write(\u0026#34;Hello World!\u0026#34;) 3 # no need to close, it\u0026#39;s automatic Reading files To read a file we use open() in \u0026ldquo;r\u0026rdquo; mode and iterate over the file object3:\n1with open(\u0026#34;data.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: 2 for line in file: 3 print(line) # prints each line of the file This prints each line, including newlines.\nWe can read all lines to a list with readlines()4:\n1lines = file.readlines() 2print(lines) To read the full content to a string we use read()1:\n1text = file.read() 2print(text) We can also read a specific number of bytes or characters with read(n)2.\nFile handling operations There are several built-in functions to handle files in Python3:\nopen() - Opens a file and returns a file object close() - Closes the file write() - Writes data to the file read() - Reads data from the file readline() - Reads a line from the file truncate() - Empties the file seek() - Changes the reading/writing position rename() - Renames the file remove() - Deletes the file These allow us to perform advanced operations to read, write and maintain files.\nConclusion In this article we explained Python input and output operations in detail, including reading from standard input and writing to standard output or files. Properly handling input and output is essential for many Python applications. I recommend practising with your own examples to master these functions4.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences Downey, A. B. (2015). Think Python: How to think like a computer scientist. Needham, Massachusetts: Green Tea Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMcKinney, W. (2018). Python for data analysis: Data wrangling with Pandas, NumPy, and IPython. O\u0026rsquo;Reilly Media.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMatthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. No Starch Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1695081600,"headings":[{"anchor":"conclusion","title":"Conclusion"},{"anchor":"file-handling-operations","title":"File handling operations"},{"anchor":"keyboard-input","title":"Keyboard input"},{"anchor":"output-formatting","title":"Output formatting"},{"anchor":"output-to-a-file","title":"Output to a file"},{"anchor":"reading-files","title":"Reading files"},{"anchor":"reading-multiple-values","title":"Reading multiple values"},{"anchor":"references","title":"References"},{"anchor":"screen-output","title":"Screen output"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Input/output operations (I/O) allow a program to communicate and exchange data with the outside world. In this article we will see in detail input operations from the keyboard or a file, and output to the screen or a file.","tags":["intro","programming","input/output","I/O"],"title":"Input and output operations","url":"/en/programming/0200-basic-concepts/0202-io-operations/","year":"2023"},{"content":"","date":1694736e3,"headings":[],"kind":"term","lang":"en","summary":"","title":"binary","url":"/en/tags/binary/","year":"2023"},{"authors":["Julián Nonino"],"content":"Named in honour of George Boole, a 19th-century English mathematician, Boolean logic is a mathematical system that deals with operations resulting in one of two possible outcomes: true or false, typically represented as 1 and 0, respectively1. In his groundbreaking work, \u0026ldquo;An Investigation of the Laws of Thought,\u0026rdquo; Boole laid the foundations for this logic, introducing an algebraic system that could be employed to depict logical structures.\nBoolean operations Within Boolean logic, several fundamental operations allow for the manipulation and combination of these binary expressions:\nAND: This operation yields true (1) only if both inputs are true. For instance, if you have two switches, both need to be in the on position for a light to illuminate.\nOR: It returns true if at least one of the inputs is true. Using the switch analogy, as long as one of them is in the on position, the light will shine.\nNOT: This unary operation (accepting only one input) simply inverts the input value. Provide it with a 1, and you\u0026rsquo;ll get a 0, and vice versa.\nNAND (NOT AND): It\u0026rsquo;s the negation of AND. It only returns false if both inputs are true.\nNOR (NOT OR): The negation of OR. It yields true only if both inputs are false.\nXOR (Exclusive OR): It returns true if the inputs differ. If both are the same, it returns false.\nXNOR (Exclusive NOR): The inverse of XOR. It yields true if both inputs are the same.\nWhy is this logic important in computing and programming? Modern computing, at its core, is all about bit manipulation (those 1s and 0s we\u0026rsquo;ve mentioned). Every operation a computer undertakes, from basic arithmetic to rendering intricate graphics, involves Boolean operations at some level2.\nIn programming, Boolean logic is used in control structures, such as conditional statements (if, else) and loops, allowing programs to make decisions based on specific conditions.\nTruth Tables: mapping Boolean logic A truth table graphically represents a Boolean operation. It lists every possible input combination and displays the operation\u0026rsquo;s result for each combination3.\nFor instance:\nA B A AND B A OR B A XOR B A NOR B A NAND B NOT A A NXOR B 1 1 1 1 0 0 0 0 1 1 0 0 1 1 0 1 0 0 0 1 0 1 1 0 1 1 0 0 0 0 0 0 1 1 1 1 Concluding thoughts Boolean logic is more than a set of abstract mathematical rules. It\u0026rsquo;s the foundational language of machines, the code underpinning the digital age in which we live. By understanding its principles, not only do we become more proficient in working with technology, but we also gain a deeper appreciation of the structures supporting our digital world.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences Boole, G. (1854). An Investigation of the Laws of Thought. London: Walton and Maberly.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A. (2012). Structured Computer Organization. New Jersey: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMinsky, M. (1967). Computation: Finite and Infinite Machines. New Jersey: Prentice-Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1694736e3,"headings":[{"anchor":"boolean-operations","title":"Boolean operations"},{"anchor":"concluding-thoughts","title":"Concluding thoughts"},{"anchor":"references","title":"References"},{"anchor":"truth-tables-mapping-boolean-logic","title":"Truth Tables: mapping Boolean logic"},{"anchor":"why-is-this-logic-important-in-computing-and-programming","title":"Why is this logic important in computing and programming?"}],"kind":"page","lang":"en","series":["Programming"],"summary":"In life, we often seek certainties. Will it rain tomorrow, true or false? Is a certain action right or wrong? This dichotomy, this division between two opposing states, lies at the very core of a fundamental branch of mathematics and computer science: Boolean logic.","tags":["intro","programming","boolean-logic"],"title":"Boolean logic","url":"/en/programming/0100-intro/0103-boolean-logic/","year":"2023"},{"content":"","date":1694736e3,"headings":[],"kind":"term","lang":"en","summary":"","title":"boolean-logic","url":"/en/tags/boolean-logic/","year":"2023"},{"content":"","date":1694736e3,"headings":[],"kind":"term","lang":"en","summary":"","title":"decimal","url":"/en/tags/decimal/","year":"2023"},{"content":"","date":1694736e3,"headings":[],"kind":"term","lang":"en","summary":"","title":"hexadecimal","url":"/en/tags/hexadecimal/","year":"2023"},{"content":"At its core, programming is the act of instructing a machine on how to perform a specific task. It\u0026rsquo;s like teaching your dog to fetch, but in this case, the dog is your computer, and the ball might be, let\u0026rsquo;s say, displaying a photo on your screen.\nNow, you might think that programming is just writing lines of code. Programming is actually a broader process that not only includes writing code but also problem-solving, system design, and logical thinking.\nIn the universe of programming, there are high-level and low-level languages. A low-level language, like assembly, is closer to what the machine understands, while a high-level language, such as Python or JavaScript, is more human-friendly. Picture having a conversation: high-level languages are like chatting with a friend over coffee in New York, while low-level languages are like trying to communicate with someone speaking a very specific, localized dialect.\nAdditionally, some programming languages are compiled, while others are interpreted. If a language is compiled, it means it\u0026rsquo;s translated into a machine-understandable language before being executed. On the other hand, interpreted languages are translated in real-time, as they run.\nA brief history of Programming Programming isn\u0026rsquo;t a new concept. In fact, it\u0026rsquo;s been with us long before computers existed in the form we know today. Devices like the abacus and the astrolabe are early examples of tools we used for intricate calculations.\nHowever, it was with the advent of mechanical machines, like Charles Babbage\u0026rsquo;s Analytical Engine, that the foundation for modern programming was laid. We\u0026rsquo;re talking about the 19th century!\nOver time, landmark languages like Fortran and COBOL emerged. These languages paved the way for the technological revolutions that would follow. With the evolution of languages also came new paradigms: first Procedural, then Object-Oriented, and more recently, Functional.\nToday, we\u0026rsquo;re in a modern era dominated by web, mobile, and cloud programming. Every swipe on your phone or online purchase has lines and lines of code working behind the scenes.\nProgramming today Programming is the engine of our modern society. From apps for ordering food to advanced artificial intelligence systems aiding medical research, programming is everywhere.\nBeyond simplifying our daily lives, programming has a profound societal impact. It has enabled progress in automation, data analysis, and entertainment. And what\u0026rsquo;s even more exhilarating is that we\u0026rsquo;re just scratching the surface. With upcoming prospects on artificial intelligence, quantum computing and the Internet of Things (IoT), who knows what marvels await us in the programming world?\n","date":1694736e3,"headings":[{"anchor":"a-brief-history-of-programming","title":"A brief history of Programming"},{"anchor":"programming-today","title":"Programming today"}],"kind":"section","lang":"en","summary":"At its core, programming is the act of instructing a machine on how to perform a specific task. It’s like teaching your dog to fetch, but in this case, the dog is your computer, and the ball might be, let’s say, displaying a photo on your screen.\nNow, you might think that programming is just writing lines of code. Programming is actually a broader process that not only includes writing code but also problem-solving, system design, and logical thinking.","title":"Introduction","url":"/en/programming/0100-intro/","year":"2023"},{"authors":["Julián Nonino"],"content":"The decimal system: the bedrock of our daily life From a tender age, we\u0026rsquo;re taught to count using ten digits: 0 through 9. This system, known as the decimal system, underpins almost all our mathematical and financial activities, from basic arithmetic to calculating bank interests1. Its roots trace back to our anatomy: the ten fingers on our hands, making it the most intuitive and natural system for us. Yet, its true charm emanates from its positional nature.\nTo grasp this concept, let\u0026rsquo;s dissect the number 237:\nThe rightmost digit (7) stands for the units\u0026rsquo; position. That is, \\(7 \\times 10^0\\) (any number raised to the power of 0 is 1). Therefore, its value is simply 7. The middle digit (3) represents the tens\u0026rsquo; position, translating to \\(3 \\times 10^1 = 3 \\times 10 = 30\\) . The leftmost digit (2) is in the hundreds\u0026rsquo; position, decoding to \\(2 \\times 10^2 = 2 \\times 100 = 200\\) . When these values are combined,\n$$2 \\times 10^2 \u0026#43; 3 \\times 10^1 \u0026#43; 7 \\times 10^0 = 200 \u0026#43; 30 \u0026#43; 7 = 237$$ The binary system: computers\u0026rsquo; coded language While the decimal system reigns supreme in our everyday lives, the machines we use daily, from our smartphones to computers, operate in a starkly different realm: the binary world. In this system, only two digits exist: 0 and 1. It might seem restrictive at first glance, but this system is the essence of digital electronics. Digital devices, with their billions of transistors, operate using these two states: on (1) and off (0)2.\nDespite its apparent simplicity, the binary system can express any number or information that the decimal system can. For instance, the decimal number 5 is represented as 101 in binary.\nBinary, with its ones and zeros, operates in a manner akin to the decimal system, but instead of powers of 10, it uses powers of 2.\nConsider the binary number 1011:\nThe rightmost bit denotes \\(1 \\times 2^0 = 1\\) . The subsequent bit stands for \\(1 \\times 2^1 = 2\\) . Next up is \\(0 \\times 2^2 = 0\\) . The leftmost bit in this number signifies \\(1 \\times 2^3 = 8\\) . Thus, 1011 in binary translates to the following in the decimal system:\n$$1011 = 1 \\times 2^3 \u0026#43; 0 \\times 2^2 \u0026#43; 1 \\times 2^1 \u0026#43; 1 \\times 2^0 = 8 \u0026#43; 0 \u0026#43; 2 \u0026#43; 1 = 11$$ Hexadecimal system: bridging humans and machines While the binary system is perfect for machines, it can get a tad cumbersome for us, especially when dealing with lengthy binary numbers. Here is where the hexadecimal system, employing sixteen distinct digits: 0-9 and A-F, with A representing 10, B as 11, and so forth, up to F, which stands for 153 comes to help.\nHexadecimal proves invaluable as it offers a more compact way to represent binary numbers. Each hexadecimal digit corresponds precisely to four binary bits. For instance, think of the binary representation of the number 41279 and notice how the hexadecimal system achieves a more succinct representation:\n$$41279 = 1010 0001 0011 1111 = A13F$$ But the hexadecimal system is more than just a compressed representation of binary numbers; it\u0026rsquo;s a positional numbering system like decimal or binary but based on 16 instead of 10 or 2. Let\u0026rsquo;s see how to derive the decimal representation of the example number (A13F):\nThe rightmost digit represents \\(F \\times 16^0 = 15 \\times 16^0 = 15\\) . The subsequent one stands for \\(3 \\times 16^1 = 48\\) . The next digit denotes \\(1 \\times 16^2 = 256\\) . The leftmost digit in this number signifies \\(A \\times 16^3 = 10 \\times 16^3 = 40960\\) . Therefore, A13F in hexadecimal translates to the following in the decimal system:\n$$A13F = A \\times 16^3 \u0026#43; 1 \\times 16^2 \u0026#43; 3 \\times 16^1 \u0026#43; F \\times 16^0 = 10 \\times 4096 \u0026#43; 1 \\times 256 \u0026#43; 3 \\times 16 \u0026#43; 15 \\times 1 = 40960 \u0026#43; 256 \u0026#43; 48 \u0026#43; 15 = 41279$$ Conclusion Numbering systems are like lenses through which we perceive and understand the world of mathematics and computing. Although the decimal system may be the linchpin of our daily existence, it\u0026rsquo;s crucial to appreciate and comprehend the binary and hexadecimal systems, especially in this digital age.\nSo, the next time you\u0026rsquo;re in front of your computer or using an app on your smartphone, remember that behind that user-friendly interface, a binary world is in full swing, with the hexadecimal system acting as a translator between that realm and us.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences\nIfrah, G. (2000). The Universal History of Numbers. London: Harvill Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A. (2012). Structured Computer Organization. New Jersey: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKnuth, D. (2007). The Art of Computer Programming: Seminumerical Algorithms. California: Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1694736e3,"headings":[{"anchor":"conclusion","title":"Conclusion"},{"anchor":"hexadecimal-system-bridging-humans-and-machines","title":"Hexadecimal system: bridging humans and machines"},{"anchor":"the-binary-system-computers-coded-language","title":"The binary system: computers\u0026rsquo; coded language"},{"anchor":"the-decimal-system-the-bedrock-of-our-daily-life","title":"The decimal system: the bedrock of our daily life"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Every day, we're surrounded by numbers. From the alarm clock's digits waking us up in the morning to the price of our favorite morning coffee. But, have you ever stopped to ponder the essence of these numbers? In this article, we will dive deep into the captivating world of numbering systems, unraveling how one number can have myriad representations depending on the context.","tags":["intro","programming","numerical-systems","decimal","binary","hexadecimal"],"title":"Numerical systems","url":"/en/programming/0100-intro/0102-numerical-systems/","year":"2023"},{"content":"","date":1694736e3,"headings":[],"kind":"term","lang":"en","summary":"","title":"numerical-systems","url":"/en/tags/numerical-systems/","year":"2023"},{"content":"","date":1694563200,"headings":[],"kind":"term","lang":"en","summary":"","title":"computer","url":"/en/tags/computer/","year":"2023"},{"content":"","date":1694563200,"headings":[],"kind":"term","lang":"en","summary":"","title":"cpu","url":"/en/tags/cpu/","year":"2023"},{"content":"","date":1694563200,"headings":[],"kind":"term","lang":"en","summary":"","title":"hardware","url":"/en/tags/hardware/","year":"2023"},{"content":"","date":1694563200,"headings":[],"kind":"term","lang":"en","summary":"","title":"memory","url":"/en/tags/memory/","year":"2023"},{"content":"","date":1694563200,"headings":[],"kind":"term","lang":"en","summary":"","title":"software","url":"/en/tags/software/","year":"2023"},{"authors":["Julián Nonino"],"content":"To the uninitiated, a computer might seem like a mere box—perhaps sometimes sleek and shiny—but a box nonetheless. Yet, within this \u0026ldquo;box\u0026rdquo; lies a universe of complexity and coordination.\nHardware represents the physical components of a computer: the Central Processing Unit (CPU) which is often likened to the brain of the system, the Random Access Memory (RAM) acting as a temporary storage while tasks are underway, storage devices that retain data, and peripherals like keyboards, mice, and monitors1.\nOn the other side of this duality is software, a set of instructions that guides the hardware. There are various types of software, from system software like the operating system (OS), which coordinates the myriad hardware components, to application software that allows users to perform specific tasks, such as word processing or gaming2.\nThe role of the operating system is pivotal. It acts as a bridge, translating user commands into instructions that the hardware can execute. If the hardware were an orchestra, the OS would be its conductor, ensuring each instrument plays its part harmoniously.\nThe binary system: decoding the language of machines Human civilizations have developed numerous numbering systems over the millennia, but computers, with their logical circuits, have settled on the binary system. But why binary? Simply put, at the most foundational level, a computer\u0026rsquo;s operation is based on switches (transistors) that can be either \u0026lsquo;on\u0026rsquo; or \u0026lsquo;off\u0026rsquo;, corresponding naturally to the binary digits, or \u0026lsquo;bits\u0026rsquo;, 1 and 0 respectively3.\nIn this binary realm, a bit is the smallest data unit, representing a single binary value. A byte, comprising 8 bits, can represent 256 distinct values, ranging from \\(00000000\\) to \\(11111111\\) 4. This binary encoding isn\u0026rsquo;t restricted to numbers; it extends to text, images, and virtually all forms of data. For instance, in ASCII encoding, the capital letter \u0026lsquo;A\u0026rsquo; is represented as \\(01000001\\) .\nIn a following post we\u0026rsquo;ll describe in more details the binary system and introduce another system used a lot in relations to computers, the hexadecimal.\nMemory and Storage: the sanctuaries of data The concepts of memory and storage are pivotal in understanding computer architecture. Though sometimes used interchangeably in colloquial parlance, their roles in a computer system are distinct.\nMemory, particularly RAM, is volatile, meaning information stored is lost once the computer is turned off. RAM serves as the computer\u0026rsquo;s \u0026ldquo;workspace\u0026rdquo;, temporarily storing data and instructions during operations. There are various RAM types, with DRAM and SRAM being the most prevalent5.\nContrastingly, Read-Only Memory (ROM) is non-volatile, used predominantly to store firmware—software intrinsically linked to specific hardware, requiring infrequent alterations.\nIn terms of data storage, devices like hard drives, SSDs, and flash drives offer permanent data retention. These storage mechanisms are part of the memory hierarchy, which ranges from the swift but limited cache memory to the expansive but slower secondary storage6.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences Patterson, D. \u0026amp; Hennessy, J. (2014). Computer Organization and Design. Elsevier.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSilberschatz, A., Galvin, P. B., \u0026amp; Gagne, G. (2009). Operating System Concepts. John Wiley \u0026amp; Sons.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A. (2012). Structured Computer Organization. Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBrookshear, J. G. (2011). Computer Science: An Overview. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nJacob, B., Ng, S. W., \u0026amp; Wang, D. T. (2007). Memory Systems: Cache, DRAM, Disk. Morgan Kaufmann.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSiewiorek, D. P. \u0026amp; Swarz, R. S. (2017). Reliable Computer Systems: Design and Evaluation. A K Peters/CRC Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1694563200,"headings":[{"anchor":"memory-and-storage-the-sanctuaries-of-data","title":"Memory and Storage: the sanctuaries of data"},{"anchor":"references","title":"References"},{"anchor":"the-binary-system-decoding-the-language-of-machines","title":"The binary system: decoding the language of machines"}],"kind":"page","lang":"en","series":["Programming"],"summary":"In today's digital age, where electronic gadgets seamlessly integrate into our daily lives, understanding the bedrock upon which these marvels stand becomes not just an academic interest but a societal necessity. As we embark on this enlightening voyage into the heart of computers, we aim to demystify the intricate dance between the physical and the abstract, between the tangible hardware and the intangible software.","tags":["intro","programming","computer","hardware","software","cpu","memory"],"title":"The essence of computers","url":"/en/programming/0100-intro/0101-computers/","year":"2023"},{"content":"","date":1693612800,"headings":[],"kind":"section","lang":"en","summary":"","title":"Blog","url":"/en/blog/","year":"2023"},{"content":"","date":1693612800,"headings":[],"kind":"term","lang":"en","summary":"","title":"cd","url":"/en/tags/cd/","year":"2023"},{"authors":["Julián Nonino"],"content":"Continuous Delivery (CD) is deeply rooted in the first principle of the Agile Manifesto posted in 20011:\nOur highest priority is to satisfy the customer through early and continuous delivery of valuable software.\nAccording to Martin Fowler2, a project is truly embracing Continuous Delivery when:\nThe software can be deployed at any stage of its lifecycle. The team values keeping the software deployment-ready over adding new features. Any software version can be deployed to any environment on-demand. In many ways, Continuous Delivery is the next step from Continuous Integration, seamlessly automating processes all the way to the software\u0026rsquo;s end user.\nMuch like in Continuous Integration, the pipeline stands as the cornerstone of Continuous Delivery. However, it\u0026rsquo;s not just about integrating code, testing it, and generating a deliverable artifact. With CD, this artifact progresses through a series of test phases in environments that increasingly resemble production settings. After passing through the Continuous Integration pipeline, what emerges is a potentially deployable artifact. CD then takes this artifact and puts it through the necessary tests, ensuring it\u0026rsquo;s primed for a live deployment.\nThe delivery process The following figure illustrates the fundamental steps of a Continuous Delivery (CD) process. It\u0026rsquo;s vital to note that an effective CD process presupposes a well-oiled Continuous Integration (CI) system as its foundation.\nFigure 1: CD process flowchart\nThe CD process adds two distinct phases to the CI system: deployment stages and system validation and verification testing. A critical premise is that the deployment process is paramount to product delivery. Thus, automating and frequently testing it is essential. Ideally, testing should also be automated to facilitate execution, especially if you aim for Continuous Deployment. However, it\u0026rsquo;s not imperative to automate all tests, especially at the beginning of the CD process implementation.\nUpon creating a potentially deliverable artifact in the CI pipeline, the initial step is to deploy it in a testing or QA environment. The primary goal of this environment is to offer a space where software tests, both automatic and manual, can be run. The only possible variations between the QA and actual production environment (the one used by customers) may pertain to its capacity or resource size. This scaled-down capacity, whether in processing, memory, storage, or database size, is typically a cost-saving measure.\nIf system and acceptance tests are successful in the QA environment, the next phase is to deploy the artifact in a staging environment. This environment should be an exact replica of the production setting. Its purpose is to facilitate performance and load testing on the system, effectively putting it under stress to validate its functionality under high loads and assess its processing and response times.\nWhen the previous tests are satisfactory, the artifact is ready to be deployed in a production environment. This space is also referred to as the live environment, where users interact with the system.\nAs evident, the product deployment method is exercised at least twice before the final production deployment, considerably reducing risks associated with potential errors as the final delivery approaches.\nCore principles and practices One of CD\u0026rsquo;s primary objectives is to boost delivery frequency. This naturally means that each release should minimize its size. A smaller delivery not only implies fewer potential errors but also facilitates their identification and resolution2. To achieve this, the code must always be in a deploy-ready state.\nRapid automated testing is crucial for today\u0026rsquo;s software development3. In the context of CD, automated tests are of utmost importance as they must ensure comprehensive system quality without hampering the delivery cycle\u0026rsquo;s speed4. Lengthy test runs force the team to await results, leading to wasted time3. If these tests aren\u0026rsquo;t parallelized and optimized, developers may start sidelining them5. To ensure test optimization, it\u0026rsquo;s recommended to fail tests that exceed a reasonable limit6.\nThe software should always be potentially deliverable. It\u0026rsquo;s essential for the software\u0026rsquo;s build status to remain \u0026lsquo;green\u0026rsquo; consistently. This means if a new repository commit breaks the build, this error must be rectified before any new commit is made. Adhering to this practice simplifies error tracing, while deviating may condition developers to overlook a broken or \u0026lsquo;red\u0026rsquo; build6. Broken builds signify product flaws and render it undeliverable.\nIn using CD, the aim is to ensure each commit results in a production-ready artifact. If this artifact is rebuilt at every process stage, there\u0026rsquo;s no guarantee of their identical nature, and validation and verification test results from one artifact cannot be applied to others. This could lead to deploying untested artifacts6. Hence, artifacts should be produced only once and undergo all tests on that single artifact before deploying that very software piece to production.\nSoftware should always be deployed identically across all environments. Otherwise, there\u0026rsquo;s no assurance of the deployment process\u0026rsquo;s efficacy. If environment differences exist, they should be managed using configuration files, but the deployment process should remain consistent6.\nDeployment should be achievable with a mere button press. The ability to deploy the latest product version anytime with a single button press is a robust indicator of CD implementation2. This not only requires the aforementioned steps but also mandates version-controlled software deployment scripts that are regularly checked and validated6.\nAs mentioned earlier, CD\u0026rsquo;s main objective is to ascertain the product\u0026rsquo;s readiness post each commit2. For this, aside from ensuring a swift compilation and testing process, process outcomes should be visible and shared with the team. Display screens showcasing the current status, build times, test coverage, and more, offer a way to maintain constant visibility6. Presenting these results not only supports CD but, as some authors suggest, also bolsters team motivation4.\nBenefits of Continuous Delivery With the rise of Continuous Delivery (CD) practices, businesses are realizing numerous advantages:\nSwift value delivery: the adoption of CD practices facilitates a faster rollout of features and error rectifications to end users7. This speed is attributed to the code becoming potentially deployable to users as it traverses through the Continuous Integration (CI) pipeline4.\nDiminished delivery failures: frequent releases lead to fewer delivery risks since each release embodies fewer changes. This, in turn, means there\u0026rsquo;s a reduced margin for errors2. Even if an error emerges, its origin is easier to trace and correct. Plus, reverting to a previous version in the face of complications becomes straightforward8. A delightful byproduct of this streamlined process is the diminished stress levels amongst stakeholders7 5. Furthermore, the consistency and quality in the delivery process cement trust between the development team and clients7.\nProductivity amplification: Chen\u0026rsquo;s study reveals that, in the absence of CD practices, teams spent nearly \\(20%\\) of their time setting up and maintaining environments7. The introduction of CD automates this ordeal, which translates to heightened productivity by phasing out manual, non-value-add tasks6.\nPrompt feedback: a consensus among experts highlights the value of early feedback during the development phase2 7 4. Regular releases not only fetch this feedback promptly but also ensure that the developed product aligns seamlessly with customer requirements2. The agility to swiftly address customer needs, fix reported bugs, and introduce demanded features can significantly elevate customer satisfaction4.\nEnhanced software quality: the rigorous automation of software tests (unit, integration, and system), essential for implementing CD, combined with more frequent software deliveries encapsulating fewer changes, culminates in a notable boost in software quality4.\nTransparency in progress: thanks to frequent releases, clients find it easier to stay abreast of the latest product updates, embracing novel features and bug fixes with open arms.\nChallenges in adopting Continuous Delivery The journey to incorporate Continuous Delivery (CD) isn’t without its hurdles. Here\u0026rsquo;s a look at some of the key challenges faced by businesses:\nProduct complexity: certain products consist of myriad interconnected modules or possess dependencies with other projects. This can create bottlenecks when automating CD pipelines4. Such complexities might frustrate teams, pushing them to retain manual processes or longer integration procedures.\nTest suite creation: crafting a comprehensive test suite to ensure product quality is labour-intensive. All team members must allocate significant time to pen tests, which might require extra training. Besides, tests can be time-consuming, so the trick lies in devising effective yet swift tests4.\nLegacy code: systems that have been in development for an extended period and weren\u0026rsquo;t designed with automated testing in mind can pose a significant challenge. Transitioning such systems to CD is not only a technical endeavour but also a social and cultural shift4.\nEnvironmental discrepancies: all environments in the CI pipeline should mirror the production setting (\u0026lsquo;production-like\u0026rsquo;)6. If not, unforeseen errors can arise, demanding valuable time on non-value-add tasks4. Ensuring multiple deployment stages in similar environments means that the deployment process is tested repetitively.\nClient restrictions: not every client might desire or require a shortened product delivery cycle4. Such client limitations aren\u0026rsquo;t direct obstacles to CD implementation but play a pivotal role when aiming for Continuous Deployment. This could potentially sideline some CD benefits, like swift client feedback or minimal change deliveries. Moreover, the domain itself can act as a bottleneck. Software related to heavily-regulated sectors like healthcare and defence may find CD implementation challenging, if not nearly impossible4.\nTransparency and reporting: a successful CD adoption hinges on collaboration and transparency, introducing challenges tied to providing effective status reports to stakeholders9. This encompasses technical hurdles around automated report generation and analytics challenges to pinpoint essential information.\nResistance to change: any transformative change, like adopting CD, faces the innate human trait of resistance. Convincing the team to adapt to new practices and modify their workflow is a task. On a higher level, management might also be hesitant to experiment with fresh processes.\nContinuous Deployment The notion of Continuous Deployment was popularized by Fitz10. The standout distinction between this method and Continuous Delivery (CD) is that, once the product is deemed ready for release, there\u0026rsquo;s no waiting for manual intervention to launch it into production11 6. If CD is properly executed, the step towards Continuous Deployment should demand no extra efforts from the development perspective8. In essence, the core difference lies in decision-making: with CD, releasing the product to production remains a business decision, whereas with Continuous Deployment, the launch is automated.\nIt\u0026rsquo;s worth noting that when we discuss CD, it inherently includes Continuous Delivery but may or may not encompass Continuous Deployment.\nReferences Beck, Kent, Mike Beedle, Arie van Bennekum, Alistair Cockburn, Ward Cunningham, Martin Fowler, James Grenning, Jim Highsmith, Andrew Hunt, Ron Jeffries, Jon Kern, Brian Marick, Robert C. Martin, Steve Mellor, Ken Schwaber, Jeff Sutherland, and Dave Thomas. Manifesto for Agile Software Development, 2001.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, Martin. Continuous Delivery, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUdd, Raoul. Adopting Continuous Delivery: A Case Study, 2016.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLeppanen, Marko, Simo Makinen, Max Pagels, Veli-Pekka Eloranta, Juha Itkonen, Mika V. Mantyla, and Tomi Mannisto. The highways and country roads to continuous deployment. IEEE Software, 32(2):64-72, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNeely, Steve, and Steve Stolt. Continuous delivery? Easy! Just change everything (well, maybe it is not that easy). Proceedings - AGILE 2013, pp.121-128, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez, and David Farley. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChen, Lianping. Continuous Delivery: Huge Benefits, but Challenges Too. IEEE Software, 32(2):50-54, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez. Continuous Delivery vs Continuous Deployment, 2010.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOlsson, Helena Holmstrom, Hiva Alahyari, and Jan Bosch. Climbing the \u0026ldquo;Stairway to Heaven\u0026rdquo; \u0026ndash; A Multiple-Case Study Exploring Barriers in the Transition from Agile Development towards Continuous Deployment of Software. 2012 38th Euromicro Conference on Software Engineering and Advanced Applications, pp.392-399, 2012.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFitz, Timothy. Continuous Deployment, 2009.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPulkkinen, Ville. Continuous Deployment of Software. Proceedings of Cloud-Based Software Engineering, pp.46-52, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1693612800,"headings":[{"anchor":"benefits-of-continuous-delivery","title":"Benefits of Continuous Delivery"},{"anchor":"challenges-in-adopting-continuous-delivery","title":"Challenges in adopting Continuous Delivery"},{"anchor":"continuous-deployment","title":"Continuous Deployment"},{"anchor":"core-principles-and-practices","title":"Core principles and practices"},{"anchor":"references","title":"References"},{"anchor":"the-delivery-process","title":"The delivery process"}],"kind":"page","lang":"en","summary":"Here you can find information about Continuous Delivery, what is it, which benefits can you expect from it, the challenges you might face trying to adopted and so on.","tags":["cd","continuous-delivery","continuous-deployment"],"title":"Continuous Delivery","url":"/en/blog/2023/09/continuous-delivery/","year":"2023"},{"content":"","date":1693612800,"headings":[],"kind":"term","lang":"en","summary":"","title":"continuous-delivery","url":"/en/tags/continuous-delivery/","year":"2023"},{"content":"","date":1693612800,"headings":[],"kind":"term","lang":"en","summary":"","title":"continuous-deployment","url":"/en/tags/continuous-deployment/","year":"2023"},{"content":"","date":1692403200,"headings":[],"kind":"term","lang":"en","summary":"","title":"ci","url":"/en/tags/ci/","year":"2023"},{"authors":["Julián Nonino"],"content":"One of the most pivotal challenges in the realm of software development is effectively integrating changes 1. In a small-scale project steered by a single developer, this challenge might appear to be trivial. However, as the magnitude of the project escalates and more individuals join the development fold, the significance of seamless integration becomes paramount.\nHistorically, integration was often an afterthought, relegated to the tail end of the software development process 2. Postponing it to such a late stage not only amplifies the risk of complex, undetected errors but also heightens the tension as delivery dates loom.\nHowever, the paradigm shifted around the turn of the millennium. Continuous Integration (CI) was formally introduced in 2000 by Kent Beck as an intrinsic part of the \u0026lsquo;Extreme Programming\u0026rsquo; methodology 3. CI emphasizes the frequent and early-stage integration of code. By continuously amalgamating new code into the system, developers can gauge its impact promptly. This approach streamlines error detection, enabling developers to tackle issues as they emerge 2. The ability to tie an error to a specific code change reduces error complexity and promotes efficient troubleshooting. Today, CI has become an indispensable practice in software development projects 4.\nMartin Fowler, a luminary in the field, eloquently defined CI as:\nContinuous Integration is a software development practice where team members integrate their work frequently, typically multiple times a day. Each integration is verified by an automated build system that runs test suites to swiftly detect any integration anomalies. Teams adopting this methodology often witness a significant reduction in integration hiccups, empowering them to produce cohesive software at an accelerated pace2.\nBuilding upon Fowler’s definition, Duvall 5 underscored several vital facets:\nDevelopers must maintain a conducive local environment for code construction and testing, ensuring their updates do not disrupt the established integration. Team members should commit their code to the Version Control System (VCS) daily. The integration process must be undertaken on a distinct machine, aptly termed the CI server. Only builds that pass all tests can be deemed deliverable. Error resolution is of paramount importance. A central repository displaying build and test results—often a website—is essential. Most CI tools readily offer such platforms. Furthermore, Patrick Cauldwell 6 advocates for frequent and early integration. The rationale? The more regular the integration, the less overhead for the team down the line. He distilled the primary goals of CI into:\nEnsuring a consistently available, tested version of the product with the latest modifications. Keeping the team abreast of any integration issues as early as possible. The impetus behind CI is to maintain an error-free, tested product throughout the development life cycle. This avoids the pitfalls of a last-minute integration phase, which is often fraught with errors and consumes both time and resources. More crucially, if project components aren\u0026rsquo;t integrated during their development, there\u0026rsquo;s no guarantee they\u0026rsquo;ll gel cohesively in the final product 7.\nTechnical implementation of CI revolves around two core components: process automation and a system to showcase results, thereby fuelling the developmental feedback loop 7.\nIn summing up the tenets of CI, Martin Fowler 1 emphasizes:\nRetaining code in a singular repository. Streamlining software construction through automation. Implementing automated testing processes. Ensuring new code additions undergo integration and construction on the CI system\u0026rsquo;s machine. Keeping the build process agile and swift. Providing easy access to the product\u0026rsquo;s latest executable version. Ensuring product status transparency for all stakeholders. Elements of a CI system A basic Continuous Integration (CI) pipeline initiates when a new code change is pushed to the repository. The CI server, linked to the repository, gets notified of every new change, subsequently downloading the latest version to initiate the integration process, which will be elaborated on in the subsequent section. Once completed, it communicates the system\u0026rsquo;s status to the team members.\nIn computer science, a \u0026ldquo;pipeline\u0026rdquo; refers to a sequence of processes or tasks linked such that the output of one becomes the input for the next.\nFigure 1: Basic elements of CI (Duvall5)\nThe system\u0026rsquo;s primary component consists of the developers. After making code modifications, they run tests locally and compile the code to ensure that they haven\u0026rsquo;t introduced new errors.\nAn essential part of every CI system is the Version Control System (VCS). It oversees the changes made to the code and other significant elements. This system establishes a unified access point for all source code, enabling the CI system to fetch the most recent version for integration. Most software development projects utilize a VCS even if they don\u0026rsquo;t implement CI processes.\nThe CI Server is responsible for initiating a new build (comprising both compilation and tests) every time a change is added to the repository. They offer configurations to simplify the creation of integration pipelines. Additionally, most come with a web interface to display the build status and previous results. Currently, numerous powerful options are available, both free and paid. It\u0026rsquo;s worth noting that the CI server should operate on a dedicated machine and not on team members\u0026rsquo; computers.\nThe CI server must automatically conduct software tests, source code analysis, and compile to produce the deliverable product. Therefore, build and test execution scripts are vital. These scripts outline the necessary steps to be executed. Popular tools for this purpose include Make, Ant, Maven, Gradle, among others.\nEvery CI system should have a notification mechanism to relay results to the team. This mechanism ensures that in the event of an error, the team becomes aware as soon as possible, enabling them to address the issue. While most CI tools offer a web interface to view results, they also support other notification methods like emails, messaging applications, etc.\nThe integration process The figure below broadly illustrates the stages of the integration process taking place within the Continuous Integration (CI) system.\nFigure 2: CI process flowchart\nInitially, the system must retrieve the latest source code version each time a new change is pushed to the Version Control System (VCS). Two mechanisms facilitate this. The first involves setting up the CI server to periodically check the VCS for updates. The alternative is to establish a commit hook within the VCS, ensuring that the CI server receives notifications whenever changes are made.\nAfter obtaining the code, the CI server can be configured to scrutinize the source code for potential undetected errors, be they syntactic, logical, or patterns that might lead to faults. Various tools aid this process. For instance, Java boasts utilities like FindBugs, CheckStyle, and PMD, while Python has Pylint. JavaScript can be analysed with tools like JSLint or JSHint. An example of a code analysis criterion could be ensuring every developed method has a cyclomatic complexity8 under 10. By employing automated source code inspection, one can assess code correctness, spot duplicate portions, and expedite the time between error detection and rectification. While automated inspection might not catch every error, the results can approximate those of peer reviews, thereby lightening the team\u0026rsquo;s review load.\nThe subsequent step revolves around automated test execution on the product. This automation is paramount to successfully implementing a CI system. Thus, developers can confidently make alterations, knowing a robust testing framework safeguards against compromising existing functionalities. Some popular tools in this domain include Junit, JBehave, and Selenium, which not only facilitate test drafting but also generate comprehensive reports, often as visualizations or web pages. Several software testing levels exist, such as unit tests, integration tests, and system tests. In the CI pipeline context, the focus rests on automating unit and integration tests, with system tests\u0026rsquo; automation being recommended but not mandatory.\nOnce the tests pass, the CI pipeline advances to compiling the source code. During this phase, the source code morphs into one or multiple files or packages, ready for distribution and user execution. This process\u0026rsquo;s specifics hinge on the employed programming language. For instance, languages like Java necessitate code compilation, resulting in an executable. Conversely, languages like Python might involve stricter code structure checks without generating any binary files.\nThroughout this integration journey, the team should steadfastly adhere to three fundamental rules:\nLocally run tests and compile software before integrating it into the VCS to minimize error introduction chances (avoiding \u0026ldquo;breaking the build\u0026rdquo;). Avoid pushing new code to the VCS if the CI server flags errors (indicative of a \u0026ldquo;broken build\u0026rdquo;). Should the CI server report faults, code modifications should exclusively aim at rectifying them. Core principles and practices Martin Fowler2 identifies a set of foundational elements intrinsic to every Continuous Integration (CI) system. While some of these have been touched upon earlier in this chapter, we will succinctly encapsulate them here for clarity:\nCentralized Code Repository: Retain all code within a singular, unified repository. Streamlined Compilation and Build Process: Entirely automate the compilation and construction workflows, negating manual intervention. Full-Spectrum Automated Testing: Ensure all software tests are automated, driving efficiency and precision. Daily Commitment: Encourage the team to consistently merge their changes to the repository on a daily basis. Stringent Integration Checks: Each alteration made to the Version Control System (VCS) undergoes rigorous integration processes within the CI system. Prompt Error Rectification: Should the CI system flag any issues (indicative of a \u0026ldquo;broken build\u0026rdquo;), immediate action is imperative. Either rectify the flaw or reverse the change to ensure the repository\u0026rsquo;s latest version remains operational. Swift CI Procedures: Aim to complete the CI process rapidly—ideally within 15 minutes or less. This approach ensures timely integration and facilitates the expedited delivery of results. Universal Access to Latest Executables: Always provide the team with access to the most recent executable or deliverable package, promoting transparency. Real-time Product Status Visibility: Grant every team member the ability to monitor the product\u0026rsquo;s status at any given moment, fostering informed decision-making. Benefits The overarching consensus within the software community is that the implementation of a Continuous Integration (CI) process yields an array of substantial advantages. Duvall5 outlines these core benefits in his publication.\nRisk Mitigation: Adopting frequent integration minimizes project risks. It facilitates early detection of issues and offers a continuous snapshot of the product\u0026rsquo;s health. By identifying these issues early in the development cycle, there\u0026rsquo;s a consequent reduction in both the cost of fixes and the risk of releasing a subpar product. Furthermore, automated inspections provide real-time insights into the product\u0026rsquo;s size, code complexity, and other metrics. This automation diminishes the chance of human-induced errors.\nMinimization of Manual Repetitive Tasks: Automation curtails the need for recurring manual tasks such as compilation, inspection, test execution, and report generation. This efficiency not only leads to significant time and cost savings but also allows teams to focus on activities that directly enhance product value. It liberates team members to dedicate more time to addressing new requirements or rectifying existing product issues.\nOn-Demand Availability of a Functional Product: A hallmark of CI is its ability to deliver a functional software product at any given moment. This is invaluable for stakeholders, offering them a rapid glance into product development progress. By leveraging CI, errors can be swiftly detected and remedied soon after a new change is introduced. This is far more efficient than uncovering them close to the release date when they are more expensive and challenging to amend. Such issues, if left unchecked, can lead to delivery delays, unsatisfied clients, escalated costs, and more. This ties back to the concept of the \u0026ldquo;Broken Window Theory\u0026rdquo;9, which, in essence, postulates that a product marred by numerous issues or perceived disorder can demotivate teams from addressing them.\nEnhanced Project Transparency: Implementing CI augments visibility into the project, rendering the development process more transparent. It aids project management with up-to-the-minute information, making it straightforward to gauge product quality, error trends, and more.\nElevated Product Confidence: The CI environment bolsters confidence in the product. Team members gain immediate insights into the ramifications of their changes, enabling them to promptly rectify any emergent issues.\nChallenges While Duvall5 has extolled the virtues of Continuous Integration (CI) in his works, he also highlights potential challenges that might deter development teams from embracing it fully or realizing its benefits.\nBias: A widespread misconception is that CI system implementation is exorbitant and would esecalate development costs due to its prolonged setup and maintenance. Contrarily, most software development projects already involve phases like inspection, testing, compilation, and integration, even if they don’t explicitly use a CI system. A common refrain is that there\u0026rsquo;s insufficient time or funds for CI system implementation, but the reality is that far more resources are spent performing redundant manual tasks throughout the development cycle. Furthermore, an automated CI system is infinitely more manageable and consistent compared to disparate manual processes.\nDisruption Fears: Projects in advanced development stages often fret that integrating a CI system would overhaul their established workflows, spawning significant delays. It’s pivotal to recognize that CI system implementation can be incremental. Teams can address one integration stage at a time, gradually ramping up the integration frequency as confidence builds.\nOverwhelming Failed Integrations: When CI practices aren’t diligently applied, there\u0026rsquo;s a risk of encountering an excessive number of failed integrations or \u0026ldquo;broken builds.\u0026rdquo; This could stem from developers bypassing local tests before uploading their changes to the Version Control System (VCS). A surge in failed integrations can erode trust in the CI system, reminiscent of the \u0026ldquo;Broken Window Theory\u0026rdquo;9.\nPerceived Additional Costs: There\u0026rsquo;s an apprehension among organizations about incurring extra expenses either for procuring CI product licenses or securing hardware to support these systems. However, this expenditure pales in comparison to the latent costs of late-stage integrations, where issues are discovered near the release date, far removed from their inception. On a brighter note, the current landscape is rife with a myriad of free and open-source alternatives, obviating any additional costs.\nReferences Continuous integration. ThoughtWorks, 2018.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, Martin. Continuous Integration. 2006.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBeck, Kent. Embrace Change with Extreme Programming. IEEE Computer Magazine, (c), 70-77. 1999.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRodriguez Pilar, Markkula, Jouni, Oivo, Markku, \u0026amp; Turula, Kimmo. Survey on agile and lean usage in Finnish software industry. In Proceedings of the ACM-IEEE international symposium on Empirical software engineering and measurement - ESEM \u0026lsquo;12 (p. 139). ACM Press. DOI: 10.1145/2372251.2372275. 2012.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDuvall, Paul M., Matyas, Steve, \u0026amp; Glover, Andrew. Continuous integration: improving software quality and reducing risk. Pearson Education, Inc., 2007.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCauldwell, Patrick. Code Leader: Using people, tools and processes to build successful software. Wiley Publishing, Inc., 2008.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez \u0026amp; Farley, David. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCyclomatic Complexity Explanation\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe Broken Window Theory in Software Development\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1692403200,"headings":[{"anchor":"benefits","title":"Benefits"},{"anchor":"challenges","title":"Challenges"},{"anchor":"core-principles-and-practices","title":"Core principles and practices"},{"anchor":"elements-of-a-ci-system","title":"Elements of a CI system"},{"anchor":"references","title":"References"},{"anchor":"the-integration-process","title":"The integration process"}],"kind":"page","lang":"en","summary":"What is Continuous Integration? Which benefits it provides? In this article you can find answers to those questions and many more.","tags":["ci","continuous-integration"],"title":"Continuous Integration","url":"/en/blog/2023/08/continuous-integration/","year":"2023"},{"content":"","date":1692403200,"headings":[],"kind":"term","lang":"en","summary":"","title":"continuous-integration","url":"/en/tags/continuous-integration/","year":"2023"},{"content":"","date":1692316800,"headings":[],"kind":"term","lang":"en","summary":"","title":"requirements","url":"/en/tags/requirements/","year":"2023"},{"authors":["Julián Nonino"],"content":"According to Sommerville and Sawyer, a requirement is a statement about an intended product that specifies what it should do or how it should perform1.\nRequirements identify the goals, needs and constraints that the software must address in order to deliver value. They are a form of specification that serve as the foundation for all subsequent software engineering activities.\nSome key definitions of requirements are:\nDescription of how the system should behave. Features that the software needs to deliver. Functionalities that users expect from the software. Statements of business rules that software must comply with. Constraints on development of the software. Requirements convey the intended purpose, context and environment in which the software will operate. They express the underlying motivations for why the software needs to be built by identifying problems faced by users or organization.\nAs Wiegers puts it, requirements describe the inner and outer capabilities, characteristics, and qualities that the product must have or perform well to satisfy all aspects of the product vision2.\nWhat should requirements define? Good requirements provide a complete description of what the software will do, without dealing with how it will be implemented.\nSome key aspects that requirements should define are:\nUser capabilities: what can users do with the system? e.g. login, search, make payment etc. Operational workflows: how does system interact with users and external systems? e.g. order processing workflow. Business rules: what policies and rules does system need to comply with? e.g. credit limits. Integration touch points: how does system integrate with other systems? e.g. payment gateway APIs. Quality attributes: what non-functional qualities are important? e.g. security, availability. External interfaces: how does system interact with external actors? e.g. device interfaces. Environment conditions: what environmental constraints are present? e.g. operating system. Design/architectural constraints: are there constraints on design choices? e.g. use cloud infrastructure. Documenting these aspects ensures requirements provide a good view into the problem space and what the software solution needs to achieve.\nProperties of good requirements High quality requirements exhibit certain desired characteristics:\nComplete: requirements capture the full capabilities needed without any gaps. Correct: requirements precisely represent genuine user needs. Feasible: requirements can be reasonably implemented within constraints. Unambiguous: requirements have clear meaning that is open to only one interpretation. Consistent: there are no conflicts or contradictions between requirements. Prioritized: importance and urgency is indicated to guide implementation. Verifiable: requirements can be validated via concrete acceptance criteria. Traceable: origin of each requirement is clear for analysis. Atomic: requirements define one need instead of multiple combined needs. Implementation free: requirements avoid implementation choices or design details. Adhering to these qualities results in a strong set of requirements that serve as a solid foundation for the software design and development.\nLevels of requirements Requirements are defined at different levels of abstraction and detail. Requirements evolve from high-level needs to detailed specifications through this hierarchical breakdown.\nBusiness requirements These capture high-level needs related to business objectives, problems and outcomes the software should achieve. They are written using terminology familiar to business users. Examples include:\nImprove customer retention by 10%. Reduce operational costs by optimizing order processing. Enable omni-channel order fulfillment. User requirements These describe the needs and wishes of end-users related to functionality and quality. They capture who, what, where, when and why of user interactions. Examples:\nUser shall be able to place orders 24/7 via website. System shall provide real-time order status tracking. User shall be able to save payment information securely. System requirements These describe the detailed behaviours, operations, capabilities and business rules the system needs to implement. Or, impose quality constraints, performance needs and other attributes on the system. Examples:\nSystem shall verify customer identity before accepting order. User shall be able to filter orders by date, status, amount, etc. System shall interface with the inventory system to validate product availability. System must have a uptime of 99.95%. Page response time must be under 100 ms for 90% of requests. System must store customer data encrypted at rest. Types of requirements There are two main types of requirements:\nFunctional requirements These describe the specific behaviours and operations that the system needs to perform in order to accomplish the intended purpose. Functional requirements depend heavily on the type of software being developed. Some examples of functional requirements are:\nThe system shall allow users to sign in using their email address and password. The system shall allow admins to add new user accounts. The system shall allow managers to generate sales reports by region. The system shall integrate with PayPal to accept payments. Non-functional requirements Non-functional requirements specify quality attributes and constraints that software must meet. They impose restrictions on how the system performs its functions. Examples of non-functional requirements:\nThe system shall have an uptime of 99.95%. The system shall support up to 100 concurrent active users. User passwords must be stored in encrypted format. The website shall work on mobile and desktop browsers. In turn, non-functional requirements can be divided into the following categories. Covering relevant categories of non-functional needs results in a comprehensive set of quality requirements.\nProduct Requirements These relate to quality characteristics of the software itself. Types include:\nUsability: how easy is it for users to learn and operate the system? Performance: response times, throughput, resource usage, scalability targets, etc. Security: access control, encryption, vulnerability prevention, etc. Availability: uptime, reliability, disaster recovery needs, etc. Maintainability: ability to make changes, add new features, repair defects, etc. Portability: ability to work across different environments and platforms. Organizational Requirements These relate to business, process and compliance needs of the organization. Types include:\nDelivery: schedule, release planning, milestones to be met. Legal: regulations, policies, standards that must be complied with. Data: data formats, retention periods, reporting needs, etc. Process: integration with organizational workflows, change management, etc. Operational: server environments, infrastructure standards, monitoring needs, etc. External Requirements These relate to integration with external systems and end user environments. Types include:\nInterfaces: protocols, APIs, formats for exchanging data. Interoperability: ability to integrate with other systems as needed. Hardware: support for client hardware like scanners, handhelds, etc. Platform: compatibility with end user operating systems. Software Requirements Specification (SRS) The Software Requirements Specification (SRS) is the official document that captures the complete set of requirements for the system in detail. It is treated as the contract between customers and developers.\nAccording to IEEE, the SRS can be defined as a document that describes all data, functional and behavioural requirements; analyzes, specifies, and validates the system requirements3.\nSome key purposes that the SRS serves are:\nFormally documents the requirements agreed upon by stakeholders. Serves as reference for planning, estimating and tracking the project. Reduces ambiguity by recording details about requirements. Serves as basis for design, development and testing activities. Facilitates communication and consensus between teams. Becomes basis for verification and validation. Evolves into system tests, user manuals, etc. The main users of the SRS document are:\nCustomers: clarify needs, review and approve requirements. Managers: estimate effort, plan activities, track progress. Architects: analyze requirements to design solutions. Developers: understand detailed needs to implement. Testers: derive test conditions and test cases. Technical Writers: use it as foundation for user manuals. A typical SRS is organized into the following sections:\nIntroduction: purpose, scope, definitions, acronyms, references. User Requirements: capabilities, user characteristics, constraints. Functional Requirements: functionalities, operations, business rules. Non-functional Requirements: qualities, performance, attributes. External Interface Requirements: interactions with other systems, devices, etc. Other Requirements: licensing, compliance, platform, deliverables. Appendix: diagrams, analysis models, schema definitions. The SRS maintains traceability between stakeholder needs, requirements specification and system design. This enables tracking of requirements throughout the product lifecycle.\nNotations for documenting requirements Textual description is the most common way of documenting requirements in the SRS. However, visual models and formal notations can also be used to express specific aspects precisely. Here there are different ways of expressing software requirements.\nUser stories: used in agile methods to capture user requirements. Written as \u0026ldquo;As a , I want so that \u0026rdquo;. Use cases: describe interactions between users and the system to achieve a goal. Data models: express structure of data as entities, attributes, relationships etc. e.g. ER diagrams. Behaviour models: represent dynamic behaviour and workflows e.g. state machine diagrams, activity diagrams. Interface models: specify external interfaces using API blueprints, protocol specs, etc. Supplementary specifications: detailed non-functional specs e.g. security standards, compliance rules. Choosing appropriate techniques allows capturing complete details in an unambiguous manner. The textual SRS can reference these as needed.\nEliciting and analysing requirements Requirements come from analysing the needs of various stakeholders. Typical steps are:\nStakeholder identification: identify various stakeholders - end users, business managers, operations team, etc. Requirements gathering: gather needs via interviews, observation, focus groups, workshops, surveys, etc. Requirements gathering relies heavily on techniques like prototyping, scenario analysis, domain modelling and qualitative user research. Requirements analysis: analyze requirements for clarity, conflicts and prioritization. Requirements documentation: document requirements, review with stakeholders and baseline. Requirements validation: validate requirements to ensure consistency, completeness, technical feasibility, etc. Requirements management: manage changes through proper change control processes. According to Davis, requirements management is critical for aligning software capabilities with business objectives throughout the product lifecycle4. Challenges Some key challenges faced in requirements engineering are:\nIncomplete, unclear and ambiguous requirements. Infeasible requirements beyond project constraints. Conflicting stakeholder needs and priorities. Frequent requirement changes leading to scope creep. Missing key details and assumptions. Lack of customer availability and engagement. Users not knowing what they need. Weak change management discipline. Communication gaps across customer and development teams. According to Christel and Kang, requirements elicitation is a complex activity due to factors like vague customer needs, lack of user involvement and staggered feedback5. Using proven elicitation techniques, sound documentation practices, rigorous analysis and reviews, and disciplined change management helps tackle these challenges.\nEmerging Trends Some key trends shaping the future of requirements engineering:\nIncreased end user involvement through prototyping and crowdsourcing. Growing use of iterative approaches to allow for emergent requirements. Greater reliance on product managers as customer proxies. Increased adoption of agile user stories over traditional SRS docs. Enhanced traceability through modelling and automation. Integration with design models and testing to realize \u0026ldquo;single source of truth\u0026rdquo;. Introducing requirements management tools for collaboration. Leveraging AI techniques for analysing and deriving complex requirements. Focus on continuously capturing and refining requirements throughout product lifecycle. According to Nuseibeh and Easterbrook, requirements engineering will need to adapt to factors like faster delivery cycles, evolving design approaches and increased automation6.\nConclusion Defining complete, correct requirements that accurately capture end user and business needs is essential to delivering effective software solutions. Requirements engineering done right lays the foundation for developing a product that delivers maximum value. Applying sound specification techniques, following collaborative elicitation processes, documenting requirements clearly, and managing changing needs systematically are key disciplines that lead to high quality software products that meet customer expectations.\nReferences Sommerville, Ian, and Pete Sawyer. Requirements engineering: a good practice guide. John Wiley \u0026amp; Sons, Inc., 1997.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKarl E. Wiegers, and Joy Beatty. Software requirements. Pearson Education, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIEEE. IEEE Guide for Developing System Requirements Specifications. IEEE Std 1233, 1998 edition.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nA. M. Davis. Just enough requirements management: where software development meets marketing. Dorset House Publishing Co., Inc., 2005.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChristel, Michael G., and Kyo C. Kang. Issues in requirements elicitation. Carnegie Mellon University, 1992.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNuseibeh, Bashar, and Steve Easterbrook. \u0026ldquo;Requirements engineering: a roadmap.\u0026rdquo; Proceedings of the Conference on the Future of Software Engineering. 2000.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1692316800,"headings":[{"anchor":"business-requirements","title":"Business requirements"},{"anchor":"challenges","title":"Challenges"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"eliciting-and-analysing-requirements","title":"Eliciting and analysing requirements"},{"anchor":"emerging-trends","title":"Emerging Trends"},{"anchor":"external-requirements","title":"External Requirements"},{"anchor":"functional-requirements","title":"Functional requirements"},{"anchor":"levels-of-requirements","title":"Levels of requirements"},{"anchor":"non-functional-requirements","title":"Non-functional requirements"},{"anchor":"notations-for-documenting-requirements","title":"Notations for documenting requirements"},{"anchor":"organizational-requirements","title":"Organizational Requirements"},{"anchor":"product-requirements","title":"Product Requirements"},{"anchor":"properties-of-good-requirements","title":"Properties of good requirements"},{"anchor":"references","title":"References"},{"anchor":"software-requirements-specification-srs","title":"Software Requirements Specification (SRS)"},{"anchor":"system-requirements","title":"System requirements"},{"anchor":"types-of-requirements","title":"Types of requirements"},{"anchor":"user-requirements","title":"User requirements"},{"anchor":"what-should-requirements-define","title":"What should requirements define?"}],"kind":"page","lang":"en","series":["Software Engineering"],"summary":"Requirements engineering is the process of defining, documenting and maintaining requirements for a software system. It is the first and foundational stage in the software development lifecycle. Requirements express the needs and constraints that the software must satisfy in order to solve problems and provide value to users and the business. Let's get started understanding the basics of requirements in software projects.","tags":["software-engineering","requirements","srs"],"title":"Requirements Engineering","url":"/en/software-engineering/0300-requirements-engineering/01-requirements-engineering/","year":"2023"},{"content":"","date":1692316800,"headings":[],"kind":"term","lang":"en","summary":"","title":"Software Engineering","url":"/en/series/software-engineering/","year":"2023"},{"content":"Welcome to this exclusive series of articles that make up a comprehensive course on Software Engineering. From theoretical roots to contemporary practices, this collection has been meticulously crafted to provide readers with a deep and practical understanding of the various facets of Software Engineering.\nWhether you\u0026rsquo;re a student eager to dive into the fundamentals, a professional looking to refresh your knowledge, or simply someone curious about the magic behind software development, this collection will guide you step by step. Through each article, we will explore key concepts, emerging techniques, essential tools, and best practices that define our industry today.\nWe invite you to embark on this educational journey. Each article is a lesson in itself, designed to offer you a rich learning experience applicable in the real world. Prepare to immerse yourself in the captivating discipline of Software Engineering and discover the methodologies and tools that shape the digital world around us.\n","date":1692316800,"headings":[],"kind":"section","lang":"en","summary":"Welcome to this exclusive series of articles that make up a comprehensive course on Software Engineering. From theoretical roots to contemporary practices, this collection has been meticulously crafted to provide readers with a deep and practical understanding of the various facets of Software Engineering.\nWhether you’re a student eager to dive into the fundamentals, a professional looking to refresh your knowledge, or simply someone curious about the magic behind software development, this collection will guide you step by step.","title":"Software Engineering","url":"/en/software-engineering/","year":"2023"},{"content":"","date":1692316800,"headings":[],"kind":"term","lang":"en","summary":"","title":"software-engineering","url":"/en/tags/software-engineering/","year":"2023"},{"content":"","date":1692316800,"headings":[],"kind":"term","lang":"en","summary":"","title":"srs","url":"/en/tags/srs/","year":"2023"},{"authors":["Julián Nonino"],"content":"What is Software? Several thought leaders in the world of computing have defined software in various ways:\nIan Sommerville1: Computer programs and associated documentation.\nRoger S. Pressman2: A collection of computer programs, procedures, rules, and associated documentation and data.\nAndrew S. Tanenbaum3: A series of instructions that tells a computer what to do.\nGrady Booch4: Set of items or objects that form a configuration that includes programs, documents, and data.\nPeter Denning5: Map of a machine, detailing its possible states, transitions, and the actions for these transitions.\nAnalysing these definitions, common themes emerge: software encompasses instructions, data, associated documentation, and serves as a guiding structure for computer operations. So we can conclude:\nSoftware is a meticulously structured collection of programs, data, and documentation that serves as a guiding blueprint, directing a computer\u0026rsquo;s operations and interactions with users and other systems.\nAlthough we can classify software in many different types, each with its specific function, we can define three primary categories:\nSystem Software: This forms the core of a computer\u0026rsquo;s operation. It includes operating systems like Windows, Linux, and macOS, which manage hardware resources and provide services for application software. Application Software: Tailored for end-users to perform specific tasks, this category ranges from word processors (like Microsoft Word) to graphic design tools (like Adobe Photoshop) and games. Embedded Software: Found within hardware devices such as washing machines, traffic lights, or digital watches, embedded software operates specific functions of these devices. Unlike general-purpose software, it\u0026rsquo;s dedicated to specific tasks or functions. What is Software Engineering? Several prominent figures have also provided their perspectives on Software Engineering:\nIan Sommerville1: A discipline concerned with all aspects of software production.\nRoger S. Pressman2: Establishment and use of sound engineering principles to obtain economically software that is reliable and works efficiently on real machines.\nFrederick P. Brooks6: The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software.\nBarry W. Boehm7: Aims to produce quality software, software that is delivered on time, within budget, and that satisfies its requirements.\nFritz Bauer8: The establishment and use of sound engineering principles to economically obtain software that is reliable and works on real machines.\nFrom these definitions, we can discern that software engineering integrates principles of engineering, emphasizes systematic methods, seeks reliability and efficiency, and aims for the production of high-quality software that meets its specified requirements. Concluding that\nSoftware Engineering is the disciplined application of engineering principles and systematic methods to design, develop, and maintain reliable and efficient software that economically meets specified requirements and user needs.\nSoftware Engineering should not be confused with Computer Science. While the latter is a discipline that dives deep into the theoretical and mathematical aspects of computing, studying algorithms, computational theory, and more, the first one primarily focuses on designing and building large software systems. It emphasizes practical techniques and methodologies that ensure the production of high-quality, maintainable software.\nWhy it is important to develop quality software Today, we\u0026rsquo;re surrounded by a digital ecosystem. Software runs our phones, cars, banks, hospitals, and even our homes. This ubiquity underscores its significance. That means that software flaws can have catastrophic outcomes. From banking systems to healthcare applications, the demand for faultless, efficient software is sky-high.\nSoftware Engineering, ensures this vast amount of software is reliable, efficient, and meets user needs. As technology advances at breakneck speed, the role of software engineers becomes even more pivotal, making sure innovations are safe and effective.\nWhether you\u0026rsquo;re using a social media app, making a bank transaction, or checking health diagnostics, remember there\u0026rsquo;s a meticulously engineered software system running behind the scenes, making it all possible.\nReferences Sommerville, I., 2010. Software Engineering. 9th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPressman, R.S., 2010. Software Engineering: A Practitioner\u0026rsquo;s Approach. 7th ed. McGraw-Hill.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A.S., 2012. Structured Computer Organization. 6th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBooch, G., 2007. Object-Oriented Analysis and Design with Applications. 3rd ed. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDenning, P.J., 2009. The Profession of IT, Beyond Computational Thinking. Communications of the ACM, 52(6).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBrooks, F.P., 1995. The Mythical Man-Month: Essays on Software Engineering. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBoehm, B.W., 1988. A Spiral Model of Software Development and Enhancement. Computer, 21(5).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBauer, F.L., 1972. Software Engineering. Information Processing, 71.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1691625600,"headings":[{"anchor":"references","title":"References"},{"anchor":"what-is-software","title":"What is Software?"},{"anchor":"what-is-software-engineering","title":"What is Software Engineering?"},{"anchor":"why-it-is-important-to-develop-quality-software","title":"Why it is important to develop quality software"}],"kind":"page","lang":"en","series":["Software Engineering"],"summary":"In today's digital age, it's impossible to imagine a world without software. From the apps we use daily to sophisticated systems that run entire cities, software is an intricate part of our lives. If you're at the beginning of your journey into the world of software, this article will provide a foundational understanding of what software is, what software engineering entails, and the paramount significance of both in today's world.","tags":["intro","software-engineering"],"title":"Introduction","url":"/en/software-engineering/0100-intro/01-intro/","year":"2023"},{"content":"","date":1678665600,"headings":[],"kind":"term","lang":"en","summary":"","title":"data-types","url":"/en/tags/data-types/","year":"2023"},{"content":"","date":1678665600,"headings":[],"kind":"term","lang":"en","summary":"","title":"variables","url":"/en/tags/variables/","year":"2023"},{"authors":["Julián Nonino"],"content":"Variables A variable is a container to store data in the computer\u0026rsquo;s memory. We can think of it as a box with a label. The label is the variable name and inside the box its value is stored.\nTo declare a variable in Python we just write the name and assign a value:\n1age = 28 2price = 19.95 3student = True Variable names must start with letters or underscore, and can only contain letters, numbers and underscores. It is recommended to use meaningful names that represent the purpose of the variable.\nIn Python variables do not need to be declared with a particular type. The type is inferred automatically when assigning the value:\n1age = 28 # age is integer type 2price = 19.95 # price is float type 3single = True # single is boolean type Once assigned, a variable can change its value at any time:\n1age = 30 # We change age to 30 Scope and lifetime The scope of a variable refers to the parts of the code where it is available. Variables declared outside functions are global and available throughout the file. Variables inside a function are local and only visible within it.\nThe lifetime is the period during which the variable exists in memory. Local variables exist while the function executes, then they are destroyed. Global variables exist while the program is running.\nAssignment Assignment with the = operator allows changing or initializing a variable\u0026rsquo;s value:\n1number = 10 2number = 20 # Now number is 20 There are also compound assignment operators like += and -= that combine an operation with assignment:\n1number += 5 # Adds 5 to number (number = number + 5) 2number -= 2 # Subtracts 2 from number Data types Data types define what kind of value a variable can store. Python has several built-in types, including:\nNumerical: To store integer, float, and complex numeric values:\n1integer = 10 2float = 10.5 3complex = 3 + 4j Strings: To store text:\n1text = \u0026#34;Hello World\u0026#34; Boolean: For True or False logical values:\n1true_variable = True 2false_variable = False Collections: To store multiple values like lists, tuples and dictionaries:\nLists: Mutable sequences of values:\n1list = [1, 2, 3] Tuples: Immutable sequences of values:\n1tuple = (1, 2, 3) Dictionaries: Key-value pair structures:\n1dictionary = {\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 20} It is important to choose the data type that best represents the information we want to store.\nOperators Operators allow us to perform operations with values and variables in Python. Some common operators are:\nArithmetic: +, -, *, /, %, //, **\nComparison: ==, !=, \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;=\nLogical: and, or, not\nAssignment: =, +=, -=, *=, /=\nLet\u0026rsquo;s see concrete examples of expressions using these operators in Python:\n1# Arithmetic 25 + 4 # Addition, result 9 310 - 3 # Subtraction, result 7 44 * 5 # Multiplication, result 20 5 6# Comparison 75 \u0026gt; 4 # Greater than, result True 87 \u0026lt; 10 # Less than, result True 9 10# Logical 11True and False # Result False 12True or False # Result True 13not True # Result False 14 15# Assignment 16number = 10 17number += 5 # Adds 5 to number, equivalent to number = number + 5 Each type of operator works with specific data types. We must use them consistently according to our variable data types.\nType conversions Sometimes we need to convert one data type to another to perform certain operations. In Python we can convert explicitly or implicitly:\nExplicit: Using functions like int(), float(), str():\n1float = 13.5 2integer = int(float) # converts 13.5 to 13 3 4text = \u0026#34;100\u0026#34; 5number = int(text) # converts \u0026#34;100\u0026#34; to 100 Implicit: Python automatically converts in some cases:\n1integer = 100 2float = 3.5 3result = integer + float # result is 103.5, integer converted to float Some conversions can generate data loss or errors:\n1float = 13.5 2integer = int(float) 3 4print(integer) # 13, decimals are lost To prevent this we must explicitly choose conversions that make sense for our data.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nConclusion In this article we reviewed key concepts like variables, operators, data types and conversions in Python. Applying these concepts well will allow you to efficiently manipulate data in your programs. I recommend practising with your own examples to gain experience using these features. Good luck in your Python learning!\n","date":1678665600,"headings":[{"anchor":"assignment","title":"Assignment"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"data-types","title":"Data types"},{"anchor":"operators","title":"Operators"},{"anchor":"scope-and-lifetime","title":"Scope and lifetime"},{"anchor":"type-conversions","title":"Type conversions"},{"anchor":"variables","title":"Variables"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Understanding how variables and data types work is essential to master any programming language. In this article we will review the basic concepts of variables, operators, data types and type conversions using the Python language. We will cover both theory and practical examples so you can apply these concepts in your own programs.","tags":["intro","programming","variables","data-types"],"title":"Variables and Data Types","url":"/en/programming/0200-basic-concepts/0201-variables-data-types/","year":"2023"},{"content":"","date":167832e4,"headings":[],"kind":"term","lang":"en","summary":"","title":"install","url":"/en/tags/install/","year":"2023"},{"content":"","date":167832e4,"headings":[],"kind":"term","lang":"en","summary":"","title":"python","url":"/en/tags/python/","year":"2023"},{"authors":["Julián Nonino"],"content":" Choosing a programming language Choosing a programming language is the first and perhaps the most crucial step in the learning process. Several factors to consider when selecting a language include:\nPurpose: What do you want to code for? If it\u0026rsquo;s web development, JavaScript or PHP might be good options. If you\u0026rsquo;re into data science, R or Python might be more appropriate. Community: A language with an active community can be vital for beginners. A vibrant community usually means more resources, tutorials, and solutions available online. Learning curve: Some languages are easier to pick up than others. It\u0026rsquo;s essential to pick one that matches your experience level and patience. Job opportunities: If you\u0026rsquo;re eyeing a career in programming, researching the job market demand for various languages can be insightful. While there are many valuable and potent languages, for the purpose of this course, we\u0026rsquo;ve chosen Python. This language is renowned for its simplicity and readability, making it ideal for those just starting out. Moreover, Python boasts an active community and a wide range of applications, from web development to artificial intelligence1.\nInstalling Python For Windows users: Download the installer: Visit the official Python website at https://www.python.org/downloads/windows/ Click on the download link for the latest version of Python 3.x. Run the installer: Once the download is complete, locate and run the installer .exe file. Make sure to check the box that says \u0026ldquo;Add Python to PATH\u0026rdquo; during installation. This step is crucial for making Python accessible from the Command Prompt. Follow the installation prompts. Verify installation: Open the Command Prompt and type: 1python --version This should display the version of Python you just installed. For Mac users: Download the installer: Visit the official Python website at https://www.python.org/downloads/mac-osx/ Click on the download link for the latest version of Python 3.x. Run the installer: Once the download is complete, locate and run the .pkg file. Follow the installation prompts. Verify installation: Open the Terminal and type: 1python3 --version This should display the version of Python you just installed. For Linux (Ubuntu/Debian) users: Update packages: 1sudo apt update Install Python: 1sudo apt install python3 Verify installation: After installation, you can check the version of Python installed by typing: 1python3 --version Integrated Development Environments (IDEs) An IDE is a tool that streamlines application development by combining commonly-used functionalities into a single software package: code editor, compiler, debugger, and more. Choosing the right IDE can make the programming process more fluid and efficient.\nWhen evaluating IDEs, consider:\nLanguage compatibility: Not all IDEs are compatible with every programming language. Features: Some IDEs offer features like auto-completion, syntax highlighting, and debugging tools. Extensions and plugins: Being able to customize and extend your IDE through plugins can be extremely beneficial. Price: There are free and paid IDEs. Evaluate whether the additional features of a paid IDE justify its cost. For this course, we\u0026rsquo;ve selected Visual Studio Code (VS Code). It\u0026rsquo;s a popular IDE that\u0026rsquo;s free and open-source. It\u0026rsquo;s known for its straightforward interface, a vast array of plugins, and its capability to handle multiple programming languages2. Its active community ensures regular updates and a plethora of learning resources.\nInstalling Visual Studio Code For Windows users: Download the installer: Visit the official VS Code website at https://code.visualstudio.com/ Click on the \u0026ldquo;Download for Windows\u0026rdquo; button. Run the installer: Once the download is complete, locate and run the installer .exe file. Follow the installation prompts, including accepting the license agreement and choosing the installation location. Launch VS Code: After installation, you can find VS Code in your Start menu. Launch it, and you\u0026rsquo;re ready to start coding! For Mac users: Download the installer: Visit the official VS Code website at https://code.visualstudio.com/ Click on the \u0026ldquo;Download for Mac\u0026rdquo; button. Install VS Code: Once the download is complete, open the downloaded .zip file. Drag the Visual Studio Code .app to the Applications folder, making it available in the Launchpad. Launch VS Code: Use Spotlight search or navigate to your Applications folder to launch VS Code. For Linux (Ubuntu/Debian) users: Update packages and install dependencies: 1sudo apt update 2sudo apt install software-properties-common apt-transport-https wget Download and install the key: 1wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Add the VS Code repository: 1sudo add-apt-repository \u0026#34;deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main\u0026#34; Install Visual Studio Code: 1sudo apt update 2sudo apt install code Launch VS Code: You can start VS Code from the terminal by typing code or find it in your list of installed applications. Write and execute your first program Once you\u0026rsquo;ve set up your programming environment, it\u0026rsquo;s time to dive into coding.\nHello, World! This is arguably the most iconic program for beginners. It\u0026rsquo;s simple, but it introduces you to the process of writing and executing code.\n1print(\u0026#34;Hello, World!\u0026#34;) Running the Hello World program\nTriangle area and perimeter calculation This program is a tad more intricate. It doesn\u0026rsquo;t just print out a message; it also performs mathematical calculations.\n1# User input 2side1 = float(input(\u0026#34;Enter the length of the first side: \u0026#34;)) 3side2 = float(input(\u0026#34;Enter the length of the second side: \u0026#34;)) 4side3 = float(input(\u0026#34;Enter the length of the third side: \u0026#34;)) 5 6# Perimeter calculation 7perimeter = side1 + side2 + side3 8 9# Area calculation using Heron\u0026#39;s formula 10s = perimeter / 2 11area = (s*(s-side1)*(s-side2)*(s-side3)) ** 0.5 12 13print(f\u0026#34;The triangle\u0026#39;s perimeter is: {perimeter}\u0026#34;) 14print(f\u0026#34;The triangle\u0026#39;s area is: {area:.2f}\u0026#34;) Running the Triangle program\nConclusion Setting up a programming environment might appear daunting at first, but with the right tools and resources, it becomes a manageable and rewarding task. We hope this article provided you with a solid foundation to kickstart your programming journey. Happy coding!\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences Lutz, M. (2013). Learning Python. O\u0026rsquo;Reilly Media.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMicrosoft. (2020). Visual Studio Code Documentation. Microsoft Docs.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":167832e4,"headings":[{"anchor":"choosing-a-programming-language","title":"Choosing a programming language"},{"anchor":"conclusion","title":"Conclusion"},{"anchor":"for-linux-ubuntudebian-users","title":"For Linux (Ubuntu/Debian) users:"},{"anchor":"for-linux-ubuntudebian-users-1","title":"For Linux (Ubuntu/Debian) users:"},{"anchor":"for-mac-users","title":"For Mac users:"},{"anchor":"for-mac-users-1","title":"For Mac users:"},{"anchor":"for-windows-users","title":"For Windows users:"},{"anchor":"for-windows-users-1","title":"For Windows users:"},{"anchor":"hello-world","title":"Hello, World!"},{"anchor":"installing-python","title":"Installing Python"},{"anchor":"installing-visual-studio-code","title":"Installing Visual Studio Code"},{"anchor":"integrated-development-environments-ides","title":"Integrated Development Environments (IDEs)"},{"anchor":"references","title":"References"},{"anchor":"triangle-area-and-perimeter-calculation","title":"Triangle area and perimeter calculation"},{"anchor":"write-and-execute-your-first-program","title":"Write and execute your first program"}],"kind":"page","lang":"en","series":["Programming"],"summary":"Venturing into the world of programming might seem like a Herculean task, especially when faced with the initial decision: Where to begin? This article will guide you through the essential steps to set up your programming environment, ensuring a solid foundation for your coding journey.","tags":["intro","programming","python","install","tools"],"title":"Set up your development environment","url":"/en/programming/0100-intro/0104-setup-dev-environment/","year":"2023"},{"content":"","date":167832e4,"headings":[],"kind":"term","lang":"en","summary":"","title":"tools","url":"/en/tags/tools/","year":"2023"},{"content":"","date":1674e6,"headings":[],"kind":"term","lang":"en","summary":"","title":"git","url":"/en/tags/git/","year":"2023"},{"content":"","date":1674e6,"headings":[],"kind":"term","lang":"en","summary":"","title":"revert","url":"/en/tags/revert/","year":"2023"},{"authors":["Julián Nonino"],"content":"When we have created a commit locally but have not published it to the remote yet, we can use git reset to undo the commit and, if we wish, discard the changes. Although there are several options for git reset the most used are:\n--soft: Does not touch the index file or the working tree at all (but resets the head to , just like all modes do). This leaves all your changed files \u0026ldquo;Changes to be committed\u0026rdquo;, as git status would put it. --hard: Resets the index and working tree. Any changes to tracked files in the working tree since are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted. Git reset documentation {: style=\u0026ldquo;text-align: right;\u0026rdquo;}\nHere there is an example about using git reset. We start by changing a file and creating a commit with the change.\n1bash-3.2$ cat README.md 2# Index 3 41 5bash-3.2$ 6bash-3.2$ cat README.md 7# Index 8 91 102 11bash-3.2$ 12bash-3.2$ git add README.md 13bash-3.2$ 14bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md\u0026#34; 15[main 3734fd5] Add number 2 in README.md 16 1 file changed, 1 insertion(+) git status shows there is one commit pending to be published.\n1bash-3.2$ git status 2On branch main 3Your branch is ahead of \u0026#39;origin/main\u0026#39; by 1 commit. 4 (use \u0026#34;git push\u0026#34; to publish your local commits) 5 6nothing to commit, working tree clean Using git reflog to see the history.\n13734fd5 (HEAD -\u0026gt; main) HEAD@{0}: commit: Add number 2 in README.md 2866bfa8 (origin/main) HEAD@{1}: revert: Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 3e2f6d08 HEAD@{2}: merge feature-1: Merge made by the \u0026#39;ort\u0026#39; strategy. 423644da HEAD@{3}: checkout: moving from feature-1 to main Now we can use git reset --soft \u0026lt;COMMIT_ID\u0026gt; to undo the commit but keep the changes.\n1bash-3.2$ git reset --soft 866bfa8 2bash-3.2$ 3bash-3.2$ git status 4On branch main 5Your branch is up to date with \u0026#39;origin/main\u0026#39;. 6 7Changes to be committed: 8 (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) 9 modified: README.md git log after using git reset\n1commit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) 2Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 3Date: Wed Jan 18 20:06:40 2023 -0300 4 5 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 6 7 This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing 8 changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. We create a new commit so we can test the git reset --hard command.\n1bash-3.2$ git status 2On branch main 3Your branch is up to date with \u0026#39;origin/main\u0026#39;. 4 5Changes to be committed: 6 (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) 7 modified: README.md 8 9bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md - NEW COMMIT\u0026#34; 10[main 2e7193d] Add number 2 in README.md - NEW COMMIT 11 1 file changed, 1 insertion(+) git log now shows the new commit.\n1commit 2e7193db650b9ba0762fe73525df599a08f8577d (HEAD -\u0026gt; main) 2Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 3Date: Thu Jan 19 08:32:57 2023 -0300 4 5 Add number 2 in README.md - NEW COMMIT 6 7commit 866bfa8a952d11240707ebfc87f3266034d42443 (origin/main) 8Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 9Date: Wed Jan 18 20:06:40 2023 -0300 10 11 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 12 13 This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing 14 changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. Now we can use git reset --hard \u0026lt;COMMIT_ID\u0026gt; to undo the commit and discard all the changes.\n1bash-3.2$ git reset --hard 866bfa8 2HEAD is now at 866bfa8 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 3bash-3.2$ 4bash-3.2$ git status 5On branch main 6Your branch is up to date with \u0026#39;origin/main\u0026#39;. 7 8nothing to commit, working tree clean git log remains as it nothing had happened.\n1commit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) 2Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 3Date: Wed Jan 18 20:06:40 2023 -0300 4 5 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 6 7 This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing 8 changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. ","date":1674e6,"headings":[],"kind":"page","lang":"en","summary":"How to discard changes in Git before pushing them.","tags":["vcs","version-control","git","revert"],"title":"Revert a local change in Git","url":"/en/blog/2023/01/revert-a-local-change-in-git/","year":"2023"},{"authors":["Julián Nonino"],"content":"When we realized that the last commit was a mistake but we already published it, the command to use is git revert \u0026lt;COMMIT_HASH\u0026gt;.\nFirst we need to locate the ID of the commit we want to revert, it can be done with git log or git reflog commands. Then, run the git revert \u0026lt;COMMIT_HASH\u0026gt; command using the ID obtained in the previous step. Use the options -e or --edit to edit the commit message if we like. Push our changes so the revert is available for everyone in our group. Reverting multiple commits If we need to revert multiple commits we can revert them one by one using the --no-commit option in order to create a single revert commit at the end.\nImagine the history is like the following and we need to go back to COMMIT-3.\n1COMMIT-1 -\u0026gt; COMMIT-2 -\u0026gt; COMMIT-3 -\u0026gt; COMMIT-4 -\u0026gt; COMMIT-5 -\u0026gt; COMMIT-6 -\u0026gt; HEAD This sequence of commands will get our files to the version of COMMIT-3:\n1bash-3.2$ git revert --no-commit COMMIT-6 2bash-3.2$ git revert --no-commit COMMIT-5 3bash-3.2$ git revert --no-commit COMMIT-4 4bash-3.2$ git commit -m \u0026#34;Revert to version in COMMIT-3\u0026#34; 5bash-3.2$ git push Reverting a merge commit -m parent-number, \u0026ndash;mainline parent-number\nUsually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.\nGit revert documentation {: style=\u0026ldquo;text-align: right;\u0026rdquo;}\nWhen we need to revert a merge commit git revert command needs to be run with the -m or --mainline option to indicate the parent number because a merge commit has more than one parent and Git does not know which parent was target branch and which was the branch with the changes that should be reverted.\nHere there is an example showing how to revert a merge commit.\nCreate the first commit in main branch.\n1bash-3.2$ cat README.md 2# Index 3 41 5bash-3.2$ 6bash-3.2$ git commit -m \u0026#34;Add number 1 in README.md - main branch\u0026#34; 7[main (root-commit) 23644da] Add number 1 in README.md - main branch 8 1 file changed, 3 insertions(+) 9 create mode 100644 README.md 10bash-3.2$ 11bash-3.2$ git push -u origin main 12Enumerating objects: 3, done. 13Counting objects: 100% (3/3), done. 14Writing objects: 100% (3/3), 254 bytes | 254.00 KiB/s, done. 15Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 16To github.com:jnonino/test-repo.git 17 * [new branch] main -\u0026gt; main 18branch \u0026#39;main\u0026#39; set up to track \u0026#39;origin/main\u0026#39;. 19bash-3.2$ The state of the README.md file in main branch.\n1bash-3.2$git status 2On branch main 3Your branch is up to date with \u0026#39;origin/main\u0026#39;. 4 5nothing to commit, working tree clean 6bash-3.2$ 7bash-3.2$ cat README.md 8# Index 9 101 Branch feature-1 created and added one commit.\n1bash-3.2$ git checkout -b feature-1 2Switched to a new branch \u0026#39;feature-1\u0026#39; 3bash-3.2$ 4bash-3.2$ cat README.md 5# Index 6 71 82 9bash-3.2$ 10bash-3.2$ git add README.md 11bash-3.2$ 12bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md - feature-1 branch\u0026#34; 13[feature-1 83ea1a3] Add number 2 in README.md - feature-1 branch 14 1 file changed, 1 insertion(+) 15bash-3.2$ 16bash-3.2$ git push --set-upstream origin feature-1 17Enumerating objects: 5, done. 18Counting objects: 100% (5/5), done. 19Writing objects: 100% (3/3), 292 bytes | 292.00 KiB/s, done. 20Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 21remote: 22remote: Create a pull request for \u0026#39;feature-1\u0026#39; on GitHub by visiting: 23remote: https://github.com/jnonino/test-repo/pull/new/feature-1 24remote: 25To github.com:jnonino/test-repo.git 26 * [new branch] feature-1 -\u0026gt; feature-1 27branch \u0026#39;feature-1\u0026#39; set up to track \u0026#39;origin/feature-1\u0026#39;. 28bash-3.2$ The state of README.md in the feature-1 branch.\n1bash-3.2$ git status 2On branch feature-1 3Your branch is up to date with \u0026#39;origin/feature-1\u0026#39;. 4 5nothing to commit, working tree clean 6bash-3.2$ 7bash-3.2$ cat README.md 8# Index 9 101 112 Merge the feature-1 branch into the main branch.\n1bash-3.2$ git checkout main 2Switched to branch \u0026#39;main\u0026#39; 3Your branch is up to date with \u0026#39;origin/main\u0026#39;. 4bash-3.2$ 5bash-3.2$ git merge --no-ff feature-1 6Merge made by the \u0026#39;ort\u0026#39; strategy. 7 README.md | 1 + 8 1 file changed, 1 insertion(+) 9bash-3.2$ 10bash-3.2$ git push 11Enumerating objects: 1, done. 12Counting objects: 100% (1/1), done. 13Writing objects: 100% (1/1), 233 bytes | 233.00 KiB/s, done. 14Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 15To github.com:jnonino/test-repo.git 16 23644da..e2f6d08 main -\u0026gt; main 17bash-3.2$ Current state of README.md in main branch.\n1bash-3.2$ git status 2On branch main 3Your branch is up to date with \u0026#39;origin/main\u0026#39;. 4 5nothing to commit, working tree clean 6bash-3.2$ 7bash-3.2$ cat README.md 8# Index 9 101 112 git log after merging feature-1 into main branch.\n1commit e2f6d08d3b38a02a1c026cfb879f3131536757ac (HEAD -\u0026gt; main, origin/main) 2Merge: 23644da 83ea1a3 3Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 4Date: Wed Jan 18 19:58:19 2023 -0300 5 6 Merge branch \u0026#39;feature-1\u0026#39; 7 8commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) 9Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 10Date: Wed Jan 18 19:53:38 2023 -0300 11 12 Add number 2 in README.md - feature-1 branch 13 14commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 15Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 16Date: Wed Jan 18 19:48:37 2023 -0300 17 18 Add number 1 in README.md - main branch To revert the merge commit, as it was stated above we need to pay attention to the merge field.\n1Merge: 23644da 83ea1a3 Running git revert e2f6d08 -m 1 will reinstate the tree as it was in 23644da, and git revert e2f6d08 -m 2 will set the tree as it was in 83ea1a3. In this example we would like to leave the main branch as it was before the merge commit. For doing that, we need to run git revert e2f6d08 -m 1.\n1bash-3.2$ git revert e2f6d08 -m 1 2[main 866bfa8] Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 3 1 file changed, 1 deletion(-) 4bash-3.2$ 5bash-3.2$ git status 6On branch main 7Your branch is ahead of \u0026#39;origin/main\u0026#39; by 1 commit. 8 (use \u0026#34;git push\u0026#34; to publish your local commits) 9 10nothing to commit, working tree clean 11bash-3.2$ 12bash-3.2$ git push 13Enumerating objects: 5, done. 14Counting objects: 100% (5/5), done. 15Writing objects: 100% (3/3), 344 bytes | 344.00 KiB/s, done. 16Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 17To github.com:jnonino/test-repo.git 18 e2f6d08..866bfa8 main -\u0026gt; main git log after reverting the merge commit.\n1commit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) 2Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 3Date: Wed Jan 18 20:06:40 2023 -0300 4 5 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 6 7 This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing 8 changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. 9 10commit e2f6d08d3b38a02a1c026cfb879f3131536757ac 11Merge: 23644da 83ea1a3 12Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 13Date: Wed Jan 18 19:58:19 2023 -0300 14 15 Merge branch \u0026#39;feature-1\u0026#39; 16 17commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) 18Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 19Date: Wed Jan 18 19:53:38 2023 -0300 20 21 Add number 2 in README.md - feature-1 branch 22 23commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 24Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; 25Date: Wed Jan 18 19:48:37 2023 -0300 26 27 Add number 1 in README.md - main branch Current state of README.md in main branch.\n1bash-3.2$ git status 2On branch main 3Your branch is up to date with \u0026#39;origin/main\u0026#39;. 4 5nothing to commit, working tree clean 6bash-3.2$ 7bash-3.2$ cat README.md 8# Index 9 101 ","date":1674e6,"headings":[{"anchor":"reverting-a-merge-commit","title":"Reverting a merge commit"},{"anchor":"reverting-multiple-commits","title":"Reverting multiple commits"}],"kind":"page","lang":"en","summary":"Have you ever pushed a change in Git and it was wrong? Here you'll learn how to revert the change, even if the problem was with a merge commit.","tags":["vcs","version-control","git","revert"],"title":"Revert a pushed change in Git","url":"/en/blog/2023/01/revert-a-pushed-change-in-git/","year":"2023"},{"content":"","date":1674e6,"headings":[],"kind":"term","lang":"en","summary":"","title":"vcs","url":"/en/tags/vcs/","year":"2023"},{"content":"","date":1674e6,"headings":[],"kind":"term","lang":"en","summary":"","title":"version-control","url":"/en/tags/version-control/","year":"2023"},{"content":"Latest Articles Programming Nov 3, 2023 Queues Queues are an abstract data structure that operates under the FIFO (first in, first out) principle, where the first... Read more Programming Nov 2, 2023 Stacks Stacks are an abstract data structure that operates under the LIFO (last in, first out) principle, where the last... Read more Programming Nov 1, 2023 Linked Lists Linked lists are a dynamic and flexible data structure that allows efficiently storing collections of elements. Unlike... Read more Programming Oct 31, 2023 Arrays Arrays are fundamental data structures in programming that allow storing and organizing collections of data of the same... Read more Programming Oct 31, 2023 Maps (Dictionaries) Maps (also called hashes or dictionaries) are data structures that associate keys with values. They allow ultra fast... Read more Programming Sep 28, 2023 Recursive functions Recursion is a fundamental concept in programming that allows a function to call itself. At first it may seem... Read more Programming Sep 27, 2023 Control Flow When we embark on the exciting journey of learning to program, we soon discover that programming is not just about... Read more Programming Sep 27, 2023 Functions In the vast and exciting world of programming, there are concepts that are fundamental pillars for any developer,... Read more Programming Sep 19, 2023 Input and output operations Input/output operations (I/O) allow a program to communicate and exchange data with the outside world. In this article... Read more Programming Sep 15, 2023 Boolean logic In life, we often seek certainties. Will it rain tomorrow, true or false? Is a certain action right or wrong? This... Read more Programming Sep 15, 2023 Numerical systems Every day, we\u0026#39;re surrounded by numbers. From the alarm clock\u0026#39;s digits waking us up in the morning to the price of our... Read more Programming Sep 13, 2023 The essence of computers In today\u0026#39;s digital age, where electronic gadgets seamlessly integrate into our daily lives, understanding the bedrock... Read more ","date":1662422400,"headings":[{"anchor":"latest-articles","title":"Latest Articles"}],"kind":"home","lang":"en","summary":"Latest Articles Programming Nov 3, 2023 Queues Queues are an abstract data structure that operates under the FIFO (first in, first out) principle, where the first... Read more Programming Nov 2, 2023 Stacks Stacks are an abstract data structure that operates under the LIFO (last in, first out) principle, where the last... Read more Programming Nov 1, 2023 Linked Lists Linked lists are a dynamic and flexible data structure that allows efficiently storing collections of elements.","title":"Learn-Software.com","url":"/en/","year":"2022"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"2023","url":"/en/archives/2023/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"April","url":"/en/archives/2023/04/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"Archives","url":"/en/archives/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"August","url":"/en/archives/2023/08/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"Blog","url":"/en/posts/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"taxonomy","lang":"en","summary":"","title":"Categories","url":"/en/categories/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"December","url":"/en/archives/2023/12/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"February","url":"/en/archives/2023/02/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"term","lang":"en","summary":"","title":"I/O","url":"/en/tags/i/o/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"term","lang":"en","summary":"","title":"input/output","url":"/en/tags/input/output/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"January","url":"/en/archives/2023/01/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"July","url":"/en/archives/2023/07/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"June","url":"/en/archives/2023/06/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"March","url":"/en/archives/2023/03/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"term","lang":"en","summary":"","title":"María Florencia Caro","url":"/en/authors/mfcaro/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"May","url":"/en/archives/2023/05/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"November","url":"/en/archives/2023/11/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"October","url":"/en/archives/2023/10/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"en","summary":"","title":"September","url":"/en/archives/2023/09/","year":"0001"}]