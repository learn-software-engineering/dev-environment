[{"body":"","categories":"","description":"","excerpt":"","ref":"/es/programming/","tags":"","title":"Programación"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/programming/","tags":"","title":"Programming"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/software-engineering/","tags":"","title":"Ingeniería de Software"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/software-engineering/","tags":"","title":"Software Engineering"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/blog/","tags":"","title":"Blog"},{"body":"La programación, en su esencia, es el acto de instruir a una máquina sobre cómo realizar una tarea específica. Es como si le estuvieras enseñando a tu perro a buscar la pelota, pero en este caso, el perro es tu computadora y la pelota es, por ejemplo, mostrar una foto en tu pantalla.\nAhora, es posible que pienses que programar es simplemente escribir líneas de código. En realidad, la programación es un proceso más amplio que incluye no solo escribir código, sino también resolver problemas, diseñar sistemas y pensar lógicamente.\nEn el universo de la programación, hay lenguajes de alto nivel y lenguajes de bajo nivel. Un lenguaje de bajo nivel, como el ensamblador, está más cerca de lo que la máquina entiende, mientras que un lenguaje de alto nivel, como Python o JavaScript, es más amigable para nosotros, los humanos. Imagina tener una conversación: los lenguajes de alto nivel son como charlar con un amigo en un café, mientras que los lenguajes de bajo nivel son como intentar comunicarte con alguien que habla un dialecto muy particular y localizado.\nAdemás, algunos lenguajes de programación son compilados y otros son interpretados. Si un lenguaje es compilado, significa que se traduce a un lenguaje que la máquina entiende antes de ser ejecutado. Por otro lado, los lenguajes interpretados son traducidos en tiempo real, mientras se ejecutan.\nBreve historia de la programación La programación no es un concepto nuevo. De hecho, ha estado con nosotros desde mucho antes de que las computadoras existieran en la forma que las conocemos hoy. Dispositivos como el ábaco y el astrolabio son ejemplos tempranos de herramientas que usamos para realizar cálculos complejos.\nPero fue con la llegada de las máquinas mecánicas, como la Máquina Analítica de Charles Babbage, que se sentaron las bases para la programación moderna. ¡Estamos hablando del siglo XIX!\nCon el paso del tiempo, nacieron lenguajes que marcaron hitos, como Fortran y COBOL. Estos lenguajes sentaron las bases para las revoluciones tecnológicas que vendrían. Con la evolución de los lenguajes, también surgieron nuevos paradigmas: primero el Procedural, luego el Orientado a Objetos y más recientemente, el Funcional.\nHoy, estamos en una era moderna, dominada por la programación para la web, móviles y la nube. Cada vez que deslizas tu dedo por la pantalla de tu celular o compras algo online, hay líneas y líneas de código trabajando detrás de escena.\nLa programación hoy La programación es el motor de nuestra sociedad moderna. Desde aplicaciones para pedir comida hasta sistemas avanzados de inteligencia artificial que ayudan en investigaciones médicas, la programación está en todas partes.\nAdemás de simplificar nuestras vidas cotidianas, la programación tiene un impacto profundo en la sociedad. Ha permitido avances en la automatización, el análisis de datos y el entretenimiento. Y lo que es aún más emocionante, es que apenas estamos rasguñando la superficie. Con los avances en inteligencia artificial, computación cuántica y el Internet de las Cosas (IoT), ¿quién sabe qué maravillas nos esperan en mundo de la programación?\n","categories":"","description":"","excerpt":"La programación, en su esencia, es el acto de instruir a una máquina …","ref":"/es/programming/0100-intro/","tags":"","title":"Introducción a la Programación"},{"body":"At its core, programming is the act of instructing a machine on how to perform a specific task. It’s like teaching your dog to fetch, but in this case, the dog is your computer, and the ball might be, let’s say, displaying a photo on your screen.\nNow, you might think that programming is just writing lines of code. Programming is actually a broader process that not only includes writing code but also problem-solving, system design, and logical thinking.\nIn the universe of programming, there are high-level and low-level languages. A low-level language, like assembly, is closer to what the machine understands, while a high-level language, such as Python or JavaScript, is more human-friendly. Picture having a conversation: high-level languages are like chatting with a friend over coffee in New York, while low-level languages are like trying to communicate with someone speaking a very specific, localized dialect.\nAdditionally, some programming languages are compiled, while others are interpreted. If a language is compiled, it means it’s translated into a machine-understandable language before being executed. On the other hand, interpreted languages are translated in real-time, as they run.\nA brief history of Programming Programming isn’t a new concept. In fact, it’s been with us long before computers existed in the form we know today. Devices like the abacus and the astrolabe are early examples of tools we used for intricate calculations.\nHowever, it was with the advent of mechanical machines, like Charles Babbage’s Analytical Engine, that the foundation for modern programming was laid. We’re talking about the 19th century!\nOver time, landmark languages like Fortran and COBOL emerged. These languages paved the way for the technological revolutions that would follow. With the evolution of languages also came new paradigms: first Procedural, then Object-Oriented, and more recently, Functional.\nToday, we’re in a modern era dominated by web, mobile, and cloud programming. Every swipe on your phone or online purchase has lines and lines of code working behind the scenes.\nProgramming today Programming is the engine of our modern society. From apps for ordering food to advanced artificial intelligence systems aiding medical research, programming is everywhere.\nBeyond simplifying our daily lives, programming has a profound societal impact. It has enabled progress in automation, data analysis, and entertainment. And what’s even more exhilarating is that we’re just scratching the surface. With upcoming prospects on artificial intelligence, quantum computing and the Internet of Things (IoT), who knows what marvels await us in the programming world?\n","categories":"","description":"","excerpt":"At its core, programming is the act of instructing a machine on how to …","ref":"/en/programming/0100-intro/","tags":"","title":"Introduction to Programming"},{"body":"Si alguna vez te has preguntado qué es lo que hace “tictac” dentro de esa caja metálica que llamamos computadora, estás en el lugar indicado. En esencia, una computadora es una combinación de hardware y software que trabajan juntos para llevar a cabo tareas específicas.\nEl hardware es toda la parte física de la computadora: el CPU (que es como el cerebro de la máquina), la RAM (donde la computadora guarda la información con la que está trabajando en un momento determinado), dispositivos de almacenamiento (donde se guardan los datos de forma permanente) y periféricos (como el teclado, el mouse o la pantalla)1.\nPor otro lado, el software es el conjunto de instrucciones que le dice al hardware qué hacer. Hay varios tipos de software, desde el software del sistema, como el sistema operativo que coordina todas las acciones de la máquina, hasta software de aplicación que nos permite hacer cosas como escribir documentos o jugar videojuegos2.\nEl papel del sistema operativo es crucial. Es el mediador entre el usuario y el hardware, asegurando que todo funcione armónicamente. Si el hardware fuera una orquesta, el sistema operativo sería el director que asegura que cada instrumento toque en el momento y de la manera correcta.\nEl sistema binario: el lenguaje secreto de las computadoras A diferencia de nosotros, que usamos un sistema decimal basado en diez dígitos (del 0 al 9), las computadoras usan el sistema binario, que solo tiene dos dígitos: 0 y 1. ¿Por qué? Bueno, en el nivel más básico, una computadora está hecha de millones de transistores que pueden estar en uno de dos estados: encendido o apagado. Estos estados se representan con esos dígitos: 0 para apagado y 1 para encendido3.\nLos términos “bit” y “byte” son fundamentales aquí. Un bit es la unidad más pequeña de datos en una computadora y puede tener un valor de 0 o 1. Un byte, por otro lado, es un conjunto de 8 bits y puede representar 256 valores diferentes (desde \\(00000000\\) hasta \\(11111111\\) en binario)4.\nEste sistema binario no solo representa números, sino también texto, imágenes y cualquier tipo de dato. Por ejemplo, en el código ASCII (un estándar de codificación de caracteres), la letra “A” se representa como \\(01000001\\) en binario.\nEn un artículo posterior, vamos a hablar en detalle acerca del sistema binario y otro sistema muy utilizado en el ambiente de la computación, el hexadecimal.\nMemoria y almacenamiento: donde residen nuestros datos La memoria y el almacenamiento son dos conceptos cruciales en la informática. Si bien a menudo se usan indistintamente, tienen roles muy diferentes.\nLa memoria, específicamente la RAM, es volátil. Esto significa que la información se pierde cuando apagamos la computadora. La RAM es esencialmente el “espacio de trabajo” de la computadora, donde almacena datos e instrucciones mientras está en uso. Hay varios tipos de RAM, siendo DRAM y SRAM los más comunes5.\nPor otro lado, tenemos la ROM (Memoria de Solo Lectura). A diferencia de la RAM, la ROM no es volátil y se utiliza para almacenar firmware, es decir, software que está íntimamente ligado al hardware y que no necesita cambios frecuentes.\nEn cuanto al almacenamiento, dispositivos como discos duros, SSDs y unidades flash nos permiten guardar información de manera permanente. Estos dispositivos forman parte de lo que se conoce como la jerarquía de memoria, que va desde la memoria caché (rápida pero pequeña) hasta el almacenamiento secundario (más lento pero con gran capacidad)6.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias Patterson, D. \u0026 Hennessy, J. (2014). Arquitectura de Computadoras. Buenos Aires: Ediciones Omega. ↩︎\nSilberschatz, A., Galvin, P. B., \u0026 Gagne, G. (2009). Fundamentos de Sistemas Operativos. Buenos Aires: Ediciones M. ↩︎\nTanenbaum, A. (2012). Estructura de Computadoras. Buenos Aires: Prentice Hall. ↩︎\nBrookshear, J. G. (2011). Ciencia de la Computación: Una visión general. Buenos Aires: Pearson Educación. ↩︎\nJacob, B., Ng, S. W., \u0026 Wang, D. T. (2007). Arquitecturas de memoria en sistemas de computadoras. Buenos Aires: Wiley-Interscience. ↩︎\nSiewiorek, D. P. \u0026 Swarz, R. S. (2017). Principios de diseño de sistemas computacionales. Buenos Aires: Morgan Kaufmann. ↩︎\n","categories":"","description":"En el mundo actual, donde las tecnologías digitales se han convertido en una extensión de nuestras vidas diarias, resulta esencial comprender los cimientos sobre los que se construyen nuestras herramientas digitales. En esta ocasión, nos sumergiremos en el corazón de las computadoras para entender cómo funcionan y por qué son esenciales en nuestra sociedad moderna.\n","excerpt":"En el mundo actual, donde las tecnologías digitales se han convertido …","ref":"/es/programming/0100-intro/0101-computers/","tags":["intro","programming","computer","hardware","software","cpu","memory"],"title":"La Computadora"},{"body":"To the uninitiated, a computer might seem like a mere box—perhaps sometimes sleek and shiny—but a box nonetheless. Yet, within this “box” lies a universe of complexity and coordination.\nHardware represents the physical components of a computer: the Central Processing Unit (CPU) which is often likened to the brain of the system, the Random Access Memory (RAM) acting as a temporary storage while tasks are underway, storage devices that retain data, and peripherals like keyboards, mice, and monitors1.\nOn the other side of this duality is software, a set of instructions that guides the hardware. There are various types of software, from system software like the operating system (OS), which coordinates the myriad hardware components, to application software that allows users to perform specific tasks, such as word processing or gaming2.\nThe role of the operating system is pivotal. It acts as a bridge, translating user commands into instructions that the hardware can execute. If the hardware were an orchestra, the OS would be its conductor, ensuring each instrument plays its part harmoniously.\nThe binary system: decoding the language of machines Human civilizations have developed numerous numbering systems over the millennia, but computers, with their logical circuits, have settled on the binary system. But why binary? Simply put, at the most foundational level, a computer’s operation is based on switches (transistors) that can be either ‘on’ or ‘off’, corresponding naturally to the binary digits, or ‘bits’, 1 and 0 respectively3.\nIn this binary realm, a bit is the smallest data unit, representing a single binary value. A byte, comprising 8 bits, can represent 256 distinct values, ranging from \\(00000000\\) to \\(11111111\\)4. This binary encoding isn’t restricted to numbers; it extends to text, images, and virtually all forms of data. For instance, in ASCII encoding, the capital letter ‘A’ is represented as \\(01000001\\).\nIn a following post we’ll describe in more details the binary system and introduce another system used a lot in relations to computers, the hexadecimal.\nMemory and Storage: the sanctuaries of data The concepts of memory and storage are pivotal in understanding computer architecture. Though sometimes used interchangeably in colloquial parlance, their roles in a computer system are distinct.\nMemory, particularly RAM, is volatile, meaning information stored is lost once the computer is turned off. RAM serves as the computer’s “workspace”, temporarily storing data and instructions during operations. There are various RAM types, with DRAM and SRAM being the most prevalent5.\nContrastingly, Read-Only Memory (ROM) is non-volatile, used predominantly to store firmware—software intrinsically linked to specific hardware, requiring infrequent alterations.\nIn terms of data storage, devices like hard drives, SSDs, and flash drives offer permanent data retention. These storage mechanisms are part of the memory hierarchy, which ranges from the swift but limited cache memory to the expansive but slower secondary storage6.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe’re keen to hear your thoughts, so don’t be shy – drop your comments, suggestions, and those bright ideas you’re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we’ve cooked up for you. You’ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences Patterson, D. \u0026 Hennessy, J. (2014). Computer Organization and Design. Elsevier. ↩︎\nSilberschatz, A., Galvin, P. B., \u0026 Gagne, G. (2009). Operating System Concepts. John Wiley \u0026 Sons. ↩︎\nTanenbaum, A. (2012). Structured Computer Organization. Prentice Hall. ↩︎\nBrookshear, J. G. (2011). Computer Science: An Overview. Addison-Wesley. ↩︎\nJacob, B., Ng, S. W., \u0026 Wang, D. T. (2007). Memory Systems: Cache, DRAM, Disk. Morgan Kaufmann. ↩︎\nSiewiorek, D. P. \u0026 Swarz, R. S. (2017). Reliable Computer Systems: Design and Evaluation. A K Peters/CRC Press. ↩︎\n","categories":"","description":"In today's digital age, where electronic gadgets seamlessly integrate into our daily lives, understanding the bedrock upon which these marvels stand becomes not just an academic interest but a societal necessity. As we embark on this enlightening voyage into the heart of computers, we aim to demystify the intricate dance between the physical and the abstract, between the tangible hardware and the intangible software.\n","excerpt":"In today's digital age, where electronic gadgets seamlessly integrate …","ref":"/en/programming/0100-intro/0101-computers/","tags":["intro","programming","computer","hardware","software","cpu","memory"],"title":"The Computer"},{"body":"What is Software? Several thought leaders in the world of computing have defined software in various ways:\nIan Sommerville1: Computer programs and associated documentation.\nRoger S. Pressman2: A collection of computer programs, procedures, rules, and associated documentation and data.\nAndrew S. Tanenbaum3: A series of instructions that tells a computer what to do.\nGrady Booch4: Set of items or objects that form a configuration that includes programs, documents, and data.\nPeter Denning5: Map of a machine, detailing its possible states, transitions, and the actions for these transitions.\nAnalysing these definitions, common themes emerge: software encompasses instructions, data, associated documentation, and serves as a guiding structure for computer operations. So we can conclude:\nSoftware is a meticulously structured collection of programs, data, and documentation that serves as a guiding blueprint, directing a computer’s operations and interactions with users and other systems.\nAlthough we can classify software in many different types, each with its specific function, we can define three primary categories:\nSystem Software: This forms the core of a computer’s operation. It includes operating systems like Windows, Linux, and macOS, which manage hardware resources and provide services for application software. Application Software: Tailored for end-users to perform specific tasks, this category ranges from word processors (like Microsoft Word) to graphic design tools (like Adobe Photoshop) and games. Embedded Software: Found within hardware devices such as washing machines, traffic lights, or digital watches, embedded software operates specific functions of these devices. Unlike general-purpose software, it’s dedicated to specific tasks or functions. What is Software Engineering? Several prominent figures have also provided their perspectives on Software Engineering:\nIan Sommerville1: A discipline concerned with all aspects of software production.\nRoger S. Pressman2: Establishment and use of sound engineering principles to obtain economically software that is reliable and works efficiently on real machines.\nFrederick P. Brooks6: The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software.\nBarry W. Boehm7: Aims to produce quality software, software that is delivered on time, within budget, and that satisfies its requirements.\nFritz Bauer8: The establishment and use of sound engineering principles to economically obtain software that is reliable and works on real machines.\nFrom these definitions, we can discern that software engineering integrates principles of engineering, emphasizes systematic methods, seeks reliability and efficiency, and aims for the production of high-quality software that meets its specified requirements. Concluding that\nSoftware Engineering is the disciplined application of engineering principles and systematic methods to design, develop, and maintain reliable and efficient software that economically meets specified requirements and user needs.\nSoftware Engineering should not be confused with Computer Science. While the latter is a discipline that dives deep into the theoretical and mathematical aspects of computing, studying algorithms, computational theory, and more, the first one primarily focuses on designing and building large software systems. It emphasizes practical techniques and methodologies that ensure the production of high-quality, maintainable software.\nWhy it is important to develop quality software Today, we’re surrounded by a digital ecosystem. Software runs our phones, cars, banks, hospitals, and even our homes. This ubiquity underscores its significance. That means that software flaws can have catastrophic outcomes. From banking systems to healthcare applications, the demand for faultless, efficient software is sky-high.\nSoftware Engineering, ensures this vast amount of software is reliable, efficient, and meets user needs. As technology advances at breakneck speed, the role of software engineers becomes even more pivotal, making sure innovations are safe and effective.\nWhether you’re using a social media app, making a bank transaction, or checking health diagnostics, remember there’s a meticulously engineered software system running behind the scenes, making it all possible.\nReferences Sommerville, I., 2010. Software Engineering. 9th ed. Pearson. ↩︎ ↩︎\nPressman, R.S., 2010. Software Engineering: A Practitioner’s Approach. 7th ed. McGraw-Hill. ↩︎ ↩︎\nTanenbaum, A.S., 2012. Structured Computer Organization. 6th ed. Pearson. ↩︎\nBooch, G., 2007. Object-Oriented Analysis and Design with Applications. 3rd ed. Addison-Wesley. ↩︎\nDenning, P.J., 2009. The Profession of IT, Beyond Computational Thinking. Communications of the ACM, 52(6). ↩︎\nBrooks, F.P., 1995. The Mythical Man-Month: Essays on Software Engineering. Addison-Wesley. ↩︎\nBoehm, B.W., 1988. A Spiral Model of Software Development and Enhancement. Computer, 21(5). ↩︎\nBauer, F.L., 1972. Software Engineering. Information Processing, 71. ↩︎\n","categories":"","description":"In today's digital age, it's impossible to imagine a world without software. From the apps we use daily to sophisticated systems that run entire cities, software is an intricate part of our lives. If you're at the beginning of your journey into the world of software, this article will provide a foundational understanding of what software is, what software engineering entails, and the paramount significance of both in today's world.\n","excerpt":"In today's digital age, it's impossible to imagine a world without …","ref":"/en/software-engineering/0100-intro/01-intro/","tags":["intro","software-engineering"],"title":"Introduction"},{"body":"The decimal system: the bedrock of our daily life From a tender age, we’re taught to count using ten digits: 0 through 9. This system, known as the decimal system, underpins almost all our mathematical and financial activities, from basic arithmetic to calculating bank interests1. Its roots trace back to our anatomy: the ten fingers on our hands, making it the most intuitive and natural system for us. Yet, its true charm emanates from its positional nature.\nTo grasp this concept, let’s dissect the number 237:\nThe rightmost digit (7) stands for the units’ position. That is, \\(7 \\times 10^0\\) (any number raised to the power of 0 is 1). Therefore, its value is simply 7. The middle digit (3) represents the tens’ position, translating to \\(3 \\times 10^1 = 3 \\times 10 = 30\\). The leftmost digit (2) is in the hundreds’ position, decoding to \\(2 \\times 10^2 = 2 \\times 100 = 200\\). When these values are combined,\n$$2 \\times 10^2 + 3 \\times 10^1 + 7 \\times 10^0 = 200 + 30 + 7 = 237$$ The binary system: computers’ coded language While the decimal system reigns supreme in our everyday lives, the machines we use daily, from our smartphones to computers, operate in a starkly different realm: the binary world. In this system, only two digits exist: 0 and 1. It might seem restrictive at first glance, but this system is the essence of digital electronics. Digital devices, with their billions of transistors, operate using these two states: on (1) and off (0)2.\nDespite its apparent simplicity, the binary system can express any number or information that the decimal system can. For instance, the decimal number 5 is represented as 101 in binary.\nBinary, with its ones and zeros, operates in a manner akin to the decimal system, but instead of powers of 10, it uses powers of 2.\nConsider the binary number 1011:\nThe rightmost bit denotes \\(1 \\times 2^0 = 1\\). The subsequent bit stands for \\(1 \\times 2^1 = 2\\). Next up is \\(0 \\times 2^2 = 0\\). The leftmost bit in this number signifies \\(1 \\times 2^3 = 8\\). Thus, 1011 in binary translates to the following in the decimal system:\n$$1011 = 1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 = 8 + 0 + 2 + 1 = 11$$ Hexadecimal system: bridging humans and machines While the binary system is perfect for machines, it can get a tad cumbersome for us, especially when dealing with lengthy binary numbers. Here is where the hexadecimal system, employing sixteen distinct digits: 0-9 and A-F, with A representing 10, B as 11, and so forth, up to F, which stands for 153 comes to help.\nHexadecimal proves invaluable as it offers a more compact way to represent binary numbers. Each hexadecimal digit corresponds precisely to four binary bits. For instance, think of the binary representation of the number 41279 and notice how the hexadecimal system achieves a more succinct representation:\n$$41279 = 1010 0001 0011 1111 = A13F$$But the hexadecimal system is more than just a compressed representation of binary numbers; it’s a positional numbering system like decimal or binary but based on 16 instead of 10 or 2. Let’s see how to derive the decimal representation of the example number (A13F):\nThe rightmost digit represents \\(F \\times 16^0 = 15 \\times 16^0 = 15\\). The subsequent one stands for \\(3 \\times 16^1 = 48\\). The next digit denotes \\(1 \\times 16^2 = 256\\). The leftmost digit in this number signifies \\(A \\times 16^3 = 10 \\times 16^3 = 40960\\). Therefore, A13F in hexadecimal translates to the following in the decimal system:\n$$A13F = A \\times 16^3 + 1 \\times 16^2 + 3 \\times 16^1 + F \\times 16^0 = 10 \\times 4096 + 1 \\times 256 + 3 \\times 16 + 15 \\times 1 = 40960 + 256 + 48 + 15 = 41279$$ Conclusion Numbering systems are like lenses through which we perceive and understand the world of mathematics and computing. Although the decimal system may be the linchpin of our daily existence, it’s crucial to appreciate and comprehend the binary and hexadecimal systems, especially in this digital age.\nSo, the next time you’re in front of your computer or using an app on your smartphone, remember that behind that user-friendly interface, a binary world is in full swing, with the hexadecimal system acting as a translator between that realm and us.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe’re keen to hear your thoughts, so don’t be shy – drop your comments, suggestions, and those bright ideas you’re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we’ve cooked up for you. You’ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences\nIfrah, G. (2000). The Universal History of Numbers. London: Harvill Press. ↩︎\nTanenbaum, A. (2012). Structured Computer Organization. New Jersey: Prentice Hall. ↩︎\nKnuth, D. (2007). The Art of Computer Programming: Seminumerical Algorithms. California: Addison-Wesley. ↩︎\n","categories":"","description":"Every day, we're surrounded by numbers. From the alarm clock's digits waking us up in the morning to the price of our favorite morning coffee. But, have you ever stopped to ponder the essence of these numbers? In this article, we will dive deep into the captivating world of numbering systems, unraveling how one number can have myriad representations depending on the context.\n","excerpt":"Every day, we're surrounded by numbers. From the alarm clock's digits …","ref":"/en/programming/0100-intro/0102-numerical-systems/","tags":["intro","programming","numerical-systems","decimal","binary","hexadecimal"],"title":"Numerical Systems"},{"body":"El sistema decimal: la base de nuestra cotidianidad Desde pequeños, nos enseñan a contar usando diez dígitos: del 0 al 9. Este sistema, conocido como decimal, es la base de casi todas nuestras actividades matemáticas y financieras, desde sumar cuentas hasta calcular intereses en el banco1. Tiene su origen en la cantidad de dedos que tenemos en las manos, lo que lo convierte en el sistema más intuitivo y natural para nosotros. Pero lo que lo hace especial es su naturaleza posicional.\nPara comprender este concepto, consideremos el número 237:\nEl 7, situado a la derecha, está en la posición de las unidades. Es decir, \\(7 \\times 10^0\\) (cualquier número elevado a la potencia de 0 es 1). Por lo tanto, su valor es simplemente 7. El 3, en la posición del medio, representa las decenas, es decir, \\(3 \\times 10^1 = 3 \\times 10 = 30\\). El 2, el número más a la izquierda, está en la posición de las centenas, traduciéndose a \\(2 \\times 10^2 = 2 \\times 100 = 200\\). Si sumamos estos valores,\n$$2 \\times 10^2 + 3 \\times 10^1 + 7 \\times 10^0 = 200 + 30 + 7 = 237$$ El sistema binario: el lenguaje secreto de las computadoras Si bien el sistema decimal domina nuestra vida cotidiana, las máquinas que usamos todos los días, desde nuestros celulares hasta las computadoras, operan en un mundo completamente diferente: el mundo binario. En este sistema, solo existen dos dígitos: 0 y 1. A primera vista, puede parecer limitante, pero este sistema es la esencia de la electrónica digital. Los dispositivos electrónicos, con sus millones de transistores, operan usando estos dos estados: encendido (1) y apagado (0)2.\nA pesar de su aparente simplicidad, el sistema binario puede representar cualquier cantidad o información que el sistema decimal pueda expresar. Por ejemplo, el número decimal 5 se representa como 101 en binario.\nEl sistema binario, con sus unos y ceros, opera de manera similar al sistema decimal, pero en lugar de potencias de 10, usa potencias de 2.\nTomemos el número binario 1011:\nEl bit más a la derecha representa \\(1 \\times 2^0 = 1\\) El siguiente bit representa \\(1 \\times 2^1 = 2\\) Luego viene \\(0 \\times 2^2 = 0\\) El bit más a la izquierda en este número representa \\(1 \\times 2^3 = 8\\) Entonces, 1011 en binario se traduce a decimal de la siguiente manera:\n$$1011 = 1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 = 8 + 0 + 2 + 1 = 11$$ El sistema hexadecimal: un puente entre humanos y máquinas Mientras que el sistema binario es perfecto para las máquinas, puede ser un poco engorroso para nosotros, especialmente cuando tratamos con números binarios largos. Aquí es donde entra el sistema hexadecimal, que utiliza dieciséis dígitos distintos: 0-9 y A-F, donde A representa 10, B es 11, y así sucesivamente hasta F que es 153.\nEl hexadecimal es especialmente útil porque proporciona una forma más compacta de representar números binarios. Cada dígito hexadecimal corresponde a exactamente cuatro dígitos binarios (bits). Por ejemplo pensemos en la representación en binario del número 41279 y como el sistema hexadecimal consigue una representación más compacta:\n$$41279 = 1010 0001 0011 1111 = A13F$$Pero el sistema hexadecimal es más que una representación compacta de números binarios, es un sistema de numeración posicional como el decimal o binario con base 16 en lugar de 10 o 2. Veamos como conseguir la representación decimal del número del ejemplo anterior (A13F).\nEl dígito más a la derecha representa \\(F \\times 16^0 = 15 \\times 16^0 = 15\\) El siguiente representa \\(3 \\times 16^1 = 48\\) Luego viene \\(1 \\times 16^2 = 256\\) El dígito más a la izquierda en este número representa \\(A \\times 16^3 = 10 \\times 16^3 = 40960\\) Entonces, A13F en hexadecimal se traduce a decimal de la siguiente manera:\n$$A13F = A \\times 16^3 + 1 \\times 16^2 + 3 \\times 16^1 + F \\times 16^0 = 10 \\times 4096 + 1 \\times 256 + 3 \\times 16 + 15 \\times 1 = 40960 + 256 + 48 + 15 = 41279$$ Conclusión Los sistemas de numeración son como lentes a través de los cuales vemos y entendemos el mundo de las matemáticas y la computación. Aunque en nuestra vida diaria el sistema decimal sea el rey, es esencial apreciar y comprender los sistemas binario y hexadecimal, especialmente en esta era digital.\nAsí que, la próxima vez que estés frente a tu computadora o usando una app en tu celular, recordá que detrás de esa interfaz amigable, hay un mundo binario en pleno funcionamiento, y que el sistema hexadecimal actúa como un traductor entre ese mundo y nosotros.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias Ifrah, G. (2000). Historia universal de las cifras. Buenos Aires: Editorial Taurus. ↩︎\nTanenbaum, A. (2012). Estructura de Computadoras. Buenos Aires: Prentice Hall. ↩︎\nKnuth, D. (2007). El Arte de Programar Computadoras: Sistemas de numeración. Buenos Aires: Ediciones Omega. ↩︎\n","categories":"","description":"En nuestro día a día, estamos rodeados de números. Desde la hora que marca el reloj cuando suena la alarma por la mañana, hasta el precio del café que compramos en la esquina. Pero, ¿alguna vez te detuviste a pensar en la naturaleza de esos números? En este artículo, nos sumergiremos en el fascinante mundo de los sistemas de numeración y aprenderemos cómo, dependiendo del contexto, un número puede tener múltiples representaciones.\n","excerpt":"En nuestro día a día, estamos rodeados de números. Desde la hora que …","ref":"/es/programming/0100-intro/0102-numerical-systems/","tags":["intro","programming","sistemas-numeracion","decimal","binario","hexadecimal"],"title":"Sistemas de Numeración"},{"body":"Named in honour of George Boole, a 19th-century English mathematician, Boolean logic is a mathematical system that deals with operations resulting in one of two possible outcomes: true or false, typically represented as 1 and 0, respectively1. In his groundbreaking work, “An Investigation of the Laws of Thought,” Boole laid the foundations for this logic, introducing an algebraic system that could be employed to depict logical structures.\nBoolean operations Within Boolean logic, several fundamental operations allow for the manipulation and combination of these binary expressions:\nAND: This operation yields true (1) only if both inputs are true. For instance, if you have two switches, both need to be in the on position for a light to illuminate.\nOR: It returns true if at least one of the inputs is true. Using the switch analogy, as long as one of them is in the on position, the light will shine.\nNOT: This unary operation (accepting only one input) simply inverts the input value. Provide it with a 1, and you’ll get a 0, and vice versa.\nNAND (NOT AND): It’s the negation of AND. It only returns false if both inputs are true.\nNOR (NOT OR): The negation of OR. It yields true only if both inputs are false.\nXOR (Exclusive OR): It returns true if the inputs differ. If both are the same, it returns false.\nXNOR (Exclusive NOR): The inverse of XOR. It yields true if both inputs are the same.\nWhy is this logic important in computing and programming? Modern computing, at its core, is all about bit manipulation (those 1s and 0s we’ve mentioned). Every operation a computer undertakes, from basic arithmetic to rendering intricate graphics, involves Boolean operations at some level2.\nIn programming, Boolean logic is used in control structures, such as conditional statements (if, else) and loops, allowing programs to make decisions based on specific conditions.\nTruth Tables: mapping Boolean logic A truth table graphically represents a Boolean operation. It lists every possible input combination and displays the operation’s result for each combination3.\nFor instance:\nA B A AND B A OR B A XOR B A NOR B A NAND B NOT A A NXOR B 1 1 1 1 0 0 0 0 1 1 0 0 1 1 0 1 0 0 0 1 0 1 1 0 1 1 0 0 0 0 0 0 1 1 1 1 Concluding thoughts Boolean logic is more than a set of abstract mathematical rules. It’s the foundational language of machines, the code underpinning the digital age in which we live. By understanding its principles, not only do we become more proficient in working with technology, but we also gain a deeper appreciation of the structures supporting our digital world.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe’re keen to hear your thoughts, so don’t be shy – drop your comments, suggestions, and those bright ideas you’re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we’ve cooked up for you. You’ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences Boole, G. (1854). An Investigation of the Laws of Thought. London: Walton and Maberly. ↩︎\nTanenbaum, A. (2012). Structured Computer Organization. New Jersey: Prentice Hall. ↩︎\nMinsky, M. (1967). Computation: Finite and Infinite Machines. New Jersey: Prentice-Hall. ↩︎\n","categories":"","description":"In life, we often seek certainties. Will it rain tomorrow, true or false? Is a certain action right or wrong? This dichotomy, this division between two opposing states, lies at the very core of a fundamental branch of mathematics and computer science: Boolean logic.\n","excerpt":"In life, we often seek certainties. Will it rain tomorrow, true or …","ref":"/en/programming/0100-intro/0103-boolean-logic/","tags":["intro","programming","boolean-logic"],"title":"Boolean Logic"},{"body":"La lógica booleana, nombrada en honor a George Boole, un matemático inglés del siglo XIX, es un sistema matemático que se ocupa de operaciones que tienen solo dos resultados posibles: verdadero o falso, representados generalmente como 1 y 0, respectivamente1. En su obra “An Investigation of the Laws of Thought”, Boole estableció las bases de esta lógica, presentando un sistema algebraico que podría utilizarse para representar estructuras lógicas.\nOperaciones Booleanas Dentro de la lógica booleana, existen operaciones fundamentales que permiten manipular y combinar estas expresiones binarias:\nAND (Y): Esta operación devuelve verdadero (1) solo si ambas entradas son verdaderas. Por ejemplo, si tenemos dos interruptores, ambos deben estar en la posición encendido para que una luz se encienda.\nOR (O): Devuelve verdadero si al menos una de las entradas es verdadera. Siguiendo con el ejemplo de los interruptores, con que uno de ellos esté encendido, la luz se iluminará.\nNOT (NO): Es una operación unaria, lo que significa que solo tiene una entrada. Simplemente invierte el valor de entrada. Si le das un 1, devuelve un 0 y viceversa.\nNAND (NO Y): Es la negación de AND. Solo devuelve falso si ambas entradas son verdaderas.\nNOR (NO O): Es la negación de OR. Devuelve verdadero solo si ambas entradas son falsas.\nXOR (O exclusivo): Devuelve verdadero si las entradas son diferentes. Si ambas son iguales, devuelve falso.\nXNOR (NO O exclusivo): Es la negación de XOR. Devuelve verdadero si ambas entradas son iguales.\nLa importancia de esta lógica en computación y programación La computación moderna, en su esencia, es la manipulación de bits, esos unos y ceros que mencionamos. Cada operación que realiza una computadora, desde simples cálculos hasta la renderización de gráficos complejos, implica operaciones booleanas en algún nivel2.\nEn programación, la lógica booleana se utiliza en estructuras de control, como condiciones (if, else) y bucles, permitiendo a los programas tomar decisiones basadas en ciertas condiciones.\nTablas de verdad: el mapa de la lógica Booleana Una tabla de verdad es una representación gráfica de una operación booleana. Enumera todas las combinaciones posibles de entradas y muestra el resultado de la operación para cada combinación3.\nPor ejemplo,\nA B A AND B A OR B A XOR B A NOR B A NAND B NOT A A NXOR B 1 1 1 1 0 0 0 0 1 1 0 0 1 1 0 1 0 0 0 1 0 1 1 0 1 1 0 0 0 0 0 0 1 1 1 1 Conclusiones La lógica booleana es mucho más que un conjunto de reglas matemáticas abstractas. Es el lenguaje fundamental de las máquinas, el código que subyace a la era digital en la que vivimos. Al comprender sus principios, no solo nos volvemos más adeptos a trabajar con tecnología, sino que también adquirimos una apreciación más profunda de las estructuras que sustentan nuestro mundo digital.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias Boole, G. (1854). An Investigation of the Laws of Thought. Londres: Walton and Maberly. ↩︎\nTanenbaum, A. (2012). Estructura de Computadoras. Buenos Aires: Prentice Hall. ↩︎\nMinsky, M. (1967). Computation: Finite and Infinite Machines. Buenos Aires: Prentice-Hall. ↩︎\n","categories":"","description":"En la vida, a menudo buscamos certezas. ¿Es cierto o falso que va a llover mañana? ¿Es correcto o incorrecto actuar de cierta manera? Esta dicotomía, esta división entre dos estados opuestos, se encuentra en el núcleo mismo de una rama esencial de las matemáticas y la informática: la lógica booleana.\n","excerpt":"En la vida, a menudo buscamos certezas. ¿Es cierto o falso que va a …","ref":"/es/programming/0100-intro/0103-boolean-logic/","tags":["intro","programming","boolean-logic"],"title":"Lógica Booleana"},{"body":" Elegir un lenguaje de programación La elección del lenguaje de programación es el primer y quizás el más crucial paso en el proceso de aprendizaje. Hay varios factores a considerar al seleccionar un lenguaje, incluyendo:\nPropósito: ¿Para qué quieres programar? Si es para desarrollo web, JavaScript o PHP podrían ser buenas opciones. Si estás interesado en la ciencia de datos, R o Python podrían ser más adecuados. Comunidad: Un lenguaje con una comunidad activa puede ser esencial para los principiantes. Una comunidad vibrante generalmente significa más recursos, tutoriales y soluciones disponibles en línea. Curva de aprendizaje: Algunos lenguajes son más fáciles de aprender que otros. Es fundamental elegir uno que coincida con tu nivel de experiencia y paciencia. Oportunidades de trabajo: Si estás buscando una carrera en programación, investigar la demanda del mercado para diferentes lenguajes puede ser útil. Aunque hay muchos lenguajes valiosos y poderosos, para este curso, hemos elegido Python. Este lenguaje es conocido por su simplicidad y legibilidad, lo que lo hace ideal para aquellos que están empezando. Además, Python cuenta con una comunidad activa y una amplia gama de aplicaciones, desde desarrollo web hasta inteligencia artificial1.\nInstalación de Python Para usuarios de Windows: Descargar el instalador: Visita el sitio web oficial de Python en https://www.python.org/downloads/windows/ Haz clic en el enlace de descarga para la última versión de Python 3.x. Ejecuta el instalador: Una vez completada la descarga, localiza y ejecuta el archivo instalador .exe. Asegúrate de marcar la casilla que dice “Agregar Python al PATH” durante la instalación. Este paso es crucial para hacer que Python sea accesible desde el Símbolo del Sistema. Sigue las indicaciones de instalación. Verifica la instalación: Abre el Símbolo del Sistema y escribe: python --version Esto debería mostrar la versión de Python que acabas de instalar. Para usuarios de Mac: Descargar el instalador: Visita el sitio web oficial de Python en https://www.python.org/downloads/mac-osx/ Haz clic en el enlace de descarga para la última versión de Python 3.x. Ejecuta el instalador: Una vez descargado, localiza y ejecuta el archivo .pkg. Sigue las indicaciones de instalación. Verifica la instalación: Abre la Terminal y escribe: python3 --version Esto debería mostrar la versión de Python que acabas de instalar. Para usuarios de Linux (Ubuntu/Debian): Actualiza los paquetes: sudo apt update Instala Python: sudo apt install python3 Verifica la instalación: Después de la instalación, puedes comprobar la versión de Python instalada escribiendo: python3 --version Entornos de Desarrollo Integrado (IDEs) Un IDE es una herramienta que facilita el desarrollo de aplicaciones al combinar comúnmente utilizadas en un solo software: editor de código, compilador, depurador, entre otros. Elegir el IDE adecuado puede hacer que el proceso de programación sea más fluido y eficiente.\nAl evaluar IDEs, considera:\nCompatibilidad con el lenguaje: No todos los IDEs son compatibles con todos los lenguajes de programación. Características: Algunos IDEs ofrecen funcionalidades como autocompletado, resaltado de sintaxis y herramientas de depuración. Extensiones y plugins: La posibilidad de personalizar y extender tu IDE a través de plugins puede ser muy útil. Precio: Hay IDEs gratuitos y otros de pago. Evalúa si las características adicionales de un IDE de pago justifican el costo. Para este curso, hemos seleccionado Visual Studio Code (VS Code). Es un IDE popular que es gratuito y de código abierto. Es conocido por su interfaz sencilla, amplia gama de plugins y capacidad para manejar múltiples lenguajes de programación2. Su comunidad activa garantiza actualizaciones regulares y una amplia gama de recursos de aprendizaje.\nInstalación de Visual Studio Code Para usuarios de Windows: Descargar el instalador: Visita el sitio web oficial de VS Code en https://code.visualstudio.com/ Haz clic en el botón “Descargar para Windows”. Ejecuta el instalador: Una vez completada la descarga, localiza y ejecuta el archivo instalador .exe. Sigue las indicaciones de instalación, incluyendo aceptar el acuerdo de licencia y elegir la ubicación de instalación. Inicia VS Code: Tras la instalación, puedes encontrar VS Code en tu menú de inicio. Lánzalo, ¡y estarás listo para comenzar a programar! Para usuarios de Mac: Descargar el instalador: Visita el sitio web oficial de VS Code en https://code.visualstudio.com/ Haz clic en el botón “Descargar para Mac”. Instala VS Code: Una vez descargado, abre el archivo .zip. Arrastra la aplicación Visual Studio Code .app a la carpeta Aplicaciones, para que esté disponible en el Launchpad. Inicia VS Code: Usa la búsqueda de Spotlight o navega hasta tu carpeta de Aplicaciones para iniciar VS Code. Para usuarios de Linux (Ubuntu/Debian): Actualiza los paquetes e instala las dependencias: sudo apt update sudo apt install software-properties-common apt-transport-https wget **Descarga e instala la claves necesarias: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Añade el repositorio de VS Code: sudo add-apt-repository \"deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main\" Instala Visual Studio Code: sudo apt update sudo apt install code Inicia VS Code: Puedes iniciar VS Code desde la terminal escribiendo code o encontrarlo en tu lista de aplicaciones instaladas. Escribe y ejecuta tu primer programa Una vez que hayas configurado tu entorno de programación, es hora de sumergirse en la codificación.\n¡Hola mundo! Este es posiblemente el programa más icónico para principiantes. Es simple, pero te introduce al proceso de escribir y ejecutar código.\nprint(\"¡Hola mundo!\") Ejecución del programa Hola Mundo\nCálculo de área y perímetro de un triángulo Este programa es un poco más complejo. No solo imprime un mensaje, sino que también realiza cálculos matemáticos.\n# Entrada del usuario lado1 = float(input(\"Introduce la longitud del primer lado: \")) lado2 = float(input(\"Introduce la longitud del segundo lado: \")) lado3 = float(input(\"Introduce la longitud del tercer lado: \")) # Cálculo del perímetro perimetro = lado1 + lado2 + lado3 # Cálculo del área usando la fórmula de Herón s = perimetro / 2 area = (s*(s-lado1)*(s-lado2)*(s-lado3)) ** 0.5 print(f\"El perímetro del triángulo es: {perimetro}\") print(f\"El área del triángulo es: {area:.2f}\") Ejecución del programa Triangulo\nConclusión Configurar un entorno de programación puede parecer desalentador al principio, pero con las herramientas y recursos adecuados, se convierte en una tarea manejable y gratificante. Esperamos que este artículo te haya proporcionado una base sólida para comenzar tu viaje en programación. ¡Feliz codificación!\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias Lutz, M. (2013). Learning Python. O’Reilly Media. ↩︎\nMicrosoft. (2020). Visual Studio Code Documentation. Microsoft Docs. ↩︎\n","categories":"","description":"Adentrarse en el mundo de la programación puede parecer una tarea titánica, especialmente cuando te encuentras frente a la decisión inicial: ¿por dónde empezar? Este artículo te guiará a través de los pasos esenciales para configurar tu entorno de programación, garantizando una base sólida para tu viaje codificador.\n","excerpt":"Adentrarse en el mundo de la programación puede parecer una tarea …","ref":"/es/programming/0100-intro/0104-setup-dev-environment/","tags":["intro","programming","ide","python","install","tools"],"title":"Configura tu Entorno de Desarrollo"},{"body":" Choosing a programming language Choosing a programming language is the first and perhaps the most crucial step in the learning process. Several factors to consider when selecting a language include:\nPurpose: What do you want to code for? If it’s web development, JavaScript or PHP might be good options. If you’re into data science, R or Python might be more appropriate. Community: A language with an active community can be vital for beginners. A vibrant community usually means more resources, tutorials, and solutions available online. Learning curve: Some languages are easier to pick up than others. It’s essential to pick one that matches your experience level and patience. Job opportunities: If you’re eyeing a career in programming, researching the job market demand for various languages can be insightful. While there are many valuable and potent languages, for the purpose of this course, we’ve chosen Python. This language is renowned for its simplicity and readability, making it ideal for those just starting out. Moreover, Python boasts an active community and a wide range of applications, from web development to artificial intelligence1.\nInstalling Python For Windows users: Download the installer: Visit the official Python website at https://www.python.org/downloads/windows/ Click on the download link for the latest version of Python 3.x. Run the installer: Once the download is complete, locate and run the installer .exe file. Make sure to check the box that says “Add Python to PATH” during installation. This step is crucial for making Python accessible from the Command Prompt. Follow the installation prompts. Verify installation: Open the Command Prompt and type: python --version This should display the version of Python you just installed. For Mac users: Download the installer: Visit the official Python website at https://www.python.org/downloads/mac-osx/ Click on the download link for the latest version of Python 3.x. Run the installer: Once the download is complete, locate and run the .pkg file. Follow the installation prompts. Verify installation: Open the Terminal and type: python3 --version This should display the version of Python you just installed. For Linux (Ubuntu/Debian) users: Update packages: sudo apt update Install Python: sudo apt install python3 Verify installation: After installation, you can check the version of Python installed by typing: python3 --version Integrated Development Environments (IDEs) An IDE is a tool that streamlines application development by combining commonly-used functionalities into a single software package: code editor, compiler, debugger, and more. Choosing the right IDE can make the programming process more fluid and efficient.\nWhen evaluating IDEs, consider:\nLanguage compatibility: Not all IDEs are compatible with every programming language. Features: Some IDEs offer features like auto-completion, syntax highlighting, and debugging tools. Extensions and plugins: Being able to customize and extend your IDE through plugins can be extremely beneficial. Price: There are free and paid IDEs. Evaluate whether the additional features of a paid IDE justify its cost. For this course, we’ve selected Visual Studio Code (VS Code). It’s a popular IDE that’s free and open-source. It’s known for its straightforward interface, a vast array of plugins, and its capability to handle multiple programming languages2. Its active community ensures regular updates and a plethora of learning resources.\nInstalling Visual Studio Code For Windows users: Download the installer: Visit the official VS Code website at https://code.visualstudio.com/ Click on the “Download for Windows” button. Run the installer: Once the download is complete, locate and run the installer .exe file. Follow the installation prompts, including accepting the license agreement and choosing the installation location. Launch VS Code: After installation, you can find VS Code in your Start menu. Launch it, and you’re ready to start coding! For Mac users: Download the installer: Visit the official VS Code website at https://code.visualstudio.com/ Click on the “Download for Mac” button. Install VS Code: Once the download is complete, open the downloaded .zip file. Drag the Visual Studio Code .app to the Applications folder, making it available in the Launchpad. Launch VS Code: Use Spotlight search or navigate to your Applications folder to launch VS Code. For Linux (Ubuntu/Debian) users: Update packages and install dependencies: sudo apt update sudo apt install software-properties-common apt-transport-https wget Download and install the key: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Add the VS Code repository: sudo add-apt-repository \"deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main\" Install Visual Studio Code: sudo apt update sudo apt install code Launch VS Code: You can start VS Code from the terminal by typing code or find it in your list of installed applications. Write and execute your first program Once you’ve set up your programming environment, it’s time to dive into coding.\nHello, World! This is arguably the most iconic program for beginners. It’s simple, but it introduces you to the process of writing and executing code.\nprint(\"Hello, World!\") Running the Hello World program\nTriangle area and perimeter calculation This program is a tad more intricate. It doesn’t just print out a message; it also performs mathematical calculations.\n# User input side1 = float(input(\"Enter the length of the first side: \")) side2 = float(input(\"Enter the length of the second side: \")) side3 = float(input(\"Enter the length of the third side: \")) # Perimeter calculation perimeter = side1 + side2 + side3 # Area calculation using Heron's formula s = perimeter / 2 area = (s*(s-side1)*(s-side2)*(s-side3)) ** 0.5 print(f\"The triangle's perimeter is: {perimeter}\") print(f\"The triangle's area is: {area:.2f}\") Running the Triangle program\nConclusion Setting up a programming environment might appear daunting at first, but with the right tools and resources, it becomes a manageable and rewarding task. We hope this article provided you with a solid foundation to kickstart your programming journey. Happy coding!\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe’re keen to hear your thoughts, so don’t be shy – drop your comments, suggestions, and those bright ideas you’re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we’ve cooked up for you. You’ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences Lutz, M. (2013). Learning Python. O’Reilly Media. ↩︎\nMicrosoft. (2020). Visual Studio Code Documentation. Microsoft Docs. ↩︎\n","categories":"","description":"Venturing into the world of programming might seem like a Herculean task, especially when faced with the initial decision: Where to begin? This article will guide you through the essential steps to set up your programming environment, ensuring a solid foundation for your coding journey.\n","excerpt":"Venturing into the world of programming might seem like a Herculean …","ref":"/en/programming/0100-intro/0104-setup-dev-environment/","tags":["intro","programming","python","install","tools"],"title":"Set Up your Development Environment"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/programming/0200-starting-concepts/","tags":"","title":"Conceptos Iniciales"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/programming/0200-starting-concepts/","tags":"","title":"Starting Concepts"},{"body":"Variables A variable is a container to store data in the computer’s memory. We can think of it as a box with a label. The label is the variable name and inside the box its value is stored.\nTo declare a variable in Python we just write the name and assign a value:\nage = 28 price = 19.95 student = True Variable names must start with letters or underscore, and can only contain letters, numbers and underscores. It is recommended to use meaningful names that represent the purpose of the variable.\nIn Python variables do not need to be declared with a particular type. The type is inferred automatically when assigning the value:\nage = 28 # age is integer type price = 19.95 # price is float type single = True # single is boolean type Once assigned, a variable can change its value at any time:\nage = 30 # We change age to 30 Scope and lifetime The scope of a variable refers to the parts of the code where it is available. Variables declared outside functions are global and available throughout the file. Variables inside a function are local and only visible within it.\nThe lifetime is the period during which the variable exists in memory. Local variables exist while the function executes, then they are destroyed. Global variables exist while the program is running.\nAssignment Assignment with the = operator allows changing or initializing a variable’s value:\nnumber = 10 number = 20 # Now number is 20 There are also compound assignment operators like += and -= that combine an operation with assignment:\nnumber += 5 # Adds 5 to number (number = number + 5) number -= 2 # Subtracts 2 from number Data types Data types define what kind of value a variable can store. Python has several built-in types, including:\nNumerical: To store integer, float, and complex numeric values:\ninteger = 10 float = 10.5 complex = 3 + 4j Strings: To store text:\ntext = \"Hello World\" Boolean: For True or False logical values:\ntrue_variable = True false_variable = False Collections: To store multiple values like lists, tuples and dictionaries:\nLists: Mutable sequences of values:\nlist = [1, 2, 3] Tuples: Immutable sequences of values:\ntuple = (1, 2, 3) Dictionaries: Key-value pair structures:\ndictionary = {\"name\":\"John\", \"age\": 20} It is important to choose the data type that best represents the information we want to store.\nOperators Operators allow us to perform operations with values and variables in Python. Some common operators are:\nArithmetic: +, -, *, /, %, //, **\nComparison: ==, !=, \u003e, \u003c, \u003e=, \u003c=\nLogical: and, or, not\nAssignment: =, +=, -=, *=, /=\nLet’s see concrete examples of expressions using these operators in Python:\n# Arithmetic 5 + 4 # Addition, result 9 10 - 3 # Subtraction, result 7 4 * 5 # Multiplication, result 20 # Comparison 5 \u003e 4 # Greater than, result True 7 \u003c 10 # Less than, result True # Logical True and False # Result False True or False # Result True not True # Result False # Assignment number = 10 number += 5 # Adds 5 to number, equivalent to number = number + 5 Each type of operator works with specific data types. We must use them consistently according to our variable data types.\nType conversions Sometimes we need to convert one data type to another to perform certain operations. In Python we can convert explicitly or implicitly:\nExplicit: Using functions like int(), float(), str():\nfloat = 13.5 integer = int(float) # converts 13.5 to 13 text = \"100\" number = int(text) # converts \"100\" to 100 Implicit: Python automatically converts in some cases:\ninteger = 100 float = 3.5 result = integer + float # result is 103.5, integer converted to float Some conversions can generate data loss or errors:\nfloat = 13.5 integer = int(float) print(integer) # 13, decimals are lost To prevent this we must explicitly choose conversions that make sense for our data.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe’re keen to hear your thoughts, so don’t be shy – drop your comments, suggestions, and those bright ideas you’re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we’ve cooked up for you. You’ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nConclusion In this article we reviewed key concepts like variables, operators, data types and conversions in Python. Applying these concepts well will allow you to efficiently manipulate data in your programs. I recommend practising with your own examples to gain experience using these features. Good luck in your Python learning!\n","categories":"","description":"Understanding how variables and data types work is essential to master any programming language. In this article we will review the basic concepts of variables, operators, data types and type conversions using the Python language. We will cover both theory and practical examples so you can apply these concepts in your own programs.\n","excerpt":"Understanding how variables and data types work is essential to master …","ref":"/en/programming/0200-starting-concepts/0201-variables-data-types/","tags":["intro","programming","variables","data-types"],"title":"Variables and Data Types"},{"body":"Variables Una variable es un contenedor para almacenar datos en la memoria de la computadora. Podemos pensar en ella como una caja con una etiqueta. La etiqueta es el nombre de la variable y dentro de la caja se almacena su valor.\nPara declarar una variable en Python solo escribimos el nombre y le asignamos un valor:\nedad = 28 precio = 19.95 soltero = True Los nombres de variables deben comenzar con letras o guión bajo, y sólo pueden contener letras, números y guiones bajos. Se recomienda usar nombres significativos que representen el propósito de la variable.\nEn Python las variables no necesitan ser declaradas con un tipo particular. El tipo se infiere automáticamente al asignar el valor:\nedad = 28 # edad es de tipo entero (int) precio = 19.95 # precio es de tipo float estudiante = True # soltero es de tipo booleano Una vez asignada, una variable puede cambiar su valor en cualquier momento:\nedad = 30 # Cambiamos edad a 30 Alcance y tiempo de vida El alcance de una variable se refiere a las partes del código donde está disponible. Las variables declaradas fuera de funciones son globales y están disponibles en todo el archivo. Las variables dentro de una función son locales y solo visibles dentro de ella.\nEl tiempo de vida es el período durante el cual existe la variable en memoria. Las variables locales existen mientras se ejecuta la función, luego son destruidas. Las globales existen mientras el programa está en ejecución.\nAsignación La asignación con el operador = permite cambiar o inicializar el valor de una variable:\nnumero = 10 numero = 20 # Ahora numero vale 20 También existen los operadores de asignación compuesta como += y -= que combinan una operación y asignación:\nnumero += 5 # Suma 5 a numero (numero = numero + 5) numero -= 2 # Resta 2 a numero Tipos de datos Los tipos de datos definen el tipo de valor que puede almacenar una variable. Python tiene varios tipos incorporados, incluyendo:\nNuméricos: Para almacenar valores numéricos como enteros, flotantes, complejos:\nentero = 10 flotante = 10.5 complejo = 3 + 4j Cadenas: Para almacenar texto:\ntexto = \"Hola Mundo\" Booleano: Para valores lógicos Verdadero o Falso:\nvariable_verdadera = True variable_falsa = False Colecciones: Para almacenar múltiples valores como listas, tuplas y diccionarios:\nListas: Secuencias mutables de valores:\nlista = [1, 2, 3] Tuplas: Secuencias inmutables de valores:\ntupla = (1, 2, 3) Diccionarios: Estructuras de pares llave-valor:\ndiccionario = {\"nombre\":\"Juan\", \"edad\": 20} Es importante elegir el tipo de dato que mejor represente la información que queremos almacenar.\nOperadores Los operadores nos permiten realizar operaciones con valores y variables en Python. Algunos operadores comunes son:\nAritméticos: +, -, *, /, %, //, **\nComparación: ==, !=, \u003e, \u003c, \u003e=, \u003c=\nLógicos: and, or, not\nAsignación: =, +=, -=, *=, /=\nVeamos ejemplos concretos de expresiones usando estos operadores en Python:\n# Aritméticos 5 + 4 # Suma, resultado 9 10 - 3 # Resta, resultado 7 4 * 5 # Multiplicación, resultado 20 # Comparación 5 \u003e 4 # Mayor que, resultado Verdadero 7 \u003c 10 # Menor que, resultado Verdadero # Lógicos True and False # Resultado False True or False # Resultado True not True # Resultado False # Asignación numero = 10 numero += 5 # Suma 5 a numero, equivalente a numero = numero + 5 Cada tipo de operador trabaja con tipos de datos específicos. Debemos usarlos de forma consistente según el tipo de datos de nuestras variables.\nConversiones de tipo A veces necesitamos convertir un tipo de dato a otro para realizar ciertas operaciones. En Python podemos convertir de forma explícita o implícita:\nExplícita: Usando funciones como int(), float(), str():\nflotante = 13.5 entero = int(flotante) # convierte 13.5 a 13 texto = \"100\" numero = int(texto) # convierte \"100\" a 100 Implícita: Python convierte automáticamente en algunos casos:\nentero = 100 flotante = 3.5 resultado = entero + flotante # resultado es 103.5, entero se convirtió a float Algunas conversiones pueden generar pérdida de datos o errores:\nflotante = 13.5 entero = int(flotante) print(entero) # 13, se pierden los decimales Para prevenir esto debemos elegir explícitamente conversiones que tengan sentido para nuestros datos.\nConclusión En este artículo revisamos conceptos clave como variables, operadores, tipos de datos y conversiones en Python. Aplicar bien estos conceptos te permitirá manipular datos de forma eficiente en tus programas. Recomiendo practicar con ejemplos propios para ganar experiencia en usar estas características. ¡Éxitos en tu aprendizaje de Python!\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\n","categories":"","description":"Entender cómo funcionan las variables y los tipos de datos es fundamental para dominar cualquier lenguaje de programación. En este artículo repasaremos los conceptos básicos sobre variables, operadores, tipos de datos y conversiones de tipo utilizando el lenguaje Python. Cubriremos tanto la teoría como ejemplos prácticos para que puedas aplicar estos conceptos en tus propios programas.\n","excerpt":"Entender cómo funcionan las variables y los tipos de datos es …","ref":"/es/programming/0200-starting-concepts/0201-variables-data-types/","tags":["intro","programming","variables","data-types"],"title":"Variables y Tipos de Datos"},{"body":"Screen output Python also provides functions to send program output to “standard output”, usually the screen or terminal1.\nThe print() function displays the value passed as a parameter:\nname = \"Eric\" print(name) # displays \"Eric\" We can print multiple values separated by commas2:\nprint(\"Hello\", name, \"!\") # displays \"Hello Eric!\" We can also use literal values without assigning to variables3:\nprint(\"2 + 3 =\", 2 + 3) # displays \"2 + 3 = 5\" Output formatting Python provides various ways to format output4:\nf-Strings: Allow inserting variables into a string:\nname = \"Eric\" print(f\"Hello {name}\") # displays \"Hello Eric\" %s: Inserts string text into a format string:\nname = \"Eric\" print(\"Hello %s\" % name) # displays \"Hello Eric\" %d: Inserts integer numbers:\nvalue = 15 print(\"The value is %d\" % value) # displays \"The value is 15\" .format(): Inserts values into a format string:\nname = \"Eric\" print(\"Hello {}. Welcome\".format(name)) # displays \"Hello Eric. Welcome\" These formatting options allow us to interpolate variables and values into text strings to generate custom outputs. We can combine multiple values and formats in a single output string2.\nKeyboard input Python provides built-in functions to read data entered by the user at runtime. This is known as “standard input”4.\nThe input() function allows reading a value entered by the user and assigning it to a variable. For example:\nname = input(\"Enter your name: \") This displays the message “Enter your name: \" and waits for the user to enter text and press Enter. That value is assigned to the name variable2.\nThe input() function always returns a string. If we want to ask for a number or other data type, we must convert it using int(), float(), etc1:\nage = int(input(\"Enter your age: \")) pi = float(input(\"Enter the value of pi: \")) Reading multiple values We can ask for and read multiple values on the same line separating them with commas3:\nname, age = input(\"Enter name and age: \").split() The split() method divides the input into parts and returns a list of strings. We then assign the list elements to separate variables.\nWe can also read multiple lines of input with a loop4:\nnames = [] # empty list for x in range(3): name = input(\"Enter a name: \") names.append(name) This code reads 3 names entered by the user and adds them to a list.\nOutput to a file In addition to printing to the screen, we can write output to a file using the open() function1:\nfile = open(\"data.txt\", \"w\") This opens data.txt for writing (“w”) and returns a file object.\nThen we use file.write() to write to that file3:\nfile.write(\"Hello World!\") file.write(\"This text goes to the file\") We must close the file with file.close() when finished4:\nfile.close() We can also use with to open and automatically close:\nwith open(\"data.txt\", \"w\") as file: file.write(\"Hello World!\") # no need to close, it's automatic Reading files To read a file we use open() in “r” mode and iterate over the file object1:\nwith open(\"data.txt\", \"r\") as file: for line in file: print(line) # prints each line of the file This prints each line, including newlines.\nWe can read all lines to a list with readlines()3:\nlines = file.readlines() print(lines) To read the full content to a string we use read()4:\ntext = file.read() print(text) We can also read a specific number of bytes or characters with read(n)2.\nFile handling operations There are several built-in functions to handle files in Python1:\nopen() - Opens a file and returns a file object close() - Closes the file write() - Writes data to the file read() - Reads data from the file readline() - Reads a line from the file truncate() - Empties the file seek() - Changes the reading/writing position rename() - Renames the file remove() - Deletes the file These allow us to perform advanced operations to read, write and maintain files.\nConclusion In this article we explained Python input and output operations in detail, including reading from standard input and writing to standard output or files. Properly handling input and output is essential for many Python applications. I recommend practising with your own examples to master these functions3.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe’re keen to hear your thoughts, so don’t be shy – drop your comments, suggestions, and those bright ideas you’re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we’ve cooked up for you. You’ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences McKinney, W. (2018). Python for data analysis: Data wrangling with Pandas, NumPy, and IPython. O’Reilly Media. ↩︎ ↩︎ ↩︎ ↩︎ ↩︎\nLutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O’Reilly Media, Incorporated. ↩︎ ↩︎ ↩︎ ↩︎\nMatthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. No Starch Press. ↩︎ ↩︎ ↩︎ ↩︎ ↩︎\nDowney, A. B. (2015). Think Python: How to think like a computer scientist. Needham, Massachusetts: Green Tea Press. ↩︎ ↩︎ ↩︎ ↩︎ ↩︎\n","categories":"","description":"Input/output operations (I/O) allow a program to communicate and exchange data with the outside world. In this article we will see in detail input operations from the keyboard or a file, and output to the screen or a file.\n","excerpt":"Input/output operations (I/O) allow a program to communicate and …","ref":"/en/programming/0200-starting-concepts/0202-io-operations/","tags":["intro","programming","input/output","I/O"],"title":"Input and output operations"},{"body":"Salida a pantalla Python también provee funciones para enviar la salida de un programa a la “salida estándar”, generalmente la pantalla o terminal1.\nLa función print() muestra el valor pasado como parámetro:\nnombre = \"Eric\" print(nombre) # muestra \"Eric\" Podemos imprimir múltiples valores separados por comas2:\nprint(\"Hola\", nombre, \"!\") # muestra \"Hola Eric!\" También podemos usar valores literales sin asignar a variables3:\nprint(\"2 + 3 =\", 2 + 3) # muestra \"2 + 3 = 5\" Formateo de salida Python provee varias formas de dar formato a la salida4:\nf-Strings: Permiten insertar variables dentro de una cadena:\nnombre = \"Eric\" print(f\"Hola {nombre}\") # muestra \"Hola Eric\" %s: Inserta cadenas de texto en una cadena de formato:\nnombre = \"Eric\" print(\"Hola %s\" % nombre) # muestra \"Hola Eric\" %d: Inserta números enteros:\nvalor = 15 print(\"El valor es %d\" % valor) # muestra \"El valor es 15\" .format(): Inserta valores en una cadena de formato:\nnombre = \"Eric\" print(\"Hola {}. Bienvenido\".format(nombre)) # muestra \"Hola Eric. Bienvenido\" Estas opciones de formateo nos permiten interpolar variables y valores en cadenas de texto para generar outputs personalizados. Podemos combinar múltiples valores y formateos en una sola cadena de salida2.\nEntrada desde el teclado Python provee funciones incorporadas para leer datos ingresados por el usuario en tiempo de ejecución. Esto se conoce como “entrada estándar”4.\nLa función input() permite leer un valor ingresado por el usuario y asignarlo a una variable. Por ejemplo:\nnombre = input(\"Ingresa tu nombre: \") Esto muestra el mensaje “Ingresa tu nombre: \" y espera a que el usuario escriba un texto y presione Enter. Ese valor se asigna a la variable nombre2.\nLa función input() siempre regresa una cadena de texto. Si queremos pedir un número u otro tipo de dato, debemos convertirlo usando int(), float(), etc1:\nedad = int(input(\"Ingresa tu edad: \")) pi = float(input(\"Ingresa el valor de pi: \")) Leyendo múltiples valores Podemos pedir y leer varios valores en una misma línea separándolos con comas3:\nnombre, edad = input(\"Ingresa nombre y edad: \").split() El método split() divide la entrada en partes y retorna una lista de cadenas. Luego asignamos los elementos de la lista a variables separadas.\nTambién podemos leer varias líneas de entrada con un ciclo4:\nnombres = [] # lista vacía for x in range(3): nombre = input(\"Ingresa un nombre: \") nombres.append(nombre) Este código lee 3 nombres ingresados por el usuario y los agrega a una lista.\nSalida a un archivo Además de imprimir a pantalla, podemos escribir la salida a un archivo usando la función open()1:\narchivo = open(\"datos.txt\", \"w\") Esto abre datos.txt para escritura (“w”) y retorna un objeto archivo.\nLuego usamos archivo.write() para escribir a ese archivo3:\narchivo.write(\"Hola mundo!\") archivo.write(\"Este texto va al archivo\") Debemos cerrar el archivo con archivo.close() cuando terminamos4:\narchivo.close() También podemos usar with para abrir y cerrar automáticamente2:\nwith open(\"datos.txt\", \"w\") as archivo: archivo.write(\"Hola mundo!\") # no hace falta cerrar, es automático Lectura de archivos Para leer un archivo usamos open() con modo “r” y iteramos sobre el objeto archivo1:\nwith open(\"datos.txt\", \"r\") as archivo: for linea in archivo: print(linea) # muestra cada línea del archivo Esto imprime cada línea, incluyendo los saltos de línea.\nPodemos leer todas las líneas a una lista con readlines()3:\nlinenas = archivo.readlines() print(linenas) Para leer el contenido completo a una cadena usamos read()4:\ntexto = archivo.read() print(texto) También podemos leer un número determinado de bytes o caracteres con read(n)2.\nOperaciones para el manejo de archivos Existen varias funciones incorporadas para manipular archivos en Python1:\nopen() - Abre un archivo y retorna un objeto archivo close() - Cierra el archivo write() - Escribe datos al archivo read() - Lee datos del archivo readline() - Lee una línea del archivo truncate() - Vacía el archivo seek() - Mueve la posición de lectura/escritura rename() - Renombra el archivo remove() - Elimina el archivo Estas funciones nos permiten efectuar operaciones avanzadas para leer, escribir y mantener archivos.\nConclusión En este artículo explicamos en detalle operaciones de entrada y salida en Python, incluyendo leer de entrada estándar y escribir a salida estándar o archivos. Manejar correctamente la entrada y salida es esencial para muchas aplicaciones de Python. Recomiendo practicar con ejemplos propios para dominar estas funciones3.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias McKinney, W. (2018). Python for data analysis: Data wrangling with Pandas, NumPy, and IPython. O’Reilly Media. ↩︎ ↩︎ ↩︎ ↩︎ ↩︎\nLutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O’Reilly Media, Incorporated. ↩︎ ↩︎ ↩︎ ↩︎ ↩︎\nMatthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. No Starch Press. ↩︎ ↩︎ ↩︎ ↩︎ ↩︎\nDowney, A. B. (2015). Think Python: How to think like a computer scientist. Needham, Massachusetts: Green Tea Press. ↩︎ ↩︎ ↩︎ ↩︎ ↩︎\n","categories":"","description":"Las operaciones de entrada y salida (input/output o I/O) permiten que un programa se comunique e intercambie datos con el mundo exterior. En este artículo veremos en detalle operaciones de entrada desde el teclado o un archivo, y salida hacia la pantalla o un archivo.\n","excerpt":"Las operaciones de entrada y salida (input/output o I/O) permiten que …","ref":"/es/programming/0200-starting-concepts/0202-io-operations/","tags":["intro","programming","input/output","I/O"],"title":"Operaciones de Entrada y Salida"},{"body":"Condiciones: tomando decisiones en el código La vida está llena de decisiones: “Si llueve, llevaré un paraguas. De lo contrario, usaré anteojos de sol”. Estas decisiones también están presentes en el mundo de la programación. Las condiciones son como preguntas que la computadora se hace. Nos permiten tomar decisiones y ejecutar código específico dependiendo de una condición1. Pueden ser simples como “¿Está lloviendo?” o complejas como “¿Es fin de semana y tengo menos de $100 en mi cuenta bancaria?”.\nif La estructura if nos permite evaluar condiciones y tomar decisiones basadas en el resultado de esa evaluación.\nedad = 15 if edad \u003e= 18: print(\"Eres mayor de edad\") El código anterior permite ejecutar una porción de código si la edad de una persona es mayo o igual a 18 años.\nif-else Cuando se desea ejecutar un código alternativo si la condición es falsa, utilizamos la estructura if-else\nedad = 21 if edad \u003e= 18: print(\"Eres mayor de edad\") else: print(\"Eres menor de edad\") En este caso, se determina si la persona es mayor de edad, o menor de edad, el mensaje mostrado es diferente\nif-elif-else Cuando las condiciones son múltiples y no es suficientes con dos caminos, se utiliza la estructura if-elif-else para evaluarlas forma encadenada.\nedad = 5 if edad \u003c= 13: print(\"Eres un niño\") elif edad \u003e 13 and edad \u003c 18: print(\"Eres un adolescente\") else: print(\"Eres un adulto\") En el código anterior se observan tres caminos claros, uno para cuando la edad es menor o igual a 13 años, otro para cuando la edad esta entre 13 y 18 y otro para cuando es mayor o igual a 18.\nOtra manera de resolver este problema es mediante la estructura switch-case, que, aunque Python no incorpora de manera nativa, como si lo hacen otros lenguajes como Java o C++, es una herramienta importante para conocer. Esta estructura permite a los programadores manejar múltiples condiciones de manera más organizada que una serie de if-elif-else.\nEn Java, por ejemplo:\nint dia = 3; switch(dia) { case 1: System.out.println(\"Lunes\"); break; case 2: System.out.println(\"Martes\"); break; case 3: System.out.println(\"Miércoles\"); break; // ... y así sucesivamente default: System.out.println(\"Día no válido\"); } En el ejemplo anterior, dependiendo del valor de dia, se imprimirá el día correspondiente2.\nBucles: repitiendo acciones A veces, en programación, necesitamos repetir una acción varias veces. En lugar de escribir el mismo código varias veces, podemos usar bucles. Estos, permiten repetir la ejecución de un bloque de código mientras se cumpla una condición3.\nwhile El bucle while es útil cuando queremos repetir una acción basada en una condición.\n# Imprime del 1 al 5 i = 1 while i \u003c= 5: print(i) i = i + 1 do-while Similar a while pero garantiza al menos una ejecución dado que primero se ejecuta el bloque de código y luego se evalúa la condición. Python no implementa esta estructura, pero otros lenguajes como Java y C++ sí lo hacen.\nint i = 1; do { System.out.println(i); i++; } while(i \u003c= 5); int numero = 0; do { std::cout \u003c\u003c \"Hola, mundo!\" \u003c\u003c std::endl; numero++; } while (numero \u003c 5); for El bucle for es útil cuando sabemos cuántas veces queremos repetir una acción.\nfor i in range(5): print(\"Hola, mundo!\") El código anterior imprimirá “Hola, mundo!” cinco veces.\nTambién podemos iterar sobre los elementos de una lista u objeto iterable:\nnombres = [\"María\", \"Florencia\", \"Julián\"] for nombre in nombres: print(f\"Hola {nombre}\") # Imprime # Hola María # Hola Florencia # Hola Julián Las sentencias break y continue Podemos usar break para terminar el bucle y continue para saltar a la siguiente iteración.\nEl break se usa para terminar completamente el bucle cuando se cumple una condición, en el ejemplo siguiente, cuando i llega a 5.\n# Ejemplo de break i = 0 while i \u003c 10: print(i) if i == 5: break i += 1 # Imprime: # 0 # 1 # 2 # 3 # 4 # 5 El continue se usa para saltarse una iteración del bucle y continuar con la siguiente cuando se cumple una condición. Aquí lo usamos para saltarnos los números pares.\n# Ejemplo de continue i = 0 while i \u003c 10: i += 1 if i % 2 == 0: continue print(i) # Imprime: # 1 # 3 # 5 # 7 # 9 Anidamiento: combinando estructuras Las estructuras de control de flujo pueden anidarse dentro de otras. Por ejemplo, podemos tener bucles dentro de bucles o condiciones dentro de bucles.\nfor i in range(5): for j in range(10): if (i % 2 == 0 and j % 3 == 0): print(f\"i = {i}, j = {j}\") Este código imprimirá combinaciones de i y j sólo cuando i sea divisible por 2 y j sea divisible por 3, demostrando cómo los bucles se anidan y se ejecutan3.\nPatrones de uso comunes Existen patrones específicos para resolver necesidades habituales con control de flujo.\nBúsqueda Buscar un valor en una colección:\nfrutas = [\"manzana\", \"naranja\"] buscando = \"naranja\" encontrado = False for fruta in frutas: if fruta == buscando: encontrado = True break if encontrado: print(\"Fruta encontrada!\") Acumulación Acumular valores incrementales en un bucle.\ntotal = 0 for i in range(10): total += i print(total) # Suma de 0..9 = 45 Diagramas de flujo: la ruta visual hacia el entendimiento del código Los programadores, sin importar si son principiantes o expertos, a menudo se encuentran enfrentando desafíos que requieren una planificación detallada antes de sumergirse en el código. Aquí es donde los diagramas de flujo entran en juego como una herramienta esencial. Estos diagramas son representaciones gráficas de los procesos y la lógica detrás de un programa o sistema. En este artículo, desentrañaremos el mundo de los diagramas de flujo, desde sus conceptos básicos hasta las técnicas avanzadas, y cómo pueden beneficiar a programadores de todos los niveles.\nUn diagrama de flujo es una representación gráfica de un proceso. Utiliza símbolos específicos para representar diferentes tipos de instrucciones o acciones. Su objetivo principal es simplificar la comprensión de un proceso, mostrando paso a paso cómo fluye la información o las decisiones. Estos diagramas:\nFacilitan la comprensión de procesos complejos. Ayudan en la fase de diseño y planificación de un programa. Sirven como documentación y referencia para futuros desarrollos. Los diagramas de flujo son una herramienta poderosa que no solo beneficia a los principiantes, sino también a los programadores experimentados. Ofrecen una visión clara y estructurada de un proceso o programa, facilitando la planificación, el diseño y la comunicación entre los miembros del equipo.\nElementos básicos Los diagramas de flujo constan de varios símbolos, cada uno con un significado específico:\nOvalo: Representa el inicio o el fin de un proceso. Rectángulo: Denota una operación o instrucción. Diamante: Indica una decisión basada en una condición. Flechas: Muestran la dirección del flujo. graph TD; start((Inicio)) process[Proceso] decision{¿Repetir?} final((Final)) start --\u003e process; process --\u003e decision; decision --\u003e |Si| process decision --\u003e |No| final Ejemplos Vamos a diseñar un diagrama de flujo para un programa que pida un número y nos diga si es par o impar.\ngraph TB inicio((Inicio)) entrada[Ingresar número] decision{¿Es par?} esPar[Es par] esImpar[Es impar] final((Final)) inicio --\u003e entrada entrada --\u003e decision decision --\u003e |Si| esPar decision --\u003e |No| esImpar esPar --\u003e final esImpar --\u003e final Conforme los programas se vuelven más complejos, es posible que necesites incorporar bucles, múltiples condiciones y otros elementos avanzados en tu diagrama de flujo. Por ejemplo, aquí diagramamos un programa que sume los números desde el 1 al número ingresado por el usuario.\ngraph TD inicio((Inicio)) entrada[Ingresar número] setVariables[Establecer suma=0 y contador=1] bucle_condicion{¿contador \u003c= N?} bucle_codigo[Sumar valor e incrementar el contador] resultado[Mostrar suma] final((Final)) inicio --\u003e entrada entrada --\u003e setVariables setVariables --\u003e bucle_condicion bucle_condicion --\u003e |Si| bucle_codigo bucle_codigo --\u003e bucle_condicion bucle_condicion --\u003e |No| resultado resultado --\u003e final Conclusión El control de flujo es el corazón de la programación. Sin él, los programas serían secuencias lineales de acciones sin la capacidad de tomar decisiones o repetir tareas. Al dominar estas estructuras, no solo mejoras tu capacidad para escribir código, sino también tu capacidad para pensar lógicamente y resolver problemas complejos.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O’Reilly Media, Incorporated. ↩︎\nDeitel, P., \u0026 Deitel, H. (2012). Java: How to program. Upper Saddle River, NJ: Prentice Hall. ↩︎\nMatthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. San Francisco, CA: No Starch Press. ↩︎ ↩︎\n","categories":"","description":"Cuando nos embarcamos en la emocionante travesía de aprender a programar, no tardamos en descubrir que la programación no es solo acerca de escribir código, sino también sobre cómo controlar el flujo de ese código. Podemos compararlo con el flujo de decisiones que tomamos en nuestra vida diaria. Por ejemplo, si hace frío afuera, nos ponemos un abrigo antes de salir. Si no tenemos tareas pendientes, vamos al cine. Nuestras acciones dependen de estas evaluaciones y decisiones. El control de flujo es, en esencia, la manera en que decidimos qué parte del código se ejecuta, cuándo se ejecuta y cuántas veces lo hace. Para ello, contamos con una variedad de estructuras que nos permiten tomar decisiones, repetir acciones y dividir nuestro código en bloques lógicos.\n","excerpt":"Cuando nos embarcamos en la emocionante travesía de aprender a …","ref":"/es/programming/0200-starting-concepts/0203-flow-control-structures/","tags":["intro","programming","control-flujo","condicionales","if","bucles","for","while"],"title":"Control de Flujo"},{"body":"Conditions: making decisions in code Life is full of decisions: “If it rains, I’ll take an umbrella. Otherwise, I’ll wear sunglasses.” These decisions are also present in the world of programming. Conditions are like questions the computer asks itself. They allow us to make decisions and execute specific code based on a condition1. They can be as simple as “Is it raining?” or as complex as “Is it the weekend and do I have less than $100 in my bank account?”.\nif The if structure allows us to evaluate conditions and make decisions based on the result of that evaluation.\nage = 15 if age \u003e= 18: print(\"You are an adult\") The code above allows executing a portion of code if a person’s age is greater than or equal to 18 years.\nif-else When you want to execute alternative code if the condition is false, you use the if-else structure.\nage = 21 if age \u003e= 18: print(\"You are an adult\") else: print(\"You are a minor\") In this case, it determines if the person is an adult or a minor, and the message displayed is different.\nif-elif-else When conditions are multiple and two paths are not enough, the if-elif-else structure is used to evaluate them in a chained way.\nage = 5 if age \u003c= 13: print(\"You are a child\") elif age \u003e 13 and age \u003c 18: print(\"You are a teenager\") else: print(\"You are an adult\") In the code above, there are three clear paths: one for when age is less than or equal to 13, one for when age is between 13 and 18, and another for when age is greater than or equal to 18.\nAnother way to solve this problem is through the switch-case structure, which, although Python does not natively incorporate, other languages like Java or C++ do, and it is an important tool to be familiar with. This structure allows programmers to handle multiple conditions in a more organized way than a series of if-elif-else.\nIn Java, for example:\nint day = 3; switch(day) { case 1: System.out.println(\"Monday\"); break; case 2: System.out.println(\"Tuesday\"); break; case 3: System.out.println(\"Wednesday\"); break; // ... and so on default: System.out.println(\"Invalid day\"); } In the previous example, depending on the value of day, the corresponding day will be printed2.\nLoops: repeating actions Sometimes in programming we need to repeat an action several times. Instead of writing the same code many times, we can use loops. These allow repeating the execution of a block of code while a condition is met3.\nwhile The while loop is useful when we want to repeat an action based on a condition.\n# Prints 1 to 5 i = 1 while i \u003c= 5: print(i) i = i + 1 do-while Similar to while but guarantees at least one execution since the code block is executed first and then the condition is evaluated. Python does not implement this structure, but other languages like Java and C++ do.\nint i = 1; do { System.out.println(i); i++; } while(i \u003c= 5); int number = 0; do { std::cout \u003c\u003c \"Hello, world!\" \u003c\u003c std::endl; number++; } while (number \u003c 5); for The for loop is useful when we know how many times we want to repeat an action.\nfor i in range(5): print(\"Hello, world!\") The code above will print “Hello, world!” five times.\nWe can also iterate over the elements of a list or iterable object:\nnames = [\"Maria\", \"Florencia\", \"Julian\"] for name in names: print(f\"Hello {name}\") # Prints # Hello Maria # Hello Florencia # Hello Julian The break and continue statements We can use break to terminate the loop and continue to skip to the next iteration.\nbreak is used to completely terminate the loop when a condition is met, in the following example, when i reaches 5.\n# break example i = 0 while i \u003c 10: print(i) if i == 5: break i += 1 # Prints: # 0 # 1 # 2 # 3 # 4 # 5 continue is used to skip an iteration of the loop and continue with the next one when a condition is met. Here we use it to skip even numbers.\n# continue example i = 0 while i \u003c 10: i += 1 if i % 2 == 0: continue print(i) # Prints: # 1 # 3 # 5 # 7 # 9 Nesting: combining structures Control flow structures can be nested within each other. For example, we can have loops within loops or conditions within loops.\nfor i in range(5): for j in range(10): if (i % 2 == 0 and j % 3 == 0): print(f\"i = {i}, j = {j}\") This code will print combinations of i and j only when i is divisible by 2 and j is divisible by 3, demonstrating how loops are nested and executed3.\nCommon usage patterns There are specific patterns to solve common needs with control flow.\nSearch Search for a value in a collection:\nfruits = [\"apple\", \"orange\"] searching = \"orange\" found = False for fruit in fruits: if fruit == searching: found = True break if found: print(\"Fruit found!\") Accumulation Accumulate incremental values in a loop:\ntotal = 0 for i in range(10): total += i print(total) # Sum from 0..9 = 45 Flowcharts: the visual route to understanding code Programmers, whether beginners or experts, often find themselves facing challenges that require detailed planning before diving into code. This is where flowcharts come into play as an essential tool. These charts are graphical representations of the processes and logic behind a program or system. In this article, we will unravel the world of flowcharts, from basic concepts to advanced techniques, and how they can benefit programmers of all levels.\nA flowchart is a graphical representation of a process. It uses specific symbols to represent different types of instructions or actions. Its main purpose is to simplify understanding of a process by showing step by step how information or decisions flow. These charts:\nFacilitate understanding of complex processes. Aid in the design and planning phase of a program. Serve as documentation and reference for future developments. Flowcharts are a powerful tool that not only benefits beginners but also experienced programmers. They provide a clear and structured view of a process or program, facilitating planning, design, and communication between team members.\nBasic elements Flowcharts consist of several symbols, each with a specific meaning:\nOval: Represents the start or end of a process. Rectangle: Denotes an operation or instruction. Diamond: Indicates a decision based on a condition. Arrows: Show the direction of flow. graph TD; start((Start)) process[Process] decision{Decision?} final((End)) start --\u003e process; process --\u003e decision; decision --\u003e |Yes| process decision --\u003e |No| final Examples Let’s design a flowchart for a program that asks for a number and tells us if it’s even or odd.\ngraph TB start((Start)) input[Input number] decision{Even?} isEven[Is even] isOdd[Is odd] final((End)) start --\u003e input input --\u003e decision decision --\u003e |Yes| isEven decision --\u003e |No| isOdd isEven --\u003e final isOdd --\u003e final As programs become more complex, you may need to incorporate loops, multiple conditions, and other advanced elements into your flowchart. For example, here we diagram a program that sums numbers from 1 to a number entered by the user.\ngraph TD start((Start)) input[Input number] setVariables[Set sum=0 and counter=1] loop_condition{counter \u003c= N?} loop_code[Add value and increment counter] result[Show sum] final((End)) start --\u003e input input --\u003e setVariables setVariables --\u003e loop_condition loop_condition --\u003e |Yes| loop_code loop_code --\u003e loop_condition loop_condition --\u003e |No| result result --\u003e final Conclusion Control flow is the heart of programming. Without it, programs would be linear sequences of actions without the ability to make decisions or repeat tasks. By mastering these structures not only do you improve your ability to write code, but also your ability to think logically and solve complex problems.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe’re keen to hear your thoughts, so don’t be shy – drop your comments, suggestions, and those bright ideas you’re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we’ve cooked up for you. You’ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O’Reilly Media, Incorporated. ↩︎\nDeitel, P., \u0026 Deitel, H. (2012). Java: How to program. Upper Saddle River, NJ: Prentice Hall. ↩︎\nMatthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. San Francisco, CA: No Starch Press. ↩︎ ↩︎\n","categories":"","description":"When we embark on the exciting journey of learning to program, we soon discover that programming is not just about writing code, but also about controlling the flow of that code. We can compare it to the flow of decisions we make in our daily lives. For example, if it’s cold outside, we put on a coat before going out. If we have no pending tasks, we go to the movies. Our actions depend on these evaluations and decisions. Control flow is, essentially, the way we decide which part of the code runs, when it runs, and how many times it does. To do this, we have a variety of structures that allow us to make decisions, repeat actions, and split our code into logical blocks.\n","excerpt":"When we embark on the exciting journey of learning to program, we soon …","ref":"/en/programming/0200-starting-concepts/0203-flow-control-structures/","tags":["intro","programming","control-flow","conditionals","if","loops","for","while"],"title":"Flow Control"},{"body":"¿Qué son las funciones? Una función, en términos simples, es un bloque de código que se ejecuta sólo cuando es llamado. Puedes pensar en ella como un pequeño programa dentro de tu programa principal, diseñado para realizar una tarea específica1. Una función también puede verse como una caja negra: le pasamos una entrada (parámetros), ocurre algún procesamiento interno, y produce una salida (retorno).\nLas funciones nos permiten segmentar nuestro código en partes lógicas, donde cada parte realiza una única acción. Esto brinda varios beneficios2:\nReutilización: Una vez definida la función, podemos ejecutar (llamar) ese código desde cualquier lugar de nuestro programa cuantas veces sea necesario. Organización: Permite dividir un programa grande en partes más pequeñas y manejables. Encapsulamiento: Las funciones reducen la complejidad escondiendo los detalles de implementación internos. Mantenimiento: Si necesitamos realizar cambios, solo debemos modificar el código en un lugar (la función) en lugar de rastrear todas las instancias de ese código. Procedimientos vs. Funciones\nEs vital distinguir entre estos dos conceptos. Mientras que una función siempre devuelve un valor, un procedimiento realiza una tarea pero no devuelve nada. En algunos lenguajes, esta diferencia es más clara que en otros. Python, por ejemplo, tiene funciones que pueden o no devolver valores.\nAnatomía de una función En Python, una función se declara usando la palabra clave def, seguida del nombre de la función y paréntesis. El código dentro de la función se denomina el cuerpo de la función3 y contiene el conjunto de instrucciones a ejecutar para cumplir con su tarea..\ndef mi_funcion(): print(\"¡Hola desde mi función!\") Para llamar o invocar una función, simplemente usamos su nombre seguido de paréntesis:\nmi_funcion() # Salida: ¡Hola desde mi función! Parámetros y argumentos Las funciones se vuelven aún más poderosas cuando les pasamos información, conocida como parámetros. Estos actúan como “variables” dentro de la función y permiten que la función trabaje con diferentes datos cada vez que se llama.\nMientras que los parámetros son variables definidas en la definición de la función. Los argumentos son los valores reales pasados al llamar a la función.\ndef saludo(nombre): print(f\"¡Hola {nombre}!\") saludo(\"María\") # Salida: # ¡Hola María! Podemos definir valores por defecto para los parámetros Python permite parámetros por defecto, que tienen un valor predeterminado, lo cual hace opcional pasar esos argumentos al llamar la función. También permite parámetros nombrados que permiten pasar los argumentos en cualquier orden, especificando su nombre.\ndef saludo(nombre=\"María\", repeticiones=3): repeticion = 1 while repeticion \u003c= repeticiones: print(f\"¡Hola {nombre}!\") repeticion += 1 saludo() # Salida: # ¡Hola María! # ¡Hola María! # ¡Hola María! saludo(\"Florencia\", 4) # Salida: # ¡Hola Florencia! # ¡Hola Florencia! # ¡Hola Florencia! # ¡Hola Florencia! saludo(repeticiones=2, nombre=\"Julián\") # Salida # ¡Hola Julián! # ¡Hola Julián! Retorno de valores Las funciones pueden devolver un resultado o valor de retorno usando la palabra reservada return.\ndef area_circulo(radio): return 3.14 * (radio ** 2) resultado = area_circulo(10) print(resultado) # Salida: 314 El valor de retorno se pasa de vuelta a donde se llamó la función y se puede asignar a una variable para usarlo.\nLas funciones también pueden ejecutar alguna tarea sin devolver nada explícitamente. En Python esto se conoce como retornar None.\nVariables locales y globales Las variables locales se definen dentro de una función y solo existen en ese ámbito, mientras que las variables globales están definidas fuera y pueden ser accedidas desde cualquier parte del código. Es crucial entender su alcance (dónde puede ser accesible una variable) y duración (cuánto tiempo vive una variable).\nx = 10 # x es global def suma(): y = 5 # y es local return x + y suma() # Salida: 15 print(y) # Error, y no existe fuera de la función Podemos leer variables globales desde una función, pero si necesitamos modificarla debemos declararla global.\nx = 10 def suma(): global x x = x + 5 suma() print(x) # 15 Idealmente las funciones solo deben trabajar con variables locales y parámetros. Limita el uso de variables globales. Si bien pueden ser útiles, también pueden hacer que el código sea difícil de leer y mantener. Buenas prácticas Al crear funciones debemos seguir ciertos principios y patrones4:\nEl nombre de una función debe indicar claramente su propósito. Hacer las funciones pequeñas, simples y enfocadas en una tarea. Una función debe hacer una cosa y hacerla bien. Utilizar nombres descriptivos para las funciones y sus parámetros. Evitar efectos secundarios y modificación de variables globales. Documentar adecuadamente el propósito y uso de cada función. Limitar el número de parámetros, idealmente de 0 a 3 parámetros. Seguir estas buenas prácticas nos ayudará a crear funciones reutilizables, encapsuladas y fáciles de mantener.\nConclusión Las funciones son componentes fundamentales en la programación, permitiéndonos organizar, reutilizar y encapsular código. Definiendo funciones que realicen una sola tarea mantenemos nuestros programas simplificados, fáciles de entender y modificar. Al comprender y dominar este concepto, no solo mejoras la calidad de tu código sino también tu eficiencia como desarrollador.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias McConnell, S. (2004). Code Complete. Microsoft Press. ↩︎\nJoyanes Aguilar, L. (2008). Fundamentos de programación: algoritmos, estructura de datos y objetos. McGraw-Hill. ↩︎\nPython Software Foundation. (2022). Documentación oficial de Python. ↩︎\nKindler, E., \u0026 Krivy, I. (2011). Object-Oriented Simulation of systems with Java: A working introduction. BoD–Books on Demand. ↩︎\n","categories":"","description":"En el vasto y emocionante mundo de la programación, existen conceptos que son pilares fundamentales para cualquier desarrollador, sin importar su nivel de experiencia. Uno de estos conceptos es el de las funciones. ¿Qué son? ¿Por qué son tan cruciales? ¡Vamos a descubrirlo!\n","excerpt":"En el vasto y emocionante mundo de la programación, existen conceptos …","ref":"/es/programming/0200-starting-concepts/0204-functions/","tags":["intro","programming","functions","methods"],"title":"Funciones"},{"body":"What are functions? A function, in simple terms, is a block of code that executes only when called. You can think of it as a small program within your main program, designed to perform a specific task1. A function can also be seen as a black box: we pass an input (parameters), some internal processing occurs, and it produces an output (return value).\nFunctions allow us to segment our code into logical parts where each part performs a single action. This provides several benefits2:\nReusability: Once defined, we can execute (call) that code from anywhere in our program as many times as needed. Organization: It allows dividing a large program into smaller, more manageable parts. Encapsulation: Functions reduce complexity by hiding internal implementation details. Maintainability: If we need to make changes, we only have to modify the code in one place (the function) instead of tracking down all instances of that code. Procedures vs. Functions\nIt is vital to distinguish between these two concepts. While a function always returns a value, a procedure performs a task but does not return anything. In some languages, this difference is clearer than in others. Python, for example, has functions that can optionally return values.\nAnatomy of a function In Python, a function is declared using the def keyword, followed by the function name and parentheses. The code inside the function is called the body of the function3 and contains the set of instructions to execute to perform its task.\ndef my_function(): print(\"Hello from my function!\") To call or invoke a function, we simply use its name followed by parentheses:\nmy_function() # Output: Hello from my function! Parameters and arguments Functions become even more powerful when we pass information to them, known as parameters. These act as “variables” inside the function, allowing the function to work with different data each time it is called.\nWhile parameters are variables defined in the function definition, arguments are the actual values passed when calling the function.\ndef greet(name): print(f\"Hello {name}!\") greet(\"Maria\") # Output: # Hello Maria! Python allows default parameters, which have a predetermined value, making passing those arguments optional when calling the function. It also allows named parameters which enable passing arguments in any order by specifying their name.\ndef greet(name=\"Maria\", repetitions=3): repetition = 1 while repetition \u003c= repetitions: print(f\"Hello {name}!\") repetition += 1 greet() # Output: # Hello Maria! # Hello Maria! # Hello Maria! greet(\"Florencia\", 4) # Output: # Hello Florencia! # Hello Florencia! # Hello Florencia! # Hello Florencia! greet(repetitions=2, name=\"Julian\") # Output # Hello Julian! # Hello Julian! Returning values Functions can return a result or return value using the return keyword.\ndef circle_area(radius): return 3.14 * (radius ** 2) result = circle_area(10) print(result) # Output: 314 The return value is passed back to where the function was called and can be assigned to a variable for later use.\nFunctions can also perform some task without explicitly returning anything. In Python this is known as returning None.\nLocal and global variables Local variables are defined inside a function and only exist in that scope, while global variables are defined outside and can be accessed from anywhere in the code. It is crucial to understand their scope (where a variable is accessible) and lifetime (how long a variable lives).\nx = 10 # x is global def add(): y = 5 # y is local return x + y add() # Output: 15 print(y) # Error, y does not exist outside the function We can read global variables from a function, but if we need to modify it we must declare it global.\nx = 10 def add(): global x x = x + 5 add() print(x) # 15 Ideally functions should only work with local variables and parameters. Limit the use of global variables. While they can be useful, they can also make code difficult to read and maintain. Best Practices When creating functions we should follow certain principles and patterns4:\nThe name of a function should clearly indicate its purpose. Make functions small, simple, and focused on one task. A function should do one thing and do it well. Use descriptive names for functions and parameters. Avoid side effects and modifying global variables. Properly document the purpose and usage of each function. Limit the number of parameters, ideally 0 to 3 parameters. Following these best practices will help us create reusable, encapsulated, and maintainable functions.\nConclusion Functions are core components in programming, allowing us to organize, reuse, and encapsulate code. By defining functions that perform a single task we keep our programs simplified, easy to understand, and modify. By understanding and mastering this concept, you not only improve the quality of your code but also your efficiency as a developer.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe’re keen to hear your thoughts, so don’t be shy – drop your comments, suggestions, and those bright ideas you’re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we’ve cooked up for you. You’ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences McConnell, S. (2004). Code Complete. Microsoft Press. ↩︎\nJoyanes Aguilar, L. (2008). Fundamentos de programación: algoritmos, estructura de datos y objetos. McGraw-Hill. ↩︎\nPython Software Foundation. (2022). Python Official Documentation. ↩︎\nKindler, E., \u0026 Krivy, I. (2011). Object-Oriented Simulation of systems with Java: A working introduction. BoD–Books on Demand. ↩︎\n","categories":"","description":"In the vast and exciting world of programming, there are concepts that are fundamental pillars for any developer, regardless of their experience level. One of these concepts is functions. What are they? Why are they so crucial? Let's find out!\n","excerpt":"In the vast and exciting world of programming, there are concepts that …","ref":"/en/programming/0200-starting-concepts/0204-functions/","tags":["intro","programming","functions","methods"],"title":"Functions"},{"body":"Recursión: el arte de llamarse a sí mismo Imagina una caja de espejos donde cada espejo refleja lo que ve en el siguiente, creando una serie infinita de reflejos. La recursión en programación es algo similar. Es una técnica donde una función se llama a sí misma directa o indirectamente[^1^]. Esto crea un ciclo en el cual la función resuelve un problema dividiéndolo en instancias más pequeñas del mismo problema, hasta llegar a un caso base sencillo de resolver.\nPor ejemplo, imaginemos una función que imprime un contador regresivo:\ndef cuenta_regresiva(numero): if numero \u003e 0: print(numero) cuenta_regresiva(numero - 1) else: print(\"¡Despegue!\") cuenta_regresiva(5) Esta función se llama recursivamente reduciendo el número cada vez hasta llegar a 0, y luego imprime el mensaje de despegue.\nLa recursión es un enfoque declarativo donde se enfoca en dividir un problema en casos recursivos sin necesidad de controlar explícitamente el bucle usando iteradores o contadores como en la programación imperativa.\nLa estructura de una función recursiva El poder de la recursión radica en su simplicidad. Sin embargo, es esencial entender su estructura para evitar caer en trampas comunes. Una función recursiva típica tiene dos partes principales1:\nCaso base: El caso más simple con una solución conocida que no requiere recursión. Es la condición de parada, que detiene la recursión. Sin el caso base, caeríamos en una recursión infinita que eventualmente desborda la pila de llamadas. Caso recursivo: Es donde ocurre la mágica llamada recursiva. En este punto, la función se llama a sí misma con un argumento modificado, generalmente una versión reducida del problema original. Ejemplos clásicos de recursión Factorial El factorial de un entero positivo \\(n\\) es el producto de todos los enteros positivos menores o iguales a \\(n\\). Por ejemplo:\n\\(5! = 5 * 4 * 3 * 2 * 1 = 120\\) \\(4! = 4 * 3 * 2 * 1 = 24\\) \\(3! = 3 * 2 * 1 = 6\\) Aquí está el código en Python para calcular el factorial usando recursión:\ndef factorial(n): if n == 1: return 1 # Caso base return n * factorial(n-1) # Caso recursivo Caso base: El caso base es la instancia más simple y pequeña del problema que puede responderse directamente. Para el factorial, cuando \\(n = 1\\), el resultado es \\(1\\). Caso recursivo: Si \\(n\\) es mayor que \\(1\\), la función se llama a sí misma con \\(n-1\\), y multiplica el resultado por \\(n\\). Digamos que quieres calcular el factorial de \\(5\\), así que llamas a factorial(5).\nEsto es lo que sucede:\nPaso 1: Como \\(n = 5\\) no es \\(1\\), la función llama a factorial(4), luego multiplica el resultado por \\(5\\). Paso 2: Ahora, dentro de factorial(4), \\(n = 4\\), entonces la función llama a factorial(3), luego multiplica el resultado por \\(4\\). Paso 3: Dentro de factorial(3), \\(n = 3\\), así que llama a factorial(2), luego multiplica el resultado por \\(3\\). Paso 4: Dentro de factorial(2), \\(n = 2\\), así que llama a factorial(1), luego multiplica el resultado por \\(2\\). Paso 5: Finalmente, factorial(1) alcanza el caso base, donde \\(n = 1\\), así que retorna \\(1\\). Ahora los resultados se desenrollan:\nfactorial(2) retorna \\(2 * 1 = 2\\) factorial(3) retorna \\(3 * 2 = 6\\) factorial(4) retorna \\(4 * 6 = 24\\) factorial(5) retorna \\(5 * 24 = 120\\) El resultado final es \\(120\\), que es el valor de \\(5!\\).\nAquí hay una representación visual de la pila de llamadas:\nfactorial(5) -\u003e factorial(4) -\u003e factorial(3) -\u003e factorial(2) -\u003e factorial(1) return 1 return 2 return 6 return 24 return 120 Serie de Fibonacci La serie de Fibonacci es una secuencia de números donde cada número es la suma de los dos anteriores. Comienza con \\(0\\) y \\(1\\), y cada número posterior es la suma de los dos números anteriores. Los primeros números de la secuencia son: \\(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …\\)\nAquí está el código en Python para calcular el \\(n^th\\) número de Fibonacci usando recursión de cola:\ndef fibonacci(n, a=0, b=1): if n == 0: return a return fibonacci(n-1, b, a+b) La función toma tres parámetros:\n\\(n\\): La posición del número deseado en la secuencia. \\(a\\) y \\(b\\): Dos números que ayudan en el cálculo de la secuencia. Aquí hay un desglose de cómo funciona la función:\nCaso Base: Si \\(n\\) es \\(0\\), la función devuelve \\(a\\). Este es el valor del \\(n^th\\) número en la secuencia.\nCaso Recursivo: Si \\(n\\) no es \\(0\\), la función se llama a sí misma con \\(n-1\\), \\(b\\), y \\(a+b\\). Estos parámetros cambian la posición en la secuencia y preparan los siguientes números para la suma.\nSupongamos que queremos encontrar el \\(5^th\\) número en la secuencia de Fibonacci llamando a fibonacci(5).\nEsto es lo que sucede:\nPaso 1: Dado que \\(n = 5\\), llama a fibonacci(4, 1, 1) (porque \\(a = 0\\), \\(b = 1\\), \\(a + b = 1\\)). Paso 2: Dado que \\(n = 4\\), llama a fibonacci(3, 1, 2) (porque \\(a = 1\\), \\(b = 1\\), \\(a + b = 2\\)). Paso 3: Dado que \\(n = 3\\), llama a fibonacci(2, 2, 3) (porque \\(a = 1\\), \\(b = 2\\), \\(a + b = 3\\)). Paso 4: Dado que \\(n = 2\\), llama a fibonacci(1, 3, 5) (porque \\(a = 2\\), \\(b = 3\\), \\(a + b = 5\\)). Paso 5: Dado que \\(n = 1\\), llama a fibonacci(0, 5, 8) (porque \\(a = 3\\), \\(b = 5\\), \\(a + b = 8\\)). Paso 6: Dado que \\(n = 0\\), devuelve \\(a\\), que es \\(5\\). El resultado es \\(5\\), que es el \\(5^th\\) número en la secuencia de Fibonacci.\nAquí hay una representación visual de la pila de llamadas:\nfibonacci(5, 0, 1) -\u003e fibonacci(4, 1, 1) -\u003e fibonacci(3, 1, 2) -\u003e fibonacci(2, 2, 3) -\u003e fibonacci(1, 3, 5) -\u003e fibonacci(0, 5, 8) return 5 Ventajas y desventajas La recursión tiene ciertas ventajas2:\nPuede resultar en soluciones simples y elegantes para problemas que se dividen fácilmente en subproblemas. Elimina la necesidad de control de bucles explícito. Sigue la estructura matemática de una definición recursiva. Las desventajas incluyen:\nPuede ser menos eficiente (alto consumo de memoria) que la iteración debido a las llamadas repetidas y creación de marcos de pila. Demasiada recursión puede desbordar la pila de llamadas y causar errores. Puede ser más difícil de depurar y analizar que la iteración. Por lo tanto, la recursión es una herramienta poderosa que debe usarse con discreción en los casos apropiados.\nRecursión vs Iteración La recursión y la iteración (usando ciclos) son paralelos y podemos usar cualquiera para resolver muchos problemas. Ambas técnicas tienen el potencial de resolver los mismos problemas, pero su implementación y eficiencia pueden variar. Tomemos el ejemplo del factorial:\nIterativo\ndef factorial_iterativo(n): resultado = 1 for i in range(1, n+1): resultado *= i return resultado Recursivo\ndef factorial_recursivo(n): if n == 1: return 1 return n * factorial(n-1) La versión iterativa es más eficiente en términos de espacio, pero la recursiva es más limpia y fácil de entender. La elección entre recursión e iteración a menudo depende del problema específico, las restricciones de memoria y las preferencias del programador.\nConclusión La recursión es una técnica clave que permite escribir algoritmos elegante, naturales y eficientes si se utiliza adecuadamente. Entender cómo dividir un problema en casos recursivos es esencial para dominar esta habilidad. La recursión ofrece una alternativa declarativa única para resolver problemas complejos sin necesidad de administrar bucles explícitos. Sin embargo, es crucial recordar siempre definir un caso base adecuado y ser consciente de las limitaciones de la recursión en términos de eficiencia y uso de memoria. Saber combinar recursión e iteración nos da flexibilidad al crear soluciones óptimas.\nComo siempre, la clave está en encontrar el equilibrio adecuado y utilizar la herramienta correcta para el trabajo adecuado.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias Kindler, E., \u0026 Krivy, I. (2011). Object-Oriented Simulation of systems with Java: A working introduction. BoD–Books on Demand. ↩︎\nLutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O’Reilly Media, Incorporated. ↩︎\n","categories":"","description":"La recursión es un concepto fundamental en programación que permite que una función se llame a sí misma. A primera vista puede parecer contraintuitivo, pero dominar este enfoque abre la puerta a soluciones elegantes para ciertos problemas.\n","excerpt":"La recursión es un concepto fundamental en programación que permite …","ref":"/es/programming/0200-starting-concepts/0205-recursive-functions/","tags":["programming","functions","recursion","factorial","fibonacci"],"title":"Funciones Recursivas"},{"body":"Recursion: the art of calling yourself Imagine a box of mirrors where each mirror reflects what it sees in the next, creating an infinite series of reflections. Recursion in programming is something similar. It is a technique where a function calls itself directly or indirectly1. This creates a cycle where the function solves a problem by dividing it into smaller instances of the same problem, until reaching a simple base case that can be solved directly.\nFor example, let’s imagine a function that prints a countdown:\ndef countdown(number): if number \u003e 0: print(number) countdown(number - 1) else: print(\"Blastoff!\") countdown(5) This function calls itself recursively decrementing the number each time until reaching 0, and then prints the blastoff message.\nRecursion is a declarative approach that focuses on dividing a problem into recursive cases without needing to explicitly control the loop using iterators or counters like in imperative programming.\nThe structure of a recursive function The power of recursion lies in its simplicity. However, it is essential to understand its structure to avoid common pitfalls. A typical recursive function has two main parts2:\nBase case: The simplest case with a known solution that doesn’t require recursion. It is the stopping condition that halts the recursion. Without a base case, we would fall into infinite recursion which eventually overflows the call stack. Recursive case: This is where the magical recursive call occurs. At this point, the function calls itself with a modified argument, usually a reduced version of the original problem. Classic recursion examples Factorial The factorial of a positive integer \\(n\\) is the product of all positive integers less than or equal to \\(n\\). For example:\n\\(5! = 5 * 4 * 3 * 2 * 1 = 120\\) \\(4! = 4 * 3 * 2 * 1 = 24\\) \\(3! = 3 * 2 * 1 = 6\\) Here is the Python code for calculating factorial using recursion:\ndef factorial(n): if n == 1: return 1 # Base case return n * factorial(n-1) # Recursive case Base case: The base case is the simplest, smallest instance of the problem that can be answered directly. For factorial, when \\(n = 1\\), the result is \\(1\\). Recursive case: If \\(n\\) is greater than \\(1\\), the function calls itself with \\(n-1\\), and multiplies the result by \\(n\\). Let’s say you want to calculate the factorial of \\(5\\), so you call factorial(5).\nHere is what happens:\nStep 1: Since \\(n = 5\\) is not \\(1\\), the function calls factorial(4), then multiplies the result by \\(5\\). Step 2: Now, inside factorial(4), \\(n = 4\\), so the function calls factorial(3), then multiplies the result by \\(4\\). Step 3: Inside factorial(3), \\(n = 3\\), so it calls factorial(2), then multiplies the result by \\(3\\). Step 4: Inside factorial(2), \\(n = 2\\), so it calls factorial(1), then multiplies the result by \\(2\\). Step 5: Finally, factorial(1) reaches the base case, where \\(n = 1\\), so it returns \\(1\\). Now the results unwind:\nfactorial(2) returns \\(2 * 1 = 2\\) factorial(3) returns \\(3 * 2 = 6\\) factorial(4) returns \\(4 * 6 = 24\\) factorial(5) returns \\(5 * 24 = 120\\) The final result is \\(120\\), which is the value of \\(5!\\).\nHere is a visual representation of the call stack:\nfactorial(5) -\u003e factorial(4) -\u003e factorial(3) -\u003e factorial(2) -\u003e factorial(1) return 1 return 2 return 6 return 24 return 120 Fibonacci sequence The Fibonacci sequence is a series of numbers where each number is the sum of the previous two. It starts with \\(0\\) and \\(1\\), and each subsequent number is the sum of the two numbers before it. The beginning of the sequence is: \\(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …\\)\nHere is the Python code for calculating the \\(n^th\\) Fibonacci number using tail recursion:\ndef fibonacci(n, a=0, b=1): if n == 0: return a return fibonacci(n-1, b, a+b) The function takes three parameters:\n\\(n\\): The position of the desired number in the sequence. \\(a\\) and \\(b\\): Two numbers that aid in the sequence calculation. Here is a breakdown of how the function works:\nBase case: If \\(n\\) is \\(0\\), the function returns \\(a\\). This is the value of the \\(n^th\\) number in the sequence. Recursive case: If \\(n\\) is not \\(0\\), the function calls itself with \\(n-1\\), \\(b\\), and \\(a+b\\). These parameters change the position in the sequence and prepare the next numbers for summation. Suppose we want to find the \\(5^th\\) number in the Fibonacci sequence by calling fibonacci(5).\nHere is what happens:\nStep 1: Since \\(n = 5\\), it calls fibonacci(4, 1, 1) (because \\(a = 0\\), \\(b = 1\\), \\(a + b = 1\\)). Step 2: Since \\(n = 4\\), it calls fibonacci(3, 1, 2) (because \\(a = 1\\), \\(b = 1\\), \\(a + b = 2\\)). Step 3: Since \\(n = 3\\), it calls fibonacci(2, 2, 3) (because \\(a = 1\\), \\(b = 2\\), \\(a + b = 3\\)). Step 4: Since \\(n = 2\\), it calls fibonacci(1, 3, 5) (because \\(a = 2\\), \\(b = 3\\), \\(a + b = 5\\)). Step 5: Since \\(n = 1\\), it calls fibonacci(0, 5, 8) (because \\(a = 3\\), \\(b = 5\\), \\(a + b = 8\\)). Step 6: Since \\(n = 0\\), it returns \\(a\\), which is \\(5\\). The result is \\(5\\), which is the \\(5^th\\) number in the Fibonacci sequence.\nHere is a visual representation of the call stack:\nfibonacci(5, 0, 1) -\u003e fibonacci(4, 1, 1) -\u003e fibonacci(3, 1, 2) -\u003e fibonacci(2, 2, 3) -\u003e fibonacci(1, 3, 5) -\u003e fibonacci(0, 5, 8) return 5 Advantages and Disadvantages Recursion has certain advantages3:\nIt can result in simple, elegant solutions for problems that easily break down into subproblems. It eliminates the need for explicit loop control. It mirrors the mathematical structure of a recursive definition. The disadvantages include:\nIt can be less efficient (high memory consumption) than iteration due to repeated function calls and stack frame creation. Too much recursion can overflow the call stack and cause crashes. It can be harder to debug and analyze than iteration. Therefore, recursion is a powerful tool that should be used judiciously in appropriate cases.\nRecursion vs Iteration Recursion and iteration (using loops) are parallel tools and we can use either one to solve many problems. Both techniques have the potential to solve the same problems, but their implementation and efficiency may vary. Let’s take the factorial example:\nIterative\ndef factorial_iterative(n): result = 1 for i in range(1, n+1): result *= i return result Recursive\ndef factorial_recursive(n): if n == 1: return 1 return n * factorial(n-1) The iterative version is more efficient in terms of space, but the recursive is cleaner and easier to understand. The choice between recursion and iteration often depends on the specific problem, memory constraints, and programmer preferences.\nConclusion Recursion is a key technique that allows writing elegant, natural, and efficient algorithms when properly leveraged. Understanding how to break down a problem into recursive cases is essential to master this skill. Recursion provides a unique declarative alternative to solve complex problems without managing explicit loops. However, it is crucial to always remember to define an adequate base case and be aware of recursion limitations in terms of efficiency and memory usage. Knowing how to combine recursion and iteration gives flexibility when creating optimal solutions.\nAs always, the key lies in finding the right balance and using the right tool for the right job.\nCheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe’re keen to hear your thoughts, so don’t be shy – drop your comments, suggestions, and those bright ideas you’re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we’ve cooked up for you. You’ll find all the code and projects in our GitHub repository learn-software-engineering/examples-programming.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\nReferences Cormen, T.H., Leiserson, C.E., Rivest, R.L., \u0026 Stein, C. (2009). Introduction to Algorithms. MIT Press. ↩︎\nKindler, E., \u0026 Krivy, I. (2011). Object-Oriented Simulation of systems with Java: A working introduction. BoD–Books on Demand. ↩︎\nLutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O’Reilly Media, Incorporated. ↩︎\n","categories":"","description":"Recursion is a fundamental concept in programming that allows a function to call itself. At first it may seem counterintuitive, but mastering this approach opens the door to elegant solutions for certain problems.\n","excerpt":"Recursion is a fundamental concept in programming that allows a …","ref":"/en/programming/0200-starting-concepts/0205-recursive-functions/","tags":["programming","functions","recursion","factorial","fibonacci\""],"title":"Recursive Functions"},{"body":"Object-Oriented Programming (OOP) is a programming paradigm that has become indispensable nowadays. This approach models real-world elements as “objects” that have properties and behaviours, which allows for more intuitive and maintainable programmes to be created. In this article we will look at the basic concepts of OOP and its advantages over other paradigms like procedural programming. Let’s get started!\nThis paradigm is based on two fundamental concepts:\nObjects: entities that combine state (data) and behaviour (operations) in a single unit. For example, a “car” object would have properties like colour, number of doors, maximum speed, etc. And behaviours like accelerate, brake, steer, etc. Classes: specifications that define the common structure and behaviour of a group of objects. The “car” class would serve as a template for creating car objects with the same characteristics. As explained by programmer Alan Kay, one of the creators of OOP:\n“The big idea is to design programmes in terms of conceptual objects and concepts from the real world. The interfaces with the real world should, therefore, be constructed in terms of these conceptual objects.”1\nThat is, OOP conceptually models real-world elements to make programming more intuitive.\nProgramming paradigms Before delving into OOP, it is worth understanding that there are different paradigms or approaches to tackle programming. The main ones are:\nProcedural programming Ordered sequence of instructions that the programme must follow step-by-step. The focus is on procedures and functions. For example, C is a language geared towards procedural programming.\nProcedural programming is better for:\nSimple problems or sequential algorithms. Code that won’t need heavy reusing or expanding. Cases where performance and efficiency are critical. Object-Oriented programming Model based on objects that contain data and code in cohesive units. The focus is on classes and the interaction between objects. For example, Java and Python are object-oriented languages.\nOOP allows modelling real-world elements more directly, better encapsulating data, and reusing code through inheritance between classes.\nThe main advantages of OOP over procedural programming are:\nModularity: objects group related data and operations, encapsulating internal complexity. This allows working with independent modules. Information hiding: Objects can expose a simple interface and hide internal implementation details. This reduces coupling. Reusability: Classes enable code reuse. An abstract class can inherit to multiple subclasses. Extensibility: We can extend the behaviour of parent classes by creating new subclasses. Conceptual mapping: Objects represent real-world entities, which eases the translation of requirements into code. However, OOP also has disadvantages. According to programmer Paul Graham:\n“Object-oriented programming often makes things harder than they need to be.”2\nFor example, for simple problems OOP can be excessive. And in large projects there is a risk of overusing inheritance and polymorphism, making the code difficult to follow.\nUltimately, OOP is more suitable when:\nThe problem to be modelled has clear, structured entities. We want to reuse encapsulated code in modular classes. We work on systems that need to be easily extended and maintained. Basic OOP concepts Now that we know the general ideas behind OOP, let’s look at some key concepts:\nObjects An object is a combination of data (properties) and behaviours (methods). For example, a Car object would have properties like make, model, colour and methods like accelerate, brake, etc.\n# Car Class class Car: def __init__(self, make, colour): self.make = make self.colour = colour def accelerate(self): print(\"Accelerating\", self.make) # Create Object my_car = Car(\"Toyota\", \"Red\") my_car is now a Car object with properties and methods defined in its class. Classes A class defines the common attributes (properties) and methods (functions) for a group of objects. It works like a template for creating similar objects.\nBy convention, classes are defined with the first letter capitalised. The properties and methods of a class get the self prefix to indicate they belong to that object instance.\nclass Circle: def __init__(self, radius): self.radius = radius def area(self): return 3.1416 * (self.radius ** 2) Circle defines the class with radius property and area() method. Methods Methods are functions that define the behaviour of an object. They are declared inside the class and can access the object’s properties via self.\nA constructor is a special method (__init__) that runs when creating objects to initialise their properties.\nclass Person: def __init__(self, name, age): self.name = name self.age = age def greet(self): print(f\"Hello! I'm {self.name}\") john = Person(\"John\", 30) # Runs __init__ john.greet() # \"Hello! I'm John\" The constructor assigns name and age. The greet() method accesses the name attribute. Properties Properties are variables associated with an object that define its characteristics or state. They are declared in the class and accessed through the object reference.\nclass Rectangle: def __init__(self, height, width): self.height = height self.width = width r = Rectangle(3, 4) print(r.height) # 3 r.width = 8 print(r.width) # 8 It is recommended to declare properties as private and access via getter/setter methods to respect encapsulation.\nEncapsulation It consists of hiding the internal implementation details of an object, exposing only a public interface. This is achieved by declaring methods and properties with public or private modifiers.\nIn Python this is denoted with a leading underscore for private methods/properties:\nclass BankAccount: def __init__(self, balance=0): self.balance = balance def deposit(self, amount): self._balance += amount def check_balance(self): return self._balance _balance is private, only accessed internally or via check_balance(). Encapsulation makes it easier to change internal parts of a class without affecting its public interface.\nConclusion Object-Oriented Programming models real-world elements as classes and objects, prioritising modularity, information hiding, and code reuse to create more robust and maintainable programmes.\nAlthough it can be excessive for simple problems, OOP is ideal for medium/large systems that need to expand and evolve in complexity over time.\nConcepts like inheritance, polymorphism, abstraction, and interfaces allow fully leveraging the advantages of this paradigm. With a solid understanding of its fundamentals we are ready to apply OOP in any programming language and project.\nReferences Kay, Alan. The early history of Smalltalk. http://gagne.homedns.org/~tgagne/contrib/EarlyHistoryST.html ↩︎\nGraham, Paul. Why Arc Isn’t Especially Object-Oriented. http://www.paulgraham.com/noop.html ↩︎\n","categories":"","description":"","excerpt":"Object-Oriented Programming (OOP) is a programming paradigm that has …","ref":"/en/programming/0300-oop/","tags":"","title":"Object-Oriented Programming"},{"body":"La Programación Orientada a Objetos (POO) es un paradigma de programación que se ha vuelto indispensable en la actualidad. Este enfoque modela elementos del mundo real como “objetos” que tienen propiedades y comportamientos, lo cual permite crear programas más intuitivos y fáciles de mantener. En este artículo veremos los conceptos básicos de POO y sus ventajas frente a otros paradigmas como la programación procedural. ¡Empecemos!\nEste paradigma se basa en dos conceptos fundamentales:\nObjetos: entidades que combinan estado (datos) y comportamiento (operaciones) en una misma unidad. Por ejemplo, un objeto “coche” tendría propiedades como color, número de puertas, velocidad máxima, etc. Y comportamientos como acelerar, frenar, girar, etc. Clases: especificaciones que definen la estructura y comportamiento común de un grupo de objetos. La clase “coche” serviría como molde para crear objetos coche con las mismas características. Como explica el programador Alan Kay, uno de los creadores de la POO:\n“La idea central de POO es que los usuarios deben manipular objetos conceptuales más que máquinas de Turing. Las interfaces con el mundo real deben, por lo tanto, ser construidas en términos de objetos conceptuales.”1\nEs decir, la POO modela conceptualmente elementos del mundo real para hacer la programación más intuitiva.\nParadigmas de programación Antes de profundizar en la POO, conviene entender que existen diferentes paradigmas o enfoques para abordar la programación. Los principales son:\nProgramación procedural Secuencia ordenada de instrucciones que el programa debe seguir paso a paso. El foco está en procedimientos y funciones. Por ejemplo, C es un lenguaje orientado a la programación procedural.\nLa programación procedural es mejor para:\nProblemas sencillos o algoritmos secuenciales. Código que no necesitará reusarse ni expandirse mucho. Casos donde el rendimiento y eficiencia son críticos. Programación orientada a objetos Modelo basado en objetos que contienen datos y código en unidades cohesivas. El foco está en las clases y en la interacción entre objetos. Por ejemplo, Java y Python son lenguajes orientados a objetos.\nLa POO permite modelar de forma más directa elementos del mundo real, encapsular mejor los datos y reutilizar código a través de la herencia entre clases.\nLas principales ventajas de POO frente a la programación procedural son:\nModularidad: los objetos agrupan datos y operaciones relacionadas, encapsulando la complejidad interna. Esto permite trabajar con módulos independientes. Ocultación de información: Los objetos pueden exponer una interfaz simple y ocultar detalles de implementación internos. Esto reduce acoplamientos. Reusabilidad: Las clases permiten reuse de código. Una clase abstracta puede heredar a múltiples subclases. Extensibilidad: Podemos extender el comportamiento de clases padres creando nuevas subclases. Mapeo conceptual: Los objetos representan entidades del mundo real, lo cual facilita la traducción de requerimientos a código. Sin embargo, la POO también tiene desventajas. Según el programador Paul Graham:\n“La programación orientada a objetos suele ser una molestia. Hace que las cosas sean más difíciles de lo que deberían ser.”2\nPor ejemplo, para problemas simples la POO puede resultar excesiva. Y en proyectos grandes existe el riesgo de abusar de la herencia y el polimorfismo, volviendo el código difícil de seguir.\nEn definitiva, la POO es más adecuada cuando:\nEl problema a modelar tiene entidades claras y estructuradas. Queremos reutilizar código encapsulado en clases modulares. Trabajamos en sistemas que deben extenderse y mantenerse con facilidad. Conceptos básicos de POO Ahora que conocemos las ideas generales detrás de la POO, veamos algunos de los conceptos clave:\nObjetos Un objeto es una combinación de datos (propiedades) y comportamientos (métodos). Por ejemplo, un objeto Coche tendría propiedades como marca, modelo, color y métodos como acelerar, frenar, etc.\n# Clase Coche class Coche: def __init__(self, marca, color): self.marca = marca self.color = color def acelerar(self): print(\"Acelerando\", self.marca) # Crear Objeto mi_coche = Coche(\"Toyota\", \"Rojo\") mi_coche es ahora un objeto Coche con propiedades y métodos definidos en su clase. Clases Una clase define los atributos (propiedades) y métodos (funciones) comunes a un grupo de objetos. Funciona como un molde para crear objetos similares.\nPor convención las clases se definen con la primera letra en mayúscula. Las propiedades y métodos de una clase reciben el prefijo self para indicar que pertenecen a esa instancia de objeto.\nclass Circulo: def __init__(self, radio): self.radio = radio def area(self): return 3.1416 * (self.radio ** 2) Circulo define la clase con propiedad radio y método area(). Métodos Los métodos son funciones que definen el comportamiento de un objeto. Se declaran dentro de la clase y pueden acceder a las propiedades del objeto mediante self.\nUn constructor es un método especial (__init__) que se ejecuta al crear objetos para inicializar sus propiedades.\nclass Persona: def __init__(self, nombre, edad): self.nombre = nombre self.edad = edad def saludar(self): print(f\"Hola! Soy {self.nombre}\") juan = Persona(\"Juan\", 30) # Ejecuta __init__ juan.saludar() # \"Hola! Soy Juan\" El constructor asigna nombre y edad. El método saludar() accede al atributo nombre. Propiedades Las propiedades son variables asociadas a un objeto que definen sus características o estado. Se declaran en la clase y se accede a ellas mediante la referencia del objeto.\nclass Rectangulo: def __init__(self, alto, ancho): self.alto = alto self.ancho = ancho r = Rectangulo(3,4) print(r.alto) # 3 r.ancho = 8 print(r.ancho) # 8 Se recomienda declarar las propiedades como privadas y acceder mediante métodos getters/setters para respetar el encapsulamiento.\nEncapsulamiento Consiste en ocultar los detalles de implementación internos de un objeto exponiendo solo una interfaz pública. Esto se logra declarando métodos y propiedades con los modificadores public o private.\nEn Python se denota con guion bajo prefijo para métodos/propiedades privadas:\nclass CuentaBancaria: def __init__(self, saldo=0): self.saldo = saldo def depositar(self, monto): self._saldo += monto def consultar_saldo(self): return self._saldo _saldo es privado, solo se accede internamente o por consultar_saldo(). El encapsulamiento facilita cambiar partes internas de una clase sin afectar su interfaz pública.\nConclusión La Programación Orientada a Objetos modela elementos del mundo real como clases y objetos, priorizando la modularidad, ocultación de información y reuso de código para crear programas más robustos y fáciles de mantener.\nAunque puede resultar excesiva para problemas simples, la POO es ideal para sistemas de mediana/gran escala que necesitan expandirse y evolucionar en complejidad con el tiempo.\nConceptos como herencia, polimorfismo, abstracción e interfaces permiten aprovechar al máximo las ventajas de este paradigma. Con una comprensión sólida de sus fundamentos estamos listos para aplicar la POO en cualquier lenguaje y proyecto de programación.\nReferencias Kay, Alan. The early history of Smalltalk. http://gagne.homedns.org/~tgagne/contrib/EarlyHistoryST.html ↩︎\nGraham, Paul. Why Arc Isn’t Especially Object-Oriented. http://www.paulgraham.com/noop.html ↩︎\n","categories":"","description":"","excerpt":"La Programación Orientada a Objetos (POO) es un paradigma de …","ref":"/es/programming/0300-oop/","tags":"","title":"Programación Orientada a Objetos"},{"body":"Anatomía de una clase Una clase actúa como un plano o molde para construir objetos similares, definiendo sus características comunes y funcionalidades. Es similar al plano para construir casas de un mismo barrio: todas comparten ciertos atributos clave.\nLos componentes típicos de una clase son:\nAtributos (propiedades): Variables que caracterizan al objeto. Por ejemplo, para una clase Persona, atributos como nombre, edad, DNI, etc.\nclass Persona: dni = \"\" nombre = \"\" edad = 0 Métodos: Funciones que definen comportamientos. Por ejemplo, una Persona puede caminar(), hablar(), comer(), etc. Acceden a los atributos para implementar dicha funcionalidad.\nConstructor: Método especial __init__() que se ejecuta al instanciar la clase y permite inicializar los atributos.\nDestructor: Método __del__() que se ejecuta al eliminar la instancia liberando recursos. Opcional en algunos lenguajes.\nCreando objetos A partir de la clase generamos objetos, que son instancias concretas con sus propios atributos definidos. Digamos que la clase Casa es el plano, y una casa específica en una calle determinada es el objeto.\nEn código creamos un objeto invocando la clase como si fuera un método:\n# Clase Persona class Persona: def __init__(self, n, e): self.nombre = n self.edad = e # Objeto Persona específico pepe = Persona(\"Pepe\", 30) juan = Persona(\"Juan\", 35) Cada objeto comparte la estructura y comportamiento general, pero puede almacenar distintos datos.\nUtilizando Propiedades y Métodos Ya tenemos una clase Persona y un objeto pepe de tipo Persona. ¿Cómo interactuamos con el objeto?\nPropiedades: Es posible acceder al valor de un atributo del objeto utilizando la referencia al objeto (pepe) y el nombre del atributo. pepe.nombre # \"Pepe\" pepe.edad # 30 Métodos: De la misma manera en la que se accede a los atributos pero agregando un paréntesis dentro del cual se pasan los argumentos si es que recibe alguno. # Clase Persona class Persona: def __init__(self, n, e): self.nombre = n self.edad = e def comer(self, comida): print(f\"Comiendo {comida}\") # Objeto Persona específico pepe = Persona(\"Pepe\", 30) pepe.comer(\"pizza\") # Imprime \"Comiendo pizza\" El objeto pepe tiene ahora estado (propiedades) y comportamiento (métodos) propios.\nSelf vs This Un detalle importante en los métodos es cómo acceden a los atributos y otros métodos del objeto. Aquí entra otra diferencia entre lenguajes:\nSelf: En Python, los atributos y métodos se acceden dentro de la clase anteponiendo self. Esto apunta al objeto instanciado. class Persona: def __init__(self, nombre): self.nombre = nombre def saludar(self): print(f\"Hola! Soy {self.nombre}\") juan = Persona(\"Juan\") juan.saludar() # Imprime \"Hola! Soy Juan\" This: En Java o C#, se utiliza this en lugar de self. Cumple la misma funcionalidad de apuntar a los miembros del objeto. public class Person { private String nombre; public Person(String nombre) { this.nombre= nombre; } public void saludar() { System.out.println(\"Hola! Soy \" + this.nombre); } } Person juan = new Person(\"Juan\"); juan.saludar(); // Imprime \"Hola! Soy Juan\" Conclusión Las clases y objetos son los conceptos clave de la POO, permitiendo modelar entidades de la realidad y generar componentes modulares y genéricos de nuestro sistema para construir programas más robustos y fáciles de entender y mantener.\n","categories":"","description":"En programación orientada a objetos, las clases y objetos son los conceptos centrales para entender cómo modelamos elementos de la realidad y definimos su estructura y comportamiento dentro del software. Veamos en detalle la anatomía de una clase, cómo crear objetos a partir de ella para usar sus propiedades y métodos, y otros detalles clave de su relación.\n","excerpt":"En programación orientada a objetos, las clases y objetos son los …","ref":"/es/programming/0300-oop/0301-classes-objects/","tags":["oop","object-oriented","classes","objects"],"title":"Clases y Objetos"},{"body":"Anatomy of a class A class acts as a blueprint or mould to construct similar objects, defining their common characteristics and functionalities. It is similar to the blueprint used to construct houses in the same neighbourhood: they all share certain key attributes.\nThe typical components of a class are:\nAttributes (properties): Variables that characterise the object. For example, for a Person class, attributes like name, age, ID, etc.\nclass Person: id = \"\" name = \"\" age = 0 Methods: Functions that define behaviours. For example, a Person can walk(), talk(), eat(), etc. They access the attributes to implement said functionality.\nConstructor: Special __init__() method that executes when instantiating the class and allows initialising attributes.\nDestructor: __del__() method that executes when deleting the instance, freeing up resources. Optional in some languages.\nCreating objects From the class we generate objects, which are specific instances with their own defined attributes. Let’s say the House class is the blueprint, and a specific house on a particular street is the object.\nIn code, we create an object by invoking the class as if it were a method:\n# Person class class Person: def __init__(self, n, a): self.name = n self.age = a # Specific Person objects john = Person(\"John\", 30) mary = Person(\"Mary\", 35) Each object shares the general structure and behaviour but can store different data.\nUsing properties and methods We now have a Person class and a john object of type Person. How do we interact with the object?\nProperties: It is possible to access the value of an object attribute using the object reference (john) and the attribute name. john.name # \"John\" john.age # 30 Methods: In the same way as accessing attributes but adding parentheses inside which arguments are passed if it takes any. # Person class class Person: def __init__(self, n, a): self.name = n self.age = a def eat(self, food): print(f\"Eating {food}\") # Specific Person object john = Person(\"John\", 30) john.eat(\"pizza\") # Prints \"Eating pizza\" The john object now has its own state (properties) and behaviour (methods).\nSelf vs This An important detail in methods is how they access the object’s attributes and other methods. Here another difference between languages comes into play:\nSelf: In Python, attributes and methods are accessed within the class by prepending self. This points to the instantiated object. class Person: def __init__(self, name): self.name = name def greet(self): print(f\"Hello! I'm {self.name}\") john = Person(\"John\") john.greet() # Prints \"Hello! I'm John\" This: In Java or C#, this is used instead of self. It fulfils the same functionality of pointing to the object’s members. public class Person { private String name; public Person(String name) { this.name = name; } public void greet() { System.out.println(\"Hello! I'm \" + this.name); } } Person john = new Person(\"John\"); john.greet(); # Prints \"Hello! I'm John\" Conclusion Classes and objects are the key concepts in OOP, allowing modelling real-world entities and generating modular, generic components of our system to construct more robust and easy to understand programmes.\n","categories":"","description":"In object-oriented programming, classes and objects are the key concepts to understand how we model elements of reality and define their structure and behaviour within software. Let's look in detail at the anatomy of a class, how to create objects from it to use their properties and methods, and other key details of their relationship.\n","excerpt":"In object-oriented programming, classes and objects are the key …","ref":"/en/programming/0300-oop/0301-classes-objects/","tags":["oop","object-oriented","classes","objects"],"title":"Classes and objects"},{"body":"According to Sommerville and Sawyer, a requirement is a statement about an intended product that specifies what it should do or how it should perform1.\nRequirements identify the goals, needs and constraints that the software must address in order to deliver value. They are a form of specification that serve as the foundation for all subsequent software engineering activities.\nSome key definitions of requirements are:\nDescription of how the system should behave. Features that the software needs to deliver. Functionalities that users expect from the software. Statements of business rules that software must comply with. Constraints on development of the software. Requirements convey the intended purpose, context and environment in which the software will operate. They express the underlying motivations for why the software needs to be built by identifying problems faced by users or organization.\nAs Wiegers puts it, requirements describe the inner and outer capabilities, characteristics, and qualities that the product must have or perform well to satisfy all aspects of the product vision2.\nWhat should requirements define? Good requirements provide a complete description of what the software will do, without dealing with how it will be implemented.\nSome key aspects that requirements should define are:\nUser capabilities: what can users do with the system? e.g. login, search, make payment etc. Operational workflows: how does system interact with users and external systems? e.g. order processing workflow. Business rules: what policies and rules does system need to comply with? e.g. credit limits. Integration touch points: how does system integrate with other systems? e.g. payment gateway APIs. Quality attributes: what non-functional qualities are important? e.g. security, availability. External interfaces: how does system interact with external actors? e.g. device interfaces. Environment conditions: what environmental constraints are present? e.g. operating system. Design/architectural constraints: are there constraints on design choices? e.g. use cloud infrastructure. Documenting these aspects ensures requirements provide a good view into the problem space and what the software solution needs to achieve.\nProperties of good requirements High quality requirements exhibit certain desired characteristics:\nComplete: requirements capture the full capabilities needed without any gaps. Correct: requirements precisely represent genuine user needs. Feasible: requirements can be reasonably implemented within constraints. Unambiguous: requirements have clear meaning that is open to only one interpretation. Consistent: there are no conflicts or contradictions between requirements. Prioritized: importance and urgency is indicated to guide implementation. Verifiable: requirements can be validated via concrete acceptance criteria. Traceable: origin of each requirement is clear for analysis. Atomic: requirements define one need instead of multiple combined needs. Implementation free: requirements avoid implementation choices or design details. Adhering to these qualities results in a strong set of requirements that serve as a solid foundation for the software design and development.\nLevels of requirements Requirements are defined at different levels of abstraction and detail. Requirements evolve from high-level needs to detailed specifications through this hierarchical breakdown.\nBusiness requirements These capture high-level needs related to business objectives, problems and outcomes the software should achieve. They are written using terminology familiar to business users. Examples include:\nImprove customer retention by 10%. Reduce operational costs by optimizing order processing. Enable omni-channel order fulfillment. User requirements These describe the needs and wishes of end-users related to functionality and quality. They capture who, what, where, when and why of user interactions. Examples:\nUser shall be able to place orders 24/7 via website. System shall provide real-time order status tracking. User shall be able to save payment information securely. System requirements These describe the detailed behaviours, operations, capabilities and business rules the system needs to implement. Or, impose quality constraints, performance needs and other attributes on the system. Examples:\nSystem shall verify customer identity before accepting order. User shall be able to filter orders by date, status, amount, etc. System shall interface with the inventory system to validate product availability. System must have a uptime of 99.95%. Page response time must be under 100 ms for 90% of requests. System must store customer data encrypted at rest. Types of requirements There are two main types of requirements:\nFunctional requirements These describe the specific behaviours and operations that the system needs to perform in order to accomplish the intended purpose. Functional requirements depend heavily on the type of software being developed. Some examples of functional requirements are:\nThe system shall allow users to sign in using their email address and password. The system shall allow admins to add new user accounts. The system shall allow managers to generate sales reports by region. The system shall integrate with PayPal to accept payments. Non-functional requirements Non-functional requirements specify quality attributes and constraints that software must meet. They impose restrictions on how the system performs its functions. Examples of non-functional requirements:\nThe system shall have an uptime of 99.95%. The system shall support up to 100 concurrent active users. User passwords must be stored in encrypted format. The website shall work on mobile and desktop browsers. In turn, non-functional requirements can be divided into the following categories. Covering relevant categories of non-functional needs results in a comprehensive set of quality requirements.\nProduct Requirements These relate to quality characteristics of the software itself. Types include:\nUsability: how easy is it for users to learn and operate the system? Performance: response times, throughput, resource usage, scalability targets, etc. Security: access control, encryption, vulnerability prevention, etc. Availability: uptime, reliability, disaster recovery needs, etc. Maintainability: ability to make changes, add new features, repair defects, etc. Portability: ability to work across different environments and platforms. Organizational Requirements These relate to business, process and compliance needs of the organization. Types include:\nDelivery: schedule, release planning, milestones to be met. Legal: regulations, policies, standards that must be complied with. Data: data formats, retention periods, reporting needs, etc. Process: integration with organizational workflows, change management, etc. Operational: server environments, infrastructure standards, monitoring needs, etc. External Requirements These relate to integration with external systems and end user environments. Types include:\nInterfaces: protocols, APIs, formats for exchanging data. Interoperability: ability to integrate with other systems as needed. Hardware: support for client hardware like scanners, handhelds, etc. Platform: compatibility with end user operating systems. Software Requirements Specification (SRS) The Software Requirements Specification (SRS) is the official document that captures the complete set of requirements for the system in detail. It is treated as the contract between customers and developers.\nAccording to IEEE, the SRS can be defined as a document that describes all data, functional and behavioural requirements; analyzes, specifies, and validates the system requirements3.\nSome key purposes that the SRS serves are:\nFormally documents the requirements agreed upon by stakeholders. Serves as reference for planning, estimating and tracking the project. Reduces ambiguity by recording details about requirements. Serves as basis for design, development and testing activities. Facilitates communication and consensus between teams. Becomes basis for verification and validation. Evolves into system tests, user manuals, etc. The main users of the SRS document are:\nCustomers: clarify needs, review and approve requirements. Managers: estimate effort, plan activities, track progress. Architects: analyze requirements to design solutions. Developers: understand detailed needs to implement. Testers: derive test conditions and test cases. Technical Writers: use it as foundation for user manuals. A typical SRS is organized into the following sections:\nIntroduction: purpose, scope, definitions, acronyms, references. User Requirements: capabilities, user characteristics, constraints. Functional Requirements: functionalities, operations, business rules. Non-functional Requirements: qualities, performance, attributes. External Interface Requirements: interactions with other systems, devices, etc. Other Requirements: licensing, compliance, platform, deliverables. Appendix: diagrams, analysis models, schema definitions. The SRS maintains traceability between stakeholder needs, requirements specification and system design. This enables tracking of requirements throughout the product lifecycle.\nNotations for documenting requirements Textual description is the most common way of documenting requirements in the SRS. However, visual models and formal notations can also be used to express specific aspects precisely. Here there are different ways of expressing software requirements.\nUser stories: used in agile methods to capture user requirements. Written as “As a , I want so that ”. Use cases: describe interactions between users and the system to achieve a goal. Data models: express structure of data as entities, attributes, relationships etc. e.g. ER diagrams. Behaviour models: represent dynamic behaviour and workflows e.g. state machine diagrams, activity diagrams. Interface models: specify external interfaces using API blueprints, protocol specs, etc. Supplementary specifications: detailed non-functional specs e.g. security standards, compliance rules. Choosing appropriate techniques allows capturing complete details in an unambiguous manner. The textual SRS can reference these as needed.\nEliciting and analysing requirements Requirements come from analysing the needs of various stakeholders. Typical steps are:\nStakeholder identification: identify various stakeholders - end users, business managers, operations team, etc. Requirements gathering: gather needs via interviews, observation, focus groups, workshops, surveys, etc. Requirements gathering relies heavily on techniques like prototyping, scenario analysis, domain modelling and qualitative user research. Requirements analysis: analyze requirements for clarity, conflicts and prioritization. Requirements documentation: document requirements, review with stakeholders and baseline. Requirements validation: validate requirements to ensure consistency, completeness, technical feasibility, etc. Requirements management: manage changes through proper change control processes. According to Davis, requirements management is critical for aligning software capabilities with business objectives throughout the product lifecycle4. Challenges Some key challenges faced in requirements engineering are:\nIncomplete, unclear and ambiguous requirements. Infeasible requirements beyond project constraints. Conflicting stakeholder needs and priorities. Frequent requirement changes leading to scope creep. Missing key details and assumptions. Lack of customer availability and engagement. Users not knowing what they need. Weak change management discipline. Communication gaps across customer and development teams. According to Christel and Kang, requirements elicitation is a complex activity due to factors like vague customer needs, lack of user involvement and staggered feedback5. Using proven elicitation techniques, sound documentation practices, rigorous analysis and reviews, and disciplined change management helps tackle these challenges.\nEmerging Trends Some key trends shaping the future of requirements engineering:\nIncreased end user involvement through prototyping and crowdsourcing. Growing use of iterative approaches to allow for emergent requirements. Greater reliance on product managers as customer proxies. Increased adoption of agile user stories over traditional SRS docs. Enhanced traceability through modelling and automation. Integration with design models and testing to realize “single source of truth”. Introducing requirements management tools for collaboration. Leveraging AI techniques for analysing and deriving complex requirements. Focus on continuously capturing and refining requirements throughout product lifecycle. According to Nuseibeh and Easterbrook, requirements engineering will need to adapt to factors like faster delivery cycles, evolving design approaches and increased automation6.\nConclusion Defining complete, correct requirements that accurately capture end user and business needs is essential to delivering effective software solutions. Requirements engineering done right lays the foundation for developing a product that delivers maximum value. Applying sound specification techniques, following collaborative elicitation processes, documenting requirements clearly, and managing changing needs systematically are key disciplines that lead to high quality software products that meet customer expectations.\nReferences Sommerville, Ian, and Pete Sawyer. Requirements engineering: a good practice guide. John Wiley \u0026 Sons, Inc., 1997. ↩︎\nKarl E. Wiegers, and Joy Beatty. Software requirements. Pearson Education, 2013. ↩︎\nIEEE. IEEE Guide for Developing System Requirements Specifications. IEEE Std 1233, 1998 edition. ↩︎\nA. M. Davis. Just enough requirements management: where software development meets marketing. Dorset House Publishing Co., Inc., 2005. ↩︎\nChristel, Michael G., and Kyo C. Kang. Issues in requirements elicitation. Carnegie Mellon University, 1992. ↩︎\nNuseibeh, Bashar, and Steve Easterbrook. “Requirements engineering: a roadmap.” Proceedings of the Conference on the Future of Software Engineering. 2000. ↩︎\n","categories":"","description":"Requirements engineering is the process of defining, documenting and maintaining requirements for a software system. It is the first and foundational stage in the software development lifecycle. Requirements express the needs and constraints that the software must satisfy in order to solve problems and provide value to users and the business. Let's get started understanding the basics of requirements in software projects.\n","excerpt":"Requirements engineering is the process of defining, documenting and …","ref":"/en/software-engineering/0300-requirements-engineering/01-requirements-engineering/","tags":["software-engineering","requirements","srs"],"title":"Requirements Engineering"},{"body":"Uno de los pilares fundamentales de la programación orientada a objetos es el encapsulamiento. Esta potente característica nos permite controlar el acceso a los miembros de una clase, ocultando los detalles de implementación y protegiendo el estado de nuestros objetos. En este artículo veremos en profundidad el concepto de encapsulamiento, la utilidad del uso de getters, setters, propiedades y métodos públicos/privados, y los importantes beneficios que esto nos brinda como desarrolladores.\nEl diccionario de la Real Academia Española define encapsulamiento como el “envuelto o contenido como dentro de una cápsula”. Esto es precisamente lo que buscamos, “empaquetar” datos y código dentro de una única cápsula (la clase) para ocultar su complejidad interna.\nLa definición formal sería:\n“El encapsulamiento es el empaquetamiento de los datos y funciones que manipulan estos datos en una única entidad o módulo de programa.”1\nEs decir, mantener juntos datos y comportamientos relacionados para restringir el acceso directo a dichos datos desde otras partes del programa, interactuando solo a través de una interfaz controlada (API pública).\nEsto provee ventajas como las siguientes:\nControl sobre modificación de datos. Flexibilidad al poder cambiar partes internas sin afectar otras partes. Protección del estado consistente de los objetos. Ocultación de complejidad al usuario. Veamos con ejemplos concretos cómo encapsular en POO.\nGetters y Setters Digamos que tenemos una clase CuentaBancaria, con propiedades como nombre, número de cuenta y saldo:\nclass CuentaBancaria: nombre = \"\" nro_cuenta = 0 saldo = 0.0 Podemos acceder directamente a los atributos así:\ncuenta1 = CuentaBancaria() cuenta1.nombre = \"Juan\" cuenta1.nro_cuenta = 1234 cuenta1.saldo = 2500 El problema es que cualquier otro código puede modificar el saldo a valores inválidos:\ncuenta1.saldo = -9900 # ¡Saldo no puede ser negativo es este banco! Esto permite estado inconsistente. Para encapsular usamos getters y setters:\nclass CuentaBancaria: def __init__(self): self.__saldo = 0 def get_saldo(self): return self.__saldo def set_saldo(self, valor): if valor \u003c 0: raise Exception(\"Saldo no puede ser negativo en este banco\") self.__saldo = valor __saldo es ahora privado. Solo se manipula mediante los getters y setters públicos.\nEl setter controla que no se ingresen valores no válidos.\nEn Python, anteponer doble guion bajo __ denota un método o atributo privado de la clase. Con guion simple _ es por convención un elemento protegido, o sea, accesible desde la clase y subclases pero no desde fuera. Y sin guiones, los métodos y atributos son públicos.\nEn Java es explícito utilizando las palabras claves public, protected y private:\npublic class Persona { private String nombre; // Privado public String getNombre() { // Público return this.nombre; } } Esta notación nos ayuda a declarar adecuadamente la visibilidad deseada para aplicar encapsulamiento.\nBeneficios del encapsulamiento Esta poderosa técnica nos proporciona grandes ventajas:\nOcultación de información: Los detalles de implementación son invisibles para otros objetos, reduciendo acoplamientos. Podemos cambiar código interno minimizando impacto. Control sobre datos: Se garantiza la integridad y validez de estado mediante los setters/validadores. Código flexible: El aislamiento entre interfaces y detalles específicos permite construir sistemas más extensibles y fáciles de mantener en el tiempo. “Todo módulo oculta la complejidad de su contenido detrás de una fachada (interfaz) simple”, Gang of Four2.\nEn definitiva, cuando necesitamos controlar cómo se manipula el estado interno de una clase desde otras partes de la aplicación, el encapsulamiento es la mejor solución.\nConclusión Aplicar encapsulamiento restringiendo el acceso directo a los datos y codificando cuidadosamente una interfaz de acceso pública, nos permite construir sistemas POO más robustos, seguros y sustentables en el tiempo.\nDominar estas técnicas requiere experiencia y buen criterio para encontrar el balance adecuado entre ocultación de información y provisión de flexibilidad. Pero sin dudas vale la pena el esfuerzo para exprimir los beneficios que hemos visto de este maravilloso principio de la POO.\nReferencias Byron, Jeff. Encapsulation in Java. https://stackify.com/encapsulation-in-java/ ↩︎\nGamma, Erich et al. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. 1994. ↩︎\n","categories":"","description":"Uno de los pilares fundamentales de la programación orientada a objetos es la encapsulación. Esta poderosa característica nos permite controlar el acceso a los miembros de una clase, ocultando los detalles de implementación y protegiendo el estado de nuestros objetos. En este artículo profundizaremos en el concepto de encapsulación, la utilidad de los getters, setters, propiedades y métodos públicos/privados, así como en los importantes beneficios que esto nos proporciona como desarrolladores.\n","excerpt":"Uno de los pilares fundamentales de la programación orientada a …","ref":"/es/programming/0300-oop/0302-encapsulation/","tags":["oop","object-oriented","encapsulation"],"title":"Encapsulamiento"},{"body":"The Oxford Dictionary defines encapsulation as “enclosed or contained as if in a capsule”. This is precisely what we seek to achieve - “packaging” data and code within a single capsule (the class) to hide its internal complexity.\nThe formal definition would be:\n“Encapsulation refers to bundling data and functions that manipulate these data into a single entity or software module.”1\nThat is, keeping related data and behaviours together in order to restrict direct access to that data from other parts of the programme, interacting only through a controlled interface (public API).\nThis provides advantages like:\nControl over data modification. Flexibility to change internal parts without affecting others. Protection of the consistent state of objects. Hiding complexity from the user. Let’s see with concrete examples how to encapsulate in OOP.\nGetters and Setters Say we have a BankAccount class, with properties like name, account number and balance:\nclass BankAccount: name = \"\" account_number = 0 balance = 0.0 We can directly access attributes like:\naccount1 = BankAccount() account1.name = \"John\" account1.account_number = 1234 account1.balance = 2500 The problem is any other code can modify the balance to invalid values:\naccount1.balance = -9900 # Balance can't be negative in this bank! This allows inconsistent state. To encapsulate we use getters and setters:\nclass BankAccount: def __init__(self): self.__balance = 0 def get_balance(self): return self.__balance def set_balance(self, value): if value \u003c 0: raise Exception(\"Balance can't be negative in this bank\") self.__balance = value __balance is now private. It is only manipulated via the public getters and setters.\nThe setter controls invalid values not being input.\nIn Python, prepending double underscore __ denotes a private method or attribute of the class. With a single underscore _ it’s by convention a protected element, accessible from class and subclasses but not externally. And with no underscores, methods and attributes are public.\nIn Java this is explicit using the keywords public, protected and private:\npublic class Person { private String name; // Private public String getName() { // Public return this.name; } } This notation helps declare the desired visibility to properly apply encapsulation.\nBenefits of encapsulation This powerful technique provides great advantages:\nInformation hiding: Implementation details are invisible to other objects, reducing coupling. Internal code can change minimizing impact. Control over data: Integrity and validity of state is guaranteed via setters/validators. Flexible code: Isolation between interfaces and specifics enables building more extensible and maintainable systems over time. “Every module hides the complexity of its contents behind a simple fa??ade (interface)”, Gang of Four2.\nUltimately, when we need to control how internal state is manipulated in a class from other parts of the application, encapsulation is the best solution.\nConclusion Applying encapsulation by restricting direct access to data and carefully coding a public access interface allows us to build more robust, secure and sustainable OOP systems over time.\nMastering these techniques requires experience and good judgement to find the right balance between information hiding and flexibility. But undoubtedly it???s worth the effort to leverage the benefits we???ve seen from this wonderful OOP principle.\nReferences Byron, Jeff. Encapsulation in Java. https://stackify.com/encapsulation-in-java/ ↩︎\nGamma, Erich et al. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. 1994. ↩︎\n","categories":"","description":"One of the fundamental pillars of object-oriented programming is encapsulation. This powerful characteristic allows us to control access to class members, hiding implementation details and protecting the state of our objects. In this article we will delve into the concept of encapsulation, the usefulness of getters, setters, public/private properties and methods, and the important benefits this provides us as developers.\n","excerpt":"One of the fundamental pillars of object-oriented programming is …","ref":"/en/programming/0300-oop/0302-encapsulation/","tags":["oop","object-oriented","encapsulation"],"title":"Encapsulation"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/encapsulation/","tags":"","title":"Encapsulation"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/encapsulation/","tags":"","title":"Encapsulation"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/object-oriented/","tags":"","title":"Object-Oriented"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/object-oriented/","tags":"","title":"Object-Oriented"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/oop/","tags":"","title":"Oop"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/oop/","tags":"","title":"Oop"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/classes/","tags":"","title":"Classes"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/classes/","tags":"","title":"Classes"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/objects/","tags":"","title":"Objects"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/objects/","tags":"","title":"Objects"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/factorial/","tags":"","title":"Factorial"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/factorial/","tags":"","title":"Factorial"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/fibonacci/","tags":"","title":"Fibonacci"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/fibonacci/","tags":"","title":"Fibonacci\""},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/functions/","tags":"","title":"Functions"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/functions/","tags":"","title":"Functions"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/programming/","tags":"","title":"Programming"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/programming/","tags":"","title":"Programming"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/recursion/","tags":"","title":"Recursion"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/recursion/","tags":"","title":"Recursion"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/intro/","tags":"","title":"Intro"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/intro/","tags":"","title":"Intro"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/methods/","tags":"","title":"Methods"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/methods/","tags":"","title":"Methods"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/bucles/","tags":"","title":"Bucles"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/condicionales/","tags":"","title":"Condicionales"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/conditionals/","tags":"","title":"Conditionals"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/control-flow/","tags":"","title":"Control-Flow"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/control-flujo/","tags":"","title":"Control-Flujo"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/for/","tags":"","title":"For"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/for/","tags":"","title":"For"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/if/","tags":"","title":"If"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/if/","tags":"","title":"If"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/loops/","tags":"","title":"Loops"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/while/","tags":"","title":"While"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/while/","tags":"","title":"While"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/i/o/","tags":"","title":"I/O"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/i/o/","tags":"","title":"I/O"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/input/output/","tags":"","title":"Input/Output"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/input/output/","tags":"","title":"Input/Output"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/data-types/","tags":"","title":"Data-Types"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/data-types/","tags":"","title":"Data-Types"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/variables/","tags":"","title":"Variables"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/variables/","tags":"","title":"Variables"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/ide/","tags":"","title":"Ide"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/install/","tags":"","title":"Install"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/install/","tags":"","title":"Install"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/python/","tags":"","title":"Python"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/python/","tags":"","title":"Python"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/tools/","tags":"","title":"Tools"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/tools/","tags":"","title":"Tools"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/boolean-logic/","tags":"","title":"Boolean-Logic"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/boolean-logic/","tags":"","title":"Boolean-Logic"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/binario/","tags":"","title":"Binario"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/binary/","tags":"","title":"Binary"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/decimal/","tags":"","title":"Decimal"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/decimal/","tags":"","title":"Decimal"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/hexadecimal/","tags":"","title":"Hexadecimal"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/hexadecimal/","tags":"","title":"Hexadecimal"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/numerical-systems/","tags":"","title":"Numerical-Systems"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/sistemas-numeracion/","tags":"","title":"Sistemas-Numeracion"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/cd/","tags":"","title":"Cd"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/computer/","tags":"","title":"Computer"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/computer/","tags":"","title":"Computer"},{"body":"Continuous Delivery (CD) is deeply rooted in the first principle of the Agile Manifesto posted in 20011:\nOur highest priority is to satisfy the customer through early and continuous delivery of valuable software.\nAccording to Martin Fowler2, a project is truly embracing Continuous Delivery when:\nThe software can be deployed at any stage of its lifecycle. The team values keeping the software deployment-ready over adding new features. Any software version can be deployed to any environment on-demand. In many ways, Continuous Delivery is the next step from Continuous Integration, seamlessly automating processes all the way to the software’s end user.\nMuch like in Continuous Integration, the pipeline stands as the cornerstone of Continuous Delivery. However, it’s not just about integrating code, testing it, and generating a deliverable artifact. With CD, this artifact progresses through a series of test phases in environments that increasingly resemble production settings. After passing through the Continuous Integration pipeline, what emerges is a potentially deployable artifact. CD then takes this artifact and puts it through the necessary tests, ensuring it’s primed for a live deployment.\nThe delivery process The following figure illustrates the fundamental steps of a Continuous Delivery (CD) process. It’s vital to note that an effective CD process presupposes a well-oiled Continuous Integration (CI) system as its foundation.\nFigure 1: CD process flowchart\nThe CD process adds two distinct phases to the CI system: deployment stages and system validation and verification testing. A critical premise is that the deployment process is paramount to product delivery. Thus, automating and frequently testing it is essential. Ideally, testing should also be automated to facilitate execution, especially if you aim for Continuous Deployment. However, it’s not imperative to automate all tests, especially at the beginning of the CD process implementation.\nUpon creating a potentially deliverable artifact in the CI pipeline, the initial step is to deploy it in a testing or QA environment. The primary goal of this environment is to offer a space where software tests, both automatic and manual, can be run. The only possible variations between the QA and actual production environment (the one used by customers) may pertain to its capacity or resource size. This scaled-down capacity, whether in processing, memory, storage, or database size, is typically a cost-saving measure.\nIf system and acceptance tests are successful in the QA environment, the next phase is to deploy the artifact in a staging environment. This environment should be an exact replica of the production setting. Its purpose is to facilitate performance and load testing on the system, effectively putting it under stress to validate its functionality under high loads and assess its processing and response times.\nWhen the previous tests are satisfactory, the artifact is ready to be deployed in a production environment. This space is also referred to as the live environment, where users interact with the system.\nAs evident, the product deployment method is exercised at least twice before the final production deployment, considerably reducing risks associated with potential errors as the final delivery approaches.\nCore principles and practices One of CD’s primary objectives is to boost delivery frequency. This naturally means that each release should minimize its size. A smaller delivery not only implies fewer potential errors but also facilitates their identification and resolution2. To achieve this, the code must always be in a deploy-ready state.\nRapid automated testing is crucial for today’s software development3. In the context of CD, automated tests are of utmost importance as they must ensure comprehensive system quality without hampering the delivery cycle’s speed4. Lengthy test runs force the team to await results, leading to wasted time3. If these tests aren’t parallelized and optimized, developers may start sidelining them5. To ensure test optimization, it’s recommended to fail tests that exceed a reasonable limit6.\nThe software should always be potentially deliverable. It’s essential for the software’s build status to remain ‘green’ consistently. This means if a new repository commit breaks the build, this error must be rectified before any new commit is made. Adhering to this practice simplifies error tracing, while deviating may condition developers to overlook a broken or ‘red’ build6. Broken builds signify product flaws and render it undeliverable.\nIn using CD, the aim is to ensure each commit results in a production-ready artifact. If this artifact is rebuilt at every process stage, there’s no guarantee of their identical nature, and validation and verification test results from one artifact cannot be applied to others. This could lead to deploying untested artifacts6. Hence, artifacts should be produced only once and undergo all tests on that single artifact before deploying that very software piece to production.\nSoftware should always be deployed identically across all environments. Otherwise, there’s no assurance of the deployment process’s efficacy. If environment differences exist, they should be managed using configuration files, but the deployment process should remain consistent6.\nDeployment should be achievable with a mere button press. The ability to deploy the latest product version anytime with a single button press is a robust indicator of CD implementation2. This not only requires the aforementioned steps but also mandates version-controlled software deployment scripts that are regularly checked and validated6.\nAs mentioned earlier, CD’s main objective is to ascertain the product’s readiness post each commit2. For this, aside from ensuring a swift compilation and testing process, process outcomes should be visible and shared with the team. Display screens showcasing the current status, build times, test coverage, and more, offer a way to maintain constant visibility6. Presenting these results not only supports CD but, as some authors suggest, also bolsters team motivation4.\nBenefits of Continuous Delivery With the rise of Continuous Delivery (CD) practices, businesses are realizing numerous advantages:\nSwift value delivery: the adoption of CD practices facilitates a faster rollout of features and error rectifications to end users7. This speed is attributed to the code becoming potentially deployable to users as it traverses through the Continuous Integration (CI) pipeline4.\nDiminished delivery failures: frequent releases lead to fewer delivery risks since each release embodies fewer changes. This, in turn, means there’s a reduced margin for errors2. Even if an error emerges, its origin is easier to trace and correct. Plus, reverting to a previous version in the face of complications becomes straightforward8. A delightful byproduct of this streamlined process is the diminished stress levels amongst stakeholders7 5. Furthermore, the consistency and quality in the delivery process cement trust between the development team and clients7.\nProductivity amplification: Chen’s study reveals that, in the absence of CD practices, teams spent nearly \\(20%\\) of their time setting up and maintaining environments7. The introduction of CD automates this ordeal, which translates to heightened productivity by phasing out manual, non-value-add tasks6.\nPrompt feedback: a consensus among experts highlights the value of early feedback during the development phase2 7 4. Regular releases not only fetch this feedback promptly but also ensure that the developed product aligns seamlessly with customer requirements2. The agility to swiftly address customer needs, fix reported bugs, and introduce demanded features can significantly elevate customer satisfaction4.\nEnhanced software quality: the rigorous automation of software tests (unit, integration, and system), essential for implementing CD, combined with more frequent software deliveries encapsulating fewer changes, culminates in a notable boost in software quality4.\nTransparency in progress: thanks to frequent releases, clients find it easier to stay abreast of the latest product updates, embracing novel features and bug fixes with open arms.\nChallenges in adopting Continuous Delivery The journey to incorporate Continuous Delivery (CD) isn’t without its hurdles. Here’s a look at some of the key challenges faced by businesses:\nProduct complexity: certain products consist of myriad interconnected modules or possess dependencies with other projects. This can create bottlenecks when automating CD pipelines4. Such complexities might frustrate teams, pushing them to retain manual processes or longer integration procedures.\nTest suite creation: crafting a comprehensive test suite to ensure product quality is labour-intensive. All team members must allocate significant time to pen tests, which might require extra training. Besides, tests can be time-consuming, so the trick lies in devising effective yet swift tests4.\nLegacy code: systems that have been in development for an extended period and weren’t designed with automated testing in mind can pose a significant challenge. Transitioning such systems to CD is not only a technical endeavour but also a social and cultural shift4.\nEnvironmental discrepancies: all environments in the CI pipeline should mirror the production setting (‘production-like’)6. If not, unforeseen errors can arise, demanding valuable time on non-value-add tasks4. Ensuring multiple deployment stages in similar environments means that the deployment process is tested repetitively.\nClient restrictions: not every client might desire or require a shortened product delivery cycle4. Such client limitations aren’t direct obstacles to CD implementation but play a pivotal role when aiming for Continuous Deployment. This could potentially sideline some CD benefits, like swift client feedback or minimal change deliveries. Moreover, the domain itself can act as a bottleneck. Software related to heavily-regulated sectors like healthcare and defence may find CD implementation challenging, if not nearly impossible4.\nTransparency and reporting: a successful CD adoption hinges on collaboration and transparency, introducing challenges tied to providing effective status reports to stakeholders9. This encompasses technical hurdles around automated report generation and analytics challenges to pinpoint essential information.\nResistance to change: any transformative change, like adopting CD, faces the innate human trait of resistance. Convincing the team to adapt to new practices and modify their workflow is a task. On a higher level, management might also be hesitant to experiment with fresh processes.\nContinuous Deployment The notion of Continuous Deployment was popularized by Fitz10. The standout distinction between this method and Continuous Delivery (CD) is that, once the product is deemed ready for release, there’s no waiting for manual intervention to launch it into production11 6. If CD is properly executed, the step towards Continuous Deployment should demand no extra efforts from the development perspective8. In essence, the core difference lies in decision-making: with CD, releasing the product to production remains a business decision, whereas with Continuous Deployment, the launch is automated.\nIt’s worth noting that when we discuss CD, it inherently includes Continuous Delivery but may or may not encompass Continuous Deployment.\nReferences Beck, Kent, Mike Beedle, Arie van Bennekum, Alistair Cockburn, Ward Cunningham, Martin Fowler, James Grenning, Jim Highsmith, Andrew Hunt, Ron Jeffries, Jon Kern, Brian Marick, Robert C. Martin, Steve Mellor, Ken Schwaber, Jeff Sutherland, and Dave Thomas. Manifesto for Agile Software Development, 2001. ↩︎\nFowler, Martin. Continuous Delivery, 2013. ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎\nUdd, Raoul. Adopting Continuous Delivery: A Case Study, 2016. ↩︎ ↩︎\nLeppanen, Marko, Simo Makinen, Max Pagels, Veli-Pekka Eloranta, Juha Itkonen, Mika V. Mantyla, and Tomi Mannisto. The highways and country roads to continuous deployment. IEEE Software, 32(2):64-72, 2015. ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎\nNeely, Steve, and Steve Stolt. Continuous delivery? Easy! Just change everything (well, maybe it is not that easy). Proceedings - AGILE 2013, pp.121-128, 2013. ↩︎ ↩︎\nHumble, Jez, and David Farley. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011. ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎\nChen, Lianping. Continuous Delivery: Huge Benefits, but Challenges Too. IEEE Software, 32(2):50-54, 2015. ↩︎ ↩︎ ↩︎ ↩︎ ↩︎\nHumble, Jez. Continuous Delivery vs Continuous Deployment, 2010. ↩︎ ↩︎\nOlsson, Helena Holmstrom, Hiva Alahyari, and Jan Bosch. Climbing the “Stairway to Heaven” – A Multiple-Case Study Exploring Barriers in the Transition from Agile Development towards Continuous Deployment of Software. 2012 38th Euromicro Conference on Software Engineering and Advanced Applications, pp.392-399, 2012. ↩︎\nFitz, Timothy. Continuous Deployment, 2009. ↩︎\nPulkkinen, Ville. Continuous Deployment of Software. Proceedings of Cloud-Based Software Engineering, pp.46-52, 2013. ↩︎\n","categories":"","description":"Here you can find information about Continuous Delivery, what is it, which benefits can you expect from it, the challenges you might face trying to adopted and so on.\n","excerpt":"Here you can find information about Continuous Delivery, what is it, …","ref":"/en/blog/2023-09-02-continuous-delivery/","tags":["cd","continuous-delivery","continuous-deployment"],"title":"Continuous Delivery"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/continuous-delivery/","tags":"","title":"Continuous-Delivery"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/continuous-deployment/","tags":"","title":"Continuous-Deployment"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/cpu/","tags":"","title":"Cpu"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/cpu/","tags":"","title":"Cpu"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/hardware/","tags":"","title":"Hardware"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/hardware/","tags":"","title":"Hardware"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/memory/","tags":"","title":"Memory"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/memory/","tags":"","title":"Memory"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/tags/software/","tags":"","title":"Software"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/software/","tags":"","title":"Software"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/ci/","tags":"","title":"Ci"},{"body":"One of the most pivotal challenges in the realm of software development is effectively integrating changes 1. In a small-scale project steered by a single developer, this challenge might appear to be trivial. However, as the magnitude of the project escalates and more individuals join the development fold, the significance of seamless integration becomes paramount.\nHistorically, integration was often an afterthought, relegated to the tail end of the software development process 2. Postponing it to such a late stage not only amplifies the risk of complex, undetected errors but also heightens the tension as delivery dates loom.\nHowever, the paradigm shifted around the turn of the millennium. Continuous Integration (CI) was formally introduced in 2000 by Kent Beck as an intrinsic part of the ‘Extreme Programming’ methodology 3. CI emphasizes the frequent and early-stage integration of code. By continuously amalgamating new code into the system, developers can gauge its impact promptly. This approach streamlines error detection, enabling developers to tackle issues as they emerge 2. The ability to tie an error to a specific code change reduces error complexity and promotes efficient troubleshooting. Today, CI has become an indispensable practice in software development projects 4.\nMartin Fowler, a luminary in the field, eloquently defined CI as:\nContinuous Integration is a software development practice where team members integrate their work frequently, typically multiple times a day. Each integration is verified by an automated build system that runs test suites to swiftly detect any integration anomalies. Teams adopting this methodology often witness a significant reduction in integration hiccups, empowering them to produce cohesive software at an accelerated pace2.\nBuilding upon Fowler’s definition, Duvall 5 underscored several vital facets:\nDevelopers must maintain a conducive local environment for code construction and testing, ensuring their updates do not disrupt the established integration. Team members should commit their code to the Version Control System (VCS) daily. The integration process must be undertaken on a distinct machine, aptly termed the CI server. Only builds that pass all tests can be deemed deliverable. Error resolution is of paramount importance. A central repository displaying build and test results—often a website—is essential. Most CI tools readily offer such platforms. Furthermore, Patrick Cauldwell 6 advocates for frequent and early integration. The rationale? The more regular the integration, the less overhead for the team down the line. He distilled the primary goals of CI into:\nEnsuring a consistently available, tested version of the product with the latest modifications. Keeping the team abreast of any integration issues as early as possible. The impetus behind CI is to maintain an error-free, tested product throughout the development life cycle. This avoids the pitfalls of a last-minute integration phase, which is often fraught with errors and consumes both time and resources. More crucially, if project components aren’t integrated during their development, there’s no guarantee they’ll gel cohesively in the final product 7.\nTechnical implementation of CI revolves around two core components: process automation and a system to showcase results, thereby fuelling the developmental feedback loop 7.\nIn summing up the tenets of CI, Martin Fowler 1 emphasizes:\nRetaining code in a singular repository. Streamlining software construction through automation. Implementing automated testing processes. Ensuring new code additions undergo integration and construction on the CI system’s machine. Keeping the build process agile and swift. Providing easy access to the product’s latest executable version. Ensuring product status transparency for all stakeholders. Elements of a CI system A basic Continuous Integration (CI) pipeline initiates when a new code change is pushed to the repository. The CI server, linked to the repository, gets notified of every new change, subsequently downloading the latest version to initiate the integration process, which will be elaborated on in the subsequent section. Once completed, it communicates the system’s status to the team members.\nIn computer science, a “pipeline” refers to a sequence of processes or tasks linked such that the output of one becomes the input for the next.\nFigure 1: Basic elements of CI (Duvall5)\nThe system’s primary component consists of the developers. After making code modifications, they run tests locally and compile the code to ensure that they haven’t introduced new errors.\nAn essential part of every CI system is the Version Control System (VCS). It oversees the changes made to the code and other significant elements. This system establishes a unified access point for all source code, enabling the CI system to fetch the most recent version for integration. Most software development projects utilize a VCS even if they don’t implement CI processes.\nThe CI Server is responsible for initiating a new build (comprising both compilation and tests) every time a change is added to the repository. They offer configurations to simplify the creation of integration pipelines. Additionally, most come with a web interface to display the build status and previous results. Currently, numerous powerful options are available, both free and paid. It’s worth noting that the CI server should operate on a dedicated machine and not on team members’ computers.\nThe CI server must automatically conduct software tests, source code analysis, and compile to produce the deliverable product. Therefore, build and test execution scripts are vital. These scripts outline the necessary steps to be executed. Popular tools for this purpose include Make, Ant, Maven, Gradle, among others.\nEvery CI system should have a notification mechanism to relay results to the team. This mechanism ensures that in the event of an error, the team becomes aware as soon as possible, enabling them to address the issue. While most CI tools offer a web interface to view results, they also support other notification methods like emails, messaging applications, etc.\nThe integration process The figure below broadly illustrates the stages of the integration process taking place within the Continuous Integration (CI) system.\nFigure 2: CI process flowchart\nInitially, the system must retrieve the latest source code version each time a new change is pushed to the Version Control System (VCS). Two mechanisms facilitate this. The first involves setting up the CI server to periodically check the VCS for updates. The alternative is to establish a commit hook within the VCS, ensuring that the CI server receives notifications whenever changes are made.\nAfter obtaining the code, the CI server can be configured to scrutinize the source code for potential undetected errors, be they syntactic, logical, or patterns that might lead to faults. Various tools aid this process. For instance, Java boasts utilities like FindBugs, CheckStyle, and PMD, while Python has Pylint. JavaScript can be analysed with tools like JSLint or JSHint. An example of a code analysis criterion could be ensuring every developed method has a cyclomatic complexity8 under 10. By employing automated source code inspection, one can assess code correctness, spot duplicate portions, and expedite the time between error detection and rectification. While automated inspection might not catch every error, the results can approximate those of peer reviews, thereby lightening the team’s review load.\nThe subsequent step revolves around automated test execution on the product. This automation is paramount to successfully implementing a CI system. Thus, developers can confidently make alterations, knowing a robust testing framework safeguards against compromising existing functionalities. Some popular tools in this domain include Junit, JBehave, and Selenium, which not only facilitate test drafting but also generate comprehensive reports, often as visualizations or web pages. Several software testing levels exist, such as unit tests, integration tests, and system tests. In the CI pipeline context, the focus rests on automating unit and integration tests, with system tests’ automation being recommended but not mandatory.\nOnce the tests pass, the CI pipeline advances to compiling the source code. During this phase, the source code morphs into one or multiple files or packages, ready for distribution and user execution. This process’s specifics hinge on the employed programming language. For instance, languages like Java necessitate code compilation, resulting in an executable. Conversely, languages like Python might involve stricter code structure checks without generating any binary files.\nThroughout this integration journey, the team should steadfastly adhere to three fundamental rules:\nLocally run tests and compile software before integrating it into the VCS to minimize error introduction chances (avoiding “breaking the build”). Avoid pushing new code to the VCS if the CI server flags errors (indicative of a “broken build”). Should the CI server report faults, code modifications should exclusively aim at rectifying them. Core principles and practices Martin Fowler2 identifies a set of foundational elements intrinsic to every Continuous Integration (CI) system. While some of these have been touched upon earlier in this chapter, we will succinctly encapsulate them here for clarity:\nCentralized Code Repository: Retain all code within a singular, unified repository. Streamlined Compilation and Build Process: Entirely automate the compilation and construction workflows, negating manual intervention. Full-Spectrum Automated Testing: Ensure all software tests are automated, driving efficiency and precision. Daily Commitment: Encourage the team to consistently merge their changes to the repository on a daily basis. Stringent Integration Checks: Each alteration made to the Version Control System (VCS) undergoes rigorous integration processes within the CI system. Prompt Error Rectification: Should the CI system flag any issues (indicative of a “broken build”), immediate action is imperative. Either rectify the flaw or reverse the change to ensure the repository’s latest version remains operational. Swift CI Procedures: Aim to complete the CI process rapidly—ideally within 15 minutes or less. This approach ensures timely integration and facilitates the expedited delivery of results. Universal Access to Latest Executables: Always provide the team with access to the most recent executable or deliverable package, promoting transparency. Real-time Product Status Visibility: Grant every team member the ability to monitor the product’s status at any given moment, fostering informed decision-making. Benefits The overarching consensus within the software community is that the implementation of a Continuous Integration (CI) process yields an array of substantial advantages. Duvall5 outlines these core benefits in his publication.\nRisk Mitigation: Adopting frequent integration minimizes project risks. It facilitates early detection of issues and offers a continuous snapshot of the product’s health. By identifying these issues early in the development cycle, there’s a consequent reduction in both the cost of fixes and the risk of releasing a subpar product. Furthermore, automated inspections provide real-time insights into the product’s size, code complexity, and other metrics. This automation diminishes the chance of human-induced errors.\nMinimization of Manual Repetitive Tasks: Automation curtails the need for recurring manual tasks such as compilation, inspection, test execution, and report generation. This efficiency not only leads to significant time and cost savings but also allows teams to focus on activities that directly enhance product value. It liberates team members to dedicate more time to addressing new requirements or rectifying existing product issues.\nOn-Demand Availability of a Functional Product: A hallmark of CI is its ability to deliver a functional software product at any given moment. This is invaluable for stakeholders, offering them a rapid glance into product development progress. By leveraging CI, errors can be swiftly detected and remedied soon after a new change is introduced. This is far more efficient than uncovering them close to the release date when they are more expensive and challenging to amend. Such issues, if left unchecked, can lead to delivery delays, unsatisfied clients, escalated costs, and more. This ties back to the concept of the “Broken Window Theory”9, which, in essence, postulates that a product marred by numerous issues or perceived disorder can demotivate teams from addressing them.\nEnhanced Project Transparency: Implementing CI augments visibility into the project, rendering the development process more transparent. It aids project management with up-to-the-minute information, making it straightforward to gauge product quality, error trends, and more.\nElevated Product Confidence: The CI environment bolsters confidence in the product. Team members gain immediate insights into the ramifications of their changes, enabling them to promptly rectify any emergent issues.\nChallenges While Duvall5 has extolled the virtues of Continuous Integration (CI) in his works, he also highlights potential challenges that might deter development teams from embracing it fully or realizing its benefits.\nBias: A widespread misconception is that CI system implementation is exorbitant and would esecalate development costs due to its prolonged setup and maintenance. Contrarily, most software development projects already involve phases like inspection, testing, compilation, and integration, even if they don’t explicitly use a CI system. A common refrain is that there’s insufficient time or funds for CI system implementation, but the reality is that far more resources are spent performing redundant manual tasks throughout the development cycle. Furthermore, an automated CI system is infinitely more manageable and consistent compared to disparate manual processes.\nDisruption Fears: Projects in advanced development stages often fret that integrating a CI system would overhaul their established workflows, spawning significant delays. It’s pivotal to recognize that CI system implementation can be incremental. Teams can address one integration stage at a time, gradually ramping up the integration frequency as confidence builds.\nOverwhelming Failed Integrations: When CI practices aren’t diligently applied, there’s a risk of encountering an excessive number of failed integrations or “broken builds.” This could stem from developers bypassing local tests before uploading their changes to the Version Control System (VCS). A surge in failed integrations can erode trust in the CI system, reminiscent of the “Broken Window Theory”9.\nPerceived Additional Costs: There’s an apprehension among organizations about incurring extra expenses either for procuring CI product licenses or securing hardware to support these systems. However, this expenditure pales in comparison to the latent costs of late-stage integrations, where issues are discovered near the release date, far removed from their inception. On a brighter note, the current landscape is rife with a myriad of free and open-source alternatives, obviating any additional costs.\nReferences Continuous integration. ThoughtWorks, 2018. ↩︎ ↩︎\nFowler, Martin. Continuous Integration. 2006. ↩︎ ↩︎ ↩︎ ↩︎\nBeck, Kent. Embrace Change with Extreme Programming. IEEE Computer Magazine, (c), 70-77. 1999. ↩︎\nRodriguez Pilar, Markkula, Jouni, Oivo, Markku, \u0026 Turula, Kimmo. Survey on agile and lean usage in Finnish software industry. In Proceedings of the ACM-IEEE international symposium on Empirical software engineering and measurement - ESEM ‘12 (p. 139). ACM Press. DOI: 10.1145/2372251.2372275. 2012. ↩︎\nDuvall, Paul M., Matyas, Steve, \u0026 Glover, Andrew. Continuous integration: improving software quality and reducing risk. Pearson Education, Inc., 2007. ↩︎ ↩︎ ↩︎ ↩︎\nCauldwell, Patrick. Code Leader: Using people, tools and processes to build successful software. Wiley Publishing, Inc., 2008. ↩︎\nHumble, Jez \u0026 Farley, David. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011. ↩︎ ↩︎\nCyclomatic Complexity Explanation ↩︎\nThe Broken Window Theory in Software Development ↩︎ ↩︎\n","categories":"","description":"What is Continuous Integration? Which benefits it provides? In this article you can find answers to those questions and many more.\n","excerpt":"What is Continuous Integration? Which benefits it provides? In this …","ref":"/en/blog/2023-08-08-continuous-integration/","tags":["ci","continuous-integration"],"title":"Continuous Integration"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/continuous-integration/","tags":"","title":"Continuous-Integration"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/requirements/","tags":"","title":"Requirements"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/software-engineering/","tags":"","title":"Software-Engineering"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/srs/","tags":"","title":"Srs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/git/","tags":"","title":"Git"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/revert/","tags":"","title":"Revert"},{"body":"When we have created a commit locally but have not published it to the remote yet, we can use git reset to undo the commit and, if we wish, discard the changes. Although there are several options for git reset the most used are:\n--soft: Does not touch the index file or the working tree at all (but resets the head to , just like all modes do). This leaves all your changed files “Changes to be committed”, as git status would put it. --hard: Resets the index and working tree. Any changes to tracked files in the working tree since are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted. Git reset documentation {: style=“text-align: right;”}\nHere there is an example about using git reset. We start by changing a file and creating a commit with the change.\nbash-3.2$ cat README.md # Index 1 bash-3.2$ bash-3.2$ cat README.md # Index 1 2 bash-3.2$ bash-3.2$ git add README.md bash-3.2$ bash-3.2$ git commit -m \"Add number 2 in README.md\" [main 3734fd5] Add number 2 in README.md 1 file changed, 1 insertion(+) git status shows there is one commit pending to be published.\nbash-3.2$ git status On branch main Your branch is ahead of 'origin/main' by 1 commit. (use \"git push\" to publish your local commits) nothing to commit, working tree clean Using git reflog to see the history.\n3734fd5 (HEAD -\u003e main) HEAD@{0}: commit: Add number 2 in README.md 866bfa8 (origin/main) HEAD@{1}: revert: Revert \"Merge branch 'feature-1'\" e2f6d08 HEAD@{2}: merge feature-1: Merge made by the 'ort' strategy. 23644da HEAD@{3}: checkout: moving from feature-1 to main Now we can use git reset --soft \u003cCOMMIT_ID\u003e to undo the commit but keep the changes.\nbash-3.2$ git reset --soft 866bfa8 bash-3.2$ bash-3.2$ git status On branch main Your branch is up to date with 'origin/main'. Changes to be committed: (use \"git restore --staged \u003cfile\u003e...\" to unstage) modified: README.md git log after using git reset\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u003e main, origin/main) Author: Julian Nonino \u003clearn.software.eng+jnonino@gmail.com\u003e Date: Wed Jan 18 20:06:40 2023 -0300 Revert \"Merge branch 'feature-1'\" This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. We create a new commit so we can test the git reset --hard command.\nbash-3.2$ git status On branch main Your branch is up to date with 'origin/main'. Changes to be committed: (use \"git restore --staged \u003cfile\u003e...\" to unstage) modified: README.md bash-3.2$ git commit -m \"Add number 2 in README.md - NEW COMMIT\" [main 2e7193d] Add number 2 in README.md - NEW COMMIT 1 file changed, 1 insertion(+) git log now shows the new commit.\ncommit 2e7193db650b9ba0762fe73525df599a08f8577d (HEAD -\u003e main) Author: Julian Nonino \u003clearn.software.eng+jnonino@gmail.com\u003e Date: Thu Jan 19 08:32:57 2023 -0300 Add number 2 in README.md - NEW COMMIT commit 866bfa8a952d11240707ebfc87f3266034d42443 (origin/main) Author: Julian Nonino \u003clearn.software.eng+jnonino@gmail.com\u003e Date: Wed Jan 18 20:06:40 2023 -0300 Revert \"Merge branch 'feature-1'\" This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. Now we can use git reset --hard \u003cCOMMIT_ID\u003e to undo the commit and discard all the changes.\nbash-3.2$ git reset --hard 866bfa8 HEAD is now at 866bfa8 Revert \"Merge branch 'feature-1'\" bash-3.2$ bash-3.2$ git status On branch main Your branch is up to date with 'origin/main'. nothing to commit, working tree clean git log remains as it nothing had happened.\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u003e main, origin/main) Author: Julian Nonino \u003clearn.software.eng+jnonino@gmail.com\u003e Date: Wed Jan 18 20:06:40 2023 -0300 Revert \"Merge branch 'feature-1'\" This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. ","categories":"","description":"How to discard changes in Git before pushing them.\n","excerpt":"How to discard changes in Git before pushing them.\n","ref":"/en/blog/2023-01-28-git-revert-local/","tags":["vcs","version-control","git","revert"],"title":"Revert a local change in Git"},{"body":"When we realized that the last commit was a mistake but we already published it, the command to use is git revert \u003cCOMMIT_HASH\u003e.\nFirst we need to locate the ID of the commit we want to revert, it can be done with git log or git reflog commands. Then, run the git revert \u003cCOMMIT_HASH\u003e command using the ID obtained in the previous step. Use the options -e or --edit to edit the commit message if we like. Push our changes so the revert is available for everyone in our group. Reverting multiple commits If we need to revert multiple commits we can revert them one by one using the --no-commit option in order to create a single revert commit at the end.\nImagine the history is like the following and we need to go back to COMMIT-3.\nCOMMIT-1 -\u003e COMMIT-2 -\u003e COMMIT-3 -\u003e COMMIT-4 -\u003e COMMIT-5 -\u003e COMMIT-6 -\u003e HEAD This sequence of commands will get our files to the version of COMMIT-3:\nbash-3.2$ git revert --no-commit COMMIT-6 bash-3.2$ git revert --no-commit COMMIT-5 bash-3.2$ git revert --no-commit COMMIT-4 bash-3.2$ git commit -m \"Revert to version in COMMIT-3\" bash-3.2$ git push Reverting a merge commit -m parent-number, –mainline parent-number\nUsually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.\nGit revert documentation {: style=“text-align: right;”}\nWhen we need to revert a merge commit git revert command needs to be run with the -m or --mainline option to indicate the parent number because a merge commit has more than one parent and Git does not know which parent was target branch and which was the branch with the changes that should be reverted.\nHere there is an example showing how to revert a merge commit.\nCreate the first commit in main branch.\nbash-3.2$ cat README.md # Index 1 bash-3.2$ bash-3.2$ git commit -m \"Add number 1 in README.md - main branch\" [main (root-commit) 23644da] Add number 1 in README.md - main branch 1 file changed, 3 insertions(+) create mode 100644 README.md bash-3.2$ bash-3.2$ git push -u origin main Enumerating objects: 3, done. Counting objects: 100% (3/3), done. Writing objects: 100% (3/3), 254 bytes | 254.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git * [new branch] main -\u003e main branch 'main' set up to track 'origin/main'. bash-3.2$ The state of the README.md file in main branch.\nbash-3.2$git status On branch main Your branch is up to date with 'origin/main'. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 Branch feature-1 created and added one commit.\nbash-3.2$ git checkout -b feature-1 Switched to a new branch 'feature-1' bash-3.2$ bash-3.2$ cat README.md # Index 1 2 bash-3.2$ bash-3.2$ git add README.md bash-3.2$ bash-3.2$ git commit -m \"Add number 2 in README.md - feature-1 branch\" [feature-1 83ea1a3] Add number 2 in README.md - feature-1 branch 1 file changed, 1 insertion(+) bash-3.2$ bash-3.2$ git push --set-upstream origin feature-1 Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 292 bytes | 292.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 remote: remote: Create a pull request for 'feature-1' on GitHub by visiting: remote: https://github.com/jnonino/test-repo/pull/new/feature-1 remote: To github.com:jnonino/test-repo.git * [new branch] feature-1 -\u003e feature-1 branch 'feature-1' set up to track 'origin/feature-1'. bash-3.2$ The state of README.md in the feature-1 branch.\nbash-3.2$ git status On branch feature-1 Your branch is up to date with 'origin/feature-1'. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 2 Merge the feature-1 branch into the main branch.\nbash-3.2$ git checkout main Switched to branch 'main' Your branch is up to date with 'origin/main'. bash-3.2$ bash-3.2$ git merge --no-ff feature-1 Merge made by the 'ort' strategy. README.md | 1 + 1 file changed, 1 insertion(+) bash-3.2$ bash-3.2$ git push Enumerating objects: 1, done. Counting objects: 100% (1/1), done. Writing objects: 100% (1/1), 233 bytes | 233.00 KiB/s, done. Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git 23644da..e2f6d08 main -\u003e main bash-3.2$ Current state of README.md in main branch.\nbash-3.2$ git status On branch main Your branch is up to date with 'origin/main'. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 2 git log after merging feature-1 into main branch.\ncommit e2f6d08d3b38a02a1c026cfb879f3131536757ac (HEAD -\u003e main, origin/main) Merge: 23644da 83ea1a3 Author: Julian Nonino \u003clearn.software.eng+jnonino@gmail.com\u003e Date: Wed Jan 18 19:58:19 2023 -0300 Merge branch 'feature-1' commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) Author: Julian Nonino \u003clearn.software.eng+jnonino@gmail.com\u003e Date: Wed Jan 18 19:53:38 2023 -0300 Add number 2 in README.md - feature-1 branch commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 Author: Julian Nonino \u003clearn.software.eng+jnonino@gmail.com\u003e Date: Wed Jan 18 19:48:37 2023 -0300 Add number 1 in README.md - main branch To revert the merge commit, as it was stated above we need to pay attention to the merge field.\nMerge: 23644da 83ea1a3 Running git revert e2f6d08 -m 1 will reinstate the tree as it was in 23644da, and git revert e2f6d08 -m 2 will set the tree as it was in 83ea1a3. In this example we would like to leave the main branch as it was before the merge commit. For doing that, we need to run git revert e2f6d08 -m 1.\nbash-3.2$ git revert e2f6d08 -m 1 [main 866bfa8] Revert \"Merge branch 'feature-1'\" 1 file changed, 1 deletion(-) bash-3.2$ bash-3.2$ git status On branch main Your branch is ahead of 'origin/main' by 1 commit. (use \"git push\" to publish your local commits) nothing to commit, working tree clean bash-3.2$ bash-3.2$ git push Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 344 bytes | 344.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git e2f6d08..866bfa8 main -\u003e main git log after reverting the merge commit.\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u003e main, origin/main) Author: Julian Nonino \u003clearn.software.eng+jnonino@gmail.com\u003e Date: Wed Jan 18 20:06:40 2023 -0300 Revert \"Merge branch 'feature-1'\" This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. commit e2f6d08d3b38a02a1c026cfb879f3131536757ac Merge: 23644da 83ea1a3 Author: Julian Nonino \u003clearn.software.eng+jnonino@gmail.com\u003e Date: Wed Jan 18 19:58:19 2023 -0300 Merge branch 'feature-1' commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) Author: Julian Nonino \u003clearn.software.eng+jnonino@gmail.com\u003e Date: Wed Jan 18 19:53:38 2023 -0300 Add number 2 in README.md - feature-1 branch commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 Author: Julian Nonino \u003clearn.software.eng+jnonino@gmail.com\u003e Date: Wed Jan 18 19:48:37 2023 -0300 Add number 1 in README.md - main branch Current state of README.md in main branch.\nbash-3.2$ git status On branch main Your branch is up to date with 'origin/main'. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 ","categories":"","description":"Have you ever pushed a change in Git and it was wrong? Here you'll learn how to revert the change, even if the problem was with a merge commit.\n","excerpt":"Have you ever pushed a change in Git and it was wrong? Here you'll …","ref":"/en/blog/2023-01-18-git-revert-pushed/","tags":["vcs","version-control","git","revert"],"title":"Revert a pushed change in Git"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/vcs/","tags":"","title":"Vcs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/tags/version-control/","tags":"","title":"Version-Control"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/categories/","tags":"","title":"Categories"},{"body":" Welcome! Learn. Build. Master.\nProgramming Software Engineering ","categories":"","description":"","excerpt":" Welcome! Learn. Build. Master.\nProgramming Software Engineering ","ref":"/en/","tags":"","title":"Learn-Software.com"},{"body":" ¡Bienvenido! Aprende. Crea. Domina.\nProgramación Ingeniería del Software ","categories":"","description":"","excerpt":" ¡Bienvenido! Aprende. Crea. Domina.\nProgramación Ingeniería del …","ref":"/es/","tags":"","title":"Learn-Software.com"},{"body":"","categories":"","description":"","excerpt":"","ref":"/es/search/","tags":"","title":"Resultados de la Búsqueda"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/search/","tags":"","title":"Search Results"}]