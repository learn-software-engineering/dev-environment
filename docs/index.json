[{"content":"Las estructuras de datos son formas de organizar y almacenar información en un programa de computadora para que pueda ser accedida y modificada de manera eficiente. Como programadores, es esencial entender las distintas estructuras de datos disponibles y saber cuándo aplicar cada una para optimizar el rendimiento y la utilidad de nuestros programas.\nUna estructura de datos es una forma particular de organizar datos en la memoria de la computadora para que puedan ser usados de manera eficiente. Las estructuras de datos vienen en muchas formas, como arrays, listas, pilas, colas, grafos, árboles, hashes, etc.\nCada estructura organiza los datos de acuerdo a un modelo lógico específico y soporta operaciones eficientes para acceder, modificar, agregar y borrar elementos según ese modelo. Por ejemplo, un array organiza los elementos de manera secuencial en memoria para facilitar el acceso aleatorio por índices. Una lista enlazada conecta elementos en memoria usando \u0026ldquo;nodos\u0026rdquo; con referencias al siguiente nodo para facilitar la inserción y eliminación.\nAl elegir la estructura de datos apropiada para la tarea a resolver, podemos escribir programas más eficientes y reducir la complejidad computacional, utilizando menos recursos como memoria y procesamiento.\nLas estructuras de datos nos ayudan a:\nOrganizar grandes cantidades de datos para que sean más fáciles de acceder y modificar.\nModelar relaciones complejas entre datos, como con grafos y árboles.\nAcceder y modificar datos de manera eficiente, optimizando el rendimiento.\nReutilizar código y estructuras de datos existentes en lugar de tener que reescribir soluciones desde cero.\nPor ejemplo, un programa que debe almacenar miles de registros de usuarios se beneficia usando una estructura de datos hash para asociar cada usuario a datos como nombre, apellido, email, etc. De esta manera se pueden encontrar usuarios específicos muy rápido sin tener que iterar sobre toda la colección.\nOtro ejemplo son los árboles de búsqueda binaria, que permiten encontrar elementos muy rápido en conjuntos ordenados de millones de elementos. Esto se logra descartando mitades del árbol a medida que se busca el elemento deseado.\nTipos de estructuras de datos # Existen muchos tipos de estructuras de datos. A continuación, se presentan algunas categorías útiles para clasificarlas.\nSegún relación entre elementos # Lineales: Los elementos se organizan secuencialmente uno después del otro. Por ejemplo, arrays, listas, pilas, colas.\nNo lineales: Los elementos se organizan en una jerarquía o grafo. Este es el caso de los árboles y grafos.\nSegún tipo de elementos # Homogéneas: Almacenan un solo tipo de datos. Por ejemplo, arrays en un lenguaje como Java.\nHeterogéneas: Permiten diferentes tipos de datos. Objetos, registros son ejemplos de esta clasificación.\nSegún modo de acceso # Acceso secuencial: Sólo se puede acceder a los elementos en orden secuencial. Por ejemplo, listas enlazadas.\nAcceso directo: Se puede acceder a cualquier elemento directamente por su posición. En este grupo se encuentran los arrays.\nAcceso asociativo: Se accede a elementos por una clave asociada. Aquí se encuentran los diccionarios, hashes.\nSegún su funcionalidad # Arrays: Acceso rápido a elementos por índice pero difícil insertar/eliminar.\nListas: Fácil insertar/eliminar en cualquier posición pero acceso secuencial lento.\nPilas: Acceso LIFO (último en entrar, primero en salir). Útil para deshacer/rehacer.\nColas: Acceso FIFO (primero en entrar, primero en salir). Útil para procesamiento de eventos.\nÁrboles: Permiten modelar relaciones jerárquicas como con directorios de archivos o dependencias de tareas.\nGrafos: Permiten modelar redes de interconexión como mapas, relaciones sociales, etc.\nHashes / Diccionarios: Asocian elementos con claves únicas para acceso ultra rápido.\nEsta clasificación no es exhaustiva pero da una idea de la diversidad de estructuras de datos y sus diferentes propiedades que nos permiten modelar problemas complejos de manera eficiente.\nEjemplo # Veamos un ejemplo en Python para ver cómo se crea y utiliza una estructura de datos. Supongamos que queremos representar una cola de impresión donde las impresiones se procesan en orden de llegada (FIFO).\nPrimero, definimos una clase PrintQueue para representar nuestra cola:\nclass PrintQueue: def __init__(self): self.items = [] def enqueue(self, item): self.items.append(item) def dequeue(self): return self.items.pop(0) def is_empty(self): return len(self.items) == 0 Luego la utilizamos para agregar impresiones y procesarlas en orden:\nprint_queue = PrintQueue() print_queue.enqueue(\u0026#34;documento1.doc\u0026#34;) print_queue.enqueue(\u0026#34;imagen3.jpg\u0026#34;) print_queue.enqueue(\u0026#34;presentacion.ppt\u0026#34;) while not print_queue.is_empty(): next_item = print_queue.dequeue() print(f\u0026#34;Imprimiendo {next_item}\u0026#34;) Esto imprimirá:\nImprimiendo documento1.doc Imprimiendo imagen3.jpg Imprimiendo presentacion.ppt Con una estructura de datos como la cola implementamos la lógica FIFO de una forma sencilla y reutilizable. ¡Y esto es sólo una muestra, las posibilidades son infinitas!\nConclusión # Las estructuras de datos son herramientas fundamentales en programación que nos permiten organizar información de forma óptima para resolver problemas complejos. Conocer los distintos tipos de estructuras disponibles, como arrays, listas, pilas, colas, hashes, grafos y árboles, nos permite construir programas más eficientes. ¡Espero que esta introducción te haya dado algunos conocimientos y herramientas para comenzar a dominar este apasionante tema!\n","date":"04 agosto 2025","externalUrl":null,"permalink":"/programming/data-structures/introduction/","section":"Programación","summary":"","title":"Introducción","type":"programming"},{"content":"La Programación Orientada a Objetos (POO) es un paradigma de programación que se ha vuelto indispensable en la actualidad. Este enfoque modela elementos del mundo real como \u0026ldquo;objetos\u0026rdquo; que tienen propiedades y comportamientos, lo cual permite crear programas más intuitivos y fáciles de mantener. En este artículo veremos los conceptos básicos de POO y sus ventajas frente a otros paradigmas como la programación procedural. ¡Empecemos!\nEste paradigma se basa en dos conceptos fundamentales:\nObjetos: entidades que combinan estado (datos) y comportamiento (operaciones) en una misma unidad. Por ejemplo, un objeto \u0026ldquo;coche\u0026rdquo; tendría propiedades como color, número de puertas, velocidad máxima, etc. Y comportamientos como acelerar, frenar, girar, etc. Clases: especificaciones que definen la estructura y comportamiento común de un grupo de objetos. La clase \u0026ldquo;coche\u0026rdquo; serviría como molde para crear objetos coche con las mismas características. Como explica el programador Alan Kay, uno de los creadores de la POO:\n\u0026ldquo;La idea central de POO es que los usuarios deben manipular objetos conceptuales más que máquinas de Turing. Las interfaces con el mundo real deben, por lo tanto, ser construidas en términos de objetos conceptuales.\u0026rdquo;\nEs decir, la POO modela conceptualmente elementos del mundo real para hacer la programación más intuitiva.\nParadigmas de programación # Antes de profundizar en la POO, conviene entender que existen diferentes paradigmas o enfoques para abordar la programación. Los principales son:\nProgramación procedural # Secuencia ordenada de instrucciones que el programa debe seguir paso a paso. El foco está en procedimientos y funciones. Por ejemplo, C es un lenguaje orientado a la programación procedural.\nLa programación procedural es mejor para:\nProblemas sencillos o algoritmos secuenciales. Código que no necesitará reusarse ni expandirse mucho. Casos donde el rendimiento y eficiencia son críticos. Programación orientada a objetos # Modelo basado en objetos que contienen datos y código en unidades cohesivas. El foco está en las clases y en la interacción entre objetos. Por ejemplo, Java y Python son lenguajes orientados a objetos.\nLa POO permite modelar de forma más directa elementos del mundo real, encapsular mejor los datos y reutilizar código a través de la herencia entre clases.\nLas principales ventajas de POO frente a la programación procedural son:\nModularidad: los objetos agrupan datos y operaciones relacionadas, encapsulando la complejidad interna. Esto permite trabajar con módulos independientes. Ocultación de información: Los objetos pueden exponer una interfaz simple y ocultar detalles de implementación internos. Esto reduce acoplamientos. Reusabilidad: Las clases permiten reuse de código. Una clase abstracta puede heredar a múltiples subclases. Extensibilidad: Podemos extender el comportamiento de clases padres creando nuevas subclases. Mapeo conceptual: Los objetos representan entidades del mundo real, lo cual facilita la traducción de requerimientos a código. Sin embargo, la POO también tiene desventajas. Según el programador Paul Graham:\n\u0026ldquo;La programación orientada a objetos suele ser una molestia. Hace que las cosas sean más difíciles de lo que deberían ser.\u0026rdquo;\nPor ejemplo, para problemas simples la POO puede resultar excesiva. Y en proyectos grandes existe el riesgo de abusar de la herencia y el polimorfismo, volviendo el código difícil de seguir.\nEn definitiva, la POO es más adecuada cuando:\nEl problema a modelar tiene entidades claras y estructuradas. Queremos reutilizar código encapsulado en clases modulares. Trabajamos en sistemas que deben extenderse y mantenerse con facilidad. ","date":"04 agosto 2025","externalUrl":null,"permalink":"/programming/oop/introduction/","section":"Programación","summary":"","title":"Introducción","type":"programming"},{"content":"La programación, en su esencia, es el acto de instruir a una máquina sobre cómo realizar una tarea específica. Es como si le estuvieras enseñando a tu perro a buscar la pelota, pero en este caso, el perro es tu computadora y la pelota es, por ejemplo, sumar dos valores.\nAhora, es posible que pienses que programar es simplemente escribir líneas de código. En realidad, la programación es un proceso más amplio que incluye no solo escribir código, sino también resolver problemas, diseñar sistemas y pensar lógicamente.\nEn el universo de la programación, hay lenguajes de alto nivel y lenguajes de bajo nivel. Un lenguaje de bajo nivel, como el ensamblador, está más cerca de lo que la máquina entiende, mientras que un lenguaje de alto nivel, como Python o JavaScript, es más amigable para nosotros, los humanos. Los lenguajes de bajo nivel permiten una manipulación casi directa del hardware con instrucciones especificas para determinadas operaciones, como encender un determinado pixel de la pantalla. Mientras que los lenguajes de alto nivel permiten operaciones complejas en lenguaje casi natural, como por ejemplo mostrar una imagen en pantalla.\nAdemás, algunos lenguajes de programación son compilados y otros son interpretados. Si un lenguaje es compilado, significa que se traduce a un lenguaje que la máquina entiende antes de ser ejecutado. Por otro lado, los lenguajes interpretados son traducidos en tiempo real, mientras se ejecutan.\nBreve historia de la programación # La programación no es un concepto nuevo. De hecho, ha estado con nosotros desde mucho antes de que las computadoras existieran en la forma que las conocemos hoy. Dispositivos como el ábaco y el astrolabio son ejemplos tempranos de herramientas que usamos para realizar cálculos complejos.\nPero fue con la llegada de las máquinas mecánicas, como la Máquina Analítica de Charles Babbage, que se sentaron las bases para la programación moderna. ¡Estamos hablando del siglo XIX!\nCon el paso del tiempo, nacieron lenguajes que marcaron hitos, como Fortran y COBOL. Estos lenguajes sentaron las bases para las revoluciones tecnológicas que vendrían. Con la evolución de los lenguajes, también surgieron nuevos paradigmas: primero el Procedural, luego el Orientado a Objetos y más recientemente, el Funcional.\nHoy, estamos en una era moderna, dominada por la programación para la web, móviles y la nube. Cada vez que deslizas tu dedo por la pantalla de tu celular o compras algo online, hay líneas y líneas de código trabajando detrás de escena.\nLa programación hoy # La programación es el motor de nuestra sociedad moderna. Desde aplicaciones para pedir comida hasta sistemas avanzados de inteligencia artificial que ayudan en investigaciones médicas, la programación está en todas partes.\nAdemás de simplificar nuestras vidas cotidianas, la programación tiene un impacto profundo en la sociedad. Ha permitido avances en la automatización, el análisis de datos y el entretenimiento. Y lo que es aún más emocionante, es que apenas estamos rasguñando la superficie. Con los avances en inteligencia artificial, computación cuántica y el Internet de las Cosas (IoT), ¿quién sabe qué maravillas nos esperan en mundo de la programación?\n","date":"03 agosto 2025","externalUrl":null,"permalink":"/programming/intro/introduction/","section":"Programación","summary":"","title":"Introducción","type":"programming"},{"content":"","date":"03 agosto 2025","externalUrl":null,"permalink":"/programming/intro/","section":"Programación","summary":"","title":"Introducción a la Programación","type":"programming"},{"content":" Variables # Una variable es un contenedor para almacenar datos en la memoria de la computadora. Podemos pensar en ella como una caja con una etiqueta. La etiqueta es el nombre de la variable y dentro de la caja se almacena su valor.\nPara declarar una variable en Python solo escribimos el nombre y le asignamos un valor:\nedad = 28 precio = 19.95 soltero = True Los nombres de variables deben comenzar con letras o guión bajo, y sólo pueden contener letras, números y guiones bajos. Se recomienda usar nombres significativos que representen el propósito de la variable.\nEn Python las variables no necesitan ser declaradas con un tipo particular. El tipo se infiere automáticamente al asignar el valor:\nedad = 28 # edad es de tipo entero (int) precio = 19.95 # precio es de tipo float estudiante = True # soltero es de tipo booleano Una vez asignada, una variable puede cambiar su valor en cualquier momento:\nedad = 30 # Cambiamos edad a 30 Alcance y tiempo de vida # El alcance de una variable se refiere a las partes del código donde está disponible. Las variables declaradas fuera de funciones son globales y están disponibles en todo el archivo. Las variables dentro de una función son locales y solo visibles dentro de ella.\nEl tiempo de vida es el período durante el cual existe la variable en memoria. Las variables locales existen mientras se ejecuta la función, luego son destruidas. Las globales existen mientras el programa está en ejecución.\nAsignación # La asignación con el operador = permite cambiar o inicializar el valor de una variable:\nnumero = 10 numero = 20 # Ahora numero vale 20 También existen los operadores de asignación compuesta como += y -= que combinan una operación y asignación:\nnumero += 5 # Suma 5 a numero (numero = numero + 5) numero -= 2 # Resta 2 a numero Tipos de datos # Los tipos de datos definen el tipo de valor que puede almacenar una variable. Python tiene varios tipos incorporados, incluyendo:\nNuméricos: Para almacenar valores numéricos como enteros, flotantes, complejos:\nentero = 10 flotante = 10.5 complejo = 3 + 4j Cadenas: Para almacenar texto:\ntexto = \u0026#34;Hola Mundo\u0026#34; Booleano: Para valores lógicos Verdadero o Falso:\nvariable_verdadera = True variable_falsa = False Colecciones: Para almacenar múltiples valores como listas, tuplas y diccionarios:\nListas: Secuencias mutables de valores:\nlista = [1, 2, 3] Tuplas: Secuencias inmutables de valores:\ntupla = (1, 2, 3) Diccionarios: Estructuras de pares llave-valor:\ndiccionario = {\u0026#34;nombre\u0026#34;:\u0026#34;Juan\u0026#34;, \u0026#34;edad\u0026#34;: 20} Es importante elegir el tipo de dato que mejor represente la información que queremos almacenar.\nOperadores # Los operadores nos permiten realizar operaciones con valores y variables en Python. Algunos operadores comunes son:\nAritméticos: +, -, *, /, %, //, **\nComparación: ==, !=, \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;=\nLógicos: and, or, not\nAsignación: =, +=, -=, *=, /=\nVeamos ejemplos concretos de expresiones usando estos operadores en Python:\n# Aritméticos 5 + 4 # Suma, resultado 9 10 - 3 # Resta, resultado 7 4 * 5 # Multiplicación, resultado 20 # Comparación 5 \u0026gt; 4 # Mayor que, resultado Verdadero 7 \u0026lt; 10 # Menor que, resultado Verdadero # Lógicos True and False # Resultado False True or False # Resultado True not True # Resultado False # Asignación numero = 10 numero += 5 # Suma 5 a numero, equivalente a numero = numero + 5 Cada tipo de operador trabaja con tipos de datos específicos. Debemos usarlos de forma consistente según el tipo de datos de nuestras variables.\nConversiones de tipo # A veces necesitamos convertir un tipo de dato a otro para realizar ciertas operaciones. En Python podemos convertir de forma explícita o implícita:\nExplícita: Usando funciones como int(), float(), str():\nflotante = 13.5 entero = int(flotante) # convierte 13.5 a 13 texto = \u0026#34;100\u0026#34; numero = int(texto) # convierte \u0026#34;100\u0026#34; a 100 Implícita: Python convierte automáticamente en algunos casos:\nentero = 100 flotante = 3.5 resultado = entero + flotante # resultado es 103.5, entero se convirtió a float Algunas conversiones pueden generar pérdida de datos o errores:\nflotante = 13.5 entero = int(flotante) print(entero) # 13, se pierden los decimales Para prevenir esto debemos elegir explícitamente conversiones que tengan sentido para nuestros datos.\nConclusión # En este artículo revisamos conceptos clave como variables, operadores, tipos de datos y conversiones en Python. Aplicar bien estos conceptos te permitirá manipular datos de forma eficiente en tus programas. Recomiendo practicar con ejemplos propios para ganar experiencia en usar estas características. ¡Éxitos en tu aprendizaje de Python!\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\n","date":"18 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/variables-data-types/","section":"Programación","summary":"","title":"Variables y Tipos de Datos","type":"programming"},{"content":" What is Software? # Several thought leaders in the world of computing have defined software in various ways:\nIan Sommerville1: Computer programs and associated documentation.\nRoger S. Pressman2: A collection of computer programs, procedures, rules, and associated documentation and data.\nAndrew S. Tanenbaum3: A series of instructions that tells a computer what to do.\nGrady Booch4: Set of items or objects that form a configuration that includes programs, documents, and data.\nPeter Denning5: Map of a machine, detailing its possible states, transitions, and the actions for these transitions.\nAnalysing these definitions, common themes emerge: software encompasses instructions, data, associated documentation, and serves as a guiding structure for computer operations. So we can conclude:\nSoftware is a meticulously structured collection of programs, data, and documentation that serves as a guiding blueprint, directing a computer\u0026rsquo;s operations and interactions with users and other systems.\nAlthough we can classify software in many different types, each with its specific function, we can define three primary categories:\nSystem Software: This forms the core of a computer\u0026rsquo;s operation. It includes operating systems like Windows, Linux, and macOS, which manage hardware resources and provide services for application software. Application Software: Tailored for end-users to perform specific tasks, this category ranges from word processors (like Microsoft Word) to graphic design tools (like Adobe Photoshop) and games. Embedded Software: Found within hardware devices such as washing machines, traffic lights, or digital watches, embedded software operates specific functions of these devices. Unlike general-purpose software, it\u0026rsquo;s dedicated to specific tasks or functions. What is Software Engineering? # Several prominent figures have also provided their perspectives on Software Engineering:\nIan Sommerville1: A discipline concerned with all aspects of software production.\nRoger S. Pressman2: Establishment and use of sound engineering principles to obtain economically software that is reliable and works efficiently on real machines.\nFrederick P. Brooks6: The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software.\nBarry W. Boehm7: Aims to produce quality software, software that is delivered on time, within budget, and that satisfies its requirements.\nFritz Bauer8: The establishment and use of sound engineering principles to economically obtain software that is reliable and works on real machines.\nFrom these definitions, we can discern that software engineering integrates principles of engineering, emphasizes systematic methods, seeks reliability and efficiency, and aims for the production of high-quality software that meets its specified requirements. Concluding that\nSoftware Engineering is the disciplined application of engineering principles and systematic methods to design, develop, and maintain reliable and efficient software that economically meets specified requirements and user needs.\nSoftware Engineering should not be confused with Computer Science. While the latter is a discipline that dives deep into the theoretical and mathematical aspects of computing, studying algorithms, computational theory, and more, the first one primarily focuses on designing and building large software systems. It emphasizes practical techniques and methodologies that ensure the production of high-quality, maintainable software.\nWhy it is important to develop quality software # Today, we\u0026rsquo;re surrounded by a digital ecosystem. Software runs our phones, cars, banks, hospitals, and even our homes. This ubiquity underscores its significance. That means that software flaws can have catastrophic outcomes. From banking systems to healthcare applications, the demand for faultless, efficient software is sky-high.\nSoftware Engineering, ensures this vast amount of software is reliable, efficient, and meets user needs. As technology advances at breakneck speed, the role of software engineers becomes even more pivotal, making sure innovations are safe and effective.\nWhether you\u0026rsquo;re using a social media app, making a bank transaction, or checking health diagnostics, remember there\u0026rsquo;s a meticulously engineered software system running behind the scenes, making it all possible.\nReferences # Sommerville, I., 2010. Software Engineering. 9th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPressman, R.S., 2010. Software Engineering: A Practitioner\u0026rsquo;s Approach. 7th ed. McGraw-Hill.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A.S., 2012. Structured Computer Organization. 6th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBooch, G., 2007. Object-Oriented Analysis and Design with Applications. 3rd ed. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDenning, P.J., 2009. The Profession of IT, Beyond Computational Thinking. Communications of the ACM, 52(6).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBrooks, F.P., 1995. The Mythical Man-Month: Essays on Software Engineering. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBoehm, B.W., 1988. A Spiral Model of Software Development and Enhancement. Computer, 21(5).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBauer, F.L., 1972. Software Engineering. Information Processing, 71.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"10 agosto 2023","externalUrl":null,"permalink":"/en/software-engineering/introduction/","section":"Software Engineering","summary":"","title":"Introduction to Software Engineering","type":"software-engineering"},{"content":"Un array es una estructura de datos que representa un conjunto de elementos, los cuales se acceden a través de índices numéricos contiguos que van desde 0 hasta el tamaño del array menos 1. Los arrays proveen acceso rápido y directo a los elementos en base a su posición.\nEn lenguajes como Python y Ruby, los arrays se conocen como \u0026rsquo;listas\u0026rsquo; (lists). En Javascript se les conoce como \u0026lsquo;arreglos\u0026rsquo; (arrays).\nLos arrays son típicamente homogéneos, almacenando elementos del mismo tipo como enteros, cadenas, etc. Algunos lenguajes permiten arrays heterogéneos con valores de distintos tipos.\nDiagrama de un array Creación de arrays # La manera de crear arrays varía según el lenguaje de programación:\nMI_ARRAY = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] # array literal mi_array = list(range(5)) # array a partir de rango Al crear un array literal se inicializan sus elementos directamente. Al construir un array vacío se especifica su tamaño pero sus elementos son inicializados con un valor default (0 para números, null para objetos, etc).\nAcceder y modificar elementos # Los elementos individuales se acceden rápidamente por su índice utilizando corchetes []:\nmy_array = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] print(my_array[0]) # \u0026#39;a\u0026#39; print(my_array[2]) # \u0026#39;c\u0026#39; my_array[2] = \u0026#39;z\u0026#39; print(my_array[2]) # \u0026#39;z\u0026#39; Los índices comienzan en 0, por lo que en un array de tamaño N, los índices válidos están entre 0 y N-1.\nAcceder a un índice inválido causa un error, por ejemplo, acceder al índice 3 en un array de tamaño 3. Esto se conoce como \u0026ldquo;index out of bounds\u0026rdquo;.\nRecorrer un array # Podemos recorrer todos los elementos usando un ciclo for:\nletras = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] for i in range(len(letras)): print(letras[i]) Esto imprime cada elemento en orden. len() devuelve la longitud total del array.\nOtra forma es iterando directamente sobre los elementos:\nletras = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] for letra in letras: print(letra) Buscar en un array # Podemos buscar un elemento en un array mediante un ciclo y comparando elemento por elemento:\nletras = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] def buscar_en_array(array, elemento): for i in range(len(array)): if array[i] == elemento: return i return False print(buscar_en_array(letras, \u0026#39;b\u0026#39;)) # 1 print(buscar_en_array(letras, \u0026#39;z\u0026#39;)) # False Devuelve el índice si se encuentra o False si no se encuentra.\nArray multidimensional # Los arrays pueden tener más de una dimensión, por ejemplo matrices 2D, cubos 3D, etc.\nUn array 2D se puede ver como una tabla con filas y columnas. Para acceder a un elemento se especifican dos índices, uno para la fila y otro para la columna:\nmatrix = [ [1, 2, 3], [4, 5, 6] ] print(matrix[0][2]) # 3 print(matrix[1][0]) # 4 Pueden tener más dimensiones, por ejemplo un array 3D para representar pixeles en una imagen.\nConclusión # Los arrays son estructuras de datos fundamentales en programación que proveen un acceso eficiente a elementos en memoria mediante índices numéricos. Tener un buen dominio de arrays, matrices y sus usos es indispensable para cualquier programador.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\n","date":"30 octubre 2023","externalUrl":null,"permalink":"/programming/data-structures/arrays/","section":"Programación","summary":"","title":"Arreglos","type":"programming"},{"content":" Anatomía de una clase # Una clase actúa como un plano o molde para construir objetos similares, definiendo sus características comunes y funcionalidades. Es similar al plano para construir casas de un mismo barrio: todas comparten ciertos atributos clave.\nLos componentes típicos de una clase son:\nAtributos (propiedades): Variables que caracterizan al objeto. Por ejemplo, para una clase Persona, atributos como nombre, edad, DNI, etc.\nclass Persona: dni = \u0026#34;\u0026#34; nombre = \u0026#34;\u0026#34; edad = 0 Métodos: Funciones que definen comportamientos. Por ejemplo, una Persona puede caminar(), hablar(), comer(), etc. Acceden a los atributos para implementar dicha funcionalidad.\nConstructor: Método especial __init__() que se ejecuta al instanciar la clase y permite inicializar los atributos.\nDestructor: Método __del__() que se ejecuta al eliminar la instancia liberando recursos. Opcional en algunos lenguajes.\nCreando objetos # A partir de la clase generamos objetos, que son instancias concretas con sus propios atributos definidos. Digamos que la clase Casa es el plano, y una casa específica en una calle determinada es el objeto.\nEn código creamos un objeto invocando la clase como si fuera un método:\n# Clase Persona class Persona: def __init__(self, n, e): self.nombre = n self.edad = e # Objeto Persona específico pepe = Persona(\u0026#34;Pepe\u0026#34;, 30) juan = Persona(\u0026#34;Juan\u0026#34;, 35) Cada objeto comparte la estructura y comportamiento general, pero puede almacenar distintos datos.\nUtilizando Propiedades y Métodos # Ya tenemos una clase Persona y un objeto pepe de tipo Persona. ¿Cómo interactuamos con el objeto?\nPropiedades: Es posible acceder al valor de un atributo del objeto utilizando la referencia al objeto (pepe) y el nombre del atributo. pepe.nombre # \u0026#34;Pepe\u0026#34; pepe.edad # 30 Métodos: De la misma manera en la que se accede a los atributos pero agregando un paréntesis dentro del cual se pasan los argumentos si es que recibe alguno. # Clase Persona class Persona: def __init__(self, n, e): self.nombre = n self.edad = e def comer(self, comida): print(f\u0026#34;Comiendo {comida}\u0026#34;) # Objeto Persona específico pepe = Persona(\u0026#34;Pepe\u0026#34;, 30) pepe.comer(\u0026#34;pizza\u0026#34;) # Imprime \u0026#34;Comiendo pizza\u0026#34; El objeto pepe tiene ahora estado (propiedades) y comportamiento (métodos) propios.\nSelf vs This # Un detalle importante en los métodos es cómo acceden a los atributos y otros métodos del objeto. Aquí entra otra diferencia entre lenguajes:\nSelf: En Python, los atributos y métodos se acceden dentro de la clase anteponiendo self. Esto apunta al objeto instanciado. class Persona: def __init__(self, nombre): self.nombre = nombre def saludar(self): print(f\u0026#34;Hola! Soy {self.nombre}\u0026#34;) juan = Persona(\u0026#34;Juan\u0026#34;) juan.saludar() # Imprime \u0026#34;Hola! Soy Juan\u0026#34; This: En Java o C#, se utiliza this en lugar de self. Cumple la misma funcionalidad de apuntar a los miembros del objeto. public class Person { private String nombre; public Person(String nombre) { this.nombre= nombre; } public void saludar() { System.out.println(\u0026#34;Hola! Soy \u0026#34; + this.nombre); } } Person juan = new Person(\u0026#34;Juan\u0026#34;); juan.saludar(); // Imprime \u0026#34;Hola! Soy Juan\u0026#34; Conclusión # Las clases y objetos son los conceptos clave de la POO, permitiendo modelar entidades de la realidad y generar componentes modulares y genéricos de nuestro sistema para construir programas más robustos y fáciles de entender y mantener.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\n","date":"02 octubre 2023","externalUrl":null,"permalink":"/programming/oop/classes-objects/","section":"Programación","summary":"","title":"Clases y Objetos","type":"programming"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/","section":"Programación","summary":"","title":"Conceptos Iniciales","type":"programming"},{"content":" Salida a pantalla # Python también provee funciones para enviar la salida de un programa a la \u0026ldquo;salida estándar\u0026rdquo;, generalmente la pantalla o terminal1.\nLa función print() muestra el valor pasado como parámetro:\nnombre = \u0026#34;Eric\u0026#34; print(nombre) # muestra \u0026#34;Eric\u0026#34; Podemos imprimir múltiples valores separados por comas2:\nprint(\u0026#34;Hola\u0026#34;, nombre, \u0026#34;!\u0026#34;) # muestra \u0026#34;Hola Eric!\u0026#34; También podemos usar valores literales sin asignar a variables3:\nprint(\u0026#34;2 + 3 =\u0026#34;, 2 + 3) # muestra \u0026#34;2 + 3 = 5\u0026#34; Formateo de salida # Python provee varias formas de dar formato a la salida4:\nf-Strings: Permiten insertar variables dentro de una cadena:\nnombre = \u0026#34;Eric\u0026#34; print(f\u0026#34;Hola {nombre}\u0026#34;) # muestra \u0026#34;Hola Eric\u0026#34; %s: Inserta cadenas de texto en una cadena de formato:\nnombre = \u0026#34;Eric\u0026#34; print(\u0026#34;Hola %s\u0026#34; % nombre) # muestra \u0026#34;Hola Eric\u0026#34; %d: Inserta números enteros:\nvalor = 15 print(\u0026#34;El valor es %d\u0026#34; % valor) # muestra \u0026#34;El valor es 15\u0026#34; .format(): Inserta valores en una cadena de formato:\nnombre = \u0026#34;Eric\u0026#34; print(\u0026#34;Hola {}. Bienvenido\u0026#34;.format(nombre)) # muestra \u0026#34;Hola Eric. Bienvenido\u0026#34; Estas opciones de formateo nos permiten interpolar variables y valores en cadenas de texto para generar outputs personalizados. Podemos combinar múltiples valores y formateos en una sola cadena de salida2.\nEntrada desde el teclado # Python provee funciones incorporadas para leer datos ingresados por el usuario en tiempo de ejecución. Esto se conoce como \u0026ldquo;entrada estándar\u0026rdquo;4.\nLa función input() permite leer un valor ingresado por el usuario y asignarlo a una variable. Por ejemplo:\nnombre = input(\u0026#34;Ingresa tu nombre: \u0026#34;) Esto muestra el mensaje \u0026ldquo;Ingresa tu nombre: \u0026quot; y espera a que el usuario escriba un texto y presione Enter. Ese valor se asigna a la variable nombre2.\nLa función input() siempre regresa una cadena de texto. Si queremos pedir un número u otro tipo de dato, debemos convertirlo usando int(), float(), etc1:\nedad = int(input(\u0026#34;Ingresa tu edad: \u0026#34;)) pi = float(input(\u0026#34;Ingresa el valor de pi: \u0026#34;)) Leyendo múltiples valores # Podemos pedir y leer varios valores en una misma línea separándolos con comas3:\nnombre, edad = input(\u0026#34;Ingresa nombre y edad: \u0026#34;).split() El método split() divide la entrada en partes y retorna una lista de cadenas. Luego asignamos los elementos de la lista a variables separadas.\nTambién podemos leer varias líneas de entrada con un ciclo4:\nnombres = [] # lista vacía for x in range(3): nombre = input(\u0026#34;Ingresa un nombre: \u0026#34;) nombres.append(nombre) Este código lee 3 nombres ingresados por el usuario y los agrega a una lista.\nSalida a un archivo # Además de imprimir a pantalla, podemos escribir la salida a un archivo usando la función open()1:\narchivo = open(\u0026#34;datos.txt\u0026#34;, \u0026#34;w\u0026#34;) Esto abre datos.txt para escritura (\u0026ldquo;w\u0026rdquo;) y retorna un objeto archivo.\nLuego usamos archivo.write() para escribir a ese archivo3:\narchivo.write(\u0026#34;Hola mundo!\u0026#34;) archivo.write(\u0026#34;Este texto va al archivo\u0026#34;) Debemos cerrar el archivo con archivo.close() cuando terminamos4:\narchivo.close() También podemos usar with para abrir y cerrar automáticamente2:\nwith open(\u0026#34;datos.txt\u0026#34;, \u0026#34;w\u0026#34;) as archivo: archivo.write(\u0026#34;Hola mundo!\u0026#34;) # no hace falta cerrar, es automático Lectura de archivos # Para leer un archivo usamos open() con modo \u0026ldquo;r\u0026rdquo; y iteramos sobre el objeto archivo1:\nwith open(\u0026#34;datos.txt\u0026#34;, \u0026#34;r\u0026#34;) as archivo: for linea in archivo: print(linea) # muestra cada línea del archivo Esto imprime cada línea, incluyendo los saltos de línea.\nPodemos leer todas las líneas a una lista con readlines()3:\nlinenas = archivo.readlines() print(linenas) Para leer el contenido completo a una cadena usamos read()4:\ntexto = archivo.read() print(texto) También podemos leer un número determinado de bytes o caracteres con read(n)2.\nOperaciones para el manejo de archivos # Existen varias funciones incorporadas para manipular archivos en Python1:\nopen() - Abre un archivo y retorna un objeto archivo close() - Cierra el archivo write() - Escribe datos al archivo read() - Lee datos del archivo readline() - Lee una línea del archivo truncate() - Vacía el archivo seek() - Mueve la posición de lectura/escritura rename() - Renombra el archivo remove() - Elimina el archivo Estas funciones nos permiten efectuar operaciones avanzadas para leer, escribir y mantener archivos.\nConclusión # En este artículo explicamos en detalle operaciones de entrada y salida en Python, incluyendo leer de entrada estándar y escribir a salida estándar o archivos. Manejar correctamente la entrada y salida es esencial para muchas aplicaciones de Python. Recomiendo practicar con ejemplos propios para dominar estas funciones3.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias # McKinney, W. (2018). Python for data analysis: Data wrangling with Pandas, NumPy, and IPython. O\u0026rsquo;Reilly Media.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMatthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. No Starch Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDowney, A. B. (2015). Think Python: How to think like a computer scientist. Needham, Massachusetts: Green Tea Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"19 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/io-operations/","section":"Programación","summary":"","title":"Operaciones de Entrada y Salida","type":"programming"},{"content":"Si alguna vez te has preguntado qué es lo que hace \u0026ldquo;tictac\u0026rdquo; dentro de esa caja metálica que llamamos computadora, estás en el lugar indicado. En esencia, una computadora es una combinación de hardware y software que trabajan juntos para llevar a cabo tareas específicas.\nEl hardware es toda la parte física de la computadora: el CPU (que es como el cerebro de la máquina), la RAM (donde la computadora guarda la información con la que está trabajando en un momento determinado), dispositivos de almacenamiento (donde se guardan los datos de forma permanente) y periféricos (como el teclado, el mouse o la pantalla)1.\nPor otro lado, el software es el conjunto de instrucciones que le dice al hardware qué hacer. Hay varios tipos de software, desde el software del sistema, como el sistema operativo que coordina todas las acciones de la máquina, hasta software de aplicación que nos permite hacer cosas como escribir documentos o jugar videojuegos2.\nEl papel del sistema operativo es crucial. Es el mediador entre el usuario y el hardware, asegurando que todo funcione armónicamente. Si el hardware fuera una orquesta, el sistema operativo sería el director que asegura que cada instrumento toque en el momento y de la manera correcta.\nEl sistema binario: el lenguaje secreto de las computadoras # A diferencia de nosotros, que usamos un sistema decimal basado en diez dígitos (del 0 al 9), las computadoras usan el sistema binario, que solo tiene dos dígitos: 0 y 1. ¿Por qué? Bueno, en el nivel más básico, una computadora está hecha de millones de transistores que pueden estar en uno de dos estados: encendido o apagado. Estos estados se representan con esos dígitos: 0 para apagado y 1 para encendido3.\nLos términos \u0026ldquo;bit\u0026rdquo; y \u0026ldquo;byte\u0026rdquo; son fundamentales aquí. Un bit es la unidad más pequeña de datos en una computadora y puede tener un valor de 0 o 1. Un byte, por otro lado, es un conjunto de 8 bits y puede representar 256 valores diferentes (desde \\(00000000\\) hasta \\(11111111\\) en binario)4.\nEste sistema binario no solo representa números, sino también texto, imágenes y cualquier tipo de dato. Por ejemplo, en el código ASCII (un estándar de codificación de caracteres), la letra \u0026ldquo;A\u0026rdquo; se representa como \\(01000001\\) en binario.\nEn un artículo posterior, vamos a hablar en detalle acerca del sistema binario y otro sistema muy utilizado en el ambiente de la computación, el hexadecimal.\nMemoria y almacenamiento: donde residen nuestros datos # La memoria y el almacenamiento son dos conceptos cruciales en la informática. Si bien a menudo se usan indistintamente, tienen roles muy diferentes.\nLa memoria, específicamente la RAM, es volátil. Esto significa que la información se pierde cuando apagamos la computadora. La RAM es esencialmente el \u0026ldquo;espacio de trabajo\u0026rdquo; de la computadora, donde almacena datos e instrucciones mientras está en uso. Hay varios tipos de RAM, siendo DRAM y SRAM los más comunes5.\nPor otro lado, tenemos la ROM (Memoria de Solo Lectura). A diferencia de la RAM, la ROM no es volátil y se utiliza para almacenar firmware, es decir, software que está íntimamente ligado al hardware y que no necesita cambios frecuentes.\nEn cuanto al almacenamiento, dispositivos como discos duros, SSDs y unidades flash nos permiten guardar información de manera permanente. Estos dispositivos forman parte de lo que se conoce como la jerarquía de memoria, que va desde la memoria caché (rápida pero pequeña) hasta el almacenamiento secundario (más lento pero con gran capacidad)6.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias # Patterson, D. \u0026amp; Hennessy, J. (2014). Arquitectura de Computadoras. Buenos Aires: Ediciones Omega.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSilberschatz, A., Galvin, P. B., \u0026amp; Gagne, G. (2009). Fundamentos de Sistemas Operativos. Buenos Aires: Ediciones M.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A. (2012). Estructura de Computadoras. Buenos Aires: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBrookshear, J. G. (2011). Ciencia de la Computación: Una visión general. Buenos Aires: Pearson Educación.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nJacob, B., Ng, S. W., \u0026amp; Wang, D. T. (2007). Arquitecturas de memoria en sistemas de computadoras. Buenos Aires: Wiley-Interscience.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSiewiorek, D. P. \u0026amp; Swarz, R. S. (2017). Principios de diseño de sistemas computacionales. Buenos Aires: Morgan Kaufmann.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"02 septiembre 2023","externalUrl":null,"permalink":"/programming/intro/computers/","section":"Programación","summary":"","title":"Computadoras","type":"programming"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/programming/oop/","section":"Programación","summary":"","title":"Programación Orientada a Objetos","type":"programming"},{"content":"In Object-Oriented Programming, classes don\u0026rsquo;t exist in isolation. They interact and relate to each other in various ways to model complex systems and relationships. Understanding these relationships is crucial for designing effective and maintainable object-oriented systems.\nThe main types of class relationships we\u0026rsquo;ll explore in depth are:\nAssociation (\u0026ldquo;uses-a\u0026rdquo;) Aggregation (weak \u0026ldquo;has-a\u0026rdquo; relationship) Composition (strong \u0026ldquo;has-a\u0026rdquo; relationship) Inheritance (\u0026ldquo;is-a\u0026rdquo; relationship) Realisation (Implementation) Dependency Each of these relationships represents a different way that classes can be connected and interact with each other. They vary in terms of the strength of the coupling between classes, the lifecycle dependencies, and the nature of the relationship.\nBefore we dive into each type of relationship, let\u0026rsquo;s visualise them using a UML class diagram:\nclassDiagram class ClassA class ClassB class ClassC class ClassD class ClassE class ClassF class InterfaceG ClassA --\u003e ClassB : Association ClassC o-- ClassD : Aggregation ClassE *-- ClassF : Composition ClassB --|\u003e ClassA : Inheritance ClassE ..|\u003e InterfaceG : Realisation ClassA ..\u003e ClassF : Dependency end This diagram provides a high-level overview of the different types of class relationships. In the following sections, we\u0026rsquo;ll explore each of these relationships in detail, providing explanations, examples, and more specific UML diagrams.\n","date":"07 diciembre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-introduction/","section":"Programming","summary":"","title":"Class relations","type":"programming"},{"content":"Un diccionario, o mapa, consiste en una colección de pares clave-valor. La clave se utiliza para acceder al valor asociado. Las claves deben ser únicas dentro de un diccionario. Los valores pueden repetirse.\nDiagrama de un diccionario Operaciones principales # Añadir/actualizar: Inserta un par clave-valor. Si la clave existía, su valor es reemplazado. diccionario[\u0026#39;clave\u0026#39;] = \u0026#39;valor\u0026#39; Obtener valor: Acceder al valor dada una clave. valor = diccionario[\u0026#39;clave\u0026#39;] Eliminar: Remueve un par clave-valor del diccionario. del diccionario[\u0026#39;clave\u0026#39;] Recorrer: Iterar sobre las claves, valores o pares del diccionario. for clave in diccionario: print(clave, diccionario[clave]) # clave, valor Creación de un diccionario o mapa # La sintaxis para crear mapas o diccionarios en Python es la siguiente:\ndiccionario_vacio = {} persona = { \u0026#39;nombre\u0026#39;: \u0026#39;Juan\u0026#39;, \u0026#39;edad\u0026#39;: 25 } Ejemplos de uso # Los diccionarios son útiles en muchos casos. A continuación se mencionan algunos de ellos.\nObjetos y mapeos # Podemos modelar objetos y entidades con atributos clave-valor:\nproducto = { \u0026#39;nombre\u0026#39;: \u0026#39;Smartphone\u0026#39;, \u0026#39;precio\u0026#39;: 500, \u0026#39;marca\u0026#39;: \u0026#39;XYZ\u0026#39; } Conteos y frecuencias # Contar ocurrencias de elementos en secuencias:\ntexto = \u0026#34;Hola mundo mundo\u0026#34; frecuencias = {} for palabra in texto.split(): if palabra in frecuencias: frecuencias[palabra] += 1 else: frecuencias[palabra] = 1 print(frecuencias) # {\u0026#39;Hola\u0026#39;: 1, \u0026#39;mundo\u0026#39;: 2} Almacenar y acceder a datos # Como alternativa de alta performance a lists y arrays.\nConclusión # Los diccionarios son estructuras de datos versátiles gracias a su rápido acceso basado en claves únicas. Tienen usos en casi todos los programas, por lo que dominar diccionarios es indispensable en cualquier lenguaje.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\n","date":"30 octubre 2023","externalUrl":null,"permalink":"/programming/data-structures/maps/","section":"Programación","summary":"","title":"Mapas (Diccionarios)","type":"programming"},{"content":" Condiciones: tomando decisiones en el código # La vida está llena de decisiones: \u0026ldquo;Si llueve, llevaré un paraguas. De lo contrario, usaré anteojos de sol\u0026rdquo;. Estas decisiones también están presentes en el mundo de la programación. Las condiciones son como preguntas que la computadora se hace. Nos permiten tomar decisiones y ejecutar código específico dependiendo de una condición1. Pueden ser simples como \u0026ldquo;¿Está lloviendo?\u0026rdquo; o complejas como \u0026ldquo;¿Es fin de semana y tengo menos de $100 en mi cuenta bancaria?\u0026rdquo;.\nif # La estructura if nos permite evaluar condiciones y tomar decisiones basadas en el resultado de esa evaluación.\nedad = 15 if edad \u0026gt;= 18: print(\u0026#34;Eres mayor de edad\u0026#34;) El código anterior permite ejecutar una porción de código si la edad de una persona es mayo o igual a 18 años.\nif-else # Cuando se desea ejecutar un código alternativo si la condición es falsa, utilizamos la estructura if-else\nedad = 21 if edad \u0026gt;= 18: print(\u0026#34;Eres mayor de edad\u0026#34;) else: print(\u0026#34;Eres menor de edad\u0026#34;) En este caso, se determina si la persona es mayor de edad, o menor de edad, el mensaje mostrado es diferente\nif-elif-else # Cuando las condiciones son múltiples y no es suficientes con dos caminos, se utiliza la estructura if-elif-else para evaluarlas forma encadenada.\nedad = 5 if edad \u0026lt;= 13: print(\u0026#34;Eres un niño\u0026#34;) elif edad \u0026gt; 13 and edad \u0026lt; 18: print(\u0026#34;Eres un adolescente\u0026#34;) else: print(\u0026#34;Eres un adulto\u0026#34;) En el código anterior se observan tres caminos claros, uno para cuando la edad es menor o igual a 13 años, otro para cuando la edad esta entre 13 y 18 y otro para cuando es mayor o igual a 18.\nOtra manera de resolver este problema es mediante la estructura switch-case, que, aunque Python no incorpora de manera nativa, como si lo hacen otros lenguajes como Java o C++, es una herramienta importante para conocer. Esta estructura permite a los programadores manejar múltiples condiciones de manera más organizada que una serie de if-elif-else.\nEn Java, por ejemplo:\nint dia = 3; switch(dia) { case 1: System.out.println(\u0026#34;Lunes\u0026#34;); break; case 2: System.out.println(\u0026#34;Martes\u0026#34;); break; case 3: System.out.println(\u0026#34;Miércoles\u0026#34;); break; // ... y así sucesivamente default: System.out.println(\u0026#34;Día no válido\u0026#34;); } En el ejemplo anterior, dependiendo del valor de dia, se imprimirá el día correspondiente2.\nBucles: repitiendo acciones # A veces, en programación, necesitamos repetir una acción varias veces. En lugar de escribir el mismo código varias veces, podemos usar bucles. Estos, permiten repetir la ejecución de un bloque de código mientras se cumpla una condición3.\nwhile # El bucle while es útil cuando queremos repetir una acción basada en una condición.\n# Imprime del 1 al 5 i = 1 while i \u0026lt;= 5: print(i) i = i + 1 do-while # Similar a while pero garantiza al menos una ejecución dado que primero se ejecuta el bloque de código y luego se evalúa la condición. Python no implementa esta estructura, pero otros lenguajes como Java y C++ sí lo hacen.\nint i = 1; do { System.out.println(i); i++; } while(i \u0026lt;= 5); int numero = 0; do { std::cout \u0026lt;\u0026lt; \u0026#34;Hola, mundo!\u0026#34; \u0026lt;\u0026lt; std::endl; numero++; } while (numero \u0026lt; 5); for # El bucle for es útil cuando sabemos cuántas veces queremos repetir una acción.\nfor i in range(5): print(\u0026#34;Hola, mundo!\u0026#34;) El código anterior imprimirá \u0026ldquo;Hola, mundo!\u0026rdquo; cinco veces.\nTambién podemos iterar sobre los elementos de una lista u objeto iterable:\nnombres = [\u0026#34;María\u0026#34;, \u0026#34;Florencia\u0026#34;, \u0026#34;Julián\u0026#34;] for nombre in nombres: print(f\u0026#34;Hola {nombre}\u0026#34;) # Imprime # Hola María # Hola Florencia # Hola Julián Las sentencias break y continue # Podemos usar break para terminar el bucle y continue para saltar a la siguiente iteración.\nEl break se usa para terminar completamente el bucle cuando se cumple una condición, en el ejemplo siguiente, cuando i llega a 5.\n# Ejemplo de break i = 0 while i \u0026lt; 10: print(i) if i == 5: break i += 1 # Imprime: # 0 # 1 # 2 # 3 # 4 # 5 El continue se usa para saltarse una iteración del bucle y continuar con la siguiente cuando se cumple una condición. Aquí lo usamos para saltarnos los números pares.\n# Ejemplo de continue i = 0 while i \u0026lt; 10: i += 1 if i % 2 == 0: continue print(i) # Imprime: # 1 # 3 # 5 # 7 # 9 Anidamiento: combinando estructuras # Las estructuras de control de flujo pueden anidarse dentro de otras. Por ejemplo, podemos tener bucles dentro de bucles o condiciones dentro de bucles.\nfor i in range(5): for j in range(10): if (i % 2 == 0 and j % 3 == 0): print(f\u0026#34;i = {i}, j = {j}\u0026#34;) Este código imprimirá combinaciones de i y j sólo cuando i sea divisible por 2 y j sea divisible por 3, demostrando cómo los bucles se anidan y se ejecutan3.\nPatrones de uso comunes # Existen patrones específicos para resolver necesidades habituales con control de flujo.\nBúsqueda # Buscar un valor en una colección:\nfrutas = [\u0026#34;manzana\u0026#34;, \u0026#34;naranja\u0026#34;] buscando = \u0026#34;naranja\u0026#34; encontrado = False for fruta in frutas: if fruta == buscando: encontrado = True break if encontrado: print(\u0026#34;Fruta encontrada!\u0026#34;) Acumulación # Acumular valores incrementales en un bucle.\ntotal = 0 for i in range(10): total += i print(total) # Suma de 0..9 = 45 Diagramas de flujo: la ruta visual hacia el entendimiento del código # Los programadores, sin importar si son principiantes o expertos, a menudo se encuentran enfrentando desafíos que requieren una planificación detallada antes de sumergirse en el código. Aquí es donde los diagramas de flujo entran en juego como una herramienta esencial. Estos diagramas son representaciones gráficas de los procesos y la lógica detrás de un programa o sistema. En este artículo, desentrañaremos el mundo de los diagramas de flujo, desde sus conceptos básicos hasta las técnicas avanzadas, y cómo pueden beneficiar a programadores de todos los niveles.\nUn diagrama de flujo es una representación gráfica de un proceso. Utiliza símbolos específicos para representar diferentes tipos de instrucciones o acciones. Su objetivo principal es simplificar la comprensión de un proceso, mostrando paso a paso cómo fluye la información o las decisiones. Estos diagramas:\nFacilitan la comprensión de procesos complejos. Ayudan en la fase de diseño y planificación de un programa. Sirven como documentación y referencia para futuros desarrollos. Los diagramas de flujo son una herramienta poderosa que no solo beneficia a los principiantes, sino también a los programadores experimentados. Ofrecen una visión clara y estructurada de un proceso o programa, facilitando la planificación, el diseño y la comunicación entre los miembros del equipo.\nElementos básicos # Los diagramas de flujo constan de varios símbolos, cada uno con un significado específico:\nOvalo: Representa el inicio o el fin de un proceso. Rectángulo: Denota una operación o instrucción. Diamante: Indica una decisión basada en una condición. Flechas: Muestran la dirección del flujo. graph TD; start((Inicio)) process[Proceso] decision{¿Repetir?} final((Final)) start --\u003e process; process --\u003e decision; decision --\u003e |Si| process decision --\u003e |No| final end Ejemplos # Vamos a diseñar un diagrama de flujo para un programa que pida un número y nos diga si es par o impar.\ngraph TB inicio((Inicio)) entrada[Ingresar número] decision{¿Es par?} esPar[Es par] esImpar[Es impar] final((Final)) inicio --\u003e entrada entrada --\u003e decision decision --\u003e |Si| esPar decision --\u003e |No| esImpar esPar --\u003e final esImpar --\u003e final end Conforme los programas se vuelven más complejos, es posible que necesites incorporar bucles, múltiples condiciones y otros elementos avanzados en tu diagrama de flujo. Por ejemplo, aquí diagramamos un programa que sume los números desde el 1 al número ingresado por el usuario.\ngraph TD inicio((Inicio)) entrada[Ingresar número] setVariables[Establecer suma=0 y contador=1] bucle_condicion{¿contador \u003c= N?} bucle_codigo[Sumar valor e incrementar el contador] resultado[Mostrar suma] final((Final)) inicio --\u003e entrada entrada --\u003e setVariables setVariables --\u003e bucle_condicion bucle_condicion --\u003e |Si| bucle_codigo bucle_codigo --\u003e bucle_condicion bucle_condicion --\u003e |No| resultado resultado --\u003e final end Conclusión # El control de flujo es el corazón de la programación. Sin él, los programas serían secuencias lineales de acciones sin la capacidad de tomar decisiones o repetir tareas. Al dominar estas estructuras, no solo mejoras tu capacidad para escribir código, sino también tu capacidad para pensar lógicamente y resolver problemas complejos.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias # Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDeitel, P., \u0026amp; Deitel, H. (2012). Java: How to program. Upper Saddle River, NJ: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMatthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. San Francisco, CA: No Starch Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"27 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/flow-control-structures/","section":"Programación","summary":"","title":"Control de Flujo","type":"programming"},{"content":" El sistema decimal: la base de nuestra cotidianidad # Desde pequeños, nos enseñan a contar usando diez dígitos: del 0 al 9. Este sistema, conocido como decimal, es la base de casi todas nuestras actividades matemáticas y financieras, desde sumar cuentas hasta calcular intereses en el banco1. Tiene su origen en la cantidad de dedos que tenemos en las manos, lo que lo convierte en el sistema más intuitivo y natural para nosotros. Pero lo que lo hace especial es su naturaleza posicional.\nPara comprender este concepto, consideremos el número 237:\nEl 7, situado a la derecha, está en la posición de las unidades. Es decir, \\(7 \\times 10^0\\) (cualquier número elevado a la potencia de 0 es 1). Por lo tanto, su valor es simplemente 7. El 3, en la posición del medio, representa las decenas, es decir, \\(3 \\times 10^1 = 3 \\times 10 = 30\\). El 2, el número más a la izquierda, está en la posición de las centenas, traduciéndose a \\(2 \\times 10^2 = 2 \\times 100 = 200\\). Si sumamos estos valores,\n2 \\times 10^2 + 3 \\times 10^1 + 7 \\times 10^0 = 200 + 30 + 7 = 237 El sistema binario: el lenguaje secreto de las computadoras # Si bien el sistema decimal domina nuestra vida cotidiana, las máquinas que usamos todos los días, desde nuestros celulares hasta las computadoras, operan en un mundo completamente diferente: el mundo binario. En este sistema, solo existen dos dígitos: 0 y 1. A primera vista, puede parecer limitante, pero este sistema es la esencia de la electrónica digital. Los dispositivos electrónicos, con sus millones de transistores, operan usando estos dos estados: encendido (1) y apagado (0)2.\nA pesar de su aparente simplicidad, el sistema binario puede representar cualquier cantidad o información que el sistema decimal pueda expresar. Por ejemplo, el número decimal 5 se representa como 101 en binario.\nEl sistema binario, con sus unos y ceros, opera de manera similar al sistema decimal, pero en lugar de potencias de 10, usa potencias de 2.\nTomemos el número binario 1011:\nEl bit más a la derecha representa \\(1 \\times 2^0 = 1\\) El siguiente bit representa \\(1 \\times 2^1 = 2\\) Luego viene \\(0 \\times 2^2 = 0\\) El bit más a la izquierda en este número representa \\(1 \\times 2^3 = 8\\) Entonces, 1011 en binario se traduce a decimal de la siguiente manera:\n1011 = 1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 = 8 + 0 + 2 + 1 = 11 El sistema hexadecimal: un puente entre humanos y máquinas # Mientras que el sistema binario es perfecto para las máquinas, puede ser un poco engorroso para nosotros, especialmente cuando tratamos con números binarios largos. Aquí es donde entra el sistema hexadecimal, que utiliza dieciséis dígitos distintos: 0-9 y A-F, donde A representa 10, B es 11, y así sucesivamente hasta F que es 153.\nEl hexadecimal es especialmente útil porque proporciona una forma más compacta de representar números binarios. Cada dígito hexadecimal corresponde a exactamente cuatro dígitos binarios (bits). Por ejemplo pensemos en la representación en binario del número 41279 y como el sistema hexadecimal consigue una representación más compacta:\n41279 = 1010 0001 0011 1111 = A13F Pero el sistema hexadecimal es más que una representación compacta de números binarios, es un sistema de numeración posicional como el decimal o binario con base 16 en lugar de 10 o 2. Veamos como conseguir la representación decimal del número del ejemplo anterior (A13F).\nEl dígito más a la derecha representa \\(F \\times 16^0 = 15 \\times 16^0 = 15\\) El siguiente representa \\(3 \\times 16^1 = 48\\) Luego viene \\(1 \\times 16^2 = 256\\) El dígito más a la izquierda en este número representa \\(A \\times 16^3 = 10 \\times 16^3 = 40960\\) Entonces, A13F en hexadecimal se traduce a decimal de la siguiente manera:\nA13F = A \\times 16^3 + 1 \\times 16^2 + 3 \\times 16^1 + F \\times 16^0 = 10 \\times 4096 + 1 \\times 256 + 3 \\times 16 + 15 \\times 1 = 40960 + 256 + 48 + 15 = 41279 Conclusión # Los sistemas de numeración son como lentes a través de los cuales vemos y entendemos el mundo de las matemáticas y la computación. Aunque en nuestra vida diaria el sistema decimal sea el rey, es esencial apreciar y comprender los sistemas binario y hexadecimal, especialmente en esta era digital.\nAsí que, la próxima vez que estés frente a tu computadora o usando una app en tu celular, recordá que detrás de esa interfaz amigable, hay un mundo binario en pleno funcionamiento, y que el sistema hexadecimal actúa como un traductor entre ese mundo y nosotros.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias # Ifrah, G. (2000). Historia universal de las cifras. Buenos Aires: Editorial Taurus.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A. (2012). Estructura de Computadoras. Buenos Aires: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKnuth, D. (2007). El Arte de Programar Computadoras: Sistemas de numeración. Buenos Aires: Ediciones Omega.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"05 septiembre 2023","externalUrl":null,"permalink":"/programming/intro/numeral-systems/","section":"Programación","summary":"","title":"Sistemas de Numeración","type":"programming"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/programming/data-structures/","section":"Programación","summary":"","title":"Estructuras de Datos","type":"programming"},{"content":"Key characteristics of association:\nIt represents a loose coupling between classes. The associated classes can exist independently of each other. The lifetime of one class is not tied to the lifetime of the other. It can be unidirectional or bidirectional. There are two main types of association:\nUnidirectional Association Bidirectional Association Let\u0026rsquo;s explore each of these in more detail.\nUnidirectional association # In a unidirectional association, one class knows about and can interact with another class, but not vice versa. This is a one-way relationship.\nHere\u0026rsquo;s an example in Python:\nclass Customer: def __init__(self, name): self.name = name class Order: def __init__(self, order_number, customer): self.order_number = order_number self.customer = customer # This creates an association def display_info(self): return f\u0026#34;Order {self.order_number} placed by {self.customer.name}\u0026#34; # Creating instances customer = Customer(\u0026#34;John Doe\u0026#34;) order = Order(\u0026#34;12345\u0026#34;, customer) print(order.display_info()) # Output: Order 12345 placed by John Doe In this example, the Order class has a unidirectional association with the Customer class. An Order knows about its associated Customer, but a Customer doesn\u0026rsquo;t know about its Orders.\nHere\u0026rsquo;s a UML diagram representing this relationship:\nclassDiagram class Customer { +name: string } class Order { +order_number: string +customer: Customer +display_info() } Order --\u003e Customer : places end The arrow in the diagram points from Order to Customer, indicating that Order knows about Customer, but not the other way around.\nBidirectional association # In a bidirectional association, both classes are aware of each other and can interact with each other. This is a two-way relationship.\nHere\u0026rsquo;s an example in Python:\nclass Student: def __init__(self, name): self.name = name self.courses = [] def enrol(self, course): self.courses.append(course) course.add_student(self) def display_courses(self): return f\u0026#34;{self.name} is enrolled in: {\u0026#39;, \u0026#39;.join(course.name for course in self.courses)}\u0026#34; class Course: def __init__(self, name): self.name = name self.students = [] def add_student(self, student): self.students.append(student) def display_students(self): return f\u0026#34;{self.name} has students: {\u0026#39;, \u0026#39;.join(student.name for student in self.students)}\u0026#34; # Creating instances student1 = Student(\u0026#34;Alice\u0026#34;) student2 = Student(\u0026#34;Bob\u0026#34;) math_course = Course(\u0026#34;Mathematics\u0026#34;) physics_course = Course(\u0026#34;Physics\u0026#34;) # enrolling students in courses student1.enrol(math_course) student1.enrol(physics_course) student2.enrol(math_course) print(student1.display_courses()) print(math_course.display_students()) In this example, there\u0026rsquo;s a bidirectional association between Student and Course. A Student knows about their Courses, and a Course knows about its Students.\nHere\u0026rsquo;s a UML diagram representing this relationship:\nclassDiagram class Student { +name: string +courses: list +enrol(course) +display_courses() } class Course { +name: string +students: list +add_student(student) +display_students() } Student \"0..*\" \u003c--\u003e \"0..*\" Course : enrols in \u003e end The double-headed arrow in the diagram indicates that both Student and Course are aware of each other. The \u0026ldquo;0..*\u0026rdquo; notation indicates that a Student can be enrolled in zero or more Courses, and a Course can have zero or more Students.\nAssociation is a flexible relationship that can represent many real-world connections between objects. It\u0026rsquo;s important to choose between unidirectional and bidirectional associations carefully, as bidirectional associations can introduce more complexity and potential for errors if not managed properly.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-association/","section":"Programming","summary":"","title":"Class relations: Association","type":"programming"},{"content":"Una lista enlazada se compone de nodos donde cada nodo tiene dos partes:\nDato o información Referencia al siguiente nodo Los nodos se organizan de forma secuencial, cada uno apuntando al siguiente. El último nodo apunta a nulo para indicar el final.\nEsta estructura dinámica permite inserción y eliminación eficiente de nodos.\nTipos de listas enlazadas # Existen varios tipos:\nSimplemente enlazada: Cada nodo apunta al siguiente. Son útiles para colas (queues) y pilas (stacks). Diagrama de una lista simplemente enlazada Doblemente enlazada: Cada nodo tiene referencia al siguiente y al anterior. Permiten recorrer en ambos sentidos. Diagrama de una lista doblemente enlazada Circular: El último nodo apunta al primero formando un ciclo. Útiles para buffers circulares. Diagrama de una lista circular Operaciones comunes # Insertar: Agregar nodos al inicio, final o medio de la lista.\nEliminar: Quitar nodos por valor o posición.\nBuscar: Encontrar nodos por valor recorriendo la lista.\nRecorrer: Iterar los nodos accediendo por las referencias.\nImplementación # Las listas enlazadas se pueden implementar de la siguiente manera:\nUsa la clase ListNode para representar nodos:\nclass ListNode: def __init__(self, value): self.value = value self.next = None Luego para crear y usar una lista se define una clase LinkedList con métodos para las operaciones.\nclass LinkedList: def __init__(self): self.head = None def add_to_start(self, new_value): new_node = ListNode(new_value) new_node.next = self.head self.head = new_node def print(self): current = self.head while current != None: print(current.value) current = current.next def search(self, searched_value): current = self.head while current != None: if current.value == searched_value: return True current = current.next return False #...other methods Con esta clase LinkedList podemos crear una lista, agregar nodos, imprimirla, buscar elementos, etc.\nSe podrían agregar otros métodos como insertar al final, eliminar por valor, obtener por índice, etc. Pero esto da una idea de cómo encapsular la funcionalidad de la lista enlazada en una clase. Como práctica, podés intentar agregar estos métodos por tu cuenta, ¡no dudes en dejar tus comentarios y contactarte si necesitas ayuda!\nVentajas y desventajas # Ventajas:\nInsertar y eliminar nodos es eficiente. No requiere definir tamaño fijo como los arrays. Estructura dinámica y flexible. Desventajas:\nMayor uso de memoria por tener que almacenar referencias. El acceso a elementos por índice es más costoso al ser secuencial. Ejemplos de uso # Implementar estructuras como pilas (stacks) y colas (queues). En listas doblemente enlazadas, recorrer la lista en el sentido ambos sentidos. Blockchains como la de Bitcoin. Reproducir elementos en orden como playlists de música. Conclusión # Las listas enlazadas son una estructura de datos versátil para almacenar secuencias dinámicas de elementos. Tener un buen manejo de estas listas, sus operaciones y usos es indispensable para cualquier programador.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\n","date":"01 noviembre 2023","externalUrl":null,"permalink":"/programming/data-structures/linked-lists/","section":"Programación","summary":"","title":"Listas Enlazadas","type":"programming"},{"content":" ¿Qué son las funciones? # Una función, en términos simples, es un bloque de código que se ejecuta sólo cuando es llamado. Puedes pensar en ella como un pequeño programa dentro de tu programa principal, diseñado para realizar una tarea específica1. Una función también puede verse como una caja negra: le pasamos una entrada (parámetros), ocurre algún procesamiento interno, y produce una salida (retorno).\nLas funciones nos permiten segmentar nuestro código en partes lógicas, donde cada parte realiza una única acción. Esto brinda varios beneficios2:\nReutilización: Una vez definida la función, podemos ejecutar (llamar) ese código desde cualquier lugar de nuestro programa cuantas veces sea necesario. Organización: Permite dividir un programa grande en partes más pequeñas y manejables. Encapsulamiento: Las funciones reducen la complejidad escondiendo los detalles de implementación internos. Mantenimiento: Si necesitamos realizar cambios, solo debemos modificar el código en un lugar (la función) en lugar de rastrear todas las instancias de ese código. Procedimientos vs. Funciones\nEs vital distinguir entre estos dos conceptos. Mientras que una función siempre devuelve un valor, un procedimiento realiza una tarea pero no devuelve nada. En algunos lenguajes, esta diferencia es más clara que en otros. Python, por ejemplo, tiene funciones que pueden o no devolver valores.\nAnatomía de una función # En Python, una función se declara usando la palabra clave def, seguida del nombre de la función y paréntesis. El código dentro de la función se denomina el cuerpo de la función3 y contiene el conjunto de instrucciones a ejecutar para cumplir con su tarea..\ndef mi_funcion(): print(\u0026#34;¡Hola desde mi función!\u0026#34;) Para llamar o invocar una función, simplemente usamos su nombre seguido de paréntesis:\nmi_funcion() # Salida: ¡Hola desde mi función! Parámetros y argumentos # Las funciones se vuelven aún más poderosas cuando les pasamos información, conocida como parámetros. Estos actúan como \u0026ldquo;variables\u0026rdquo; dentro de la función y permiten que la función trabaje con diferentes datos cada vez que se llama.\nMientras que los parámetros son variables definidas en la definición de la función. Los argumentos son los valores reales pasados al llamar a la función.\ndef saludo(nombre): print(f\u0026#34;¡Hola {nombre}!\u0026#34;) saludo(\u0026#34;María\u0026#34;) # Salida: # ¡Hola María! Podemos definir valores por defecto para los parámetros Python permite parámetros por defecto, que tienen un valor predeterminado, lo cual hace opcional pasar esos argumentos al llamar la función. También permite parámetros nombrados que permiten pasar los argumentos en cualquier orden, especificando su nombre.\ndef saludo(nombre=\u0026#34;María\u0026#34;, repeticiones=3): repeticion = 1 while repeticion \u0026lt;= repeticiones: print(f\u0026#34;¡Hola {nombre}!\u0026#34;) repeticion += 1 saludo() # Salida: # ¡Hola María! # ¡Hola María! # ¡Hola María! saludo(\u0026#34;Florencia\u0026#34;, 4) # Salida: # ¡Hola Florencia! # ¡Hola Florencia! # ¡Hola Florencia! # ¡Hola Florencia! saludo(repeticiones=2, nombre=\u0026#34;Julián\u0026#34;) # Salida # ¡Hola Julián! # ¡Hola Julián! Retorno de valores # Las funciones pueden devolver un resultado o valor de retorno usando la palabra reservada return.\ndef area_circulo(radio): return 3.14 * (radio ** 2) resultado = area_circulo(10) print(resultado) # Salida: 314 El valor de retorno se pasa de vuelta a donde se llamó la función y se puede asignar a una variable para usarlo.\nLas funciones también pueden ejecutar alguna tarea sin devolver nada explícitamente. En Python esto se conoce como retornar None.\nVariables locales y globales # Las variables locales se definen dentro de una función y solo existen en ese ámbito, mientras que las variables globales están definidas fuera y pueden ser accedidas desde cualquier parte del código. Es crucial entender su alcance (dónde puede ser accesible una variable) y duración (cuánto tiempo vive una variable).\nx = 10 # x es global def suma(): y = 5 # y es local return x + y suma() # Salida: 15 print(y) # Error, y no existe fuera de la función Podemos leer variables globales desde una función, pero si necesitamos modificarla debemos declararla global.\nx = 10 def suma(): global x x = x + 5 suma() print(x) # 15 ","date":"29 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/functions/","section":"Programación","summary":"","title":"Funciones","type":"programming"},{"content":"La lógica booleana, nombrada en honor a George Boole, un matemático inglés del siglo XIX, es un sistema matemático que se ocupa de operaciones que tienen solo dos resultados posibles: verdadero o falso, representados generalmente como 1 y 0, respectivamente1. En su obra \u0026ldquo;An Investigation of the Laws of Thought\u0026rdquo;, Boole estableció las bases de esta lógica, presentando un sistema algebraico que podría utilizarse para representar estructuras lógicas.\nOperaciones Booleanas # Dentro de la lógica booleana, existen operaciones fundamentales que permiten manipular y combinar estas expresiones binarias:\nAND (Y): Esta operación devuelve verdadero (1) solo si ambas entradas son verdaderas. Por ejemplo, si tenemos dos interruptores, ambos deben estar en la posición encendido para que una luz se encienda.\nOR (O): Devuelve verdadero si al menos una de las entradas es verdadera. Siguiendo con el ejemplo de los interruptores, con que uno de ellos esté encendido, la luz se iluminará.\nNOT (NO): Es una operación unaria, lo que significa que solo tiene una entrada. Simplemente invierte el valor de entrada. Si le das un 1, devuelve un 0 y viceversa.\nNAND (NO Y): Es la negación de AND. Solo devuelve falso si ambas entradas son verdaderas.\nNOR (NO O): Es la negación de OR. Devuelve verdadero solo si ambas entradas son falsas.\nXOR (O exclusivo): Devuelve verdadero si las entradas son diferentes. Si ambas son iguales, devuelve falso.\nXNOR (NO O exclusivo): Es la negación de XOR. Devuelve verdadero si ambas entradas son iguales.\nLa importancia de esta lógica en computación y programación # La computación moderna, en su esencia, es la manipulación de bits, esos unos y ceros que mencionamos. Cada operación que realiza una computadora, desde simples cálculos hasta la renderización de gráficos complejos, implica operaciones booleanas en algún nivel2.\nEn programación, la lógica booleana se utiliza en estructuras de control, como condiciones (if, else) y bucles, permitiendo a los programas tomar decisiones basadas en ciertas condiciones.\nTablas de verdad: el mapa de la lógica Booleana # Una tabla de verdad es una representación gráfica de una operación booleana. Enumera todas las combinaciones posibles de entradas y muestra el resultado de la operación para cada combinación3.\nPor ejemplo,\nA B A AND B A OR B A XOR B A NOR B A NAND B NOT A A NXOR B 1 1 1 1 0 0 0 0 1 1 0 0 1 1 0 1 0 0 0 1 0 1 1 0 1 1 0 0 0 0 0 0 1 1 1 1 Conclusiones # La lógica booleana es mucho más que un conjunto de reglas matemáticas abstractas. Es el lenguaje fundamental de las máquinas, el código que subyace a la era digital en la que vivimos. Al comprender sus principios, no solo nos volvemos más adeptos a trabajar con tecnología, sino que también adquirimos una apreciación más profunda de las estructuras que sustentan nuestro mundo digital.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias # Boole, G. (1854). An Investigation of the Laws of Thought. Londres: Walton and Maberly.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A. (2012). Estructura de Computadoras. Buenos Aires: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMinsky, M. (1967). Computation: Finite and Infinite Machines. Buenos Aires: Prentice-Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"09 septiembre 2023","externalUrl":null,"permalink":"/programming/intro/boolean-logic/","section":"Programación","summary":"","title":"Lógica Booleana","type":"programming"},{"content":"Key characteristics of aggregation:\nIt\u0026rsquo;s a stronger relationship than a simple association, but weaker than composition. The \u0026ldquo;part\u0026rdquo; object can exist independently of the \u0026ldquo;whole\u0026rdquo; object. Multiple \u0026ldquo;whole\u0026rdquo; objects can share the same \u0026ldquo;part\u0026rdquo; object. If the \u0026ldquo;whole\u0026rdquo; object is destroyed, the \u0026ldquo;part\u0026rdquo; object continues to exist. Let\u0026rsquo;s look at an example to illustrate aggregation:\nclass Department: def __init__(self, name): self.name = name self.employees = [] def add_employee(self, employee): self.employees.append(employee) def remove_employee(self, employee): self.employees.remove(employee) def list_employees(self): return f\u0026#34;Department {self.name} has employees: {\u0026#39;, \u0026#39;.join(emp.name for emp in self.employees)}\u0026#34; class Employee: def __init__(self, name, id): self.name = name self.id = id def __str__(self): return f\u0026#34;Employee(name={self.name}, id={self.id})\u0026#34; # Creating instances hr_dept = Department(\u0026#34;Human Resources\u0026#34;) it_dept = Department(\u0026#34;Information Technology\u0026#34;) emp1 = Employee(\u0026#34;Alice\u0026#34;, \u0026#34;E001\u0026#34;) emp2 = Employee(\u0026#34;Bob\u0026#34;, \u0026#34;E002\u0026#34;) emp3 = Employee(\u0026#34;Charlie\u0026#34;, \u0026#34;E003\u0026#34;) # Adding employees to departments hr_dept.add_employee(emp1) hr_dept.add_employee(emp2) it_dept.add_employee(emp2) # Note: Bob works in both HR and IT it_dept.add_employee(emp3) print(hr_dept.list_employees()) print(it_dept.list_employees()) # If we remove the HR department, the employees still exist del hr_dept print(emp1) # Employee still exists In this example, we have an aggregation relationship between Department and Employee. A Department has Employees, but Employees can exist independently of any particular Department. Also, an Employee can belong to multiple Departments (as we see with Bob).\nHere\u0026rsquo;s a UML diagram representing this aggregation relationship:\nclassDiagram class Department { +name: string +employees: list +add_employee(employee) +remove_employee(employee) +list_employees() } class Employee { +name: string +id: string +__str__() } Department o-- Employee : has end In this diagram, the open diamond on the Department side of the relationship indicates aggregation. This shows that Department is the \u0026ldquo;whole\u0026rdquo; and Employee is the \u0026ldquo;part\u0026rdquo; in this relationship.\nIt\u0026rsquo;s important to note that while aggregation implies a whole-part relationship, the \u0026ldquo;part\u0026rdquo; (in this case, Employee) can exist independently and can even be part of multiple \u0026ldquo;wholes\u0026rdquo; (multiple Departments).\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-aggregation/","section":"Programming","summary":"","title":"Class relations: Aggregation","type":"programming"},{"content":"La naturaleza LIFO de las pilas se debe a que sólo se puede acceder y manipular el elemento superior. La operación de colocar un elemento sobre la pila se conoce como \u0026ldquo;push\u0026rdquo;, mientras que sacar un elemento de la pila es un \u0026ldquo;pop\u0026rdquo;. El funcionamiento LIFO provoca que el último elemento colocado en una pila sea el primero en ser retirado.\nDiagrama de una pila Operaciones principales # Las operaciones primarias que soporta una estructura de pila son:\nPush: agrega un elemento encima de la pila. Pop: saca el elemento de la pila que se encuentra en la cima. Peek: permite acceder al elemento de la cima sin sacarlo de la pila. isEmpty: consulta si la pila se encuentra vacía. La mayoría de los lenguajes como Python y Java proveen implementaciones de pilas en sus librerías estándar.\nImplementación # Una pila puede implementarse utilizando una lista enlazada de manera que cada node apunte al nodo anterior.\nclass Node: def __init__(self, value): self.value = value self.previous = None class Stack: def __init__(self): self.top = None self.size = 0 def push(self, value): new_node = Node(value) if self.top is None: self.top = new_node else: new_node.previous = self.top self.top = new_node self.size += 1 def pop(self): if self.top is None: return None top_node = self.top self.top = self.top.previous self.size -= 1 return top_node.value def peek(self): if self.top is None: return None return self.top.value def is_empty(self): return self.top is None # Returns true if top is None def __len__(self): return self.size def __str__(self): values = [] current = self.top while current: values.append(str(current.value)) current = current.previous return \u0026#34;\\n\u0026#34;.join(values) print(\u0026#34;Creating a new stack\u0026#34;) stack = Stack() print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if stack is empty\u0026#34;) print(f\u0026#34;Is stack empty? {stack.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Push first element\u0026#34;) print(\u0026#34; stack.push(\\\u0026#34;First\\\u0026#34;)\u0026#34;) stack.push(\u0026#34;First\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print stack:\u0026#34;) print(stack) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print top element using peek\u0026#34;) print(f\u0026#34;stack.peek() =\u0026gt; {stack.peek()}\u0026#34;) print(\u0026#34;Add two more elements: stack.push(\\\u0026#34;\\\u0026#34;):\u0026#34;) print(\u0026#34; stack.push(\\\u0026#34;Second\\\u0026#34;)\u0026#34;) print(\u0026#34; stack.push(\\\u0026#34;Third\\\u0026#34;)\u0026#34;) stack.push(\u0026#34;Second\u0026#34;) stack.push(\u0026#34;Third\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print stack:\u0026#34;) print(stack) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print top element using peek\u0026#34;) print(f\u0026#34;stack.peek() =\u0026gt; {stack.peek()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if stack is empty\u0026#34;) print(f\u0026#34;Is stack empty? {stack.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get top element using pop\u0026#34;) print(f\u0026#34;stack.pop() =\u0026gt; {stack.pop()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print top element using peek\u0026#34;) print(f\u0026#34;stack.peek() =\u0026gt; {stack.peek()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get top element using pop\u0026#34;) print(f\u0026#34;stack.pop() =\u0026gt; {stack.pop()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get top element using pop\u0026#34;) print(f\u0026#34;stack.pop() =\u0026gt; {stack.pop()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if stack is empty\u0026#34;) print(f\u0026#34;Is stack empty? {stack.is_empty()}\u0026#34;) Ejemplos de uso # Las pilas tienen muchos usos en programación:\nPila de ejecución (call stack): registra las llamadas a funciones pendientes de resolver. Implementa el comportamiento LIFO esperado.\nPila de navegador: permite volver atrás (undo) en el historial de navegación de forma similar a una pila LIFO.\nEjecución de expresiones matemáticas: mediante una pila se puede verificar paréntesis, corchetes, llaves, etc.\nAlgoritmos y estructuras de datos: como en el algoritmo quicksort y en la implementación de buses de datos (datapaths).\nConclusión # Las pilas son estructuras de datos versátiles gracias a su principio de funcionamiento LIFO. Tener un buen dominio de pilas, sus usos y aplicaciones es esencial en la ciencia de la computación.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\n","date":"02 noviembre 2023","externalUrl":null,"permalink":"/programming/data-structures/stacks/","section":"Programación","summary":"","title":"Pilas","type":"programming"},{"content":" Recursión: el arte de llamarse a sí mismo # Imagina una caja de espejos donde cada espejo refleja lo que ve en el siguiente, creando una serie infinita de reflejos. La recursión en programación es algo similar. Es una técnica donde una función se llama a sí misma directa o indirectamente[^1^]. Esto crea un ciclo en el cual la función resuelve un problema dividiéndolo en instancias más pequeñas del mismo problema, hasta llegar a un caso base sencillo de resolver.\nPor ejemplo, imaginemos una función que imprime un contador regresivo:\ndef cuenta_regresiva(numero): if numero \u0026gt; 0: print(numero) cuenta_regresiva(numero - 1) else: print(\u0026#34;¡Despegue!\u0026#34;) cuenta_regresiva(5) Esta función se llama recursivamente reduciendo el número cada vez hasta llegar a 0, y luego imprime el mensaje de despegue.\nLa recursión es un enfoque declarativo donde se enfoca en dividir un problema en casos recursivos sin necesidad de controlar explícitamente el bucle usando iteradores o contadores como en la programación imperativa.\nLa estructura de una función recursiva # El poder de la recursión radica en su simplicidad. Sin embargo, es esencial entender su estructura para evitar caer en trampas comunes. Una función recursiva típica tiene dos partes principales1:\nCaso base: El caso más simple con una solución conocida que no requiere recursión. Es la condición de parada, que detiene la recursión. Sin el caso base, caeríamos en una recursión infinita que eventualmente desborda la pila de llamadas. Caso recursivo: Es donde ocurre la mágica llamada recursiva. En este punto, la función se llama a sí misma con un argumento modificado, generalmente una versión reducida del problema original. Ejemplos clásicos de recursión # Factorial # El factorial de un entero positivo \\(n\\) es el producto de todos los enteros positivos menores o iguales a \\(n\\). Por ejemplo:\n\\(5! = 5 * 4 * 3 * 2 * 1 = 120\\) \\(4! = 4 * 3 * 2 * 1 = 24\\) \\(3! = 3 * 2 * 1 = 6\\) Aquí está el código en Python para calcular el factorial usando recursión:\ndef factorial(n): if n == 1: return 1 # Caso base return n * factorial(n-1) # Caso recursivo Caso base: El caso base es la instancia más simple y pequeña del problema que puede responderse directamente. Para el factorial, cuando \\(n = 1\\), el resultado es \\(1\\). Caso recursivo: Si \\(n\\) es mayor que \\(1\\), la función se llama a sí misma con \\(n-1\\), y multiplica el resultado por \\(n\\). Digamos que quieres calcular el factorial de \\(5\\), así que llamas a factorial(5).\nEsto es lo que sucede:\nPaso 1: Como \\(n = 5\\) no es \\(1\\), la función llama a factorial(4), luego multiplica el resultado por \\(5\\). Paso 2: Ahora, dentro de factorial(4), \\(n = 4\\), entonces la función llama a factorial(3), luego multiplica el resultado por \\(4\\). Paso 3: Dentro de factorial(3), \\(n = 3\\), así que llama a factorial(2), luego multiplica el resultado por \\(3\\). Paso 4: Dentro de factorial(2), \\(n = 2\\), así que llama a factorial(1), luego multiplica el resultado por \\(2\\). Paso 5: Finalmente, factorial(1) alcanza el caso base, donde \\(n = 1\\), así que retorna \\(1\\). Ahora los resultados se desenrollan:\nfactorial(2) retorna \\(2 * 1 = 2\\) factorial(3) retorna \\(3 * 2 = 6\\) factorial(4) retorna \\(4 * 6 = 24\\) factorial(5) retorna \\(5 * 24 = 120\\) El resultado final es \\(120\\), que es el valor de \\(5!\\).\nAquí hay una representación visual de la pila de llamadas:\nfactorial(5) -\u0026gt; factorial(4) -\u0026gt; factorial(3) -\u0026gt; factorial(2) -\u0026gt; factorial(1) return 1 return 2 return 6 return 24 return 120 Serie de Fibonacci # La serie de Fibonacci es una secuencia de números donde cada número es la suma de los dos anteriores. Comienza con \\(0\\) y \\(1\\), y cada número posterior es la suma de los dos números anteriores. Los primeros números de la secuencia son: \\(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \u0026hellip;\\)\nAquí está el código en Python para calcular el \\(n^th\\) número de Fibonacci usando recursión de cola:\ndef fibonacci(n, a=0, b=1): if n == 0: return a return fibonacci(n-1, b, a+b) La función toma tres parámetros:\n\\(n\\): La posición del número deseado en la secuencia. \\(a\\) y \\(b\\): Dos números que ayudan en el cálculo de la secuencia. Aquí hay un desglose de cómo funciona la función:\nCaso Base: Si \\(n\\) es \\(0\\), la función devuelve \\(a\\). Este es el valor del \\(n^th\\) número en la secuencia.\nCaso Recursivo: Si \\(n\\) no es \\(0\\), la función se llama a sí misma con \\(n-1\\), \\(b\\), y \\(a+b\\). Estos parámetros cambian la posición en la secuencia y preparan los siguientes números para la suma.\nSupongamos que queremos encontrar el \\(5^th\\) número en la secuencia de Fibonacci llamando a fibonacci(5).\nEsto es lo que sucede:\nPaso 1: Dado que \\(n = 5\\), llama a fibonacci(4, 1, 1) (porque \\(a = 0\\), \\(b = 1\\), \\(a + b = 1\\)). Paso 2: Dado que \\(n = 4\\), llama a fibonacci(3, 1, 2) (porque \\(a = 1\\), \\(b = 1\\), \\(a + b = 2\\)). Paso 3: Dado que \\(n = 3\\), llama a fibonacci(2, 2, 3) (porque \\(a = 1\\), \\(b = 2\\), \\(a + b = 3\\)). Paso 4: Dado que \\(n = 2\\), llama a fibonacci(1, 3, 5) (porque \\(a = 2\\), \\(b = 3\\), \\(a + b = 5\\)). Paso 5: Dado que \\(n = 1\\), llama a fibonacci(0, 5, 8) (porque \\(a = 3\\), \\(b = 5\\), \\(a + b = 8\\)). Paso 6: Dado que \\(n = 0\\), devuelve \\(a\\), que es \\(5\\). El resultado es \\(5\\), que es el \\(5^th\\) número en la secuencia de Fibonacci.\nAquí hay una representación visual de la pila de llamadas:\nfibonacci(5, 0, 1) -\u0026gt; fibonacci(4, 1, 1) -\u0026gt; fibonacci(3, 1, 2) -\u0026gt; fibonacci(2, 2, 3) -\u0026gt; fibonacci(1, 3, 5) -\u0026gt; fibonacci(0, 5, 8) return 5 Ventajas y desventajas # La recursión tiene ciertas ventajas2:\nPuede resultar en soluciones simples y elegantes para problemas que se dividen fácilmente en subproblemas. Elimina la necesidad de control de bucles explícito. Sigue la estructura matemática de una definición recursiva. Las desventajas incluyen:\nPuede ser menos eficiente (alto consumo de memoria) que la iteración debido a las llamadas repetidas y creación de marcos de pila. Demasiada recursión puede desbordar la pila de llamadas y causar errores. Puede ser más difícil de depurar y analizar que la iteración. Por lo tanto, la recursión es una herramienta poderosa que debe usarse con discreción en los casos apropiados.\nRecursión vs Iteración # La recursión y la iteración (usando ciclos) son paralelos y podemos usar cualquiera para resolver muchos problemas. Ambas técnicas tienen el potencial de resolver los mismos problemas, pero su implementación y eficiencia pueden variar. Tomemos el ejemplo del factorial:\nIterativo\ndef factorial_iterativo(n): resultado = 1 for i in range(1, n+1): resultado *= i return resultado Recursivo\ndef factorial_recursivo(n): if n == 1: return 1 return n * factorial(n-1) La versión iterativa es más eficiente en términos de espacio, pero la recursiva es más limpia y fácil de entender. La elección entre recursión e iteración a menudo depende del problema específico, las restricciones de memoria y las preferencias del programador.\nConclusión # La recursión es una técnica clave que permite escribir algoritmos elegante, naturales y eficientes si se utiliza adecuadamente. Entender cómo dividir un problema en casos recursivos es esencial para dominar esta habilidad. La recursión ofrece una alternativa declarativa única para resolver problemas complejos sin necesidad de administrar bucles explícitos. Sin embargo, es crucial recordar siempre definir un caso base adecuado y ser consciente de las limitaciones de la recursión en términos de eficiencia y uso de memoria. Saber combinar recursión e iteración nos da flexibilidad al crear soluciones óptimas.\nComo siempre, la clave está en encontrar el equilibrio adecuado y utilizar la herramienta correcta para el trabajo adecuado.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias # Kindler, E., \u0026amp; Krivy, I. (2011). Object-Oriented Simulation of systems with Java: A working introduction. BoD–Books on Demand.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"30 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/recursive-functions/","section":"Programación","summary":"","title":"Funciones Recursivas","type":"programming"},{"content":" Elegir un lenguaje de programación # La elección del lenguaje de programación es el primer y quizás el más crucial paso en el proceso de aprendizaje. Hay varios factores a considerar al seleccionar un lenguaje, incluyendo:\nPropósito: ¿Para qué quieres programar? Si es para desarrollo web, JavaScript o PHP podrían ser buenas opciones. Si estás interesado en la ciencia de datos, R o Python podrían ser más adecuados. Comunidad: Un lenguaje con una comunidad activa puede ser esencial para los principiantes. Una comunidad vibrante generalmente significa más recursos, tutoriales y soluciones disponibles en línea. Curva de aprendizaje: Algunos lenguajes son más fáciles de aprender que otros. Es fundamental elegir uno que coincida con tu nivel de experiencia y paciencia. Oportunidades de trabajo: Si estás buscando una carrera en programación, investigar la demanda del mercado para diferentes lenguajes puede ser útil. Aunque hay muchos lenguajes valiosos y poderosos, para este curso, hemos elegido Python. Este lenguaje es conocido por su simplicidad y legibilidad, lo que lo hace ideal para aquellos que están empezando. Además, Python cuenta con una comunidad activa y una amplia gama de aplicaciones, desde desarrollo web hasta inteligencia artificial1.\nInstalación de Python # Para usuarios de Windows: # Descargar el instalador: Visita el sitio web oficial de Python en https://www.python.org/downloads/windows/ Haz clic en el enlace de descarga para la última versión de Python 3.x. Ejecuta el instalador: Una vez completada la descarga, localiza y ejecuta el archivo instalador .exe. Asegúrate de marcar la casilla que dice \u0026ldquo;Agregar Python al PATH\u0026rdquo; durante la instalación. Este paso es crucial para hacer que Python sea accesible desde el Símbolo del Sistema. Sigue las indicaciones de instalación. Verifica la instalación: Abre el Símbolo del Sistema y escribe: python --version Esto debería mostrar la versión de Python que acabas de instalar. Para usuarios de Mac: # Descargar el instalador: Visita el sitio web oficial de Python en https://www.python.org/downloads/mac-osx/ Haz clic en el enlace de descarga para la última versión de Python 3.x. Ejecuta el instalador: Una vez descargado, localiza y ejecuta el archivo .pkg. Sigue las indicaciones de instalación. Verifica la instalación: Abre la Terminal y escribe: python3 --version Esto debería mostrar la versión de Python que acabas de instalar. Para usuarios de Linux (Ubuntu/Debian): # Actualiza los paquetes: sudo apt update Instala Python: sudo apt install python3 Verifica la instalación: Después de la instalación, puedes comprobar la versión de Python instalada escribiendo: python3 --version Entornos de Desarrollo Integrado (IDEs) # Un IDE es una herramienta que facilita el desarrollo de aplicaciones al combinar comúnmente utilizadas en un solo software: editor de código, compilador, depurador, entre otros. Elegir el IDE adecuado puede hacer que el proceso de programación sea más fluido y eficiente.\nAl evaluar IDEs, considera:\nCompatibilidad con el lenguaje: No todos los IDEs son compatibles con todos los lenguajes de programación. Características: Algunos IDEs ofrecen funcionalidades como autocompletado, resaltado de sintaxis y herramientas de depuración. Extensiones y plugins: La posibilidad de personalizar y extender tu IDE a través de plugins puede ser muy útil. Precio: Hay IDEs gratuitos y otros de pago. Evalúa si las características adicionales de un IDE de pago justifican el costo. Para este curso, hemos seleccionado Visual Studio Code (VS Code). Es un IDE popular que es gratuito y de código abierto. Es conocido por su interfaz sencilla, amplia gama de plugins y capacidad para manejar múltiples lenguajes de programación2. Su comunidad activa garantiza actualizaciones regulares y una amplia gama de recursos de aprendizaje.\nInstalación de Visual Studio Code # Para usuarios de Windows: # Descargar el instalador: Visita el sitio web oficial de VS Code en https://code.visualstudio.com/ Haz clic en el botón \u0026ldquo;Descargar para Windows\u0026rdquo;. Ejecuta el instalador: Una vez completada la descarga, localiza y ejecuta el archivo instalador .exe. Sigue las indicaciones de instalación, incluyendo aceptar el acuerdo de licencia y elegir la ubicación de instalación. Inicia VS Code: Tras la instalación, puedes encontrar VS Code en tu menú de inicio. Lánzalo, ¡y estarás listo para comenzar a programar! Para usuarios de Mac: # Descargar el instalador: Visita el sitio web oficial de VS Code en https://code.visualstudio.com/ Haz clic en el botón \u0026ldquo;Descargar para Mac\u0026rdquo;. Instala VS Code: Una vez descargado, abre el archivo .zip. Arrastra la aplicación Visual Studio Code .app a la carpeta Aplicaciones, para que esté disponible en el Launchpad. Inicia VS Code: Usa la búsqueda de Spotlight o navega hasta tu carpeta de Aplicaciones para iniciar VS Code. Para usuarios de Linux (Ubuntu/Debian): # Actualiza los paquetes e instala las dependencias: sudo apt update sudo apt install software-properties-common apt-transport-https wget **Descarga e instala la claves necesarias: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Añade el repositorio de VS Code: sudo add-apt-repository \u0026#34;deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main\u0026#34; Instala Visual Studio Code: sudo apt update sudo apt install code Inicia VS Code: Puedes iniciar VS Code desde la terminal escribiendo code o encontrarlo en tu lista de aplicaciones instaladas. Escribe y ejecuta tu primer programa # Una vez que hayas configurado tu entorno de programación, es hora de sumergirse en la codificación.\n¡Hola mundo! # Este es posiblemente el programa más icónico para principiantes. Es simple, pero te introduce al proceso de escribir y ejecutar código.\nprint(\u0026#34;¡Hola mundo!\u0026#34;) Ejecución del programa Hola Mundo Cálculo de área y perímetro de un triángulo # Este programa es un poco más complejo. No solo imprime un mensaje, sino que también realiza cálculos matemáticos.\n# Entrada del usuario lado1 = float(input(\u0026#34;Introduce la longitud del primer lado: \u0026#34;)) lado2 = float(input(\u0026#34;Introduce la longitud del segundo lado: \u0026#34;)) lado3 = float(input(\u0026#34;Introduce la longitud del tercer lado: \u0026#34;)) # Cálculo del perímetro perimetro = lado1 + lado2 + lado3 # Cálculo del área usando la fórmula de Herón s = perimetro / 2 area = (s*(s-lado1)*(s-lado2)*(s-lado3)) ** 0.5 print(f\u0026#34;El perímetro del triángulo es: {perimetro}\u0026#34;) print(f\u0026#34;El área del triángulo es: {area:.2f}\u0026#34;) Ejecución del programa Triangulo Conclusión # Configurar un entorno de programación puede parecer desalentador al principio, pero con las herramientas y recursos adecuados, se convierte en una tarea manejable y gratificante. Esperamos que este artículo te haya proporcionado una base sólida para comenzar tu viaje en programación. ¡Feliz codificación!\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias # Lutz, M. (2013). Learning Python. O\u0026rsquo;Reilly Media.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMicrosoft. (2020). Visual Studio Code Documentation. Microsoft Docs.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"10 septiembre 2023","externalUrl":null,"permalink":"/programming/intro/setup-dev-environment/","section":"Programación","summary":"","title":"Configura tu Entorno de Desarrollo","type":"programming"},{"content":"Key characteristics of composition:\nIt represents a strong \u0026ldquo;has-a\u0026rdquo; relationship. The \u0026ldquo;part\u0026rdquo; object cannot exist independently of the \u0026ldquo;whole\u0026rdquo; object. When the \u0026ldquo;whole\u0026rdquo; object is destroyed, all its \u0026ldquo;part\u0026rdquo; objects are also destroyed. A \u0026ldquo;part\u0026rdquo; object belongs to only one \u0026ldquo;whole\u0026rdquo; object at a time. Let\u0026rsquo;s look at an example to illustrate composition:\nclass Engine: def __init__(self, horsepower): self.horsepower = horsepower def start(self): return \u0026#34;Engine started\u0026#34; class Car: def __init__(self, make, model, horsepower): self.make = make self.model = model self.engine = Engine(horsepower) # Composition: Car creates its own Engine def start_car(self): return f\u0026#34;{self.make} {self.model}: {self.engine.start()}\u0026#34; def __del__(self): print(f\u0026#34;{self.make} {self.model} is being destroyed, and so is its engine.\u0026#34;) # Creating a Car instance my_car = Car(\u0026#34;Toyota\u0026#34;, \u0026#34;Corolla\u0026#34;, 150) print(my_car.start_car()) # Output: Toyota Corolla: Engine started # When we delete the Car, its Engine is also deleted del my_car # This will print: Toyota Corolla is being destroyed, and so is its engine. In this example, we have a composition relationship between Car and Engine. A Car has an Engine, and the Engine cannot exist independently of the Car. When a Car object is created, it creates its own Engine. When the Car object is destroyed, its Engine is also destroyed.\nHere\u0026rsquo;s a UML diagram representing this composition relationship:\nclassDiagram class Car { +make: string +model: string -engine: Engine +start_car() +__del__() } class Engine { -horsepower: int +start() } Car *-- Engine : has end In this diagram, the filled diamond on the Car side of the relationship indicates composition. This shows that Car is the \u0026ldquo;whole\u0026rdquo; and Engine is the \u0026ldquo;part\u0026rdquo; in this relationship, and that the Engine\u0026rsquo;s lifetime is tied to the Car\u0026rsquo;s lifetime.\nThe key difference between aggregation and composition is the strength of the relationship and the lifecycle dependency. In aggregation, the \u0026ldquo;part\u0026rdquo; can exist independently of the \u0026ldquo;whole\u0026rdquo;, while in composition, the \u0026ldquo;part\u0026rdquo; cannot exist without the \u0026ldquo;whole\u0026rdquo;.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-composition/","section":"Programming","summary":"","title":"Class relations: Composition","type":"programming"},{"content":"La naturaleza FIFO (first in, first out) de las colas se debe a que sólo se puede acceder y manipular el elemento inicial. Cuando se agrega un elemento a la cola se conoce como \u0026ldquo;enqueue\u0026rdquo;, mientras que eliminar un elemento se denomina \u0026ldquo;dequeue\u0026rdquo;.\nEsto hace que el primer elemento en ser añadido a la cola también sea el primero en ser retirado, de ahí su comportamiento FIFO.\nDiagrama de una cola Operaciones principales # Las operaciones básicas de una cola son:\nEnqueue: Agrega un elemento al final de la cola. Dequeue: Saca el elemento del frente de la cola. Peek: Obtiene el elemento al frente sin sacarlo. isEmpty: Consulta si la cola está vacía. Implementación # Al igual que las pilas, las colas se pueden implementar usando listas enlazadas. Se agrega al final y se saca del frente manteniendo referencias a ambos extremos.\nclass Node: def __init__(self, value): self.value = value self.next = None class Queue: def __init__(self): self.front = None self.end = None self.size = 0 def enqueue(self, value): new_node = Node(value) if self.end is None: self.end = new_node self.front = new_node return self.end.next = new_node self.end = new_node self.size += 1 def dequeue(self): if self.is_empty(): return None value = self.front.value self.front = self.front.next if self.front is None: self.end = None self.size -= 1 return value def peek(self): if self.is_empty(): return None return self.front.value def is_empty(self): return self.front is None # Returns true if front is None def __len__(self): return self.size def __str__(self): values = [] current = self.front while current: values.append(str(current.value)) current = current.next return \u0026#34;\\n\u0026#34;.join(values) print(\u0026#34;Creating a new queue\u0026#34;) queue = Queue() print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if queue is empty\u0026#34;) print(f\u0026#34;Is queue empty? {queue.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Enqueue three elements\u0026#34;) queue.enqueue(\u0026#34;ABC\u0026#34;) queue.enqueue(\u0026#34;DEF\u0026#34;) queue.enqueue(\u0026#34;GHI\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after enqueuing elements:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get front element using dequeue\u0026#34;) print(f\u0026#34;queue.dequeue() =\u0026gt; {queue.dequeue()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after dequeue element:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print front element using peek\u0026#34;) print(f\u0026#34;queue.peek() =\u0026gt; {queue.peek()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after peek:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get front element using dequeue\u0026#34;) print(f\u0026#34;queue.dequeue() =\u0026gt; {queue.dequeue()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after dequeue element:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if queue is empty\u0026#34;) print(f\u0026#34;Is queue empty? {queue.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get front element using dequeue\u0026#34;) print(f\u0026#34;queue.dequeue() =\u0026gt; {queue.dequeue()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after dequeue element:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if queue is empty\u0026#34;) print(f\u0026#34;Is queue empty? {queue.is_empty()}\u0026#34;) Ejemplos de uso # Algunos usos comunes de colas:\nColas de impresión donde primero en entrar, primero en imprimir. Colas de tareas en sistemas operativos para orden de ejecución. Simulaciones donde se debe respetar orden de llegada como en bancos. Canales de mensajes como los de RabbitMQ o Kafka. Buffers circulares en audio para streaming. Conclusión # Las colas son estructuras versátiles gracias a su principio FIFO. Tener un buen manejo de colas, implementación y aplicaciones reforzará tus habilidades como programador.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\n","date":"03 noviembre 2023","externalUrl":null,"permalink":"/programming/data-structures/queues/","section":"Programación","summary":"","title":"Colas","type":"programming"},{"content":"Key characteristics of inheritance:\nIt promotes code reuse and establishes a hierarchy between classes. The subclass inherits all public and protected members from the superclass. The subclass can add its own members and override inherited members. It supports the concept of polymorphism. Let\u0026rsquo;s look at an example to illustrate inheritance:\nclass Animal: def __init__(self, name): self.name = name def speak(self): pass class Dog(Animal): def speak(self): return f\u0026#34;{self.name} says Woof!\u0026#34; class Cat(Animal): def speak(self): return f\u0026#34;{self.name} says Meow!\u0026#34; # Creating instances dog = Dog(\u0026#34;Buddy\u0026#34;) cat = Cat(\u0026#34;Whiskers\u0026#34;) print(dog.speak()) # Output: Buddy says Woof! print(cat.speak()) # Output: Whiskers says Meow! # Demonstrating polymorphism def animal_sound(animal): print(animal.speak()) animal_sound(dog) # Output: Buddy says Woof! animal_sound(cat) # Output: Whiskers says Meow! In this example, we have a base class Animal and two derived classes Dog and Cat. Both Dog and Cat inherit from Animal and override the speak method.\nHere\u0026rsquo;s a UML diagram representing this inheritance relationship:\nclassDiagram class Animal { +name: string +speak() } class Dog { +speak() } class Cat { +speak() } Animal \u003c|-- Dog Animal \u003c|-- Cat end In this diagram, the arrows pointing from Dog and Cat to Animal indicate inheritance. This shows that Dog and Cat are subclasses of Animal.\nInheritance is a powerful feature of OOP, but it should be used judiciously. Overuse of inheritance can lead to complex class hierarchies that are difficult to understand and maintain. The principle of \u0026ldquo;composition over inheritance\u0026rdquo; suggests that it\u0026rsquo;s often better to use composition (has-a relationship) rather than inheritance (is-a relationship) when designing class relationships.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-inheritance/","section":"Programming","summary":"","title":"Class relations: Inheritance","type":"programming"},{"content":"Key characteristics of realisation:\nIt represents a contract that the implementing class must fulfil. The class must provide implementations for all methods declared in the interface. It allows for polymorphism through interfaces. Python doesn\u0026rsquo;t have a built-in interface concept like some other languages (e.g., Java), but we can simulate interfaces using abstract base classes. Here\u0026rsquo;s an example:\nfrom abc import ABC, abstractmethod class Drawable(ABC): @abstractmethod def draw(self): pass class Circle(Drawable): def draw(self): return \u0026#34;Drawing a circle\u0026#34; class Square(Drawable): def draw(self): return \u0026#34;Drawing a square\u0026#34; def draw_shape(shape: Drawable): print(shape.draw()) # Creating instances circle = Circle() square = Square() # Using polymorphism through the interface draw_shape(circle) # Output: Drawing a circle draw_shape(square) # Output: Drawing a square In this example, Drawable is an abstract base class that acts like an interface. Both Circle and Square implement the Drawable interface by providing their own implementation of the draw method.\nHere\u0026rsquo;s a UML diagram representing this realisation relationship:\nclassDiagram class Drawable { \u003c\u003e +draw() } class Circle { +draw() } class Square { +draw() } Drawable \u003c|.. Circle Drawable \u003c|.. Square end In this diagram, the dashed arrows pointing from Circle and Square to Drawable indicate realisation. This shows that Circle and Square implement the Drawable interface.\nRealisation is a powerful concept that allows for designing loosely coupled systems. By programming to interfaces rather than concrete implementations, we can create more flexible and extensible software.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-realisation/","section":"Programming","summary":"","title":"Class relations: Realisation (Implementation)","type":"programming"},{"content":"Key characteristics of dependency:\nIt represents a \u0026ldquo;uses\u0026rdquo; relationship between classes. It\u0026rsquo;s a weaker relationship compared to association, aggregation, or composition. Changes in the used class may affect the using class. Here\u0026rsquo;s an example to illustrate dependency:\nclass Printer: def print_document(self, document): return f\u0026#34;Printing: {document.get_content()}\u0026#34; class PDFDocument: def get_content(self): return \u0026#34;PDF content\u0026#34; class WordDocument: def get_content(self): return \u0026#34;Word document content\u0026#34; # Using the Printer printer = Printer() pdf = PDFDocument() word = WordDocument() print(printer.print_document(pdf)) # Output: Printing: PDF content print(printer.print_document(word)) # Output: Printing: Word document content In this example, the Printer class has a dependency on both PDFDocument and WordDocument classes. The Printer uses these classes in its print_document method, but it doesn\u0026rsquo;t maintain a long-term relationship with them.\nHere\u0026rsquo;s a UML diagram representing these dependency relationships:\nclassDiagram class Printer { +print_document(document) } class PDFDocument { +get_content() } class WordDocument { +get_content() } Printer ..\u003e PDFDocument : uses Printer ..\u003e WordDocument : uses end In this diagram, the dashed arrows pointing from Printer to PDFDocument and WordDocument indicate dependency. This shows that Printer uses these classes, but doesn\u0026rsquo;t have a stronger relationship with them.\nDependency is often used to reduce coupling between classes. By depending on abstractions (like interfaces) rather than concrete classes, we can make our code more flexible and easier to change.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-dependency/","section":"Programming","summary":"","title":"Class relations: Dependency","type":"programming"},{"content":" Comparing and contrasting relations # Now that we\u0026rsquo;ve explored the various types of class relations, let\u0026rsquo;s compare and contrast them to better understand when to use each:\nAssociation vs Aggregation vs Composition\nAssociation is the most general relationship, representing any connection between classes. Aggregation is a specialised association representing a whole-part relationship where the part can exist independently. Composition is the strongest whole-part relationship where the part cannot exist independently of the whole. Inheritance vs Composition\nInheritance represents an \u0026ldquo;is-a\u0026rdquo; relationship (e.g., a Dog is an Animal). Composition represents a \u0026ldquo;has-a\u0026rdquo; relationship (e.g., a Car has an Engine). The principle of \u0026ldquo;composition over inheritance\u0026rdquo; suggests favouring composition for more flexible designs. Realisation vs Inheritance\nRealisation is about implementing an interface, focusing on behaviour. Inheritance is about extending a class, inheriting both state and behaviour. Dependency vs Association\nDependency is a weaker, often temporary relationship (e.g., a method parameter). Association implies a more permanent relationship, often represented by a class attribute. Here\u0026rsquo;s a comparison table summarising these relationships:\nRelationship Strength Lifecycle Binding \u0026ldquo;Is-a\u0026rdquo; or \u0026ldquo;Has-a\u0026rdquo; Symbol in UML Dependency Weakest None Uses - - - - \u0026gt; Association Weak Independent Has-a (loose) ———\u0026gt; Aggregation Medium Independent Has-a ◇———\u0026gt; Composition Strong Dependent Has-a (strong) ♦———\u0026gt; Inheritance Strong N/A Is-a ——— Realisation Medium N/A Behaves-as - - - Common pitfalls # While class relationships are powerful tools in OOP, they can also lead to common pitfalls if not used carefully. Here are some common issues and how to avoid them:\nOveruse of inheritance\nProblem: Creating deep inheritance hierarchies that are hard to understand and maintain. Solution: Prefer composition over inheritance. Use inheritance only for genuine \u0026ldquo;is-a\u0026rdquo; relationships. Tight coupling\nProblem: Creating strong dependencies between classes, making the system rigid and hard to change. Solution: Use interfaces and dependency injection to reduce coupling. Depend on abstractions rather than concrete classes. God objects\nProblem: Creating classes that try to do too much, violating the Single Responsibility Principle. Solution: Break large classes into smaller, more focused classes. Use composition to bring functionality together. Circular dependencies\nProblem: Creating mutual dependencies between classes, leading to complex and hard-to-maintain code. Solution: Refactor to remove circular dependencies. Consider using interfaces or introducing a new class to break the cycle. Leaky abstractions\nProblem: Exposing implementation details through interfaces or base classes. Solution: Design interfaces and base classes carefully. Hide implementation details and expose only what\u0026rsquo;s necessary. Inappropriate intimacy\nProblem: Classes that know too much about each other\u0026rsquo;s internal details. Solution: Encapsulate data and behaviour. Use public interfaces to interact between classes. Brittle base classes\nProblem: Changes to base classes breaking derived classes in unexpected ways. Solution: Design base classes for extension. Document how derived classes should interact with base classes. Diamond problem in multiple inheritance\nProblem: Ambiguity in method resolution when a class inherits from two classes with a common ancestor. Solution: Avoid multiple inheritance if possible. Use interfaces or mixins instead. Overuse of getters and setters\nProblem: Breaking encapsulation by providing unrestricted access to internal state. Solution: Use meaningful methods that represent behaviors rather than exposing internal data directly. Violation of Liskov Substitution Principle\nProblem: Derived classes that can\u0026rsquo;t be used interchangeably with their base classes. Solution: Ensure that derived classes truly represent specialisations of their base classes. Use composition if the \u0026ldquo;is-a\u0026rdquo; relationship doesn\u0026rsquo;t hold. By being aware of these pitfalls and following best practices, you can create more robust and maintainable object-oriented designs.\nConclusion # Key takeaways:\nAssociation is a general relationship between classes. Aggregation represents a whole-part relationship where parts can exist independently. Composition is a stronger whole-part relationship where parts cannot exist independently. Inheritance represents an \u0026ldquo;is-a\u0026rdquo; relationship and promotes code reuse. Realisation is about implementing interfaces and focusing on behaviour. Dependency is a weak, often temporary relationship between classes. Remember that good object-oriented design is not just about using these relationships, but about using them appropriately. Always consider the SOLID principles and the \u0026ldquo;composition over inheritance\u0026rdquo; guideline.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-conclusion/","section":"Programming","summary":"","title":"Class relations: Conclusion","type":"programming"},{"content":"En el corazón de la Programación Orientada a Objetos (POO) se encuentran cuatro conceptos fundamentales: Encapsulamiento, Herencia, Polimorfismo y Abstracción. Estos conceptos, conocidos como los \u0026ldquo;cuatro pilares\u0026rdquo; de la POO, constituyen la base sobre la cual se construyen sistemas de software complejos. En esta guía, profundizaremos en cada uno de estos conceptos, explorando sus definiciones, implementaciones y aplicaciones prácticas. Utilizaremos Python, un lenguaje reconocido por su claridad y versatilidad, para demostrar estos conceptos en acción. Ya seas un principiante que comienza su viaje en la programación o un profesional experimentado que busca refrescar sus conocimientos, este artículo tiene como objetivo proporcionar información valiosa y una comprensión más profunda de los principios de la POO.\nEl encapsulamiento nos permite agrupar datos y métodos, ocultando detalles internos y protegiendo la integridad de los datos. La herencia permite la reutilización de código y la creación de relaciones jerárquicas entre clases. El polimorfismo proporciona una forma de usar objetos de diferentes tipos a través de una interfaz común, mejorando la flexibilidad y extensibilidad. La abstracción nos permite crear modelos simplificados de sistemas complejos, enfocándonos en las características esenciales y ocultando los detalles innecesarios. A medida que continúes tu viaje en el desarrollo de software, descubrirás que dominar estos conceptos abre nuevas formas de pensar y resolver problemas. Recuerda que la POO no se trata solo de sintaxis o características del lenguaje; es una mentalidad para modelar sistemas complejos y gestionar la complejidad en el software.\n","date":"07 diciembre 2024","externalUrl":null,"permalink":"/programming/oop/the-four-pillars-introduction/","section":"Programación","summary":"","title":"Los Cuatro Pilares","type":"programming"},{"content":"La importancia del encapsulamiento radica en varios aspectos clave:\nProtección de datos: Al controlar el acceso a los datos del objeto a través de métodos, podemos asegurar que los datos se mantengan consistentes y válidos. Modularidad: El encapsulamiento permite que los objetos sean autocontenidos, facilitando la comprensión y el mantenimiento del código. Flexibilidad: La implementación interna puede ser modificada sin afectar otras partes del código que utilizan el objeto. Reducción de complejidad: Al ocultar los detalles del funcionamiento interno, el encapsulamiento reduce la complejidad del sistema desde una perspectiva externa. Implementación en Python # Python ofrece varios mecanismos para implementar el encapsulamiento. Exploremos estos con ejemplos:\n1. Uso de atributos privados # En Python, podemos crear atributos privados prefijando el nombre del atributo con doble guion bajo (__). Esto activa el \u0026ldquo;name mangling\u0026rdquo;, que hace que el atributo sea más difícil de acceder desde fuera de la clase.\nclass CuentaBancaria: def __init__(self, numero_cuenta, saldo): self.__numero_cuenta = numero_cuenta # Atributo privado self.__saldo = saldo # Atributo privado def depositar(self, cantidad): if cantidad \u0026gt; 0: self.__saldo += cantidad return True return False def retirar(self, cantidad): if 0 \u0026lt; cantidad \u0026lt;= self.__saldo: self.__saldo -= cantidad return True return False def obtener_saldo(self): return self.__saldo # Uso cuenta = CuentaBancaria(\u0026#34;1234567890\u0026#34;, 1000) print(cuenta.obtener_saldo()) # Salida: 1000 cuenta.depositar(500) print(cuenta.obtener_saldo()) # Salida: 1500 cuenta.retirar(200) print(cuenta.obtener_saldo()) # Salida: 1300 # Esto generará un AttributeError # print(cuenta.__saldo) En este ejemplo:\n__numero_cuenta y __saldo son atributos privados. Proporcionamos métodos públicos (depositar, retirar, obtener_saldo) para interactuar con estos atributos privados. El acceso directo a __saldo desde fuera de la clase generará una excepción AttributeError. 2. Uso de propiedades # El decorador @property de Python nos permite definir métodos que pueden ser accedidos como atributos, proporcionando una forma más pythonica de implementar getters y setters.\nclass Circulo: def __init__(self, radio): self._radio = radio @property def radio(self): return self._radio @radio.setter def radio(self, valor): if valor \u0026gt; 0: self._radio = valor else: raise ValueError(\u0026#34;El radio debe ser positivo\u0026#34;) @property def area(self): return 3.14159 * self._radio ** 2 # Uso circulo = Circulo(5) print(circulo.radio) # Salida: 5 print(circulo.area) # Salida: 78.53975 circulo.radio = 7 print(circulo.radio) # Salida: 7 print(circulo.area) # Salida: 153.93791 # Esto generará un ValueError # circulo.radio = -1 En este ejemplo:\n_radio es un atributo protegido (el guion bajo simple es una convención para atributos protegidos en Python). La propiedad radio proporciona acceso de lectura y escritura a _radio con validación. La propiedad area es de solo lectura y se calcula al vuelo. Beneficios y mejores prácticas # Los beneficios del encapsulamiento son numerosos:\nMejora de la mantenibilidad: Los cambios en la implementación interna no afectan al código externo que utiliza la clase. Mayor seguridad: Los atributos privados no pueden ser modificados accidentalmente desde fuera de la clase. Flexibilidad en la implementación: Puedes cambiar cómo se almacenan o calculan los datos sin cambiar la interfaz pública. Mejor abstracción: Los usuarios de la clase no necesitan conocer su funcionamiento interno. Las mejores prácticas para el encapsulamiento en Python incluyen:\nUsar atributos privados (prefijo de doble guion bajo) para datos que no deben ser accedidos directamente desde fuera de la clase. Proporcionar métodos públicos o propiedades para el acceso controlado a los datos internos. Usar propiedades en lugar de métodos get/set para un enfoque más propio del paradigma Python. Documentar claramente la interfaz pública, incluyendo cualquier efecto secundario de los métodos. Veamos un ejemplo más complejo que demuestra estas prácticas:\nclass Empleado: def __init__(self, nombre, salario): self.__nombre = nombre self.__salario = salario self.__proyectos = [] @property def nombre(self): return self.__nombre @property def salario(self): return self.__salario @salario.setter def salario(self, valor): if valor \u0026gt; 0: self.__salario = valor else: raise ValueError(\u0026#34;El salario debe ser positivo\u0026#34;) def agregar_proyecto(self, proyecto): \u0026#34;\u0026#34;\u0026#34; Agrega un proyecto a la lista de proyectos del empleado. :param proyecto: cadena que representa el nombre del proyecto \u0026#34;\u0026#34;\u0026#34; self.__proyectos.append(proyecto) def eliminar_proyecto(self, proyecto): \u0026#34;\u0026#34;\u0026#34; Elimina un proyecto de la lista de proyectos del empleado. :param proyecto: cadena que representa el nombre del proyecto :return: True si el proyecto fue eliminado, False si no se encontró \u0026#34;\u0026#34;\u0026#34; if proyecto in self.__proyectos: self.__proyectos.remove(proyecto) return True return False @property def cantidad_proyectos(self): return len(self.__proyectos) def __str__(self): return f\u0026#34;Empleado: {self.__nombre}, Salario: ${self.__salario}, Proyectos: {self.cantidad_proyectos}\u0026#34; # Uso emp = Empleado(\u0026#34;Juan Pérez\u0026#34;, 50000) print(emp.nombre) # Salida: Juan Pérez print(emp.salario) # Salida: 50000 emp.agregar_proyecto(\u0026#34;Proyecto A\u0026#34;) emp.agregar_proyecto(\u0026#34;Proyecto B\u0026#34;) print(emp.cantidad_proyectos) # Salida: 2 emp.salario = 55000 print(emp) # Salida: Empleado: Juan Pérez, Salario: $55000, Proyectos: 2 emp.eliminar_proyecto(\u0026#34;Proyecto A\u0026#34;) print(emp.cantidad_proyectos) # Salida: 1 # Esto generará un AttributeError # print(emp.__proyectos) Este ejemplo demuestra:\nAtributos privados (__nombre, __salario, __proyectos) Propiedades para acceso controlado (nombre, salario, cantidad_proyectos) Métodos públicos para manipular datos privados (agregar_proyecto, eliminar_proyecto) Documentación clara del comportamiento de los métodos Un método __str__ personalizado para una representación de cadena agradable del objeto Siguiendo estas prácticas, creamos una clase que es flexible y robusta, encarnando el principio de encapsulamiento.\nReferencias # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ ¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/programming/oop/the-four-pillars-encapsulation/","section":"Programación","summary":"","title":"Los Cuatro Pilares: Encapsulamiento","type":"programming"},{"content":"Los aspectos clave de la herencia incluyen:\nReutilización de código: La herencia permite reutilizar código de clases existentes, reduciendo la redundancia y promoviendo un desarrollo eficiente. Clasificación jerárquica: Permite la creación de jerarquías de clases, representando relaciones y características comunes entre objetos. Extensibilidad: Se puede agregar nueva funcionalidad a las clases existentes sin modificarlas, siguiendo el principio abierto-cerrado. Polimorfismo: La herencia es un prerrequisito para el polimorfismo en tiempo de ejecución (que discutiremos en detalle más adelante). Tipos de herencia # Existen varios tipos de herencia, aunque no todos los lenguajes de programación admiten todos los tipos. Los principales tipos son:\nHerencia simple: Una clase derivada hereda de una sola clase base. Herencia múltiple: Una clase derivada hereda de múltiples clases base. Herencia multinivel: Una clase derivada hereda de otra clase derivada. Herencia jerárquica: Múltiples clases derivadas heredan de una sola clase base. Herencia híbrida: Una combinación de dos o más tipos de herencia. Python admite todos estos tipos de herencia. Exploremos cada uno con ejemplos.\nHerencia simple # La herencia simple es la forma más básica de herencia, donde una clase hereda de una sola clase base.\nclass Animal: def __init__(self, especie): self.especie = especie def hacer_sonido(self): pass class Perro(Animal): def __init__(self, nombre): super().__init__(\u0026#34;Canino\u0026#34;) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¡Guau!\u0026#34; # Uso perro = Perro(\u0026#34;Buddy\u0026#34;) print(f\u0026#34;{perro.nombre} es un {perro.especie}\u0026#34;) # Salida: Buddy es un Canino print(perro.hacer_sonido()) # Salida: ¡Guau! En este ejemplo:\nAnimal es la clase base con un método genérico hacer_sonido. Perro es derivado de Animal, heredando sus atributos y métodos. Perro sobrescribe el método hacer_sonido con su propia implementación. Usamos super().__init__() para llamar al inicializador de la clase base. Herencia múltiple # La herencia múltiple permite que una clase herede de múltiples clases base. Algunos lenguajes no permiten este tipo de herencia.\nclass Volador: def volar(self): return \u0026#34;¡Puedo volar!\u0026#34; class Nadador: def nadar(self): return \u0026#34;¡Puedo nadar!\u0026#34; class Pato(Animal, Volador, Nadador): def __init__(self, nombre): Animal.__init__(self, \u0026#34;Ave\u0026#34;) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¡Cuac!\u0026#34; # Uso pato = Pato(\u0026#34;Donald\u0026#34;) print(f\u0026#34;{pato.nombre} es un {pato.especie}\u0026#34;) # Salida: Donald es un Ave print(pato.hacer_sonido()) # Salida: ¡Cuac! print(pato.volar()) # Salida: ¡Puedo volar! print(pato.nadar()) # Salida: ¡Puedo nadar! Aquí, Pato hereda de Animal, Volador y Nadador, combinando atributos y métodos de las tres clases.\nHerencia multinivel # En la herencia multinivel, una clase derivada hereda de otra clase derivada.\nclass Mamifero(Animal): def __init__(self, especie, es_de_sangre_caliente=True): super().__init__(especie) self.es_de_sangre_caliente = es_de_sangre_caliente def dar_a_luz(self): return \u0026#34;Dando a luz crías vivas\u0026#34; class Gato(Mamifero): def __init__(self, nombre): super().__init__(\u0026#34;Felino\u0026#34;) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¡Miau!\u0026#34; # Uso gato = Gato(\u0026#34;Bigotes\u0026#34;) print(f\u0026#34;{gato.nombre} es un {gato.especie}\u0026#34;) # Salida: Bigotes es un Felino print(gato.hacer_sonido()) # Salida: ¡Miau! print(gato.dar_a_luz()) # Salida: Dando a luz crías vivas print(f\u0026#34;¿Es de sangre caliente? {gato.es_de_sangre_caliente}\u0026#34;) # Salida: ¿Es de sangre caliente? True En este ejemplo, Gato hereda de Mamifero, que a su vez hereda de Animal, formando una cadena de herencia multinivel.\nHerencia jerárquica # La herencia jerárquica implica múltiples clases derivadas heredando de una sola clase base.\nclass Ave(Animal): def __init__(self, especie, puede_volar=True): super().__init__(especie) self.puede_volar = puede_volar class Loro(Ave): def __init__(self, nombre): super().__init__(\u0026#34;Psitácido\u0026#34;, puede_volar=True) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¡Squawk!\u0026#34; class Pinguino(Ave): def __init__(self, nombre): super().__init__(\u0026#34;Esfenisciforme\u0026#34;, puede_volar=False) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¡Honk!\u0026#34; # Uso loro = Loro(\u0026#34;Polly\u0026#34;) pinguino = Pinguino(\u0026#34;Pingu\u0026#34;) print(f\u0026#34;{loro.nombre} puede volar: {loro.puede_volar}\u0026#34;) # Salida: Polly puede volar: True print(f\u0026#34;{pinguino.nombre} puede volar: {pinguino.puede_volar}\u0026#34;) # Salida: Pingu puede volar: False Aquí, tanto Loro como Pinguino heredan de Ave, lo que demuestra la herencia jerárquica.\nHerencia híbrida # La herencia híbrida es una combinación de múltiples tipos de herencia. Veamos un ejemplo más complejo para ilustrar esto:\nclass Terrestre: def caminar(self): return \u0026#34;Caminando en tierra\u0026#34; class Acuatico: def nadar(self): return \u0026#34;Nadando en el agua\u0026#34; class Anfibio(Animal, Terrestre, Acuatico): def __init__(self, especie): Animal.__init__(self, especie) def adaptarse(self): return \u0026#34;Puede sobrevivir tanto en tierra como en agua\u0026#34; class Rana(Anfibio): def __init__(self, nombre): super().__init__(\u0026#34;Anuro\u0026#34;) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¡Croac!\u0026#34; # Uso rana = Rana(\u0026#34;Kermit\u0026#34;) print(f\u0026#34;{rana.nombre} es un {rana.especie}\u0026#34;) # Salida: Kermit es un Anuro print(rana.hacer_sonido()) # Salida: ¡Croac! print(rana.caminar()) # Salida: Caminando en tierra print(rana.nadar()) # Salida: Nadando en el agua print(rana.adaptarse()) # Salida: Puede sobrevivir tanto en tierra como en agua Este ejemplo demuestra la herencia híbrida:\nRana hereda de Anfibio Anfibio hereda de Animal, Terrestre, y Acuatico Esto crea una combinación de herencia multinivel y múltiple Consideraciones # La herencia ofrece varias ventajas. Sin embargo, también hay consideraciones importantes:\nComplejidad: Las jerarquías de herencia profundas pueden volverse difíciles de entender y mantener. Acoplamiento fuerte: La herencia crea un acoplamiento fuerte entre las clases base y derivadas. Problema de la clase base frágil: Los cambios en la clase base pueden afectar inesperadamente a las clases derivadas. Problema del diamante: En la herencia múltiple, pueden surgir conflictos si dos clases base tienen métodos con el mismo nombre. Para abordar estas consideraciones:\nPrefiere la composición sobre la herencia cuando sea posible. Mantén las jerarquías de herencia poco profundas y enfocadas. Utiliza clases base abstractas para definir interfaces claras. Ten cuidado con la herencia múltiple y resuelve los conflictos explícitamente. Visualicemos las relaciones de herencia que hemos discutido utilizando un diagrama de clases UML:\nclassDiagram Animal \u0026lt;|-- Mamífero Animal \u0026lt;|-- Ave Mamífero \u0026lt;|-- Perro Mamífero \u0026lt;|-- Gato Ave \u0026lt;|-- Loro Ave \u0026lt;|-- Pingüino Animal \u0026lt;|-- Anfibio Terrestre \u0026lt;|-- Anfibio Acuático \u0026lt;|-- Anfibio Anfibio \u0026lt;|-- Rana class Animal { +especie: str +hacer_sonido() } class Mamífero { +es_de_sangre_caliente: bool +dar_a_luz() } class Ave { +puede_volar: bool } class Anfibio { +adaptarse() } class Terrestre { +caminar() } class Acuático { +nadar() } Este diagrama ilustra las relaciones de herencia entre las clases que hemos discutido, mostrando tanto la herencia simple como la múltiple.\nReferencias # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ ¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/programming/oop/the-four-pillars-inheritance/","section":"Programación","summary":"","title":"Los Cuatro Pilares: Herencia","type":"programming"},{"content":"El polimorfismo permite escribir código flexible y reutilizable al permitirnos trabajar con objetos a un nivel más abstracto, sin necesidad de conocer sus tipos específicos.\nExisten dos tipos principales de polimorfismo en la programación orientada a objetos:\nPolimorfismo en tiempo de compilación (Polimorfismo estático)\nSe logra a través de la sobrecarga de métodos. Se resuelve en tiempo de compilación. Polimorfismo en tiempo de ejecución (Polimorfismo dinámico)\nSe logra a través de la sobrescritura de métodos. Se resuelve en tiempo de ejecución. Python admite principalmente el polimorfismo en tiempo de ejecución, ya que es un lenguaje de tipado dinámico. Sin embargo, podemos demostrar conceptos similares al polimorfismo en tiempo de compilación también.\nExploremos diferentes aspectos del polimorfismo en Python:\nDuck typing # Python utiliza el duck typing, que es una forma de polimorfismo. La idea es: \u0026ldquo;Si camina como un pato y grazna como un pato, entonces debe ser un pato\u0026rdquo;. En otras palabras, Python se preocupa más por los métodos que tiene un objeto que por el tipo del objeto en sí.\nclass Pato: def hablar(self): return \u0026#34;¡Cuac cuac!\u0026#34; class Perro: def hablar(self): return \u0026#34;¡Guau guau!\u0026#34; class Gato: def hablar(self): return \u0026#34;¡Miau miau!\u0026#34; def sonido_animal(animal): return animal.hablar() # Uso pato = Pato() perro = Perro() gato = Gato() print(sonido_animal(pato)) # Salida: ¡Cuac cuac! print(sonido_animal(perro)) # Salida: ¡Guau guau! print(sonido_animal(gato)) # Salida: ¡Miau miau! En este ejemplo, sonido_animal() funciona con cualquier objeto que tenga un método hablar(), independientemente de su clase.\nSobrescritura de métodos # La sobrescritura de métodos es un aspecto clave del polimorfismo en tiempo de ejecución. Ocurre cuando una clase derivada define un método con el mismo nombre que un método en su clase base.\nclass Figura: def area(self): pass class Rectangulo(Figura): def __init__(self, ancho, alto): self.ancho = ancho self.alto = alto def area(self): return self.ancho * self.alto class Circulo(Figura): def __init__(self, radio): self.radio = radio def area(self): return 3.14159 * self.radio ** 2 # Uso figuras = [Rectangulo(5, 4), Circulo(3)] for figura in figuras: print(f\u0026#34;Área: {figura.area()}\u0026#34;) # Salida: # Área: 20 # Área: 28.27431 Aquí, Rectangulo y Circulo sobrescriben el método area() de la clase Figura.\nSobrecarga de operadores # Python permite la sobrecarga de operadores, que es una forma de polimorfismo en tiempo de compilación. Permite que el mismo operador tenga diferentes significados según los operandos.\nclass Vector: def __init__(self, x, y): self.x = x self.y = y def __add__(self, otro): return Vector(self.x + otro.x, self.y + otro.y) def __str__(self): return f\u0026#34;Vector({self.x}, {self.y})\u0026#34; # Uso v1 = Vector(2, 3) v2 = Vector(3, 4) v3 = v1 + v2 print(v3) # Salida: Vector(5, 7) Aquí, hemos sobrecargado el operador + para nuestra clase Vector.\nClases base abstractas # El módulo abc de Python proporciona infraestructura para definir clases base abstractas, que son una forma poderosa de definir interfaces en Python.\nfrom abc import ABC, abstractmethod class Animal(ABC): @abstractmethod def hacer_sonido(self): pass class Perro(Animal): def hacer_sonido(self): return \u0026#34;¡Guau!\u0026#34; class Gato(Animal): def hacer_sonido(self): return \u0026#34;¡Miau!\u0026#34; # Uso def sonido_animal(animal): return animal.hacer_sonido() perro = Perro() gato = Gato() print(sonido_animal(perro)) # Salida: ¡Guau! print(sonido_animal(gato)) # Salida: ¡Miau! # Esto generará un TypeError # animal = Animal() Las clases base abstractas no pueden ser instanciadas y obligan a las clases derivadas a implementar ciertos métodos, asegurando una interfaz consistente.\nAplicaciones en el mundo real # El polimorfismo se utiliza ampliamente en aplicaciones del mundo real:\nFrameworks de GUI: Diferentes widgets (botones, cajas de texto) pueden responder a eventos comunes (clic, hover) de sus propias maneras. Interfaces de bases de datos: Diferentes sistemas de bases de datos pueden implementar una interfaz común para consultas, permitiendo que las aplicaciones trabajen con varias bases de datos sin cambiar el código. Sistemas de plugins: Las aplicaciones pueden trabajar con plugins a través de una interfaz común, independientemente de la implementación específica de cada plugin. Desarrollo de juegos: Diferentes entidades del juego pueden compartir comportamientos comunes (mover, colisionar) pero implementarlos de manera diferente. Aquí hay un ejemplo simple de un sistema de plugins:\nclass Plugin(ABC): @abstractmethod def procesar(self, datos): pass class PluginMayusculas(Plugin): def procesar(self, datos): return datos.upper() class PluginInvertir(Plugin): def procesar(self, datos): return datos[::-1] class Aplicacion: def __init__(self): self.plugins = [] def agregar_plugin(self, plugin): self.plugins.append(plugin) def procesar_datos(self, datos): for plugin in self.plugins: datos = plugin.procesar(datos) return datos # Uso app = Aplicacion() app.agregar_plugin(PluginMayusculas()) app.agregar_plugin(PluginInvertir()) resultado = app.procesar_datos(\u0026#34;Hola, Mundo!\u0026#34;) print(resultado) # Salida: !ODNUM ,ALOH Este ejemplo demuestra cómo el polimorfismo permite que la clase Aplicacion trabaje con diferentes plugins a través de una interfaz común.\nReferencias # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ ¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/programming/oop/the-four-pillars-polymorphism/","section":"Programación","summary":"","title":"Los Cuatro Pilares: Polimorfismo","type":"programming"},{"content":"Los aspectos clave de la abstracción incluyen:\nSimplificación: La abstracción reduce la complejidad ocultando detalles innecesarios. Enfoque en características esenciales: Enfatiza lo que hace un objeto en lugar de cómo lo hace. Separación de preocupaciones: Permite separar la interfaz de una clase de su implementación. Modularidad: La abstracción promueve el diseño modular al definir límites claros entre componentes. Clases abstractas e interfaces # En muchos lenguajes orientados a objetos, la abstracción se implementa a través de clases abstractas e interfaces. Aunque Python no tiene un concepto integrado de interfaz, podemos lograr una funcionalidad similar usando clases base abstractas. El módulo abc de Python proporciona infraestructura para definir clases base abstractas:\nfrom abc import ABC, abstractmethod class Figura(ABC): @abstractmethod def area(self): pass @abstractmethod def perimetro(self): pass class Rectangulo(Figura): def __init__(self, ancho, alto): self.ancho = ancho self.alto = alto def area(self): return self.ancho * self.alto def perimetro(self): return 2 * (self.ancho + self.alto) class Circulo(Figura): def __init__(self, radio): self.radio = radio def area(self): return 3.14159 * self.radio ** 2 def perimetro(self): return 2 * 3.14159 * self.radio # Uso # figuras = [Figura()] # Esto generaría TypeError figuras = [Rectangulo(5, 4), Circulo(3)] for figura in figuras: print(f\u0026#34;Área: {figura.area()}, Perímetro: {figura.perimetro()}\u0026#34;) # Salida: # Área: 20, Perímetro: 18 # Área: 28.27431, Perímetro: 18.84954 En este ejemplo:\nFigura es una clase base abstracta que define la interfaz para todas las figuras. Rectangulo y Circulo son clases concretas que implementan la interfaz Figura. No podemos instanciar Figura directamente, pero podemos usarla como un tipo común para todas las figuras. Implementando abstracción en Python # Aunque Python proporciona clases base abstractas para definir interfaces formalmente, también podemos lograr la abstracción mediante convenciones y documentación. Veamos un ejemplo sin utilizar ABC:\nclass BaseDeDatos: def conectar(self): raise NotImplementedError(\u0026#34;La subclase debe implementar este método abstracto\u0026#34;) def ejecutar(self, consulta): raise NotImplementedError(\u0026#34;La subclase debe implementar este método abstracto\u0026#34;) class BaseDeDatosMySQL(BaseDeDatos): def conectar(self): print(\u0026#34;Conectando a la base de datos MySQL...\u0026#34;) def ejecutar(self, consulta): print(f\u0026#34;Ejecutando consulta MySQL: {consulta}\u0026#34;) class BaseDeDatosPostgreSQL(BaseDeDatos): def conectar(self): print(\u0026#34;Conectando a la base de datos PostgreSQL...\u0026#34;) def ejecutar(self, consulta): print(f\u0026#34;Ejecutando consulta PostgreSQL: {consulta}\u0026#34;) def realizar_operacion_en_bd(base_de_datos): base_de_datos.conectar() base_de_datos.ejecutar(\u0026#34;SELECT * FROM usuarios\u0026#34;) # Uso bd_mysql = BaseDeDatosMySQL() bd_postgres = BaseDeDatosPostgreSQL() realizar_operacion_en_bd(bd_mysql) realizar_operacion_en_bd(bd_postgres) # Salida: # Conectando a la base de datos MySQL... # Ejecutando consulta MySQL: SELECT * FROM usuarios # Conectando a la base de datos PostgreSQL... # Ejecutando consulta PostgreSQL: SELECT * FROM usuarios En este ejemplo:\nBaseDeDatos es una clase base abstracta (aunque no usa ABC) que define la interfaz para todos los tipos de bases de datos. BaseDeDatosMySQL y BaseDeDatosPostgreSQL son implementaciones concretas. realizar_operacion_en_bd trabaja con cualquier objeto que cumpla con la interfaz de BaseDeDatos. Principios de diseño y patrones # La abstracción es un componente clave de varios principios y patrones de diseño importantes:\nPrincipios SOLID:\nPrincipio de Responsabilidad Única (SRP). Principio de Abierto/Cerrado (OCP). Principio de Sustitución de Liskov (LSP). Principio de Segregación de Interfaces (ISP). Principio de Inversión de Dependencias (DIP). Patrones de Diseño:\nPatrón método de fábrica. Patrón fábrica abstracta. Patrón estrategia. Patrón método plantilla. Veamos una implementación del patrón estrategia:\nfrom abc import ABC, abstractmethod class EstrategiaOrdenamiento(ABC): @abstractmethod def ordenar(self, datos): pass class OrdenamientoBurbuja(EstrategiaOrdenamiento): def ordenar(self, datos): print(\u0026#34;Realizando ordenamiento de burbuja\u0026#34;) return sorted(datos) # Usamos sorted() de Python por simplicidad class OrdenamientoRapido(EstrategiaOrdenamiento): def ordenar(self, datos): print(\u0026#34;Realizando ordenamiento rápido\u0026#34;) return sorted(datos) # Usamos sorted() de Python por simplicidad class Ordenador: def __init__(self, estrategia): self.estrategia = estrategia def ordenar(self, datos): return self.estrategia.ordenar(datos) # Uso datos = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] ordenador_burbuja = Ordenador(OrdenamientoBurbuja()) print(ordenador_burbuja.ordenar(datos)) ordenador_rapido = Ordenador(OrdenamientoRapido()) print(ordenador_rapido.ordenar(datos)) # Salida: # Realizando ordenamiento de burbuja # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Realizando ordenamiento rápido # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] Este ejemplo del Patrón Estrategia muestra cómo la abstracción nos permite definir una familia de algoritmos, encapsular cada uno y hacerlos intercambiables. La clase Ordenador no necesita conocer los detalles de cómo funciona cada algoritmo de ordenamiento; solo sabe que puede llamar al método ordenar en cualquier objeto EstrategiaOrdenamiento.\nReferencias # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ ¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/programming/oop/the-four-pillars-abstraction/","section":"Programación","summary":"","title":"Los Cuatro Pilares: Abstracción","type":"programming"},{"content":"","date":"05 agosto 2025","externalUrl":null,"permalink":"/authors/","section":"Autores","summary":"","title":"Autores","type":"authors"},{"content":" Ultimas noticias y tutoriales sobre programación, ingeniería de software, DevOps, y ¡mucho más! ","date":"05 agosto 2025","externalUrl":null,"permalink":"/blog/","section":"Blog","summary":"","title":"Blog","type":"blog"},{"content":"","date":"05 agosto 2025","externalUrl":null,"permalink":"/tags/","section":"Etiquetas","summary":"","title":"Etiquetas","type":"tags"},{"content":"","date":"05 agosto 2025","externalUrl":null,"permalink":"/authors/jnonino/","section":"Autores","summary":"","title":"Julián Nonino","type":"authors"},{"content":"","date":"05 agosto 2025","externalUrl":null,"permalink":"/tags/kubernetes/","section":"Etiquetas","summary":"","title":"Kubernetes","type":"tags"},{"content":" Luego de desplegar una aplicación en Kubernetes, independientemente del método elegido para ello, si queremos que sea alcanzable por otras aplicaciones necesitamos crear un servicio. En este artículo vamos a explicar que es un servicio, como se utilizan y a repasar los cuatro tipos de servicios que están disponibles en Kubernetes, ClusterIP, NodePort, LoadBalancer y ExternalName, revisaremos sus detalles y cuando se debe utilizar cada uno. Al desplegar una aplicación en Kubernetes utilizando un objeto del tipo Deployment, los pods pertenecientes a dicho Deployment pueden ser creados y destruidos en cualquier momento en base a su funcionamiento, por ejemplo si en nuestro Deployment pedimos que existan 3 réplicas y por cualquier razón alguna de ellas deja de funcionar, una nueva réplica será creada automáticamente para reemplazar a la que falló.\nCada pod tiene su propia dirección IP dentro del cluster. En general, las demás aplicaciones que necesitan interactuar con nuestra aplicación desconocen el nombre de cada una de sus replicas, su estado y su dirección IP para iniciar una comunicación. Kubernetes nos provee el objeto Service como una forma nativa de Service Discovery sin que necesitemos hacer cambios en nuestra aplicación o en las que necesitan comunicarse con ella. Entonces, el fin para el cual creamos un servicio es para exponer una aplicación que puede estar constituida por múltiples pods a traves de un único punto de acceso. De esta manera otras aplicación contactaran al Service y este redirigirá la comunicación a alguno de los pods de nuestra aplicación.\nPods detrás de un servicio en Kubernetes Creando un servicio # Un Service puede crearse mediante una declaración en un archivo .yaml al igual que otros objetos de Kubernetes. Por ejemplo:\napiVersion: v1 kind: Service metadata: name: servicio-de-prueba spec: type: ClusterIP selector: app_name: mi-aplicacion ports: - protocol: TCP port: 8080 targetPort: 1234 En dicho ejemplo, estaremos creando un servicio llamado my-service del tipo ClusterIP que redirige las comunicaciones que llegan al puerto 8080 hacia el puerto 1234 de cualquier Pod que tenga la etiqueta app-name: my-app.\nEl nombre del servicio debe ser una etiqueta válida bajo las reglas de RFC 1035 Como se ve en el archivo, el campo ports es del tipo array, lo que significa que pueden mapearse múltiples puertos.\nCada definición de un puerto debe contener los siguientes campos:\nport: es el puerto en el que el servicio estará accesible dentro del cluster. No puede omitirse. targetPort: es un valor opcional, indica el puerto en el cual el pod estará recibiendo las comunicaciones. Si se omite, se asume que es el mismo valor que el indicado en el campo port. Puede ser un número o el nombre del puerto si es que en el pod se especificaron nombres. Se recomienda utilizarlo sólo cuando difiere del valor de port. protocol: establece el protocolo utilizado para las comunicaciones, los valores válidos son: SCTP, TCP y UDP. En caso de no indicarse explícitamente, el valor por defecto es TCP. name: permite darle un nombre al puerto. Es útil para referenciar por DNS o en situaciones donde hay múltiples puertos en un mismo servicio. Es un valor opcional, pero dentro de un mismo servicio, cada puerto debe tener un nombre único. Tipos de servicios # Como se muestra en la sección anterior, el tipo de servicio se especifica mediante el valor spec.type:\napiVersion: v1 kind: Service metadata: name: servicio-de-prueba spec: ... type: \u0026lt;TIPO_DE_SERVICIO\u0026gt; ... A continuación veremos cada uno de ellos.\nClusterIP # Es el tipo de servicio por defecto. Kubernetes asigna una dirección IP al servicio que las demás aplicaciones pueden utilizar para comunicarse. La dirección asignada proviene de un grupo de direcciones reservadas para este fin mediante el valor service-cluster-ip-range en el servidor de API de Kubernetes.\nCuando se crea un servicio del tipo ClusterIP el servicio no es accesible desde el exterior y los pods detrás de este servicio solo pueden ser contactados por otros pods del mismo cluster. Si se desea exponer el servicio al exterior se debe utilizar un objeto del tipo Ingress.\nEsquema de un servicio del tipo ClusterIP NodePort # En este caso, Kubernetes asigna al servicio un puerto del rango definido en la configuración service-node-port-range, usualmente entre los puertos 30000 y 32767. Luego, cada nodo abre dicho puerto para las comunicaciones hacia el servicio.\nEste tipo de servicio, permite un rápido acceso desde el exterior sin necesidad de infraestructura adicional, pero no contempla un mecanismo de balance de carga (load balancing), lo que puede provocar la saturación de alguno de ellos. Por otro lado, en un sistema donde existan múltiples servicios, la gestión de puertos puede volverse demasiado compleja.\nEsquema de un servicio del tipo NodePort LoadBalancer # En proveedores de servicios en la nube que soporten load balancers como Amazon Web Services, Google Cloud Platform o Microsoft Azure, crear un servicio de este tipo dispara la creación de un load balancer externo en la platform de nube utilizada. La creación ocurre de manera asíncrona e información sobre su estado es publicada en el estado del servicio (.status.loadbalancer).\nEl proveedor de servicios en la nube decide como se balancea la carga.\nLa gran ventaja de este tipo de servicio es que mediante el uso de servicios en la nube se obtiene un balanceo de carga automático y de alta disponibilidad. La desventaja es que puede generar costos adicionales.\nEsquema de un servicio del tipo LoadBalancer ExternalName # Este tipo de servicio redirecciona el tráfico a un nombre de DNS en lugar de a un conjunto de pods. El DNS al cual se apunta, se indica mediante el campo .spec.externalName\nPor ejemplo, redirige las comunicaciones hacia la dirección learn-software.com.\napiVersion: v1 kind: Service metadata: name: mi-servicio spec: type: ExternalName externalName: learn-software.com Esquema de un servicio del tipo ExternalName Headless Services # Existen casos en los que, por ejemplo, es necesario utilizar otros mecanismos de Service Discovery o en los que necesitemos conocer las direcciones IP de todos aquellos pods que podríamos contactar. Para ello existen los headless services. Se crean indicando el valor None en el campo .spec.clusterIP.\nUn headless service no tiene asignada una dirección IP única del cluster. Retorna directamente las direcciones IPs de pods en una respuesta DNS. Esto es útil para descubrimiento de servicios personalizados, bases de datos distribuidas o control detallado del balanceo. La desventaja es que el cliente del servicio debe ser capaz de resolver y gestionar por sí mismo una respuesta DNS conteniendo múltiples direcciones.\nEsquema de un Headless Service Referencias # Puedes leer más sobre el tema en la documentación oficial de Kubernetes ","date":"05 agosto 2025","externalUrl":null,"permalink":"/blog/k8s-services/","section":"Blog","summary":"","title":"Kubernetes Services","type":"blog"},{"content":"","date":"05 agosto 2025","externalUrl":null,"permalink":"/","section":"Learn-Software.com","summary":"","title":"Learn-Software.com","type":"page"},{"content":"","date":"05 agosto 2025","externalUrl":null,"permalink":"/tags/service-discovery/","section":"Etiquetas","summary":"","title":"Service Discovery","type":"tags"},{"content":"","date":"05 agosto 2025","externalUrl":null,"permalink":"/tags/services/","section":"Etiquetas","summary":"","title":"Services","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/en/series/data-structures/","section":"Series","summary":"","title":"Data Structures","type":"series"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/en/tags/data-structures/","section":"Tags","summary":"","title":"Data Structures","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/series/estructuras-de-datos/","section":"Series","summary":"","title":"Estructuras De Datos","type":"series"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/tags/estructuras-de-datos/","section":"Etiquetas","summary":"","title":"Estructuras De Datos","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/en/series/object-oriented-programming/","section":"Series","summary":"","title":"Object-Oriented Programming","type":"series"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/en/tags/object-oriented-programming/","section":"Tags","summary":"","title":"Object-Oriented Programming","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/programming/","section":"Programación","summary":"","title":"Programación","type":"programming"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/tags/programaci%C3%B3n/","section":"Etiquetas","summary":"","title":"Programación","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/series/programaci%C3%B3n-orientada-a-objetos/","section":"Series","summary":"","title":"Programación Orientada a Objetos","type":"series"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/tags/programaci%C3%B3n-orientada-a-objetos/","section":"Etiquetas","summary":"","title":"Programación Orientada a Objetos","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/en/tags/programming/","section":"Tags","summary":"","title":"Programming","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"03 agosto 2025","externalUrl":null,"permalink":"/series/introducci%C3%B3n-a-la-programaci%C3%B3n/","section":"Series","summary":"","title":"Introducción a La Programación","type":"series"},{"content":"","date":"03 agosto 2025","externalUrl":null,"permalink":"/en/series/introduction-to-programming/","section":"Series","summary":"","title":"Introduction to Programming","type":"series"},{"content":" Domina la ingeniería de IA a través de proyectos prácticos que desarrollan habilidades para el mundo real, con cada concepto introducido exactamente cuando lo necesitas. Este enfoque centrado en proyectos te ayuda a crear un portafolio impresionante mientras desarrollas la experiencia profunda necesaria para tener éxito como ingeniero profesional de IA. ¡El primer modulo será publicado muy pronto! ¡Mantente conectado para enterarte! ","date":"20 julio 2025","externalUrl":null,"permalink":"/artificial-intelligence/","section":"Inteligencia Artificial","summary":"","title":"Inteligencia Artificial","type":"artificial-intelligence"},{"content":"","date":"07 diciembre 2024","externalUrl":null,"permalink":"/en/tags/class-relations/","section":"Tags","summary":"","title":"Class Relations","type":"tags"},{"content":"","date":"07 diciembre 2024","externalUrl":null,"permalink":"/tags/los-cuatro-pilares/","section":"Etiquetas","summary":"","title":"Los Cuatro Pilares","type":"tags"},{"content":"","date":"07 diciembre 2024","externalUrl":null,"permalink":"/tags/oop/","section":"Etiquetas","summary":"","title":"OOP","type":"tags"},{"content":"","date":"07 diciembre 2024","externalUrl":null,"permalink":"/en/tags/the-four-pillars/","section":"Tags","summary":"","title":"The Four Pillars","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/tags/abstracci%C3%B3n/","section":"Etiquetas","summary":"","title":"Abstracción","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/abstraction/","section":"Tags","summary":"","title":"Abstraction","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/aggregation/","section":"Tags","summary":"","title":"Aggregation","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/association/","section":"Tags","summary":"","title":"Association","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/composition/","section":"Tags","summary":"","title":"Composition","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/dependency/","section":"Tags","summary":"","title":"Dependency","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/tags/encapsulamiento/","section":"Etiquetas","summary":"","title":"Encapsulamiento","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/encapsulation/","section":"Tags","summary":"","title":"Encapsulation","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/tags/herencia/","section":"Etiquetas","summary":"","title":"Herencia","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/implementation/","section":"Tags","summary":"","title":"Implementation","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/inheritance/","section":"Tags","summary":"","title":"Inheritance","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/tags/polimorfismo/","section":"Etiquetas","summary":"","title":"Polimorfismo","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/polymorphism/","section":"Tags","summary":"","title":"Polymorphism","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/realisation/","section":"Tags","summary":"","title":"Realisation","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/tags/colas/","section":"Etiquetas","summary":"","title":"Colas","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/en/tags/linked-lists/","section":"Tags","summary":"","title":"Linked Lists","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/tags/listas/","section":"Etiquetas","summary":"","title":"Listas","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/tags/listas-enlazadas/","section":"Etiquetas","summary":"","title":"Listas Enlazadas","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/en/tags/lists/","section":"Tags","summary":"","title":"Lists","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/en/tags/queues/","section":"Tags","summary":"","title":"Queues","type":"tags"},{"content":"","date":"02 noviembre 2023","externalUrl":null,"permalink":"/tags/pilas/","section":"Etiquetas","summary":"","title":"Pilas","type":"tags"},{"content":"","date":"02 noviembre 2023","externalUrl":null,"permalink":"/en/tags/stacks/","section":"Tags","summary":"","title":"Stacks","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/en/tags/arrays/","section":"Tags","summary":"","title":"Arrays","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/tags/arreglos/","section":"Etiquetas","summary":"","title":"Arreglos","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/tags/diccionarios/","section":"Etiquetas","summary":"","title":"Diccionarios","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/en/tags/dictionaries/","section":"Tags","summary":"","title":"Dictionaries","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/tags/mapas/","section":"Etiquetas","summary":"","title":"Mapas","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/en/tags/maps/","section":"Tags","summary":"","title":"Maps","type":"tags"},{"content":"","date":"02 octubre 2023","externalUrl":null,"permalink":"/tags/clases/","section":"Etiquetas","summary":"","title":"Clases","type":"tags"},{"content":"","date":"02 octubre 2023","externalUrl":null,"permalink":"/en/tags/classes/","section":"Tags","summary":"","title":"Classes","type":"tags"},{"content":"","date":"02 octubre 2023","externalUrl":null,"permalink":"/en/tags/objects/","section":"Tags","summary":"","title":"Objects","type":"tags"},{"content":"","date":"02 octubre 2023","externalUrl":null,"permalink":"/tags/objetos/","section":"Etiquetas","summary":"","title":"Objetos","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/tags/conceptos-iniciales/","section":"Etiquetas","summary":"","title":"Conceptos Iniciales","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/series/conceptos-iniciales-de-programaci%C3%B3n/","section":"Series","summary":"","title":"Conceptos Iniciales De Programación","type":"series"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/tags/funciones/","section":"Etiquetas","summary":"","title":"Funciones","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/en/tags/functions/","section":"Tags","summary":"","title":"Functions","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/en/tags/methods/","section":"Tags","summary":"","title":"Methods","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/tags/m%C3%A9todos/","section":"Etiquetas","summary":"","title":"Métodos","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/en/series/programming-starting-concepts/","section":"Series","summary":"","title":"Programming Starting Concepts","type":"series"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/en/tags/recursion/","section":"Tags","summary":"","title":"Recursion","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/tags/recursi%C3%B3n/","section":"Etiquetas","summary":"","title":"Recursión","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/en/tags/starting-concepts/","section":"Tags","summary":"","title":"Starting Concepts","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/en/tags/boolean-logic/","section":"Tags","summary":"","title":"Boolean Logic","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/tags/bucles/","section":"Etiquetas","summary":"","title":"Bucles","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/tags/condicionales/","section":"Etiquetas","summary":"","title":"Condicionales","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/en/tags/conditionals/","section":"Tags","summary":"","title":"Conditionals","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/tags/control-de-flujo/","section":"Etiquetas","summary":"","title":"Control De Flujo","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/en/tags/flow-control/","section":"Tags","summary":"","title":"Flow Control","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/tags/l%C3%B3gica-booleana/","section":"Etiquetas","summary":"","title":"Lógica Booleana","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/en/tags/loops/","section":"Tags","summary":"","title":"Loops","type":"tags"},{"content":"","date":"19 septiembre 2023","externalUrl":null,"permalink":"/tags/entrada/salida/","section":"Etiquetas","summary":"","title":"Entrada/Salida","type":"tags"},{"content":"","date":"19 septiembre 2023","externalUrl":null,"permalink":"/tags/i/o/","section":"Etiquetas","summary":"","title":"I/O","type":"tags"},{"content":"","date":"19 septiembre 2023","externalUrl":null,"permalink":"/en/tags/input/output/","section":"Tags","summary":"","title":"Input/Output","type":"tags"},{"content":"","date":"18 septiembre 2023","externalUrl":null,"permalink":"/en/tags/data-types/","section":"Tags","summary":"","title":"Data Types","type":"tags"},{"content":"","date":"18 septiembre 2023","externalUrl":null,"permalink":"/tags/tipos-de-datos/","section":"Etiquetas","summary":"","title":"Tipos De Datos","type":"tags"},{"content":"","date":"18 septiembre 2023","externalUrl":null,"permalink":"/tags/variables/","section":"Etiquetas","summary":"","title":"Variables","type":"tags"},{"content":"","date":"10 septiembre 2023","externalUrl":null,"permalink":"/tags/herramientas/","section":"Etiquetas","summary":"","title":"Herramientas","type":"tags"},{"content":"","date":"10 septiembre 2023","externalUrl":null,"permalink":"/tags/ide/","section":"Etiquetas","summary":"","title":"IDE","type":"tags"},{"content":"","date":"10 septiembre 2023","externalUrl":null,"permalink":"/tags/python/","section":"Etiquetas","summary":"","title":"Python","type":"tags"},{"content":"","date":"10 septiembre 2023","externalUrl":null,"permalink":"/en/tags/tools/","section":"Tags","summary":"","title":"Tools","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/tags/binario/","section":"Etiquetas","summary":"","title":"Binario","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/en/tags/binary/","section":"Tags","summary":"","title":"Binary","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/tags/decimal/","section":"Etiquetas","summary":"","title":"Decimal","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/tags/hexadecimal/","section":"Etiquetas","summary":"","title":"Hexadecimal","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/en/tags/numeral-systems/","section":"Tags","summary":"","title":"Numeral Systems","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/tags/sistemas-de-numeraci%C3%B3n/","section":"Etiquetas","summary":"","title":"Sistemas De Numeración","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/tags/cd/","section":"Tags","summary":"","title":"CD","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/tags/computadoras/","section":"Etiquetas","summary":"","title":"Computadoras","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/tags/computers/","section":"Tags","summary":"","title":"Computers","type":"tags"},{"content":"Continuous Delivery (CD) is deeply rooted in the first principle of the Agile Manifesto posted in 20011:\nOur highest priority is to satisfy the customer through early and continuous delivery of valuable software.\nAccording to Martin Fowler2, a project is truly embracing Continuous Delivery when:\nThe software can be deployed at any stage of its lifecycle. The team values keeping the software deployment-ready over adding new features. Any software version can be deployed to any environment on-demand. In many ways, Continuous Delivery is the next step from Continuous Integration, seamlessly automating processes all the way to the software\u0026rsquo;s end user.\nMuch like in Continuous Integration, the pipeline stands as the cornerstone of Continuous Delivery. However, it\u0026rsquo;s not just about integrating code, testing it, and generating a deliverable artifact. With CD, this artifact progresses through a series of test phases in environments that increasingly resemble production settings. After passing through the Continuous Integration pipeline, what emerges is a potentially deployable artifact. CD then takes this artifact and puts it through the necessary tests, ensuring it\u0026rsquo;s primed for a live deployment.\nThe delivery process # The following figure illustrates the fundamental steps of a Continuous Delivery (CD) process. It\u0026rsquo;s vital to note that an effective CD process presupposes a well-oiled Continuous Integration (CI) system as its foundation.\nFigure 1: CD process flowchart The CD process adds two distinct phases to the CI system: deployment stages and system validation and verification testing. A critical premise is that the deployment process is paramount to product delivery. Thus, automating and frequently testing it is essential. Ideally, testing should also be automated to facilitate execution, especially if you aim for Continuous Deployment. However, it\u0026rsquo;s not imperative to automate all tests, especially at the beginning of the CD process implementation.\nUpon creating a potentially deliverable artifact in the CI pipeline, the initial step is to deploy it in a testing or QA environment. The primary goal of this environment is to offer a space where software tests, both automatic and manual, can be run. The only possible variations between the QA and actual production environment (the one used by customers) may pertain to its capacity or resource size. This scaled-down capacity, whether in processing, memory, storage, or database size, is typically a cost-saving measure.\nIf system and acceptance tests are successful in the QA environment, the next phase is to deploy the artifact in a staging environment. This environment should be an exact replica of the production setting. Its purpose is to facilitate performance and load testing on the system, effectively putting it under stress to validate its functionality under high loads and assess its processing and response times.\nWhen the previous tests are satisfactory, the artifact is ready to be deployed in a production environment. This space is also referred to as the live environment, where users interact with the system.\nAs evident, the product deployment method is exercised at least twice before the final production deployment, considerably reducing risks associated with potential errors as the final delivery approaches.\nCore principles and practices # One of CD\u0026rsquo;s primary objectives is to boost delivery frequency. This naturally means that each release should minimize its size. A smaller delivery not only implies fewer potential errors but also facilitates their identification and resolution2. To achieve this, the code must always be in a deploy-ready state.\nRapid automated testing is crucial for today\u0026rsquo;s software development3. In the context of CD, automated tests are of utmost importance as they must ensure comprehensive system quality without hampering the delivery cycle\u0026rsquo;s speed4. Lengthy test runs force the team to await results, leading to wasted time3. If these tests aren\u0026rsquo;t parallelized and optimized, developers may start sidelining them5. To ensure test optimization, it\u0026rsquo;s recommended to fail tests that exceed a reasonable limit6.\nThe software should always be potentially deliverable. It\u0026rsquo;s essential for the software\u0026rsquo;s build status to remain \u0026lsquo;green\u0026rsquo; consistently. This means if a new repository commit breaks the build, this error must be rectified before any new commit is made. Adhering to this practice simplifies error tracing, while deviating may condition developers to overlook a broken or \u0026lsquo;red\u0026rsquo; build6. Broken builds signify product flaws and render it undeliverable.\nIn using CD, the aim is to ensure each commit results in a production-ready artifact. If this artifact is rebuilt at every process stage, there\u0026rsquo;s no guarantee of their identical nature, and validation and verification test results from one artifact cannot be applied to others. This could lead to deploying untested artifacts6. Hence, artifacts should be produced only once and undergo all tests on that single artifact before deploying that very software piece to production.\nSoftware should always be deployed identically across all environments. Otherwise, there\u0026rsquo;s no assurance of the deployment process\u0026rsquo;s efficacy. If environment differences exist, they should be managed using configuration files, but the deployment process should remain consistent6.\nDeployment should be achievable with a mere button press. The ability to deploy the latest product version anytime with a single button press is a robust indicator of CD implementation2. This not only requires the aforementioned steps but also mandates version-controlled software deployment scripts that are regularly checked and validated6.\nAs mentioned earlier, CD\u0026rsquo;s main objective is to ascertain the product\u0026rsquo;s readiness post each commit2. For this, aside from ensuring a swift compilation and testing process, process outcomes should be visible and shared with the team. Display screens showcasing the current status, build times, test coverage, and more, offer a way to maintain constant visibility6. Presenting these results not only supports CD but, as some authors suggest, also bolsters team motivation4.\nBenefits of Continuous Delivery # With the rise of Continuous Delivery (CD) practices, businesses are realizing numerous advantages:\nSwift value delivery: the adoption of CD practices facilitates a faster rollout of features and error rectifications to end users7. This speed is attributed to the code becoming potentially deployable to users as it traverses through the Continuous Integration (CI) pipeline4.\nDiminished delivery failures: frequent releases lead to fewer delivery risks since each release embodies fewer changes. This, in turn, means there\u0026rsquo;s a reduced margin for errors2. Even if an error emerges, its origin is easier to trace and correct. Plus, reverting to a previous version in the face of complications becomes straightforward8. A delightful by-product of this streamlined process is the diminished stress levels amongst stakeholders7 5. Furthermore, the consistency and quality in the delivery process cement trust between the development team and clients7.\nProductivity amplification: Chen\u0026rsquo;s study reveals that, in the absence of CD practices, teams spent nearly \\(20%\\) of their time setting up and maintaining environments7. The introduction of CD automates this ordeal, which translates to heightened productivity by phasing out manual, non-value-add tasks6.\nPrompt feedback: a consensus among experts highlights the value of early feedback during the development phase2 7 4. Regular releases not only fetch this feedback promptly but also ensure that the developed product aligns seamlessly with customer requirements2. The agility to swiftly address customer needs, fix reported bugs, and introduce demanded features can significantly elevate customer satisfaction4.\nEnhanced software quality: the rigorous automation of software tests (unit, integration, and system), essential for implementing CD, combined with more frequent software deliveries encapsulating fewer changes, culminates in a notable boost in software quality4.\nTransparency in progress: thanks to frequent releases, clients find it easier to stay abreast of the latest product updates, embracing novel features and bug fixes with open arms.\nChallenges in adopting Continuous Delivery # The journey to incorporate Continuous Delivery (CD) isn’t without its hurdles. Here\u0026rsquo;s a look at some of the key challenges faced by businesses:\nProduct complexity: certain products consist of myriad interconnected modules or possess dependencies with other projects. This can create bottlenecks when automating CD pipelines4. Such complexities might frustrate teams, pushing them to retain manual processes or longer integration procedures.\nTest suite creation: crafting a comprehensive test suite to ensure product quality is labour-intensive. All team members must allocate significant time to pen tests, which might require extra training. Besides, tests can be time-consuming, so the trick lies in devising effective yet swift tests4.\nLegacy code: systems that have been in development for an extended period and weren\u0026rsquo;t designed with automated testing in mind can pose a significant challenge. Transitioning such systems to CD is not only a technical endeavour but also a social and cultural shift4.\nEnvironmental discrepancies: all environments in the CI pipeline should mirror the production setting (\u0026lsquo;production-like\u0026rsquo;)6. If not, unforeseen errors can arise, demanding valuable time on non-value-add tasks4. Ensuring multiple deployment stages in similar environments means that the deployment process is tested repetitively.\nClient restrictions: not every client might desire or require a shortened product delivery cycle4. Such client limitations aren\u0026rsquo;t direct obstacles to CD implementation but play a pivotal role when aiming for Continuous Deployment. This could potentially sideline some CD benefits, like swift client feedback or minimal change deliveries. Moreover, the domain itself can act as a bottleneck. Software related to heavily-regulated sectors like healthcare and defence may find CD implementation challenging, if not nearly impossible4.\nTransparency and reporting: a successful CD adoption hinges on collaboration and transparency, introducing challenges tied to providing effective status reports to stakeholders9. This encompasses technical hurdles around automated report generation and analytics challenges to pinpoint essential information.\nResistance to change: any transformative change, like adopting CD, faces the innate human trait of resistance. Convincing the team to adapt to new practices and modify their workflow is a task. On a higher level, management might also be hesitant to experiment with fresh processes.\nContinuous Deployment # The notion of Continuous Deployment was popularized by Fitz10. The standout distinction between this method and Continuous Delivery (CD) is that, once the product is deemed ready for release, there\u0026rsquo;s no waiting for manual intervention to launch it into production11 6. If CD is properly executed, the step towards Continuous Deployment should demand no extra efforts from the development perspective8. In essence, the core difference lies in decision-making: with CD, releasing the product to production remains a business decision, whereas with Continuous Deployment, the launch is automated.\nIt\u0026rsquo;s worth noting that when we discuss CD, it inherently includes Continuous Delivery but may or may not encompass Continuous Deployment.\nReferences # ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIBbKWwWQESzQtuMvqa/V0GFc4I5fo/4xYPinLdLeCot/\nBeck, Kent, Mike Beedle, Arie van Bennekum, Alistair Cockburn, Ward Cunningham, Martin Fowler, James Grenning, Jim Highsmith, Andrew Hunt, Ron Jeffries, Jon Kern, Brian Marick, Robert C. Martin, Steve Mellor, Ken Schwaber, Jeff Sutherland, and Dave Thomas. Manifesto for Agile Software Development, 2001.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, Martin. Continuous Delivery, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUdd, Raoul. Adopting Continuous Delivery: A Case Study, 2016.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLeppanen, Marko, Simo Makinen, Max Pagels, Veli-Pekka Eloranta, Juha Itkonen, Mika V. Mantyla, and Tomi Mannisto. The highways and country roads to continuous deployment. IEEE Software, 32(2):64-72, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNeely, Steve, and Steve Stolt. Continuous delivery? Easy! Just change everything (well, maybe it is not that easy). Proceedings - AGILE 2013, pp.121-128, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez, and David Farley. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChen, Lianping. Continuous Delivery: Huge Benefits, but Challenges Too. IEEE Software, 32(2):50-54, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez. Continuous Delivery vs Continuous Deployment, 2010.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOlsson, Helena Holmstrom, Hiva Alahyari, and Jan Bosch. Climbing the \u0026ldquo;Stairway to Heaven\u0026rdquo; \u0026ndash; A Multiple-Case Study Exploring Barriers in the Transition from Agile Development towards Continuous Deployment of Software. 2012 38th Euromicro Conference on Software Engineering and Advanced Applications, pp.392-399, 2012.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFitz, Timothy. Continuous Deployment, 2009.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPulkkinen, Ville. Continuous Deployment of Software. Proceedings of Cloud-Based Software Engineering, pp.46-52, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/blog/continuous-delivery/","section":"Blog","summary":"","title":"Continuous Delivery","type":"blog"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/tags/continuous-delivery/","section":"Tags","summary":"","title":"Continuous Delivery","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/tags/continuous-deployment/","section":"Tags","summary":"","title":"Continuous Deployment","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/tags/cpu/","section":"Etiquetas","summary":"","title":"CPU","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/tags/hardware/","section":"Etiquetas","summary":"","title":"Hardware","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/tags/memoria/","section":"Etiquetas","summary":"","title":"Memoria","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/tags/memory/","section":"Tags","summary":"","title":"Memory","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/tags/software/","section":"Etiquetas","summary":"","title":"Software","type":"tags"},{"content":"","date":"19 agosto 2023","externalUrl":null,"permalink":"/en/tags/ci/","section":"Tags","summary":"","title":"CI","type":"tags"},{"content":"One of the most pivotal challenges in the realm of software development is effectively integrating changes 1. In a small-scale project steered by a single developer, this challenge might appear to be trivial. However, as the magnitude of the project escalates and more individuals join the development fold, the significance of seamless integration becomes paramount.\nHistorically, integration was often an afterthought, relegated to the tail end of the software development process 2. Postponing it to such a late stage not only amplifies the risk of complex, undetected errors but also heightens the tension as delivery dates loom.\nHowever, the paradigm shifted around the turn of the millennium. Continuous Integration (CI) was formally introduced in 2000 by Kent Beck as an intrinsic part of the \u0026lsquo;Extreme Programming\u0026rsquo; methodology 3. CI emphasizes the frequent and early-stage integration of code. By continuously amalgamating new code into the system, developers can gauge its impact promptly. This approach streamlines error detection, enabling developers to tackle issues as they emerge 2. The ability to tie an error to a specific code change reduces error complexity and promotes efficient troubleshooting. Today, CI has become an indispensable practice in software development projects 4.\nMartin Fowler, a luminary in the field, eloquently defined CI as:\nContinuous Integration is a software development practice where team members integrate their work frequently, typically multiple times a day. Each integration is verified by an automated build system that runs test suites to swiftly detect any integration anomalies. Teams adopting this methodology often witness a significant reduction in integration hiccups, empowering them to produce cohesive software at an accelerated pace2.\nBuilding upon Fowler’s definition, Duvall 5 underscored several vital facets:\nDevelopers must maintain a conducive local environment for code construction and testing, ensuring their updates do not disrupt the established integration. Team members should commit their code to the Version Control System (VCS) daily. The integration process must be undertaken on a distinct machine, aptly termed the CI server. Only builds that pass all tests can be deemed deliverable. Error resolution is of paramount importance. A central repository displaying build and test results—often a website—is essential. Most CI tools readily offer such platforms. Furthermore, Patrick Cauldwell 6 advocates for frequent and early integration. The rationale? The more regular the integration, the less overhead for the team down the line. He distilled the primary goals of CI into:\nEnsuring a consistently available, tested version of the product with the latest modifications. Keeping the team abreast of any integration issues as early as possible. The impetus behind CI is to maintain an error-free, tested product throughout the development life cycle. This avoids the pitfalls of a last-minute integration phase, which is often fraught with errors and consumes both time and resources. More crucially, if project components aren\u0026rsquo;t integrated during their development, there\u0026rsquo;s no guarantee they\u0026rsquo;ll gel cohesively in the final product 7.\nTechnical implementation of CI revolves around two core components: process automation and a system to showcase results, thereby fuelling the developmental feedback loop 7.\nIn summing up the tenets of CI, Martin Fowler 1 emphasizes:\nRetaining code in a singular repository. Streamlining software construction through automation. Implementing automated testing processes. Ensuring new code additions undergo integration and construction on the CI system\u0026rsquo;s machine. Keeping the build process agile and swift. Providing easy access to the product\u0026rsquo;s latest executable version. Ensuring product status transparency for all stakeholders. Elements of a CI system # A basic Continuous Integration (CI) pipeline initiates when a new code change is pushed to the repository. The CI server, linked to the repository, gets notified of every new change, subsequently downloading the latest version to initiate the integration process, which will be elaborated on in the subsequent section. Once completed, it communicates the system\u0026rsquo;s status to the team members.\nIn computer science, a \u0026ldquo;pipeline\u0026rdquo; refers to a sequence of processes or tasks linked such that the output of one becomes the input for the next.\nFigure 1: Basic elements of CI The system\u0026rsquo;s primary component consists of the developers. After making code modifications, they run tests locally and compile the code to ensure that they haven\u0026rsquo;t introduced new errors.\nAn essential part of every CI system is the Version Control System (VCS). It oversees the changes made to the code and other significant elements. This system establishes a unified access point for all source code, enabling the CI system to fetch the most recent version for integration. Most software development projects utilize a VCS even if they don\u0026rsquo;t implement CI processes.\nThe CI Server is responsible for initiating a new build (comprising both compilation and tests) every time a change is added to the repository. They offer configurations to simplify the creation of integration pipelines. Additionally, most come with a web interface to display the build status and previous results. Currently, numerous powerful options are available, both free and paid. It\u0026rsquo;s worth noting that the CI server should operate on a dedicated machine and not on team members\u0026rsquo; computers.\nThe CI server must automatically conduct software tests, source code analysis, and compile to produce the deliverable product. Therefore, build and test execution scripts are vital. These scripts outline the necessary steps to be executed. Popular tools for this purpose include Make, Ant, Maven, Gradle, among others.\nEvery CI system should have a notification mechanism to relay results to the team. This mechanism ensures that in the event of an error, the team becomes aware as soon as possible, enabling them to address the issue. While most CI tools offer a web interface to view results, they also support other notification methods like emails, messaging applications, etc.\nThe integration process # The figure below broadly illustrates the stages of the integration process taking place within the Continuous Integration (CI) system.\nFigure 2: CI process flowchart Initially, the system must retrieve the latest source code version each time a new change is pushed to the Version Control System (VCS). Two mechanisms facilitate this. The first involves setting up the CI server to periodically check the VCS for updates. The alternative is to establish a commit hook within the VCS, ensuring that the CI server receives notifications whenever changes are made.\nAfter obtaining the code, the CI server can be configured to scrutinize the source code for potential undetected errors, be they syntactic, logical, or patterns that might lead to faults. Various tools aid this process. For instance, Java boasts utilities like FindBugs, CheckStyle, and PMD, while Python has Pylint. JavaScript can be analysed with tools like JSLint or JSHint. An example of a code analysis criterion could be ensuring every developed method has a cyclomatic complexity8 under 10. By employing automated source code inspection, one can assess code correctness, spot duplicate portions, and expedite the time between error detection and rectification. While automated inspection might not catch every error, the results can approximate those of peer reviews, thereby lightening the team\u0026rsquo;s review load.\nThe subsequent step revolves around automated test execution on the product. This automation is paramount to successfully implementing a CI system. Thus, developers can confidently make alterations, knowing a robust testing framework safeguards against compromising existing functionalities. Some popular tools in this domain include Junit, JBehave, and Selenium, which not only facilitate test drafting but also generate comprehensive reports, often as visualizations or web pages. Several software testing levels exist, such as unit tests, integration tests, and system tests. In the CI pipeline context, the focus rests on automating unit and integration tests, with system tests\u0026rsquo; automation being recommended but not mandatory.\nOnce the tests pass, the CI pipeline advances to compiling the source code. During this phase, the source code morphs into one or multiple files or packages, ready for distribution and user execution. This process\u0026rsquo;s specifics hinge on the employed programming language. For instance, languages like Java necessitate code compilation, resulting in an executable. Conversely, languages like Python might involve stricter code structure checks without generating any binary files.\nThroughout this integration journey, the team should steadfastly adhere to three fundamental rules:\nLocally run tests and compile software before integrating it into the VCS to minimize error introduction chances (avoiding \u0026ldquo;breaking the build\u0026rdquo;). Avoid pushing new code to the VCS if the CI server flags errors (indicative of a \u0026ldquo;broken build\u0026rdquo;). Should the CI server report faults, code modifications should exclusively aim at rectifying them. Core principles and practices # Martin Fowler2 identifies a set of foundational elements intrinsic to every Continuous Integration (CI) system. While some of these have been touched upon earlier in this chapter, we will succinctly encapsulate them here for clarity:\nCentralized Code Repository: Retain all code within a singular, unified repository. Streamlined Compilation and Build Process: Entirely automate the compilation and construction workflows, negating manual intervention. Full-Spectrum Automated Testing: Ensure all software tests are automated, driving efficiency and precision. Daily Commitment: Encourage the team to consistently merge their changes to the repository on a daily basis. Stringent Integration Checks: Each alteration made to the Version Control System (VCS) undergoes rigorous integration processes within the CI system. Prompt Error Rectification: Should the CI system flag any issues (indicative of a \u0026ldquo;broken build\u0026rdquo;), immediate action is imperative. Either rectify the flaw or reverse the change to ensure the repository\u0026rsquo;s latest version remains operational. Swift CI Procedures: Aim to complete the CI process rapidly—ideally within 15 minutes or less. This approach ensures timely integration and facilitates the expedited delivery of results. Universal Access to Latest Executables: Always provide the team with access to the most recent executable or deliverable package, promoting transparency. Real-time Product Status Visibility: Grant every team member the ability to monitor the product\u0026rsquo;s status at any given moment, fostering informed decision-making. Benefits # The overarching consensus within the software community is that the implementation of a Continuous Integration (CI) process yields an array of substantial advantages. Duvall5 outlines these core benefits in his publication.\nRisk Mitigation: Adopting frequent integration minimizes project risks. It facilitates early detection of issues and offers a continuous snapshot of the product\u0026rsquo;s health. By identifying these issues early in the development cycle, there\u0026rsquo;s a consequent reduction in both the cost of fixes and the risk of releasing a subpar product. Furthermore, automated inspections provide real-time insights into the product\u0026rsquo;s size, code complexity, and other metrics. This automation diminishes the chance of human-induced errors.\nMinimization of Manual Repetitive Tasks: Automation curtails the need for recurring manual tasks such as compilation, inspection, test execution, and report generation. This efficiency not only leads to significant time and cost savings but also allows teams to focus on activities that directly enhance product value. It liberates team members to dedicate more time to addressing new requirements or rectifying existing product issues.\nOn-Demand Availability of a Functional Product: A hallmark of CI is its ability to deliver a functional software product at any given moment. This is invaluable for stakeholders, offering them a rapid glance into product development progress. By leveraging CI, errors can be swiftly detected and remedied soon after a new change is introduced. This is far more efficient than uncovering them close to the release date when they are more expensive and challenging to amend. Such issues, if left unchecked, can lead to delivery delays, unsatisfied clients, escalated costs, and more. This ties back to the concept of the \u0026ldquo;Broken Window Theory\u0026rdquo;9, which, in essence, postulates that a product marred by numerous issues or perceived disorder can demotivate teams from addressing them.\nEnhanced Project Transparency: Implementing CI augments visibility into the project, rendering the development process more transparent. It aids project management with up-to-the-minute information, making it straightforward to gauge product quality, error trends, and more.\nElevated Product Confidence: The CI environment bolsters confidence in the product. Team members gain immediate insights into the ramifications of their changes, enabling them to promptly rectify any emergent issues.\nChallenges # While Duvall5 has extolled the virtues of Continuous Integration (CI) in his works, he also highlights potential challenges that might deter development teams from embracing it fully or realizing its benefits.\nBias: A widespread misconception is that CI system implementation is exorbitant and would escalate development costs due to its prolonged setup and maintenance. Contrarily, most software development projects already involve phases like inspection, testing, compilation, and integration, even if they don’t explicitly use a CI system. A common refrain is that there\u0026rsquo;s insufficient time or funds for CI system implementation, but the reality is that far more resources are spent performing redundant manual tasks throughout the development cycle. Furthermore, an automated CI system is infinitely more manageable and consistent compared to disparate manual processes.\nDisruption Fears: Projects in advanced development stages often fret that integrating a CI system would overhaul their established workflows, spawning significant delays. It’s pivotal to recognize that CI system implementation can be incremental. Teams can address one integration stage at a time, gradually ramping up the integration frequency as confidence builds.\nOverwhelming Failed Integrations: When CI practices aren’t diligently applied, there\u0026rsquo;s a risk of encountering an excessive number of failed integrations or \u0026ldquo;broken builds.\u0026rdquo; This could stem from developers bypassing local tests before uploading their changes to the Version Control System (VCS). A surge in failed integrations can erode trust in the CI system, reminiscent of the \u0026ldquo;Broken Window Theory\u0026rdquo;9.\nPerceived Additional Costs: There\u0026rsquo;s an apprehension among organizations about incurring extra expenses either for procuring CI product licenses or securing hardware to support these systems. However, this expenditure pales in comparison to the latent costs of late-stage integrations, where issues are discovered near the release date, far removed from their inception. On a brighter note, the current landscape is rife with a myriad of free and open-source alternatives, obviating any additional costs.\nReferences # Continuous integration. ThoughtWorks, 2018.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, Martin. Continuous Integration. 2006.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBeck, Kent. Embrace Change with Extreme Programming. IEEE Computer Magazine, (c), 70-77. 1999.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRodriguez Pilar, Markkula, Jouni, Oivo, Markku, \u0026amp; Turula, Kimmo. Survey on agile and lean usage in Finnish software industry. In Proceedings of the ACM-IEEE international symposium on Empirical software engineering and measurement - ESEM \u0026lsquo;12 (p. 139). ACM Press. DOI: 10.1145/2372251.2372275. 2012.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDuvall, Paul M., Matyas, Steve, \u0026amp; Glover, Andrew. Continuous integration: improving software quality and reducing risk. Pearson Education, Inc., 2007.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCauldwell, Patrick. Code Leader: Using people, tools and processes to build successful software. Wiley Publishing, Inc., 2008.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez \u0026amp; Farley, David. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCyclomatic Complexity Explanation\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe Broken Window Theory in Software Development\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"19 agosto 2023","externalUrl":null,"permalink":"/en/blog/continuous-integration/","section":"Blog","summary":"","title":"Continuous Integration","type":"blog"},{"content":"","date":"19 agosto 2023","externalUrl":null,"permalink":"/en/tags/continuous-integration/","section":"Tags","summary":"","title":"Continuous Integration","type":"tags"},{"content":"","date":"10 agosto 2023","externalUrl":null,"permalink":"/en/series/software-engineering/","section":"Series","summary":"","title":"Software Engineering","type":"series"},{"content":"","date":"10 agosto 2023","externalUrl":null,"permalink":"/en/tags/software-engineering/","section":"Tags","summary":"","title":"Software Engineering","type":"tags"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/en/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/en/tags/revert/","section":"Tags","summary":"","title":"Revert","type":"tags"},{"content":" Reverting a commit before pushing # When we have created a commit locally but have not published it to the remote yet, we can use git reset to undo the commit and, if we wish, discard the changes. Although there are several options for git reset the most used are:\n--soft: Does not touch the index file or the working tree at all (but resets the head to , just like all modes do). This leaves all your changed files \u0026ldquo;Changes to be committed\u0026rdquo;, as git status would put it. --hard: Resets the index and working tree. Any changes to tracked files in the working tree since are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted. Git reset documentation {: style=\u0026ldquo;text-align: right;\u0026rdquo;}\nHere there is an example about using git reset. We start by changing a file and creating a commit with the change.\nbash-3.2$ cat README.md # Index 1 bash-3.2$ bash-3.2$ cat README.md # Index 1 2 bash-3.2$ bash-3.2$ git add README.md bash-3.2$ bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md\u0026#34; [main 3734fd5] Add number 2 in README.md 1 file changed, 1 insertion(+) git status shows there is one commit pending to be published.\nbash-3.2$ git status On branch main Your branch is ahead of \u0026#39;origin/main\u0026#39; by 1 commit. (use \u0026#34;git push\u0026#34; to publish your local commits) nothing to commit, working tree clean Using git reflog to see the history.\n3734fd5 (HEAD -\u0026gt; main) HEAD@{0}: commit: Add number 2 in README.md 866bfa8 (origin/main) HEAD@{1}: revert: Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; e2f6d08 HEAD@{2}: merge feature-1: Merge made by the \u0026#39;ort\u0026#39; strategy. 23644da HEAD@{3}: checkout: moving from feature-1 to main Now we can use git reset --soft \u0026lt;COMMIT_ID\u0026gt; to undo the commit but keep the changes.\nbash-3.2$ git reset --soft 866bfa8 bash-3.2$ bash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: README.md git log after using git reset\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. We create a new commit so we can test the git reset --hard command.\nbash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: README.md bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md - NEW COMMIT\u0026#34; [main 2e7193d] Add number 2 in README.md - NEW COMMIT 1 file changed, 1 insertion(+) git log now shows the new commit.\ncommit 2e7193db650b9ba0762fe73525df599a08f8577d (HEAD -\u0026gt; main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Thu Jan 19 08:32:57 2023 -0300 Add number 2 in README.md - NEW COMMIT commit 866bfa8a952d11240707ebfc87f3266034d42443 (origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. Now we can use git reset --hard \u0026lt;COMMIT_ID\u0026gt; to undo the commit and discard all the changes.\nbash-3.2$ git reset --hard 866bfa8 HEAD is now at 866bfa8 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; bash-3.2$ bash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean git log remains as it nothing had happened.\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. Reverting a commit after it was pushed # When we realized that the last commit was a mistake but we already published it, the command to use is git revert \u0026lt;COMMIT_HASH\u0026gt;.\nFirst we need to locate the ID of the commit we want to revert, it can be done with git log or git reflog commands. Then, run the git revert \u0026lt;COMMIT_HASH\u0026gt; command using the ID obtained in the previous step. Use the options -e or --edit to edit the commit message if we like. Push our changes so the revert is available for everyone in our group. Reverting multiple commits # If we need to revert multiple commits we can revert them one by one using the --no-commit option in order to create a single revert commit at the end.\nImagine the history is like the following and we need to go back to COMMIT-3.\nCOMMIT-1 -\u0026gt; COMMIT-2 -\u0026gt; COMMIT-3 -\u0026gt; COMMIT-4 -\u0026gt; COMMIT-5 -\u0026gt; COMMIT-6 -\u0026gt; HEAD This sequence of commands will get our files to the version of COMMIT-3:\nbash-3.2$ git revert --no-commit COMMIT-6 bash-3.2$ git revert --no-commit COMMIT-5 bash-3.2$ git revert --no-commit COMMIT-4 bash-3.2$ git commit -m \u0026#34;Revert to version in COMMIT-3\u0026#34; bash-3.2$ git push Reverting a merge commit # -m parent-number, \u0026ndash;mainline parent-number\nUsually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.\nGit revert documentation {: style=\u0026ldquo;text-align: right;\u0026rdquo;}\nWhen we need to revert a merge commit git revert command needs to be run with the -m or --mainline option to indicate the parent number because a merge commit has more than one parent and Git does not know which parent was target branch and which was the branch with the changes that should be reverted.\nHere there is an example showing how to revert a merge commit.\nCreate the first commit in main branch.\nbash-3.2$ cat README.md # Index 1 bash-3.2$ bash-3.2$ git commit -m \u0026#34;Add number 1 in README.md - main branch\u0026#34; [main (root-commit) 23644da] Add number 1 in README.md - main branch 1 file changed, 3 insertions(+) create mode 100644 README.md bash-3.2$ bash-3.2$ git push -u origin main Enumerating objects: 3, done. Counting objects: 100% (3/3), done. Writing objects: 100% (3/3), 254 bytes | 254.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git * [new branch] main -\u0026gt; main branch \u0026#39;main\u0026#39; set up to track \u0026#39;origin/main\u0026#39;. bash-3.2$ The state of the README.md file in main branch.\nbash-3.2$git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 Branch feature-1 created and added one commit.\nbash-3.2$ git checkout -b feature-1 Switched to a new branch \u0026#39;feature-1\u0026#39; bash-3.2$ bash-3.2$ cat README.md # Index 1 2 bash-3.2$ bash-3.2$ git add README.md bash-3.2$ bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md - feature-1 branch\u0026#34; [feature-1 83ea1a3] Add number 2 in README.md - feature-1 branch 1 file changed, 1 insertion(+) bash-3.2$ bash-3.2$ git push --set-upstream origin feature-1 Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 292 bytes | 292.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 remote: remote: Create a pull request for \u0026#39;feature-1\u0026#39; on GitHub by visiting: remote: https://github.com/jnonino/test-repo/pull/new/feature-1 remote: To github.com:jnonino/test-repo.git * [new branch] feature-1 -\u0026gt; feature-1 branch \u0026#39;feature-1\u0026#39; set up to track \u0026#39;origin/feature-1\u0026#39;. bash-3.2$ The state of README.md in the feature-1 branch.\nbash-3.2$ git status On branch feature-1 Your branch is up to date with \u0026#39;origin/feature-1\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 2 Merge the feature-1 branch into the main branch.\nbash-3.2$ git checkout main Switched to branch \u0026#39;main\u0026#39; Your branch is up to date with \u0026#39;origin/main\u0026#39;. bash-3.2$ bash-3.2$ git merge --no-ff feature-1 Merge made by the \u0026#39;ort\u0026#39; strategy. README.md | 1 + 1 file changed, 1 insertion(+) bash-3.2$ bash-3.2$ git push Enumerating objects: 1, done. Counting objects: 100% (1/1), done. Writing objects: 100% (1/1), 233 bytes | 233.00 KiB/s, done. Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git 23644da..e2f6d08 main -\u0026gt; main bash-3.2$ Current state of README.md in main branch.\nbash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 2 git log after merging feature-1 into main branch.\ncommit e2f6d08d3b38a02a1c026cfb879f3131536757ac (HEAD -\u0026gt; main, origin/main) Merge: 23644da 83ea1a3 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:58:19 2023 -0300 Merge branch \u0026#39;feature-1\u0026#39; commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:53:38 2023 -0300 Add number 2 in README.md - feature-1 branch commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:48:37 2023 -0300 Add number 1 in README.md - main branch To revert the merge commit, as it was stated above we need to pay attention to the merge field.\nMerge: 23644da 83ea1a3 Running git revert e2f6d08 -m 1 will reinstate the tree as it was in 23644da, and git revert e2f6d08 -m 2 will set the tree as it was in 83ea1a3. In this example we would like to leave the main branch as it was before the merge commit. For doing that, we need to run git revert e2f6d08 -m 1.\nbash-3.2$ git revert e2f6d08 -m 1 [main 866bfa8] Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 1 file changed, 1 deletion(-) bash-3.2$ bash-3.2$ git status On branch main Your branch is ahead of \u0026#39;origin/main\u0026#39; by 1 commit. (use \u0026#34;git push\u0026#34; to publish your local commits) nothing to commit, working tree clean bash-3.2$ bash-3.2$ git push Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 344 bytes | 344.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git e2f6d08..866bfa8 main -\u0026gt; main git log after reverting the merge commit.\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. commit e2f6d08d3b38a02a1c026cfb879f3131536757ac Merge: 23644da 83ea1a3 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:58:19 2023 -0300 Merge branch \u0026#39;feature-1\u0026#39; commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:53:38 2023 -0300 Add number 2 in README.md - feature-1 branch commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:48:37 2023 -0300 Add number 1 in README.md - main branch Current state of README.md in main branch.\nbash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 ","date":"18 enero 2023","externalUrl":null,"permalink":"/en/blog/git-revert/","section":"Blog","summary":"","title":"Reverting changes in Git","type":"blog"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/en/tags/vcs/","section":"Tags","summary":"","title":"VCS","type":"tags"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/en/tags/version-control/","section":"Tags","summary":"","title":"Version Control","type":"tags"},{"content":"","externalUrl":null,"permalink":"/software-engineering/","section":"Ingeniería de Software","summary":"","title":"Ingeniería de Software","type":"software-engineering"}]