[{"content":" En el módulo anterior exploramos los fundamentos conceptuales de la Inteligencia Artificial. Ahora es momento de sumergirnos en una de las áreas de la matemática que hacen posible que los algoritmos de Machine Learning funcionen: el álgebra lineal.\nSi eres como la mayoría de los ingenieros de software, probablemente te preguntes: \u0026ldquo;¿por qué necesito álgebra lineal para programar IA?\u0026rdquo; La respuesta es simple pero profunda: el álgebra lineal es el lenguaje nativo del machine learning.\n¿Por qué el Álgebra Lineal es crucial en IA? # Imagina que estás desarrollando un sistema de recomendaciones para Netflix. Cada usuario tiene preferencias (acción, comedia, drama) que pueden representarse como un vector. Cada película también tiene características (género, año, rating) que forman otro vector. El problema de recomendar películas se convierte en encontrar similitudes entre vectores: álgebra lineal.\nO considera una red neuronal procesando una imagen de \\(224x224\\) píxeles. Esa imagen se convierte en una matriz de \\(50176\\) elementos. Las operaciones de la red (convoluciones, transformaciones) son multiplicaciones de matrices. El entrenamiento optimiza estas matrices, otra vez: álgebra lineal.\nLos tres pilares del ML que dependen del Álgebra Lineal # Representación de Datos: Todo en ML se convierte en vectores y matrices Transformaciones: Los algoritmos manipulan datos mediante operaciones lineales Optimización: Los métodos de entrenamiento usan gradientes (derivadas de operaciones matriciales) Como programadores, estamos acostumbrados a pensar en estructuras de datos como arrays, listas o objetos. En machine learning, pensamos en vectores y matrices. En este módulo aprenderemos a hacer esa transición mental.\nVectores: más que arrays # Un vector no es simplemente un array de números. Es una entidad matemática que representa tanto magnitud como dirección. En el contexto de machine learning, un vector es una forma de codificar información.\nDefinición formal # Un vector \\(v\\) en el espacio \\(R^n\\) es una tupla ordenada de \\(n\\) números reales:\n$$v = \\begin{pmatrix} v_1 \\\\ v_2 \\\\ \\vdots \\\\ v_n \\end{pmatrix}$$Pero más importante que la definición formal es la interpretación práctica:\nEn un sistema de recomendaciones: $$v = \\begin{pmatrix} rating_{accion} \\\\ rating_{comedia} \\\\ rating_{drama} \\end{pmatrix}$$ En procesamiento de texto: $$v = \\begin{pmatrix} frecuencia_{palabra1} \\\\ frecuencia_{palabra2} \\\\ frecuencia_{palabra3} \\\\ \\vdots \\end{pmatrix}$$ En visión por computadora: $$v = \\begin{pmatrix} pixel_1 \\\\ pixel_2 \\\\ pixel_3 \\\\ \\vdots \\end{pmatrix}$$ Interpretación geométrica # Un vector en dos dimensiones (2D) se puede visualizar como una flecha desde el origen \\((0,0)\\) hasta el punto \\((v_1, v_2)\\). Esta visualización es clave para entender las operaciones vectoriales.\nimport matplotlib.pyplot as plt import numpy as np def dibujar_vector(vector, color=\u0026#39;blue\u0026#39;, label=\u0026#39;Vector\u0026#39;): plt.quiver(0, 0, vector[0], vector[1], angles=\u0026#39;xy\u0026#39;, scale_units=\u0026#39;xy\u0026#39;, scale=1, color=color, label=label, width=0.005) plt.xlim(-1, 5) plt.ylim(-1, 5) plt.grid(True) plt.axhline(y=0, color=\u0026#39;k\u0026#39;, linewidth=0.5) plt.axvline(x=0, color=\u0026#39;k\u0026#39;, linewidth=0.5) # Ejemplo: vector que representa preferencias de usuario preferencias_usuario = np.array([3, 4]) # [acción: 3, comedia: 4] plt.figure(figsize=(8, 6)) dibujar_vector(preferencias_usuario, \u0026#39;blue\u0026#39;, \u0026#39;Preferencias Usuario\u0026#39;) plt.xlabel(\u0026#39;Rating Acción\u0026#39;) plt.ylabel(\u0026#39;Rating Comedia\u0026#39;) plt.title(\u0026#39;Vector de Preferencias de Usuario\u0026#39;) plt.legend() plt.show() Al ejecutar el código anterior obtenemos:\nInterpretación geométrica de un vector en Machine Learning Suma de vectores # La suma vectorial es componente a componente:\n$$\\mathbf{u} + \\mathbf{v} = \\begin{pmatrix} u_1 + v_1 \\\\ u_2 + v_2 \\\\ \\vdots \\\\ u_n + v_n \\end{pmatrix}$$Interpretación en ML: Si tenemos las preferencias de dos usuarios similares, podemos promediar sus vectores para encontrar preferencias \u0026ldquo;típicas\u0026rdquo; de ese segmento.\nMultiplicación por escalar # $$c \\cdot \\mathbf{v} = \\begin{pmatrix} c \\cdot v_1 \\\\ c \\cdot v_2 \\\\ \\vdots \\\\ c \\cdot v_n \\end{pmatrix}$$Interpretación en ML: Amplificar o reducir la importancia de ciertas características.\nProducto Punto # El producto punto es quizás la operación más importante en ML:\n$$\\mathbf{u} \\cdot \\mathbf{v} = \\sum_{i=1}^{n} u_i v_i = u_1 v_1 + u_2 v_2 + ... + u_n v_n$$¿Por qué es tan importante?\nSimilitud: Vectores similares tienen productos punto altos Proyección: Mide cuánto un vector \u0026ldquo;apunta\u0026rdquo; en la dirección de otro Redes neuronales: La base de las operaciones en cada neurona La interpretación geométrica es crucial, el producto punto es igual al producto entre las magnitudes de cada vector y el coseno del ángulo entre ellos:\n$$\\mathbf{u} \\cdot \\mathbf{v} = ||\\mathbf{u}|| \\cdot ||\\mathbf{v}|| \\cdot \\cos(\\theta)$$Donde \\(\\theta\\) es el ángulo entre los vectores.\nO de otra manera:\n$$\\cos(\\theta) = \\frac{\\mathbf{u} \\cdot \\mathbf{v}}{||\\mathbf{u}|| \\cdot ||\\mathbf{v}||}$$$$\\theta = \\arccos(\\frac{\\mathbf{u} \\cdot \\mathbf{v}}{||\\mathbf{u}|| \\cdot ||\\mathbf{v}||})$$Conocer el ángulo entre los vectores permite determinar que tan alineados están.\nImplementación desde cero: clase Vector # Antes de usar NumPy, implementemos nuestras propias operaciones vectoriales para entender qué sucede en el detrás de escena:\nimport math from typing import List class Vector: \u0026#34;\u0026#34;\u0026#34; Implementación básica de un vector matemático. Esta clase nos ayuda a entender las operaciones vectoriales antes de usar bibliotecas optimizadas como NumPy. \u0026#34;\u0026#34;\u0026#34; def __init__(self, componentes: List[float]): \u0026#34;\u0026#34;\u0026#34; Inicializa un vector con una lista de componentes. Args: componentes: Lista de números que forman el vector \u0026#34;\u0026#34;\u0026#34; if not componentes: raise ValueError(\u0026#34;Un vector debe tener al menos un componente\u0026#34;) self.componentes = componentes self.dimension = len(componentes) def __repr__(self): return f\u0026#34;Vector({self.componentes})\u0026#34; def __len__(self): return self.dimension def __getitem__(self, index): return self.componentes[index] def __add__(self, otro_vector): \u0026#34;\u0026#34;\u0026#34; Suma vectorial: componente por componente. Ejemplo: v1 = Vector([1, 2, 3]) v2 = Vector([4, 5, 6]) v3 = v1 + v2 # Vector([5, 7, 9]) \u0026#34;\u0026#34;\u0026#34; if self.dimension != otro_vector.dimension: raise ValueError(\u0026#34;Los vectores deben tener la misma dimensión\u0026#34;) componentes_resultado = [ a + b for a, b in zip(self.componentes, otro_vector.componentes) ] return Vector(componentes_resultado) def __sub__(self, otro_vector): \u0026#34;\u0026#34;\u0026#34;Resta vectorial.\u0026#34;\u0026#34;\u0026#34; if self.dimension != otro_vector.dimension: raise ValueError(\u0026#34;Los vectores deben tener la misma dimensión\u0026#34;) componentes_resultado = [ a - b for a, b in zip(self.componentes, otro_vector.componentes) ] return Vector(componentes_resultado) def __mul__(self, escalar): \u0026#34;\u0026#34;\u0026#34; Multiplicación por escalar. Ejemplo: v = Vector([1, 2, 3]) v_scaled = v * 2 # Vector([2, 4, 6]) \u0026#34;\u0026#34;\u0026#34; return Vector([escalar * componente for componente in self.componentes]) def producto_punto(self, otro_vector): \u0026#34;\u0026#34;\u0026#34; Producto punto: la operación más importante en Machine Learning. El producto punto mide la similitud direccional entre vectores. - Producto alto: vectores apuntan en direcciones similares - Producto cero: vectores perpendiculares - Producto negativo: vectores apuntan en direcciones opuestas Args: otro_vector: Otro vector de la misma dimensión Returns: float: El producto punto \u0026#34;\u0026#34;\u0026#34; if self.dimension != otro_vector.dimension: raise ValueError(\u0026#34;Los vectores deben tener la misma dimensión\u0026#34;) return sum(a * b for a, b in zip(self.componentes, otro_vector.componentes)) def magnitud(self): \u0026#34;\u0026#34;\u0026#34; Calcula la magnitud (norma) del vector. La magnitud representa la \u0026#34;longitud\u0026#34; del vector. Es importante para normalización y cálculo de distancias. Returns: float: La magnitud del vector \u0026#34;\u0026#34;\u0026#34; return math.sqrt(sum(componente ** 2 for componente in self.componentes)) def normalizar(self): \u0026#34;\u0026#34;\u0026#34; Normaliza el vector (magnitud = 1). Los vectores normalizados son cruciales en Machine Learning porque: - Eliminan el efecto de la escala - Facilitan la comparación de direcciones - Son requeridos en muchos algoritmos Returns: Vector: Nuevo vector normalizado \u0026#34;\u0026#34;\u0026#34; mag = self.magnitud() if mag == 0: raise ValueError(\u0026#34;No se puede normalizar el vector cero\u0026#34;) return Vector([componente / mag for componente in self.componentes]) def similitud_coseno(self, otro_vector): \u0026#34;\u0026#34;\u0026#34; Calcula la similitud coseno entre dos vectores. La similitud coseno es fundamental en: - Sistemas de recomendación - Procesamiento de lenguaje natural - Búsqueda semántica Retorna valores entre -1 y 1: - 1: Vectores idénticos en dirección - 0: Vectores perpendiculares - -1: Vectores opuestos Args: otro_vector: Otro vector Returns: float: Similitud coseno \u0026#34;\u0026#34;\u0026#34; dot_prod = self.producto_punto(otro_vector) producto_magnitudes = self.magnitud() * otro_vector.magnitud() if producto_magnitudes == 0: return 0 return dot_prod / producto_magnitudes # Ejemplos de uso def demo_operaciones_vectoriales(): \u0026#34;\u0026#34;\u0026#34; Prueba las operaciones vectoriales con ejemplos de Machine Learning. \u0026#34;\u0026#34;\u0026#34; mensaje = \u0026#34;Ejemplos de Operaciones Vectoriales\u0026#34; print(\u0026#34;#\u0026#34; * len(mensaje)) print(mensaje) print(\u0026#34;#\u0026#34; * len(mensaje)) print(\u0026#34;\\n\u0026#34;) # Ejemplo 1: Preferencias de usuarios print(\u0026#34;=== Ejemplo 1: Preferencias de usuarios ===\u0026#34;) print(\u0026#34; Cada usuario se corresponde con un vector que mapea sus preferencias en películas\u0026#34;) print(\u0026#34; Vector([acción, comedia, drama])\u0026#34;) print(\u0026#34;\\n\u0026#34;) usuarios = [ Vector([4, 2, 5]), Vector([3, 4, 2]), Vector([9, 1, 2]), Vector([3, 8, 1]), Vector([1, 2, 9]) ] for index_i, usuario_i in enumerate(usuarios): print(f\u0026#34; Usuario {index_i}: {usuario_i}\u0026#34;) for index_j in range(index_i + 1, len(usuarios)): usuario_j = usuarios[index_j] print(f\u0026#34; Cálculos de similitud con el usuario {index_j}\u0026#34;) combinadas = usuario_i + usuario_j print(f\u0026#34; Suma: preferencias combinadas: {combinadas}\u0026#34;) similitud_producto_punto = usuario_i.producto_punto(usuario_j) print(f\u0026#34; Similitud (producto punto): {similitud_producto_punto}\u0026#34;) similitud_coseno = usuario_i.similitud_coseno(usuario_j) print(f\u0026#34; Similitud coseno: {similitud_coseno:.3f}\u0026#34;) print(\u0026#34;\\n\u0026#34;) # Ejemplo 2: Vectores de características print(\u0026#34;=== Ejemplo 2: Análisis de Documentos ===\u0026#34;) print(\u0026#34; Cada documento se corresponde con un vector que mapea las frecuencias de las palabras que contiene\u0026#34;) print(\u0026#34; Vector([frecuencia_palabra_1, frecuencia_palabra_2, frecuencia_palabra_3, frecuencia_palabra_4])\u0026#34;) documento_1 = Vector([2, 1, 0, 3]) # Frecuencias de palabras documento_2 = Vector([1, 2, 1, 2]) # Frecuencias de palabras print(f\u0026#34; Documento 1: {documento_1}\u0026#34;) print(f\u0026#34; Documento 2: {documento_2}\u0026#34;) similitud_documentos_producto_punto = documento_1.producto_punto(documento_2) print(f\u0026#34; Similitud (producto punto): {similitud_documentos_producto_punto}\u0026#34;) similitud_documentos_coseno = documento_1.similitud_coseno(documento_2) print(f\u0026#34; Similitud entre documentos (coseno): {similitud_documentos_coseno:.3f}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: demo_operaciones_vectoriales() Al ejecutar el código anterior obtenemos:\n\u0026gt; python vector.py ################################### Ejemplos de Operaciones Vectoriales ################################### === Ejemplo 1: Preferencias de usuarios === Cada usuario se corresponde con un vector que mapea sus preferencias en películas Vector([acción, comedia, drama]) Usuario 0: Vector([4, 2, 5]) Cálculos de similitud con el usuario 1 Suma: preferencias combinadas: Vector([7, 6, 7]) Similitud (producto punto): 30 Similitud coseno: 0.830 Cálculos de similitud con el usuario 2 Suma: preferencias combinadas: Vector([13, 3, 7]) Similitud (producto punto): 48 Similitud coseno: 0.772 Cálculos de similitud con el usuario 3 Suma: preferencias combinadas: Vector([7, 10, 6]) Similitud (producto punto): 33 Similitud coseno: 0.572 Cálculos de similitud con el usuario 4 Suma: preferencias combinadas: Vector([5, 4, 14]) Similitud (producto punto): 53 Similitud coseno: 0.852 Usuario 1: Vector([3, 4, 2]) Cálculos de similitud con el usuario 2 Suma: preferencias combinadas: Vector([12, 5, 4]) Similitud (producto punto): 35 Similitud coseno: 0.701 Cálculos de similitud con el usuario 3 Suma: preferencias combinadas: Vector([6, 12, 3]) Similitud (producto punto): 43 Similitud coseno: 0.928 Cálculos de similitud con el usuario 4 Suma: preferencias combinadas: Vector([4, 6, 11]) Similitud (producto punto): 29 Similitud coseno: 0.581 Usuario 2: Vector([9, 1, 2]) Cálculos de similitud con el usuario 3 Suma: preferencias combinadas: Vector([12, 9, 3]) Similitud (producto punto): 37 Similitud coseno: 0.464 Cálculos de similitud con el usuario 4 Suma: preferencias combinadas: Vector([10, 3, 11]) Similitud (producto punto): 29 Similitud coseno: 0.337 Usuario 3: Vector([3, 8, 1]) Cálculos de similitud con el usuario 4 Suma: preferencias combinadas: Vector([4, 10, 10]) Similitud (producto punto): 28 Similitud coseno: 0.351 Usuario 4: Vector([1, 2, 9]) === Ejemplo 2: Análisis de Documentos === Cada documento se corresponde con un vector que mapea las frecuencias de las palabras que contiene Vector([frecuencia_palabra_1, frecuencia_palabra_2, frecuencia_palabra_3, frecuencia_palabra_4]) Documento 1: Vector([2, 1, 0, 3]) Documento 2: Vector([1, 2, 1, 2]) Similitud (producto punto): 10 Similitud entre documentos (coseno): 0.845 Matrices: transformaciones de datos # Si los vectores representan datos, las matrices representan transformaciones de esos datos. Una matriz es una tabla rectangular de números organizados en filas y columnas.\n$$\\mathbf{A} = \\begin{pmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ a_{m1} \u0026 a_{m2} \u0026 \\cdots \u0026 a_{mn} \\end{pmatrix}$$En machine learning, las matrices son omnipresentes:\nDataset: Cada fila es un ejemplo, cada columna una característica Pesos de red neuronal: Transforman entradas en salidas Transformaciones: Rotación, escalado, proyección de datos Multiplicación Matriz-Vector # Esta es la operación más común en ML. Transforma un vector usando una matriz:\n$$\\mathbf{A}\\mathbf{v} = \\begin{pmatrix} \\sum_{i=1}^{n} a_{1i} v_i \\\\ \\sum_{i=1}^{n} a_{2i} v_i \\\\ \\sum_{i=1}^{n} a_{3i} v_i \\\\ \\vdots \\\\ \\sum_{i=1}^{n} a_{mi} v_i \\\\ \\end{pmatrix}$$$$\\mathbf{A}\\mathbf{v} = \\begin{pmatrix} a_{11} \u0026 a_{12} \u0026 a_{13} \u0026 \\cdots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 a_{33} \u0026 \\cdots \u0026 a_{2n} \\\\ a_{31} \u0026 a_{32} \u0026 a_{33} \u0026 \\cdots \u0026 a_{3n} \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ a_{m1} \u0026 a_{m2} \u0026 a_{m3} \u0026 \\cdots \u0026 a_{mn} \\\\ \\end{pmatrix} \\cdot \\begin{pmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ \\vdots \\\\ v_n \\end{pmatrix}$$$$\\mathbf{A}\\mathbf{v} = \\begin{pmatrix} a_{11} \\cdot v_1 + a_{12} \\cdot v_2 + a_{13} \\cdot v_3 + \\cdots + a_{1n} \\cdot v_n \\\\ a_{21} \\cdot v_1 + a_{22} \\cdot v_2 + a_{23} \\cdot v_3 + \\cdots + a_{2n} \\cdot v_n \\\\ a_{31} \\cdot v_1 + a_{32} \\cdot v_2 + a_{33} \\cdot v_3 + \\cdots + a_{3n} \\cdot v_n \\\\ \\vdots \\\\ a_{m1} \\cdot v_1 + a_{m2} \\cdot v_2 + a_{m3} \\cdot v_3 + \\cdots + a_{mn} \\cdot v_n \\\\ \\end{pmatrix}$$Cuando se multiplica una matriz por un vector, es necesario que el número de elementos del vector coincida con el número de columnas de la matriz. Si no es así, la multiplicación no está definida.\nEjemplo práctico: En una red neuronal, cada capa aplica una transformación lineal:\nsalida = pesos × entrada + sesgo Si aún no lo notaste, se puede establecer una conexión entre la multiplicación de una matriz por un vector y el producto punto entre vectores.\nLa conexión es directa: multiplicar una matriz por un vector es, en el fondo, hacer varios productos punto seguidos.\nSi \\(A\\) es una matriz de \\(m \\times n\\) y \\(v\\) es un vector de dimensión \\(n\\), el resultado de \\(A \\ v\\) es un vector de dimensión \\(m\\) donde cada componente se obtiene haciendo el producto punto de una fila de la matriz con el vector.\n$$(A \\ v)_j = fila_j(A) \\cdot v$$ Multiplicación Matriz-Matriz # Para que el producto de dos matrices \\(A\\) y \\(B\\) es decir, \\(AB\\) esté definido, la matriz \\(A\\) debe tener el mismo número de columnas que la matriz \\(B\\) tenga de filas. Si \\(A\\) es de tamaño \\(m x n\\) y \\(B\\) es de tamaño \\(n x p\\), entonces el resultado \\(C = AB\\) será una matriz de tamaño \\(m x p\\).\n$$\\mathbf{C} = \\mathbf{A}\\mathbf{B} = \\begin{pmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\\\ a_{31} \u0026 a_{32} \u0026 \\cdots \u0026 a_{3n} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ a_{m1} \u0026 a_{m2} \u0026 \\cdots \u0026 a_{mn} \\\\ \\end{pmatrix} \\cdot \\begin{pmatrix} b_{11} \u0026 b_{12} \u0026 \\cdots \u0026 b_{1p} \\\\ b_{21} \u0026 b_{22} \u0026 \\cdots \u0026 b_{2p} \\\\ b_{31} \u0026 b_{32} \u0026 \\cdots \u0026 b_{3p} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ b_{n1} \u0026 b_{n2} \u0026 \\cdots \u0026 b_{np} \\\\ \\end{pmatrix}$$$$\\mathbf{C} = \\mathbf{A}\\mathbf{B} = \\begin{pmatrix} \\sum_{k=1}^{n} a_{1k} b_{k1} \u0026 \\sum_{k=1}^{n} a_{1k} b_{k2} \u0026 \\cdots \u0026 \\sum_{k=1}^{n} a_{1k} b_{kp} \\\\ \\sum_{k=1}^{n} a_{2k} b_{k1} \u0026 \\sum_{k=1}^{n} a_{2k} b_{k2} \u0026 \\cdots \u0026 \\sum_{k=1}^{n} a_{2k} b_{kp} \\\\ \\sum_{k=1}^{n} a_{3k} b_{k1} \u0026 \\sum_{k=1}^{n} a_{3k} b_{k2} \u0026 \\cdots \u0026 \\sum_{k=1}^{n} a_{3k} b_{kp} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\sum_{k=1}^{n} a_{mk} b_{k1} \u0026 \\sum_{k=1}^{n} a_{mk} b_{k2} \u0026 \\cdots \u0026 \\sum_{k=1}^{n} a_{mk} b_{kp} \\\\ \\end{pmatrix}$$Es decir, cada elemento \\(ij\\) de la matriz resultado (\\(C\\)) será:\n$$\\mathbf{C}_{ij} = (\\mathbf{AB})_{ij} = \\sum_{k=1}^{n} a_{ik} b_{kj}$$Esta operación permite componer transformaciones lineales.\nNuevamente, la multiplicación de matrices está muy relacionada con el producto punto de vectores.\nEn la multiplicación entre las matrices \\(A(m \\times n)\\) por \\(B(n \\times p)\\), el elemento \\(c_{ij}\\) de la matriz resultado \\(C\\) se obtiene como:\n$$\\mathbf{C}_{ij} = \\sum_{k=1}^{n} a_{ik} b_{kj}$$Esto es exactamente el producto punto entre la fila \\(i\\) de \\(A\\) y la columna \\(j\\) de \\(B\\).\n$$\\mathbf{C}_{ij} = a_{i} \\cdot b_{j}$$ Implementación desde cero: clase Matriz # import math from typing import List from vector import Vector class Matriz: \u0026#34;\u0026#34;\u0026#34; Implementación básica de una matriz matemática. Esta clase nos ayuda a entender las operaciones matriciales fundamentales en Machine Learning. \u0026#34;\u0026#34;\u0026#34; def __init__(self, datos: List[List[float]]): \u0026#34;\u0026#34;\u0026#34; Inicializa una matriz con una lista de listas. Args: datos: Lista de filas, donde cada fila es una lista de números \u0026#34;\u0026#34;\u0026#34; if not datos or not datos[0]: raise ValueError(\u0026#34;La matriz debe tener al menos un elemento\u0026#34;) # Verificar que todas las filas tengan la misma longitud longitud_fila = len(datos[0]) for fila in datos: if len(fila) != longitud_fila: raise ValueError(\u0026#34;Todas las filas deben tener la misma longitud\u0026#34;) self.datos = datos self.filas = len(datos) self.columnas = len(datos[0]) self.forma = (self.filas, self.columnas) def __repr__(self): \u0026#34;\u0026#34;\u0026#34;Representación legible de la matriz.\u0026#34;\u0026#34;\u0026#34; filas = [] for fila in self.datos: row_str = \u0026#34; \u0026#34;.join(f\u0026#34;{x:8.3f}\u0026#34; for x in fila) filas.append(f\u0026#34;[{row_str}]\u0026#34;) return f\u0026#34;Matriz(\\n \u0026#34; + \u0026#34;\\n \u0026#34;.join(filas) + \u0026#34;\\n)\u0026#34; def __getitem__(self, indices): \u0026#34;\u0026#34;\u0026#34;Permite acceso con matriz[i][j] o matriz[i, j].\u0026#34;\u0026#34;\u0026#34; if isinstance(indices, tuple): fila, columna = indices return self.datos[fila][columna] else: return self.datos[indices] def __setitem__(self, indices, value): \u0026#34;\u0026#34;\u0026#34;Permite asignación con matriz[i][j] = value.\u0026#34;\u0026#34;\u0026#34; if isinstance(indices, tuple): fila, columna = indices self.datos[fila][columna] = value else: fila = indices self.datos[fila] = value def __add__(self, otra): \u0026#34;\u0026#34;\u0026#34;Suma de matrices (elemento por elemento).\u0026#34;\u0026#34;\u0026#34; if self.forma != otra.shape: raise ValueError(\u0026#34;Las matrices deben tener la misma forma\u0026#34;) datos_resultado = [ [self.datos[i][j] + otra.datos[i][j] for j in range(self.columnas)] for i in range(self.filas) ] return Matriz(datos_resultado) def trasponer(self): \u0026#34;\u0026#34;\u0026#34; Calcula la transpuesta de la matriz. La transpuesta intercambia filas por columnas. Es fundamental en álgebra lineal y en Machine Learning. Returns: Matriz: Nueva matriz transpuesta \u0026#34;\u0026#34;\u0026#34; datos_transpuestos = [ [self.datos[fila][columna] for fila in range(self.filas)] for columna in range(self.columnas) ] return Matriz(datos_transpuestos) def multiplicar_por_escalar(self, escalar): \u0026#34;\u0026#34;\u0026#34;Multiplicación por escalar.\u0026#34;\u0026#34;\u0026#34; datos_resultado = [ [escalar * self.datos[i][j] for j in range(self.columnas)] for i in range(self.filas) ] return Matriz(datos_resultado) def multiplicar_por_vector(self, vector: Vector): \u0026#34;\u0026#34;\u0026#34; Multiplica la matriz por un vector. Esta es la operación fundamental en redes neuronales: cada capa aplica una transformación lineal Ax + b. Args: vector: Vector a multiplicar Returns: Vector: Resultado de la multiplicación \u0026#34;\u0026#34;\u0026#34; if self.columnas != len(vector): raise ValueError(f\u0026#34;Dimensiones incompatibles: matriz {self.forma} * vector {len(vector)}\u0026#34;) componentes_resultado = [] for index_fila in range(self.filas): fila = [ self.datos[index_fila][columna] for columna in range(self.columnas) ] producto_punto = Vector(fila).producto_punto(vector) componentes_resultado.append(producto_punto) return Vector(componentes_resultado) def multiplicar_matrices(self, otra): \u0026#34;\u0026#34;\u0026#34; Multiplica dos matrices. La multiplicación de matrices permite componer transformaciones. En deep learning, representa la composición de capas. Args: otra: Otra matriz Returns: Matriz: Resultado de la multiplicación \u0026#34;\u0026#34;\u0026#34; if self.columnas != otra.filas: raise ValueError(f\u0026#34;Dimensiones incompatibles: {self.forma} * {otra.forma}\u0026#34;) print(f\u0026#34; Forma matriz A: {self.forma}\u0026#34;) print(f\u0026#34; Forma matriz B: {otra.forma}\u0026#34;) datos_resultado = [] for index_fila in range(self.filas): fila_i_matriz = [ self.datos[index_fila][columna] for columna in range(self.columnas) ] vector_fila_i_matriz = Vector(fila_i_matriz) fila_resultado = [] for index_columna_otra in range(otra.columnas): columna_j_matriz_otra = [ otra.datos[fila][index_columna_otra] for fila in range(otra.filas) ] vector_columna_j_matriz_otra = Vector(columna_j_matriz_otra) fila_resultado.append(vector_fila_i_matriz.producto_punto(vector_columna_j_matriz_otra)) datos_resultado.append(fila_resultado) return Matriz(datos_resultado) @staticmethod def identidad(tamano: int): \u0026#34;\u0026#34;\u0026#34; Crea una matriz identidad de tamaño size * size. La matriz identidad es el \u0026#34;1\u0026#34; de las matrices: A * I = I * A = A Args: tamano: Tamaño de la matriz cuadrada Returns: Matriz: Matriz identidad \u0026#34;\u0026#34;\u0026#34; datos = [ [1.0 if i == j else 0.0 for j in range(tamano)] for i in range(tamano) ] return Matriz(datos) def rotar_vector(vector: Vector, angulo: int): \u0026#34;\u0026#34;\u0026#34;Rotar vector\u0026#34;\u0026#34;\u0026#34; angulo_radianes = angulo * math.pi / 180 # angulo en grados convertido a radianes matriz_transformacion = Matriz([ [math.cos(angulo_radianes), -math.sin(angulo_radianes)], [math.sin(angulo_radianes), math.cos(angulo_radianes)] ]) return { \u0026#34;matriz_transformacion\u0026#34;: matriz_transformacion, \u0026#34;vector_rotado\u0026#34;: matriz_transformacion.multiplicar_por_vector(vector) } # Ejemplos de uso def demo_operaciones_matriciales(): \u0026#34;\u0026#34;\u0026#34; Demuestra las operaciones matriciales con ejemplos de Machine Learning. \u0026#34;\u0026#34;\u0026#34; mensaje = \u0026#34;Ejemplos de Operaciones Matriciales\u0026#34; print(\u0026#34;#\u0026#34; * len(mensaje)) print(mensaje) print(\u0026#34;#\u0026#34; * len(mensaje)) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;=== Ejemplo 1: Transponer ===\u0026#34;) datos = Matriz([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ]) print(datos) print(\u0026#34;Transponer...\u0026#34;) print(datos.trasponer()) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;=== Ejemplo 2: Multiplicación matriz por escalar ===\u0026#34;) print(datos) escalar = 3 print(f\u0026#34;Multiplicación por el escalar: {escalar}...\u0026#34;) print(datos.multiplicar_por_escalar(escalar)) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;=== Ejemplo 3: Multiplicación matriz por vector ===\u0026#34;) print(datos) vector = Vector([1.0, 2.0, 3.0]) print(f\u0026#34;Multiplicación por el vector: {vector}...\u0026#34;) print(datos.multiplicar_por_vector(vector)) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;=== Ejemplo 4: Multiplicación matriz por matriz ===\u0026#34;) print(datos) otra = Matriz([ [9.0, 8.0, 7.0], [6.0, 5.0, 4.0], [3.0, 2.0, 1.0] ]) print(f\u0026#34;Multiplicación por la matriz: {otra}...\u0026#34;) print(datos.multiplicar_matrices(otra)) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;=== Ejemplo 5: Rotación de un vector en 2D ===\u0026#34;) vector_original = Vector([1.0, 0.0]) print(\u0026#34;\\n\u0026#34;) angulo = 45 rotacion = rotar_vector(vector_original, angulo) print(f\u0026#34;Vector original en 2D: {vector_original}\u0026#34;) print(f\u0026#34;Matriz de rotacion en {angulo} grados: {rotacion[\u0026#34;matriz_transformacion\u0026#34;]}\u0026#34;) print(f\u0026#34;Vector rotado en {angulo} grados: {rotacion[\u0026#34;vector_rotado\u0026#34;]}\u0026#34;) print(\u0026#34;\\n\u0026#34;) angulo = 90 rotacion = rotar_vector(vector_original, angulo) print(f\u0026#34;Vector original en 2D: {vector_original}\u0026#34;) print(f\u0026#34;Matriz de rotacion en {angulo} grados: {rotacion[\u0026#34;matriz_transformacion\u0026#34;]}\u0026#34;) print(f\u0026#34;Vector rotado en {angulo} grados: {rotacion[\u0026#34;vector_rotado\u0026#34;]}\u0026#34;) print(\u0026#34;\\n\u0026#34;) angulo = 180 rotacion = rotar_vector(vector_original, angulo) print(f\u0026#34;Vector original en 2D: {vector_original}\u0026#34;) print(f\u0026#34;Matriz de rotacion en {angulo} grados: {rotacion[\u0026#34;matriz_transformacion\u0026#34;]}\u0026#34;) print(f\u0026#34;Vector rotado en {angulo} grados: {rotacion[\u0026#34;vector_rotado\u0026#34;]}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: demo_operaciones_matriciales() Al ejecutar el código anterior obtenemos:\n\u0026gt; python matriz.py ################################### Ejemplos de Operaciones Matriciales ################################### === Ejemplo 1: Transponer === Matriz( [ 1.000 2.000 3.000] [ 4.000 5.000 6.000] [ 7.000 8.000 9.000] ) Transponer... Matriz( [ 1.000 4.000 7.000] [ 2.000 5.000 8.000] [ 3.000 6.000 9.000] ) === Ejemplo 2: Multiplicación matriz por escalar === Matriz( [ 1.000 2.000 3.000] [ 4.000 5.000 6.000] [ 7.000 8.000 9.000] ) Multiplicación por el escalar: 3... Matriz( [ 3.000 6.000 9.000] [ 12.000 15.000 18.000] [ 21.000 24.000 27.000] ) === Ejemplo 3: Multiplicación matriz por vector === Matriz( [ 1.000 2.000 3.000] [ 4.000 5.000 6.000] [ 7.000 8.000 9.000] ) Multiplicación por el vector: Vector([1.0, 2.0, 3.0])... Vector([14.0, 32.0, 50.0]) === Ejemplo 4: Multiplicación matriz por matriz === Matriz( [ 1.000 2.000 3.000] [ 4.000 5.000 6.000] [ 7.000 8.000 9.000] ) Multiplicación por la matriz: Matriz( [ 9.000 8.000 7.000] [ 6.000 5.000 4.000] [ 3.000 2.000 1.000] )... Forma matriz A: (3, 3) Forma matriz B: (3, 3) Matriz( [ 30.000 24.000 18.000] [ 84.000 69.000 54.000] [ 138.000 114.000 90.000] ) === Ejemplo 5: Rotación de un vector en 2D === Vector original en 2D: Vector([1.0, 0.0]) Matriz de rotacion en 45 grados: Matriz( [ 0.707 -0.707] [ 0.707 0.707] ) Vector rotado en 45 grados: Vector([0.7071067811865476, 0.7071067811865475]) Vector original en 2D: Vector([1.0, 0.0]) Matriz de rotacion en 90 grados: Matriz( [ 0.000 -1.000] [ 1.000 0.000] ) Vector rotado en 90 grados: Vector([6.123233995736766e-17, 1.0]) Vector original en 2D: Vector([1.0, 0.0]) Matriz de rotacion en 180 grados: Matriz( [ -1.000 -0.000] [ 0.000 -1.000] ) Vector rotado en 180 grados: Vector([-1.0, 1.2246467991473532e-16]) Espacios Vectoriales y Transformaciones Lineales # Un espacio vectorial (o espacio lineal) es un conjunto no vacío de vectores, en el que se han definido dos operaciones: la suma de vectores y la multiplicación de un vector por un escalar (número real o complejo). Para que un conjunto sea considerado un espacio vectorial, debe cumplir con ciertos axiomas fundamentales.\nConmutatividad: \\(u + v = v + u\\)\nAsociatividad: \\((u + v) + w = u + (v + w)\\)\nExistencia del vector nulo: \\(\\exists \\ v_0 \\in V \\ \\;|\\; \\ v_0 + u = u \\ \\forall \\ u \\in V \\)\nExistencia del opuesto: \\(\\forall \\ v_i \\in V \\ \\exists \\ -v_i \\in V \\ \\;|\\; \\ v_i + (-v_i) = 0\\)\nDistributividad del producto respecto a la suma vectorial: \\(\\alpha (u + v) = \\alpha u + \\alpha v\\)\nDistributividad del producto respecto a la suma escalar: \\((\\alpha + \\beta) u = \\alpha u + \\beta u\\)\nAsociatividad del producto de escalares: \\(\\alpha (\\beta u) = (\\alpha \\beta) u\\)\nElemento neutro: \\(1 u = u \\ \\forall \\ u \\in V\\)\nEntre algunos ejemplos de espacios vectoriales podemos mencionar:\nVectores en el plano: Los vectores en \\(\\mathbb{R}^2\\) son un ejemplo clásico de espacio vectorial, donde cada vector se representa como un par ordenado \\((x,y)\\) Vectores en el espacio tridimensional: En \\(\\mathbb{R}^3\\), un vector se puede escribir como \\(V = \\alpha i + \\beta j + \\gamma k \\) donde \\(i\\), \\(j\\) y \\(k\\) son vectores base. Los espacios vectoriales son fundamentales en diversas áreas, incluyendo matemáticas, física, ingeniería y ciencias de la computación, ya que permiten modelar y resolver problemas complejos mediante el uso de vectores y matrices.\n¿Por qué importa en Machine Learning?\nCaracterísticas: Cada dataset define un espacio vectorial Modelos: Los algoritmos de Machine Learning operan en estos espacios Transformaciones: Cambiamos de un espacio a otro para facilitar el aprendizaje Transformaciones lineales # Una transformación \\(T: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m\\) se define como una función que asigna a cada vector \\(v\\) en un espacio vectorial \\(V\\) un único vector \\(w\\) en otro espacio vectorial \\(W\\).\nPara que \\(T\\) sea considerada lineal, debe cumplir dos condiciones fundamentales:\nAdición: Para cualquier par de vectores \\(u\\) y \\(v\\) en \\(V\\), se cumple que: $$ T(u + v) = T(u) + T(v) $$ Homogeneidad: Para cualquier escalar \\(c\\) y cualquier vector \\(v\\) en \\(V\\) se cumple que: $$ T(c \\ v) = c \\ T(v) $$ Toda transformación lineal entre espacios vectoriales de dimensión finita puede representarse mediante una matriz, por ejemplo:\nImaginemos una transformación \\(T: \\mathbb{R}^2 \\rightarrow \\mathbb{R}^2\\) definida por:\n$$T(x,y) = (2x+y,3x-4y)$$En base canónica:\n\\(T(1,0) = (2,3) \\rightarrow \\) primera columna \\(\\begin{pmatrix} 2 \\\\ 3 \\end{pmatrix}\\) \\(T(0,1) = (1,-4) \\rightarrow \\) segunda columna \\(\\begin{pmatrix} 1 \\\\ -4 \\end{pmatrix}\\) La matriz asociada a la transformación \\(T\\) es:\n$$|\\mathbf{T}| = \\begin{pmatrix} 2 \u0026 1 \\\\ 3 \u0026 -4 \\end{pmatrix}$$ La base canónica es un conjunto de vectores que forma una base ortonormal en un espacio vectorial. En el plano, la base canónica está compuesta por los vectores \\(i\\) y \\(j\\), que representan las direcciones de los ejes \\(x\\) e \\(y\\), respectivamente. Estos vectores se utilizan para expresar otros vectores como combinaciones lineales de la base canónica. Además, la base canónica es fundamental para entender la dimensión y la estructura de los espacios vectoriales.\nVectores y valores propios # Los valores propios o autovalores y los vectores propios o autovectores revelan las direcciones \u0026ldquo;especiales\u0026rdquo; de una transformación lineal.\nLos vectores propios o autovectores de una transformación lineal son los vectores no nulos que, cuando son transformados, dan lugar a un múltiplo escalar de sí mismos, con lo que no cambian su dirección. Este escalar \\(\\lambda\\) recibe el nombre de valor propio o autovalor. En muchos casos, una transformación queda completamente determinada por sus vectores propios y valores propios. Un espacio propio o autoespacio asociado al valor propio \\(\\lambda\\) es el conjunto de vectores propios con un valor propio común.\nPara una transformación lineal representada por la matriz \\(\\mathbf{A}\\), un vector \\(\\mathbf{v}\\) es un vector propio con valor propio \\(\\lambda\\) si:\n$$\\mathbf{A}\\mathbf{v} = \\lambda \\mathbf{v}$$Interpretación: La transformación \\(\\mathbf{A}\\) solo escala el vector \\(\\mathbf{v}\\) por el factor \\(\\lambda\\), sin cambiar su dirección.\nImagen de J. Finkelstein y Vb on Wikimedia Commons, dominio público En esta transformación de la Mona Lisa, la imagen se ha deformado de tal forma que su eje vertical no ha cambiado. El vector azul, representado por la flecha azul que va desde el pecho hasta el hombro, ha cambiado de dirección, mientras que el rojo, representado por la flecha roja, no ha cambiado. El vector rojo es entonces un vector propio o autovector de la transformación, mientras que el azul no lo es. Dado que el vector rojo no ha cambiado de longitud, su valor propio o autovalor es \\(1\\). Todos los vectores de esta misma dirección son vectores propios, con el mismo valor propio. Forman un subespacio del espacio propio de este valor propio.\n— Vector, valor y espacio propios. Wikipedia\nAplicaciones en Machine Learning # PCA (Análisis de Componentes Principales): Los vectores propios de la matriz de covarianza muestran las direcciones de mayor varianza en los datos.\nReducción de dimensionalidad: Proyectar datos en los vectores propios principales.\nEstabilidad de sistemas: Los valores propios indican si un sistema dinámico es estable.\nVisualizando valores y vectores propios # Crea un archivo Python con el siguiente contenido:\ndef ver_valores_propios(): \u0026#34;\u0026#34;\u0026#34; Visualiza conceptualmente los valores y los vectores propios. Esta es una simplificación para matrices 2x2. \u0026#34;\u0026#34;\u0026#34; import matplotlib.pyplot as plt import numpy as np # Matriz de ejemplo A = np.array([[3, 1], [0, 2]]) # Calcular valores y vectores propios usando NumPy valores_propios, vectores_propios = np.linalg.eig(A) # Crear varios vectores para mostrar la transformación angles = np.linspace(0, 2*np.pi, 16) vectores_originales = np.array([[np.cos(a), np.sin(a)] for a in angles]) vectores_transformados = np.array([A @ v for v in vectores_originales]) fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5)) # Vectores originales ax1.set_aspect(\u0026#39;equal\u0026#39;) for v in vectores_originales: ax1.arrow(0, 0, v[0], v[1], head_width=0.05, head_length=0.1, fc=\u0026#39;blue\u0026#39;, ec=\u0026#39;blue\u0026#39;, alpha=0.6) # Vectores propios originales for i, (val, vec) in enumerate(zip(valores_propios, vectores_propios.T)): ax1.arrow(0, 0, vec[0], vec[1], head_width=0.1, head_length=0.15, fc=\u0026#39;red\u0026#39;, ec=\u0026#39;red\u0026#39;, linewidth=3, label=f\u0026#39;Vector propio {i+1}\u0026#39;) ax1.set_xlim(-2, 2) ax1.set_ylim(-2, 2) ax1.set_title(\u0026#39;Vectores Originales\u0026#39;) ax1.grid(True) ax1.legend() # Vectores transformados ax2.set_aspect(\u0026#39;equal\u0026#39;) for v in vectores_transformados: ax2.arrow(0, 0, v[0], v[1], head_width=0.05, head_length=0.1, fc=\u0026#39;green\u0026#39;, ec=\u0026#39;green\u0026#39;, alpha=0.6) # Vectores propios transformados (escalados por valor propio) for i, (val, vec) in enumerate(zip(valores_propios, vectores_propios.T)): vectores_propios_transformados = val * vec ax2.arrow(0, 0, vectores_propios_transformados[0], vectores_propios_transformados[1], head_width=0.1, head_length=0.15, fc=\u0026#39;red\u0026#39;, ec=\u0026#39;red\u0026#39;, linewidth=3, label=f\u0026#39;λ{i+1}={val:.1f} × eigenvec{i+1}\u0026#39;) ax2.set_xlim(-4, 4) ax2.set_ylim(-4, 4) ax2.set_title(\u0026#39;Vectores Transformados por A\u0026#39;) ax2.grid(True) ax2.legend() plt.tight_layout() plt.show() print(f\u0026#34;Valores propios: {valores_propios}\u0026#34;) print(f\u0026#34;Vectores propios:\\n{vectores_propios}\u0026#34;) ver_valores_propios() Lo ejecutamos\u0026hellip;\nvirtualenv venv source venv/bin/activate pip install numpy pip install matplotlib python valores_vectores_propios.py y obtenemos:\nVisualizando vectores propios con Python Implementación práctica: un sistema de recomendaciones usando álgebra lineal # En el siguiente artículo de este módulo, vamos a actualizar nuestro sistema de recomendaciones para utilizar los conceptos de álgebra lineal que aprendimos hasta acá.\n¡Nos vemos allí! 🚀\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"12 septiembre 2025","externalUrl":null,"permalink":"/ai/module2/algebra/","section":"Inteligencia Artificial","summary":"","title":"Álgebra Lineal para Machine Learning: vectores y matrices que todo ingeniero en IA debe conocer","type":"ai"},{"content":" Bienvenido al primer módulo para convertirte en un ingeniero en IA. Si llegaste hasta aquí, es porque ya dominas Python y tienes experiencia como software engineer, pero el mundo de la inteligencia artificial te resulta un territorio desconocido. No te preocupes: estás exactamente donde necesitas estar.\nDurante los próximos módulos, vamos a transformar tus habilidades de programación en expertise en inteligencia artificial. No vamos a tomar atajos ni a usar \u0026ldquo;soluciones mágicas\u0026rdquo;, cada concepto será explicado desde sus fundamentos hasta su implementación práctica.\n¿Por qué necesitas entender los fundamentos? # Como programador, probablemente has escuchado términos como \u0026ldquo;IA\u0026rdquo;, \u0026ldquo;Machine Learning\u0026rdquo; y \u0026ldquo;Deep Learning\u0026rdquo; lanzados como sinónimos. Tal vez has visto demos impresionantes de ChatGPT o has leído sobre coches autónomos. Pero hay una diferencia enorme entre usar una API y realmente entender cómo funciona la tecnología por debajo.\nUn ingeniero en IA no es solo alguien que conecta APIs de OpenAI. Es un profesional que:\nEntiende cuándo y por qué usar cada técnica de IA Puede diagnosticar y resolver problemas en sistemas de ML Diseña arquitecturas de datos y modelos desde cero Evalúa críticamente el rendimiento y las limitaciones Implementa soluciones éticas y responsables Objetivos de este primer módulo # Al finalizar este módulo, vas a poder:\nDistinguir claramente entre IA, Machine Learning y Deep Learning Identificar qué tipo de problema requiere cada enfoque Implementar tu primer sistema inteligente usando lógica de reglas Entender los fundamentos teóricos que sustentan todas las técnicas avanzadas Crear un sistema de recomendaciones básico desde cero No vamos a usar bibliotecas complejas como TensorFlow o PyTorch todavía. Vamos a construir todo con Python puro para que entiendas realmente qué está pasando.\nTeoría fundamental: desenmascarando la IA # IA, Machine Learning y Deep Learning: aclarando la confusión # Empecemos destruyendo algunos mitos. Estos tres términos no son sinónimos, aunque a menudo se usan como si lo fueran.\nInteligencia Artificial (IA): el concepto más amplio # La Inteligencia Artificial es cualquier técnica que permite a las máquinas imitar el comportamiento inteligente humano. Esto incluye desde un simple sistema de reglas hasta las redes neuronales más complejas.\nImagina que estás construyendo un sistema para diagnosticar enfermedades. Si escribes:\ndef diagnosticar_gripe(temperatura: float, dolor_cabeza: bool, fatiga: bool): if temperatura \u0026gt; 38.0 and dolor_cabeza and fatiga: return \u0026#34;Posible gripe\u0026#34; return \u0026#34;Síntomas insuficientes\u0026#34; ¡Felicitaciones! Acabas de crear un sistema de IA. Es simple, pero es IA porque simula el proceso de razonamiento de un médico.\nMachine Learning: IA que aprende de los datos # Machine Learning es un subconjunto de la IA donde el sistema aprende patrones de los datos en lugar de seguir reglas programadas explícitamente.\nEn lugar de escribir reglas manualmente, le damos al sistema ejemplos:\nPaciente A: temperatura=38.5°, dolor=sí, fatiga=sí → Gripe Paciente B: temperatura=36.8°, dolor=no, fatiga=no → No gripe [\u0026hellip; más ejemplos \u0026hellip;] El sistema aprende automáticamente a identificar los patrones que distinguen gripe de no-gripe.\nDeep Learning: Machine Learning con redes neuronales profundas # Deep Learning es un subconjunto de Machine Learning que usa redes neuronales con múltiples capas (de ahí \u0026ldquo;profundo\u0026rdquo;). Es especialmente poderoso para datos complejos como imágenes, texto y audio.\nUna historia muy breve (pero necesaria) de la IA # Conocer y comprender la historia te ayuda a ver y entender el estado actual del desarrollo de la IA y su futuro.\nLos pioneros 1950s - 1960s Alan Turing propone el Test de Turing (1950) John McCarthy acuña el término Artificial Intelligence (1956) Primeros programas que juegan ajedrez y demuestran teoremas El primer invierno de la IA 1970s - 1980s Las expectativas eran demasiado altas. Los computadores eran lentos y la memoria limitada. La financiación se redujo drásticamente. El renacimiento con Machine Learning 1990s - 2000s Mejores algoritmos (Support Vector Machines, Random Forest) Más datos disponibles con internet Computadoras más poderosas La explosión del Deep Learning 2010s - Presente GPUs permiten entrenar redes neuronales gigantes Big Data proporciona millones de ejemplos de entrenamiento Nuevos Avances como ImageNet (2012) y GPT (2018) Tipos de aprendizaje automático # Como programador, necesitas entender cuándo usar cada enfoque. No existe una solución única para todos los problemas.\nAprendizaje Supervisado # Tienes ejemplos de entrada y salida conocida. El algoritmo aprende a mapear entradas a salidas correctas. Se utiliza cuando tienes datos históricos con respuestas correctas. Algunos ejemplos comunes de uso:\nClasificación de emails (spam/no spam) Predicción de precios de viviendas Diagnóstico médico Reconocimiento de objetos en imágenes La matemática básica: Buscamos una función \\(f\\) tal que \\(f(x) \\approx y\\), donde:\n\\(x\\) = datos de entrada (features) \\(y\\) = resultado conocido (label/target) Aprendizaje No Supervisado # En este caso, solo tienes datos de entrada, sin respuestas correctas. El algoritmo busca patrones ocultos. Se usa cuando quieres explorar datos o encontrar estructura desconocida. Algunos ejemplos comunes:\nSegmentación de clientes Detección de anomalías Compresión de datos Sistemas de recomendación Aprendizaje por Refuerzo # Aquí, el algoritmo aprende mediante prueba y error, recibiendo recompensas o castigos por sus acciones. Se utiliza en problemas secuenciales donde las decisiones afectan el futuro. Por ejemplo:\nJuegos (ajedrez, Go, videojuegos) Trading algorítmico Robots autónomos Optimización de rutas Implementación práctica: tus primeros sistemas inteligentes # En los siguientes artículos de este módulo, veremos algunos ejemplos para que te vayas adentrando en el mundo de la inteligencia artificial y el aprendizaje automático.\n¡Nos vemos allí! 🚀\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"22 agosto 2025","externalUrl":null,"permalink":"/ai/module1/intro/","section":"Inteligencia Artificial","summary":"","title":"Introducción","type":"ai"},{"content":"Las estructuras de datos son formas de organizar y almacenar información en un programa de computadora para que pueda ser accedida y modificada de manera eficiente. Como programadores, es esencial entender las distintas estructuras de datos disponibles y saber cuándo aplicar cada una para optimizar el rendimiento y la utilidad de nuestros programas.\nUna estructura de datos es una forma particular de organizar datos en la memoria de la computadora para que puedan ser usados de manera eficiente. Las estructuras de datos vienen en muchas formas, como arrays, listas, pilas, colas, grafos, árboles, hashes, etc.\nCada estructura organiza los datos de acuerdo a un modelo lógico específico y soporta operaciones eficientes para acceder, modificar, agregar y borrar elementos según ese modelo. Por ejemplo, un array organiza los elementos de manera secuencial en memoria para facilitar el acceso aleatorio por índices. Una lista enlazada conecta elementos en memoria usando \u0026ldquo;nodos\u0026rdquo; con referencias al siguiente nodo para facilitar la inserción y eliminación.\nAl elegir la estructura de datos apropiada para la tarea a resolver, podemos escribir programas más eficientes y reducir la complejidad computacional, utilizando menos recursos como memoria y procesamiento.\nLas estructuras de datos nos ayudan a:\nOrganizar grandes cantidades de datos para que sean más fáciles de acceder y modificar.\nModelar relaciones complejas entre datos, como con grafos y árboles.\nAcceder y modificar datos de manera eficiente, optimizando el rendimiento.\nReutilizar código y estructuras de datos existentes en lugar de tener que reescribir soluciones desde cero.\nPor ejemplo, un programa que debe almacenar miles de registros de usuarios se beneficia usando una estructura de datos hash para asociar cada usuario a datos como nombre, apellido, email, etc. De esta manera se pueden encontrar usuarios específicos muy rápido sin tener que iterar sobre toda la colección.\nOtro ejemplo son los árboles de búsqueda binaria, que permiten encontrar elementos muy rápido en conjuntos ordenados de millones de elementos. Esto se logra descartando mitades del árbol a medida que se busca el elemento deseado.\nTipos de estructuras de datos # Existen muchos tipos de estructuras de datos. A continuación, se presentan algunas categorías útiles para clasificarlas.\nSegún relación entre elementos # Lineales: Los elementos se organizan secuencialmente uno después del otro. Por ejemplo, arrays, listas, pilas, colas.\nNo lineales: Los elementos se organizan en una jerarquía o grafo. Este es el caso de los árboles y grafos.\nSegún tipo de elementos # Homogéneas: Almacenan un solo tipo de datos. Por ejemplo, arrays en un lenguaje como Java.\nHeterogéneas: Permiten diferentes tipos de datos. Objetos, registros son ejemplos de esta clasificación.\nSegún modo de acceso # Acceso secuencial: Sólo se puede acceder a los elementos en orden secuencial. Por ejemplo, listas enlazadas.\nAcceso directo: Se puede acceder a cualquier elemento directamente por su posición. En este grupo se encuentran los arrays.\nAcceso asociativo: Se accede a elementos por una clave asociada. Aquí se encuentran los diccionarios, hashes.\nSegún su funcionalidad # Arrays: Acceso rápido a elementos por índice pero difícil insertar/eliminar.\nListas: Fácil insertar/eliminar en cualquier posición pero acceso secuencial lento.\nPilas: Acceso LIFO (último en entrar, primero en salir). Útil para deshacer/rehacer.\nColas: Acceso FIFO (primero en entrar, primero en salir). Útil para procesamiento de eventos.\nÁrboles: Permiten modelar relaciones jerárquicas como con directorios de archivos o dependencias de tareas.\nGrafos: Permiten modelar redes de interconexión como mapas, relaciones sociales, etc.\nHashes / Diccionarios: Asocian elementos con claves únicas para acceso ultra rápido.\nEsta clasificación no es exhaustiva pero da una idea de la diversidad de estructuras de datos y sus diferentes propiedades que nos permiten modelar problemas complejos de manera eficiente.\nEjemplo # Veamos un ejemplo en Python para ver cómo se crea y utiliza una estructura de datos. Supongamos que queremos representar una cola de impresión donde las impresiones se procesan en orden de llegada (FIFO).\nPrimero, definimos una clase PrintQueue para representar nuestra cola:\nclass PrintQueue: def __init__(self): self.items = [] def enqueue(self, item): self.items.append(item) def dequeue(self): return self.items.pop(0) def is_empty(self): return len(self.items) == 0 Luego la utilizamos para agregar impresiones y procesarlas en orden:\nprint_queue = PrintQueue() print_queue.enqueue(\u0026#34;documento1.doc\u0026#34;) print_queue.enqueue(\u0026#34;imagen3.jpg\u0026#34;) print_queue.enqueue(\u0026#34;presentacion.ppt\u0026#34;) while not print_queue.is_empty(): next_item = print_queue.dequeue() print(f\u0026#34;Imprimiendo {next_item}\u0026#34;) Esto imprimirá:\nImprimiendo documento1.doc Imprimiendo imagen3.jpg Imprimiendo presentacion.ppt Con una estructura de datos como la cola implementamos la lógica FIFO de una forma sencilla y reutilizable. ¡Y esto es sólo una muestra, las posibilidades son infinitas!\nConclusión # Las estructuras de datos son herramientas fundamentales en programación que nos permiten organizar información de forma óptima para resolver problemas complejos. Conocer los distintos tipos de estructuras disponibles, como arrays, listas, pilas, colas, hashes, grafos y árboles, nos permite construir programas más eficientes. ¡Espero que esta introducción te haya dado algunos conocimientos y herramientas para comenzar a dominar este apasionante tema!\n","date":"04 agosto 2025","externalUrl":null,"permalink":"/programming/data-structures/introduction/","section":"Programación","summary":"","title":"Introducción","type":"programming"},{"content":"La Programación Orientada a Objetos (POO) es un paradigma de programación que se ha vuelto indispensable en la actualidad. Este enfoque modela elementos del mundo real como \u0026ldquo;objetos\u0026rdquo; que tienen propiedades y comportamientos, lo cual permite crear programas más intuitivos y fáciles de mantener. En este artículo veremos los conceptos básicos de POO y sus ventajas frente a otros paradigmas como la programación procedural. ¡Empecemos!\nEste paradigma se basa en dos conceptos fundamentales:\nObjetos: entidades que combinan estado (datos) y comportamiento (operaciones) en una misma unidad. Por ejemplo, un objeto \u0026ldquo;coche\u0026rdquo; tendría propiedades como color, número de puertas, velocidad máxima, etc. Y comportamientos como acelerar, frenar, girar, etc. Clases: especificaciones que definen la estructura y comportamiento común de un grupo de objetos. La clase \u0026ldquo;coche\u0026rdquo; serviría como molde para crear objetos coche con las mismas características. Como explica el programador Alan Kay, uno de los creadores de la POO:\n\u0026ldquo;La idea central de POO es que los usuarios deben manipular objetos conceptuales más que máquinas de Turing. Las interfaces con el mundo real deben, por lo tanto, ser construidas en términos de objetos conceptuales.\u0026rdquo;\nEs decir, la POO modela conceptualmente elementos del mundo real para hacer la programación más intuitiva.\nParadigmas de programación # Antes de profundizar en la POO, conviene entender que existen diferentes paradigmas o enfoques para abordar la programación. Los principales son:\nProgramación procedural # Secuencia ordenada de instrucciones que el programa debe seguir paso a paso. El foco está en procedimientos y funciones. Por ejemplo, C es un lenguaje orientado a la programación procedural.\nLa programación procedural es mejor para:\nProblemas sencillos o algoritmos secuenciales. Código que no necesitará reusarse ni expandirse mucho. Casos donde el rendimiento y eficiencia son críticos. Programación orientada a objetos # Modelo basado en objetos que contienen datos y código en unidades cohesivas. El foco está en las clases y en la interacción entre objetos. Por ejemplo, Java y Python son lenguajes orientados a objetos.\nLa POO permite modelar de forma más directa elementos del mundo real, encapsular mejor los datos y reutilizar código a través de la herencia entre clases.\nLas principales ventajas de POO frente a la programación procedural son:\nModularidad: los objetos agrupan datos y operaciones relacionadas, encapsulando la complejidad interna. Esto permite trabajar con módulos independientes. Ocultación de información: Los objetos pueden exponer una interfaz simple y ocultar detalles de implementación internos. Esto reduce acoplamientos. Reusabilidad: Las clases permiten reuse de código. Una clase abstracta puede heredar a múltiples subclases. Extensibilidad: Podemos extender el comportamiento de clases padres creando nuevas subclases. Mapeo conceptual: Los objetos representan entidades del mundo real, lo cual facilita la traducción de requerimientos a código. Sin embargo, la POO también tiene desventajas. Según el programador Paul Graham:\n\u0026ldquo;La programación orientada a objetos suele ser una molestia. Hace que las cosas sean más difíciles de lo que deberían ser.\u0026rdquo;\nPor ejemplo, para problemas simples la POO puede resultar excesiva. Y en proyectos grandes existe el riesgo de abusar de la herencia y el polimorfismo, volviendo el código difícil de seguir.\nEn definitiva, la POO es más adecuada cuando:\nEl problema a modelar tiene entidades claras y estructuradas. Queremos reutilizar código encapsulado en clases modulares. Trabajamos en sistemas que deben extenderse y mantenerse con facilidad. ","date":"04 agosto 2025","externalUrl":null,"permalink":"/programming/oop/introduction/","section":"Programación","summary":"","title":"Introducción","type":"programming"},{"content":"La programación, en su esencia, es el acto de instruir a una máquina sobre cómo realizar una tarea específica. Es como si le estuvieras enseñando a tu perro a buscar la pelota, pero en este caso, el perro es tu computadora y la pelota es, por ejemplo, sumar dos valores.\nAhora, es posible que pienses que programar es simplemente escribir líneas de código. En realidad, la programación es un proceso más amplio que incluye no solo escribir código, sino también resolver problemas, diseñar sistemas y pensar lógicamente.\nEn el universo de la programación, hay lenguajes de alto nivel y lenguajes de bajo nivel. Un lenguaje de bajo nivel, como el ensamblador, está más cerca de lo que la máquina entiende, mientras que un lenguaje de alto nivel, como Python o JavaScript, es más amigable para nosotros, los humanos. Los lenguajes de bajo nivel permiten una manipulación casi directa del hardware con instrucciones especificas para determinadas operaciones, como encender un determinado pixel de la pantalla. Mientras que los lenguajes de alto nivel permiten operaciones complejas en lenguaje casi natural, como por ejemplo mostrar una imagen en pantalla.\nAdemás, algunos lenguajes de programación son compilados y otros son interpretados. Si un lenguaje es compilado, significa que se traduce a un lenguaje que la máquina entiende antes de ser ejecutado. Por otro lado, los lenguajes interpretados son traducidos en tiempo real, mientras se ejecutan.\nBreve historia de la programación # La programación no es un concepto nuevo. De hecho, ha estado con nosotros desde mucho antes de que las computadoras existieran en la forma que las conocemos hoy. Dispositivos como el ábaco y el astrolabio son ejemplos tempranos de herramientas que usamos para realizar cálculos complejos.\nPero fue con la llegada de las máquinas mecánicas, como la Máquina Analítica de Charles Babbage, que se sentaron las bases para la programación moderna. ¡Estamos hablando del siglo XIX!\nCon el paso del tiempo, nacieron lenguajes que marcaron hitos, como Fortran y COBOL. Estos lenguajes sentaron las bases para las revoluciones tecnológicas que vendrían. Con la evolución de los lenguajes, también surgieron nuevos paradigmas: primero el Procedural, luego el Orientado a Objetos y más recientemente, el Funcional.\nHoy, estamos en una era moderna, dominada por la programación para la web, móviles y la nube. Cada vez que deslizas tu dedo por la pantalla de tu celular o compras algo online, hay líneas y líneas de código trabajando detrás de escena.\nLa programación hoy # La programación es el motor de nuestra sociedad moderna. Desde aplicaciones para pedir comida hasta sistemas avanzados de inteligencia artificial que ayudan en investigaciones médicas, la programación está en todas partes.\nAdemás de simplificar nuestras vidas cotidianas, la programación tiene un impacto profundo en la sociedad. Ha permitido avances en la automatización, el análisis de datos y el entretenimiento. Y lo que es aún más emocionante, es que apenas estamos rasguñando la superficie. Con los avances en inteligencia artificial, computación cuántica y el Internet de las Cosas (IoT), ¿quién sabe qué maravillas nos esperan en mundo de la programación?\n","date":"03 agosto 2025","externalUrl":null,"permalink":"/programming/intro/introduction/","section":"Programación","summary":"","title":"Introducción","type":"programming"},{"content":" Variables # Una variable es un contenedor para almacenar datos en la memoria de la computadora. Podemos pensar en ella como una caja con una etiqueta. La etiqueta es el nombre de la variable y dentro de la caja se almacena su valor.\nPara declarar una variable en Python solo escribimos el nombre y le asignamos un valor:\nedad = 28 precio = 19.95 soltero = True Los nombres de variables deben comenzar con letras o guión bajo, y sólo pueden contener letras, números y guiones bajos. Se recomienda usar nombres significativos que representen el propósito de la variable.\nEn Python las variables no necesitan ser declaradas con un tipo particular. El tipo se infiere automáticamente al asignar el valor:\nedad = 28 # edad es de tipo entero (int) precio = 19.95 # precio es de tipo float estudiante = True # soltero es de tipo booleano Una vez asignada, una variable puede cambiar su valor en cualquier momento:\nedad = 30 # Cambiamos edad a 30 Alcance y tiempo de vida # El alcance de una variable se refiere a las partes del código donde está disponible. Las variables declaradas fuera de funciones son globales y están disponibles en todo el archivo. Las variables dentro de una función son locales y solo visibles dentro de ella.\nEl tiempo de vida es el período durante el cual existe la variable en memoria. Las variables locales existen mientras se ejecuta la función, luego son destruidas. Las globales existen mientras el programa está en ejecución.\nAsignación # La asignación con el operador = permite cambiar o inicializar el valor de una variable:\nnumero = 10 numero = 20 # Ahora numero vale 20 También existen los operadores de asignación compuesta como += y -= que combinan una operación y asignación:\nnumero += 5 # Suma 5 a numero (numero = numero + 5) numero -= 2 # Resta 2 a numero Tipos de datos # Los tipos de datos definen el tipo de valor que puede almacenar una variable. Python tiene varios tipos incorporados, incluyendo:\nNuméricos: Para almacenar valores numéricos como enteros, flotantes, complejos:\nentero = 10 flotante = 10.5 complejo = 3 + 4j Cadenas: Para almacenar texto:\ntexto = \u0026#34;Hola Mundo\u0026#34; Booleano: Para valores lógicos Verdadero o Falso:\nvariable_verdadera = True variable_falsa = False Colecciones: Para almacenar múltiples valores como listas, tuplas y diccionarios:\nListas: Secuencias mutables de valores:\nlista = [1, 2, 3] Tuplas: Secuencias inmutables de valores:\ntupla = (1, 2, 3) Diccionarios: Estructuras de pares llave-valor:\ndiccionario = {\u0026#34;nombre\u0026#34;:\u0026#34;Juan\u0026#34;, \u0026#34;edad\u0026#34;: 20} Es importante elegir el tipo de dato que mejor represente la información que queremos almacenar.\nOperadores # Los operadores nos permiten realizar operaciones con valores y variables en Python. Algunos operadores comunes son:\nAritméticos: +, -, *, /, %, //, **\nComparación: ==, !=, \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;=\nLógicos: and, or, not\nAsignación: =, +=, -=, *=, /=\nVeamos ejemplos concretos de expresiones usando estos operadores en Python:\n# Aritméticos 5 + 4 # Suma, resultado 9 10 - 3 # Resta, resultado 7 4 * 5 # Multiplicación, resultado 20 # Comparación 5 \u0026gt; 4 # Mayor que, resultado Verdadero 7 \u0026lt; 10 # Menor que, resultado Verdadero # Lógicos True and False # Resultado False True or False # Resultado True not True # Resultado False # Asignación numero = 10 numero += 5 # Suma 5 a numero, equivalente a numero = numero + 5 Cada tipo de operador trabaja con tipos de datos específicos. Debemos usarlos de forma consistente según el tipo de datos de nuestras variables.\nConversiones de tipo # A veces necesitamos convertir un tipo de dato a otro para realizar ciertas operaciones. En Python podemos convertir de forma explícita o implícita:\nExplícita: Usando funciones como int(), float(), str():\nflotante = 13.5 entero = int(flotante) # convierte 13.5 a 13 texto = \u0026#34;100\u0026#34; numero = int(texto) # convierte \u0026#34;100\u0026#34; a 100 Implícita: Python convierte automáticamente en algunos casos:\nentero = 100 flotante = 3.5 resultado = entero + flotante # resultado es 103.5, entero se convirtió a float Algunas conversiones pueden generar pérdida de datos o errores:\nflotante = 13.5 entero = int(flotante) print(entero) # 13, se pierden los decimales Para prevenir esto debemos elegir explícitamente conversiones que tengan sentido para nuestros datos.\nConclusión # En este artículo revisamos conceptos clave como variables, operadores, tipos de datos y conversiones en Python. Aplicar bien estos conceptos te permitirá manipular datos de forma eficiente en tus programas. Recomiendo practicar con ejemplos propios para ganar experiencia en usar estas características. ¡Éxitos en tu aprendizaje de Python!\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"18 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/variables-data-types/","section":"Programación","summary":"","title":"Variables y Tipos de Datos","type":"programming"},{"content":" What is Software? # Several thought leaders in the world of computing have defined software in various ways:\nIan Sommerville1: Computer programs and associated documentation.\nRoger S. Pressman2: A collection of computer programs, procedures, rules, and associated documentation and data.\nAndrew S. Tanenbaum3: A series of instructions that tells a computer what to do.\nGrady Booch4: Set of items or objects that form a configuration that includes programs, documents, and data.\nPeter Denning5: Map of a machine, detailing its possible states, transitions, and the actions for these transitions.\nAnalysing these definitions, common themes emerge: software encompasses instructions, data, associated documentation, and serves as a guiding structure for computer operations. So we can conclude:\nSoftware is a meticulously structured collection of programs, data, and documentation that serves as a guiding blueprint, directing a computer\u0026rsquo;s operations and interactions with users and other systems.\nAlthough we can classify software in many different types, each with its specific function, we can define three primary categories:\nSystem Software: This forms the core of a computer\u0026rsquo;s operation. It includes operating systems like Windows, Linux, and macOS, which manage hardware resources and provide services for application software. Application Software: Tailored for end-users to perform specific tasks, this category ranges from word processors (like Microsoft Word) to graphic design tools (like Adobe Photoshop) and games. Embedded Software: Found within hardware devices such as washing machines, traffic lights, or digital watches, embedded software operates specific functions of these devices. Unlike general-purpose software, it\u0026rsquo;s dedicated to specific tasks or functions. What is Software Engineering? # Several prominent figures have also provided their perspectives on Software Engineering:\nIan Sommerville1: A discipline concerned with all aspects of software production.\nRoger S. Pressman2: Establishment and use of sound engineering principles to obtain economically software that is reliable and works efficiently on real machines.\nFrederick P. Brooks6: The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software.\nBarry W. Boehm7: Aims to produce quality software, software that is delivered on time, within budget, and that satisfies its requirements.\nFritz Bauer8: The establishment and use of sound engineering principles to economically obtain software that is reliable and works on real machines.\nFrom these definitions, we can discern that software engineering integrates principles of engineering, emphasizes systematic methods, seeks reliability and efficiency, and aims for the production of high-quality software that meets its specified requirements. Concluding that\nSoftware Engineering is the disciplined application of engineering principles and systematic methods to design, develop, and maintain reliable and efficient software that economically meets specified requirements and user needs.\nSoftware Engineering should not be confused with Computer Science. While the latter is a discipline that dives deep into the theoretical and mathematical aspects of computing, studying algorithms, computational theory, and more, the first one primarily focuses on designing and building large software systems. It emphasizes practical techniques and methodologies that ensure the production of high-quality, maintainable software.\nWhy it is important to develop quality software # Today, we\u0026rsquo;re surrounded by a digital ecosystem. Software runs our phones, cars, banks, hospitals, and even our homes. This ubiquity underscores its significance. That means that software flaws can have catastrophic outcomes. From banking systems to healthcare applications, the demand for faultless, efficient software is sky-high.\nSoftware Engineering, ensures this vast amount of software is reliable, efficient, and meets user needs. As technology advances at breakneck speed, the role of software engineers becomes even more pivotal, making sure innovations are safe and effective.\nWhether you\u0026rsquo;re using a social media app, making a bank transaction, or checking health diagnostics, remember there\u0026rsquo;s a meticulously engineered software system running behind the scenes, making it all possible.\nReferences # Sommerville, I., 2010. Software Engineering. 9th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPressman, R.S., 2010. Software Engineering: A Practitioner\u0026rsquo;s Approach. 7th ed. McGraw-Hill.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A.S., 2012. Structured Computer Organization. 6th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBooch, G., 2007. Object-Oriented Analysis and Design with Applications. 3rd ed. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDenning, P.J., 2009. The Profession of IT, Beyond Computational Thinking. Communications of the ACM, 52(6).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBrooks, F.P., 1995. The Mythical Man-Month: Essays on Software Engineering. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBoehm, B.W., 1988. A Spiral Model of Software Development and Enhancement. Computer, 21(5).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBauer, F.L., 1972. Software Engineering. Information Processing, 71.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"10 agosto 2023","externalUrl":null,"permalink":"/en/software-engineering/introduction/","section":"Software Engineering","summary":"","title":"Introduction to Software Engineering","type":"software-engineering"},{"content":"","externalUrl":null,"permalink":"/ai/module1/","section":"Inteligencia Artificial","summary":"","title":"Fundamentos de Inteligencia Artificial para Programadores","type":"ai"},{"content":"","externalUrl":null,"permalink":"/programming/intro/","section":"Programación","summary":"","title":"Introducción a la Programación","type":"programming"},{"content":" Para consolidar los conceptos aprendidos, implementaremos un sistema de recomendaciones completo usando solo álgebra lineal. Este proyecto demuestra cómo el álgebra lineal es fundamental en sistemas de machine learning reales. Objetivo del proyecto # Crear un sistema de recomendaciones que:\nRepresente usuarios y productos como vectores Calcule similitudes entre usuarios usando productos punto Haga recomendaciones de películas no vistas basadas en usuarios similares Datos disponibles # Para el desarrollo del sistema tenemos preparados un conjunto de datos que podés usar para verificar el funcionamiento de tu código.\nUsuarios: datos/usuarios.json\nNombre del usuario Productos: datos/peliculas.json\nNombre de la película Género de la película Interacciones: datos/interacciones.json\nID de la interacción ID del usuario ID de la película Valoración: puntuación de 1-5 estrellas Implementación Completa # Haciendo click en el siguiente enlace, puedes encontrar una posible implementación que cumple con los objetivos planteados. Incluye explicaciones detalladas.\n¡Intentá resolverlo por tu cuenta primero! 😀😀😀 Al ejecutar el sistema obtenemos:\n\u0026gt; python main.py =========================================== === Prueba del Sistema de Recomendación === =========================================== Inicializando el sistema * 13 peliculas cargadas * 6 usuarios cargados * 45 interacciones cargadas Procesando interacciones... Vectores de usuarios actualizados Matriz de puntuaciones construida: (6, 13) Calculando similitudes entre 6 usuarios Matriz de similitud entre usuarios construida: (6, 6) Sistema de recomendaciones inicializado correctamente **************************** Reporte completo del sistema **************************** Información del conjunto de datos: * Usuarios: 6 * Películas: 13 * Interacciones totales: 45 * Calificaciones dadas: 45 de 78 * Sparsity (densidad): 42.3% Análisis de los usuario * Ana López (ID: usuario_001): - Películas vistas: 6 - Puntuación promedio: 3.50 * Carlos Mendez (ID: usuario_002): - Películas vistas: 7 - Puntuación promedio: 3.57 * María Rodriguez (ID: usuario_003): - Películas vistas: 8 - Puntuación promedio: 3.00 * Diego Silva (ID: usuario_004): - Películas vistas: 8 - Puntuación promedio: 2.88 * Laura Martínez (ID: usuario_005): - Películas vistas: 7 - Puntuación promedio: 3.71 * Roberto García (ID: usuario_006): - Películas vistas: 9 - Puntuación promedio: 2.33 Matriz de puntuaciones (6, 13): +--------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+ | | Duro d | Termin | Matrix | El exo | Pesadi | El res | Mi pob | Forres | ¿Qué p | La más | Eso | Hallow | El ori | +--------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+ | Ana Ló | 5.0 | 4.0 | 0.0 | 2.0 | 1.0 | 0.0 | 4.0 | 5.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | | Carlos | 4.0 | 5.0 | 4.0 | 3.0 | 2.0 | 0.0 | 3.0 | 4.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | | María | 1.0 | 2.0 | 0.0 | 5.0 | 4.0 | 5.0 | 2.0 | 1.0 | 4.0 | 0.0 | 0.0 | 0.0 | 0.0 | | Diego | 2.0 | 1.0 | 2.0 | 1.0 | 0.0 | 3.0 | 5.0 | 4.0 | 5.0 | 0.0 | 0.0 | 0.0 | 0.0 | | Laura | 4.0 | 3.0 | 0.0 | 4.0 | 4.0 | 0.0 | 3.0 | 3.0 | 5.0 | 0.0 | 0.0 | 0.0 | 0.0 | | Robert | 2.0 | 5.0 | 1.0 | 3.0 | 4.0 | 1.0 | 2.0 | 2.0 | 1.0 | 0.0 | 0.0 | 0.0 | 0.0 | +--------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+ Matriz de similitud entre usuarios (6, 6): +-----------------+-----------+---------------+-----------------+-------------+----------------+----------------+ | | Ana López | Carlos Mendez | María Rodriguez | Diego Silva | Laura Martínez | Roberto García | +-----------------+-----------+---------------+-----------------+-------------+----------------+----------------+ | Ana López | 1.000 | 0.880 | 0.447 | 0.651 | 0.761 | 0.771 | | Carlos Mendez | 0.880 | 1.000 | 0.503 | 0.612 | 0.739 | 0.865 | | María Rodriguez | 0.447 | 0.503 | 1.000 | 0.656 | 0.782 | 0.750 | | Diego Silva | 0.651 | 0.612 | 0.656 | 1.000 | 0.727 | 0.538 | | Laura Martínez | 0.761 | 0.739 | 0.782 | 0.727 | 1.000 | 0.843 | | Roberto García | 0.771 | 0.865 | 0.750 | 0.538 | 0.843 | 1.000 | +-----------------+-----------+---------------+-----------------+-------------+----------------+----------------+ *************************************** Hacer recomendaciones para los usuarios *************************************** Recomendaciones para Ana López: Películas ya vistas: 6/13 Predicción para usuario_001 - \u0026#39;Matrix\u0026#39;: 2.43 - Basada en 3 usuarios similares Predicción para usuario_001 - \u0026#39;El resplandor\u0026#39;: 2.65 - Basada en 3 usuarios similares Predicción para usuario_001 - \u0026#39;¿Qué pasó ayer?\u0026#39;: 3.66 - Basada en 4 usuarios similares No hay usuarios similares que hayan visto \u0026#39;La máscara\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Eso\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Halloween\u0026#39; No hay usuarios similares que hayan visto \u0026#39;El origen\u0026#39; 3 recomendaciones generadas 1- ¿Qué pasó ayer? - Predicción de puntuación 3.66 2- El resplandor - Predicción de puntuación 2.65 3- Matrix - Predicción de puntuación 2.43 Recomendaciones para Carlos Mendez: Películas ya vistas: 7/13 Predicción para usuario_002 - \u0026#39;El resplandor\u0026#39;: 2.63 - Basada en 3 usuarios similares Predicción para usuario_002 - \u0026#39;¿Qué pasó ayer?\u0026#39;: 3.54 - Basada en 4 usuarios similares No hay usuarios similares que hayan visto \u0026#39;La máscara\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Eso\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Halloween\u0026#39; No hay usuarios similares que hayan visto \u0026#39;El origen\u0026#39; 2 recomendaciones generadas 1- ¿Qué pasó ayer? - Predicción de puntuación 3.54 2- El resplandor - Predicción de puntuación 2.63 Recomendaciones para María Rodriguez: Películas ya vistas: 8/13 Predicción para usuario_003 - \u0026#39;Matrix\u0026#39;: 2.13 - Basada en 3 usuarios similares No hay usuarios similares que hayan visto \u0026#39;La máscara\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Eso\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Halloween\u0026#39; No hay usuarios similares que hayan visto \u0026#39;El origen\u0026#39; 1 recomendaciones generadas 1- Matrix - Predicción de puntuación 2.13 Recomendaciones para Diego Silva: Películas ya vistas: 8/13 Predicción para usuario_004 - \u0026#39;Pesadilla en la calle Elm\u0026#39;: 3.00 - Basada en 5 usuarios similares No hay usuarios similares que hayan visto \u0026#39;La máscara\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Eso\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Halloween\u0026#39; No hay usuarios similares que hayan visto \u0026#39;El origen\u0026#39; 1 recomendaciones generadas 1- Pesadilla en la calle Elm - Predicción de puntuación 3.00 Recomendaciones para Laura Martínez: Películas ya vistas: 7/13 Predicción para usuario_005 - \u0026#39;Matrix\u0026#39;: 2.27 - Basada en 3 usuarios similares Predicción para usuario_005 - \u0026#39;El resplandor\u0026#39;: 2.95 - Basada en 3 usuarios similares No hay usuarios similares que hayan visto \u0026#39;La máscara\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Eso\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Halloween\u0026#39; No hay usuarios similares que hayan visto \u0026#39;El origen\u0026#39; 2 recomendaciones generadas 1- El resplandor - Predicción de puntuación 2.95 2- Matrix - Predicción de puntuación 2.27 Recomendaciones para Roberto García: Películas ya vistas: 9/13 No hay usuarios similares que hayan visto \u0026#39;La máscara\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Eso\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Halloween\u0026#39; No hay usuarios similares que hayan visto \u0026#39;El origen\u0026#39; 0 recomendaciones generadas - No hay recomendaciones disponibles Próximos pasos: optimizaciones y cálculo # El álgebra lineal que acabas de dominar es la base computacional del Machine Learning. En el próximo artículo exploraremos el cálculo. Allí podrás:\nEntender intuitivamente qué es una derivada y por qué es tan poderosa Calcular gradientes de funciones de múltiples variables Implementar descenso por gradiente desde cero en Python Visualizar cómo los algoritmos \u0026ldquo;aprenden\u0026rdquo; navegando funciones de costo Optimizar modelos de Machine Learning usando estos conceptos Y lo más importante: vas a ver el Machine Learning de una forma completamente nueva, entendiendo el motor matemático que lo impulsa.\nReflexión final # Hasta aquí aprendiste:\n✅ Conceptos fundamentales del Álgebra Lineal Vectores como representación de datos Matrices como transformaciones Espacios vectoriales y transformaciones lineales Valores y vectores propios ✅ Operaciones clave Producto punto para similitud Multiplicación matriz-vector para transformaciones ✅ Aplicaciones prácticas Sistema de recomendación completo ✅ Herramientas Implementación desde cero para comprensión NumPy para optimización Visualización de conceptos Para recordar\nEl álgebra lineal es el lenguaje del ML: Todo se reduce a vectores y matrices Las operaciones tienen significado: No son solo cálculos, representan conceptos La geometría importa: Visualizar ayuda a entender La optimización es crucial: NumPy vs implementación casera La teoría guía la práctica: entender el \u0026ldquo;por qué\u0026rdquo; antes del \u0026ldquo;cómo\u0026rdquo; ¡Nos vemos en el siguiente módulo! 🚀\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"14 septiembre 2025","externalUrl":null,"permalink":"/ai/module2/algebra-project/","section":"Inteligencia Artificial","summary":"","title":"Proyecto usando Álgebra Lineal: Sistema de Recomendaciones","type":"ai"},{"content":" Vamos a crear un sistema de IA clásica para diagnosticar problemas de rendimiento en aplicaciones web. Este ejemplo te muestra cómo estructurar conocimiento en reglas lógicas. Estructura del sistema # Como se mencionó, vamos a implementar un sistema que diagnostique problemas de rendimiento en aplicaciones web, el primer paso entonces es definir los síntomas que el sistema debe evaluar para emitir un diagnóstico.\nPara este caso sencillo se evaluará, el uso de CPU, uso de memoria RAM, cantidad de conexiones activas en simultáneo, tiempo de respuesta y la cantidad de solicitudes (requests) lentas, por poner un límite, aquellas que demoren más de un segundo en volver con una respuesta.\nCon ello, podemos generar una estructura inicial del sistema y ejecutarla. Es importante validar que el sistema continua funcionando luego de cada cambio.\nclass DiagnosticadorRendimiento: \u0026#34;\u0026#34;\u0026#34; Sistema experto para diagnosticar problemas de rendimiento en aplicaciones web usando reglas lógicas. \u0026#34;\u0026#34;\u0026#34; def __init__(self): # Base de conocimiento: conjunto de reglas de diagnóstico self.reglas = [] def diagnosticar(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Diagnostica problemas basándose en los síntomas reportados. Args: sintomas (dict): Diccionario con métricas del sistema - tiempo_respuesta: tiempo promedio en segundos - uso_memoria: porcentaje de memoria utilizada - queries_lentas: número de queries que tardan \u0026gt;1s - conexiones_activas: número de conexiones simultáneas - uso_cpu: porcentaje de CPU utilizada Returns: list: Lista de diagnósticos posibles con sus certezas \u0026#34;\u0026#34;\u0026#34; diagnosticos = [] # Evaluamos cada regla en nuestra base de conocimiento for regla in self.reglas: resultado = regla(sintomas) if resultado: diagnosticos.append(resultado) # Ordenamos por nivel de certeza (mayor a menor) diagnosticos.sort(key=lambda x: x[\u0026#39;certeza\u0026#39;], reverse=True) return diagnosticos # Ejemplo de uso del sistema experto if __name__ == \u0026#34;__main__\u0026#34;: # Creamos una instancia de nuestro diagnosticador diagnosticador = DiagnosticadorRendimiento() # Recibimos del usuario los valores de cada metrica print(\u0026#34;=\u0026#34; * 50) print(\u0026#34;Ingrese los valores de rendimiento del sistema\u0026#34;) cpu = int(input(\u0026#34;Porcentaje de CPU utilizada(int): \u0026#34;)) memoria = int(input(\u0026#34;Porcentaje de memoria utilizada(int): \u0026#34;)) tiempo_de_respuesta = float(input(\u0026#34;Cantidad de segundos en promedio para recibir una respuesta(float): \u0026#34;)) queries_lentas = int(input(\u0026#34;Cantidad de queries tardan más de 1 segundo(int): \u0026#34;)) conexiones_activas = int(input(\u0026#34;Cantidad de conexiones simultáneas(int): \u0026#34;)) # Simulamos métricas de un servidor con problemas metricas_servidor = { \u0026#39;tiempo_respuesta\u0026#39;: tiempo_de_respuesta, \u0026#39;uso_memoria\u0026#39;: memoria, \u0026#39;queries_lentas\u0026#39;: queries_lentas, \u0026#39;conexiones_activas\u0026#39;: conexiones_activas, \u0026#39;uso_cpu\u0026#39;: cpu } # Realizamos el diagnóstico print(\u0026#34;=\u0026#34; * 50) print(\u0026#34;DIAGNÓSTICO DEL SISTEMA\u0026#34;) print(\u0026#34;=\u0026#34; * 50) resultados = diagnosticador.diagnosticar(metricas_servidor) if not resultados: print(\u0026#34;No se detectaron problemas significativos\u0026#34;) else: for i, diagnostico in enumerate(resultados, 1): print(f\u0026#34;\\n#{i} - {diagnostico[\u0026#39;problema\u0026#39;]}\u0026#34;) print(f\u0026#34;Certeza: {diagnostico[\u0026#39;certeza\u0026#39;]:.1%}\u0026#34;) print(\u0026#34;Recomendaciones:\u0026#34;) for rec in diagnostico[\u0026#39;recomendaciones\u0026#39;]: print(f\u0026#34; • {rec}\u0026#34;) Al ejecutar el programa, vemos que el sistema dice que no hay problemas significativos. Esto se debe a que el DiagnosticadorRendimiento no tiene ninguna regla implementada, a continuación veremos cómo generar estas reglas que le darán el conocimiento necesario al diagnosticador para emitir un diagnóstico.\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 92 Cantidad de segundos en promedio para recibir una respuesta(float): 4.2 Cantidad de queries tardan más de 1 segundo(int): 15 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== No se detectaron problemas significativos Reglas # Como se observa en el método diagnosticar de la clase DiagnosticadorRendimiento, las reglas son simplemente funciones o métodos de la misma clase, que reciben con argumento un diccionario llamado sintomas que contiene las métricas del sistema definidas anteriormente.\n# Evaluamos cada regla en nuestra base de conocimiento for regla in self.reglas: resultado = regla(sintomas) if resultado: diagnosticos.append(resultado) Para que la función diagnosticar evalúe la regla, esta debe ser incluida en el diccionario de reglas definido en el constructor de la clase.\ndef __init__(self): # Base de conocimiento: conjunto de reglas de diagnóstico self.reglas = [] Se espera además que cada regla retorne un mapa con los campos:\nproblema: posible causa de un mal rendimiento. certeza: nivel de probabilidad de que el problema definido sea el causante de deficiencias en el rendimiento. recomendaciones: acciones que se podrían llevar a cabo para mejorar el rendimiento. Vale aclarar que estas reglas son ficticias y a la hora de generar un sistema experto de este tipo debes definirlas cuidadosamente en base al tipo de problema que intentas resolver y las condiciones de tu sistema.\nUso de CPU # La primera regla que implementaremos tendrá a su cargo determinar si el nivel de uso de CPU representa un problema de rendimiento o no.\nEl primer factor a decidir es que nivel se considera alto para el uso de CPU, por ejemplo \\(80\\%\\). También definimos que cuando el valor supere este límite, la certeza de que el uso de CPU es un problem será por los menos \\(0.85\\) y crecerá hasta \\(1\\) mientras el uso de CPU crezca hasta el \\(100\\%\\).\ndef _regla_cpu(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Regla: Uso de CPU alto puede indicar procesamiento intensivo o algoritmos ineficientes. \u0026#34;\u0026#34;\u0026#34; if sintomas.get(\u0026#39;uso_cpu\u0026#39;, 0) \u0026gt; 80: certeza = min(0.85, sintomas[\u0026#39;uso_cpu\u0026#39;] / 100) return { \u0026#39;problema\u0026#39;: \u0026#39;Procesamiento intensivo o algoritmos ineficientes\u0026#39;, \u0026#39;certeza\u0026#39;: certeza, \u0026#39;recomendaciones\u0026#39;: [ \u0026#39;Analizar el código para identificar cuellos de botella\u0026#39;, \u0026#39;Optimizar algoritmos, por ejemplo, aquellos O(n²) o peores\u0026#39;, \u0026#39;Implementar una cache para cálculos repetitivos\u0026#39;, \u0026#39;Considerar procesamiento asíncrono para tareas pesadas\u0026#39; ] } return None Ejecutando nuevamente el sistema con un valor de CPU del \\(93\\%\\) se obtiene:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 93 Porcentaje de memoria utilizada(int): 92 Cantidad de segundos en promedio para recibir una respuesta(float): 4.2 Cantidad de queries tardan más de 1 segundo(int): 15 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== #1 - Procesamiento intensivo o algoritmos ineficientes Certeza: 85.0% Recomendaciones: • Analizar el código para identificar cuellos de botella • Optimizar algoritmos, por ejemplo, aquellos O(n²) o peores • Implementar una cache para cálculos repetitivos • Considerar procesamiento asíncrono para tareas pesadas Uso de memoria # Para el caso de la memoria RAM, no solo consideraremos su uso (superior al \\(85\\%\\)) sino que también tenderemos en cuenta el tiempo de respuesta del sistema (mayor a \\(3.0\\) segundos).\ndef _regla_memoria(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Regla: Si el uso de memoria es alto Y el tiempo de respuesta es lento, probablemente hay una fuga (leak) de memoria. \u0026#34;\u0026#34;\u0026#34; if (sintomas.get(\u0026#39;uso_memoria\u0026#39;, 0) \u0026gt; 85 and sintomas.get(\u0026#39;tiempo_respuesta\u0026#39;, 0) \u0026gt; 3.0): # Calculamos certeza basada en qué tan extremos son los valores certeza = min(0.9, (sintomas[\u0026#39;uso_memoria\u0026#39;] / 100) * (sintomas[\u0026#39;tiempo_respuesta\u0026#39;] / 5)) return { \u0026#39;problema\u0026#39;: \u0026#39;Fuga de memoria o uso excesivo de memoria\u0026#39;, \u0026#39;certeza\u0026#39;: certeza, \u0026#39;recomendaciones\u0026#39;: [ \u0026#39;Revisar objetos no liberados en memoria\u0026#39;, \u0026#39;Implementar un grupo de conexiones para evitar abrir y cerrar nuevas\u0026#39;, \u0026#39;Analizar el consumo de memoria (memory_profiler)\u0026#39;, \u0026#39;Considerar aumentar la cantidad de RAM del servidor\u0026#39; ] } return None Veamos como funciona:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 92 Cantidad de segundos en promedio para recibir una respuesta(float): 4.2 Cantidad de queries tardan más de 1 segundo(int): 15 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== #1 - Fuga de memoria o uso excesivo de memoria Certeza: 77.3% Recomendaciones: • Revisar objetos no liberados en memoria • Implementar un grupo de conexiones para evitar abrir y cerrar nuevas • Analizar el consumo de memoria (memory_profiler) • Considerar aumentar la cantidad de RAM del servidor Si el tiempo de respuesta no se ve impactado aunque el consumo de memoria sea alto, obtenemos:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 92 Cantidad de segundos en promedio para recibir una respuesta(float): 2.8 Cantidad de queries tardan más de 1 segundo(int): 15 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== No se detectaron problemas significativos Nivel de concurrencia # De manera similar, implementaremos una regla para controlar la cantidad de conexiones simultaneas al servidor. Demasiadas conexiones pueden saturarlo y hacer que deje de responder. En este ejemplo, definiremos que \\(1000\\) conexiones simultaneas es el límite.\ndef _regla_concurrencia(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Regla: Muchas conexiones simultáneas pueden saturar el servidor. \u0026#34;\u0026#34;\u0026#34; if sintomas.get(\u0026#39;conexiones_activas\u0026#39;, 0) \u0026gt; 1000: certeza = min(0.8, sintomas[\u0026#39;conexiones_activas\u0026#39;] / 2000) return { \u0026#39;problema\u0026#39;: \u0026#39;Sobrecarga por exceso de conexiones concurrentes\u0026#39;, \u0026#39;certeza\u0026#39;: certeza, \u0026#39;recomendaciones\u0026#39;: [ \u0026#39;Implementar rate limiting\u0026#39;, \u0026#39;Usar un balanceador de carga (load balancer) con múltiples instancias\u0026#39;, \u0026#39;Utilizar un grupo de conexiones preestablecidas\u0026#39;, \u0026#39;Implementar colas para procesos no críticos\u0026#39; ] } return None Con la regla anterior, obtenemos los siguientes resultados:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 56 Cantidad de segundos en promedio para recibir una respuesta(float): 2.8 Cantidad de queries tardan más de 1 segundo(int): 15 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== No se detectaron problemas significativos \u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 56 Cantidad de segundos en promedio para recibir una respuesta(float): 2.8 Cantidad de queries tardan más de 1 segundo(int): 15 Cantidad de conexiones simultáneas(int): 1500 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== #1 - Sobrecarga por exceso de conexiones concurrentes Certeza: 75.0% Recomendaciones: • Implementar rate limiting • Usar un balanceador de carga (load balancer) con múltiples instancias • Utilizar un grupo de conexiones preestablecidas • Implementar colas para procesos no críticos Consultas a la base de datos # Una posible causa para recibir respuestas lentas puede ser el tiempo consumido en las consultas a la base de datos. Implementaremos una regla para que el sistema reconozca estos casos.\ndef _regla_base_datos(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Regla: Si hay muchas queries lentas, el problema está en la base de datos. \u0026#34;\u0026#34;\u0026#34; if sintomas.get(\u0026#39;queries_lentas\u0026#39;, 0) \u0026gt; 10: certeza = min(0.95, sintomas[\u0026#39;queries_lentas\u0026#39;] / 50) return { \u0026#39;problema\u0026#39;: \u0026#39;Queries de base de datos ineficientes\u0026#39;, \u0026#39;certeza\u0026#39;: certeza, \u0026#39;recomendaciones\u0026#39;: [ \u0026#39;Revisar índices en tablas frecuentemente consultadas\u0026#39;, \u0026#39;Optimizar queries con EXPLAIN ANALYZE\u0026#39;, \u0026#39;Implementar cache de queries (Redis)\u0026#39;, \u0026#39;Considerar particionado de tablas grandes\u0026#39; ] } return None Lo que nos da resultados como estos:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 56 Cantidad de segundos en promedio para recibir una respuesta(float): 1.5 Cantidad de queries tardan más de 1 segundo(int): 17 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== #1 - Queries de base de datos ineficientes Certeza: 34.0% Recomendaciones: • Revisar índices en tablas frecuentemente consultadas • Optimizar queries con EXPLAIN ANALYZE • Implementar cache de queries (Redis) • Considerar particionado de tablas grandes \u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 56 Cantidad de segundos en promedio para recibir una respuesta(float): 1.5 Cantidad de queries tardan más de 1 segundo(int): 49 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== #1 - Queries de base de datos ineficientes Certeza: 95.0% Recomendaciones: • Revisar índices en tablas frecuentemente consultadas • Optimizar queries con EXPLAIN ANALYZE • Implementar cache de queries (Redis) • Considerar particionado de tablas grandes Estado de la red # Si vemos que el tiempo de respuesta es alto pero CPU y memoria están bien, puede ser un problema de red. A continuación vemos el código para implementar esta regla.\ndef _regla_red(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Regla: Si el tiempo de respuesta es alto pero CPU y memoria están bien, puede ser un problema de red. \u0026#34;\u0026#34;\u0026#34; if (sintomas.get(\u0026#39;tiempo_respuesta\u0026#39;, 0) \u0026gt; 2.0 and sintomas.get(\u0026#39;uso_cpu\u0026#39;, 0) \u0026lt; 50 and sintomas.get(\u0026#39;uso_memoria\u0026#39;, 0) \u0026lt; 70): certeza = 0.7 # Menos certeza porque es por descarte return { \u0026#39;problema\u0026#39;: \u0026#39;Latencia de red o problemas de conectividad\u0026#39;, \u0026#39;certeza\u0026#39;: certeza, \u0026#39;recomendaciones\u0026#39;: [ \u0026#39;Verificar latencia entre servidor y clientes\u0026#39;, \u0026#39;Implementar CDN para recursos estáticos\u0026#39;, \u0026#39;Optimizar tamaño de respuestas (compresión)\u0026#39; ] } return None Con el siguiente resultado:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 56 Cantidad de segundos en promedio para recibir una respuesta(float): 2.8 Cantidad de queries tardan más de 1 segundo(int): 15 Cantidad de conexiones simultáneas(int): 800 ================================================== DIAGNÓSTICO DEL SISTEMA ================================================== #1 - Latencia de red o problemas de conectividad Certeza: 70.0% Recomendaciones: • Verificar latencia entre servidor y clientes • Implementar CDN para recursos estáticos • Optimizar tamaño de respuestas (compresión) ¿Qué aprendemos de este ejemplo? # Estructura del conocimiento: Las reglas están separadas en métodos independientes, lo que hace el sistema modular y fácil de mantener.\nManejo de incertidumbre: Cada regla calcula una \u0026ldquo;certeza\u0026rdquo; basada en qué tan extremos son los valores.\nExplicación del razonamiento: El sistema no solo da un diagnóstico, sino que explica por qué llegó a esa conclusión.\nEscalabilidad: Agregar nuevas reglas es tan simple como crear un nuevo método _regla_*.\nCódigo completo # Aquí tienes el código completo del sistema. También puedes encontrarlo en el repositorio de ejemplos haciendo click en el siguiente enlace.\nlearn-software-engineering/examples Programming Course - Examples Python 1 0 ¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"22 agosto 2025","externalUrl":null,"permalink":"/ai/module1/sample1/","section":"Inteligencia Artificial","summary":"","title":"Machine Learning Ejemplo 1: Sistema Experto","type":"ai"},{"content":"Un array es una estructura de datos que representa un conjunto de elementos, los cuales se acceden a través de índices numéricos contiguos que van desde 0 hasta el tamaño del array menos 1. Los arrays proveen acceso rápido y directo a los elementos en base a su posición.\nEn lenguajes como Python y Ruby, los arrays se conocen como \u0026rsquo;listas\u0026rsquo; (lists). En Javascript se les conoce como \u0026lsquo;arreglos\u0026rsquo; (arrays).\nLos arrays son típicamente homogéneos, almacenando elementos del mismo tipo como enteros, cadenas, etc. Algunos lenguajes permiten arrays heterogéneos con valores de distintos tipos.\nDiagrama de un array Creación de arrays # La manera de crear arrays varía según el lenguaje de programación:\nMI_ARRAY = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] # array literal mi_array = list(range(5)) # array a partir de rango Al crear un array literal se inicializan sus elementos directamente. Al construir un array vacío se especifica su tamaño pero sus elementos son inicializados con un valor default (0 para números, null para objetos, etc).\nAcceder y modificar elementos # Los elementos individuales se acceden rápidamente por su índice utilizando corchetes []:\nmy_array = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] print(my_array[0]) # \u0026#39;a\u0026#39; print(my_array[2]) # \u0026#39;c\u0026#39; my_array[2] = \u0026#39;z\u0026#39; print(my_array[2]) # \u0026#39;z\u0026#39; Los índices comienzan en 0, por lo que en un array de tamaño N, los índices válidos están entre 0 y N-1.\nAcceder a un índice inválido causa un error, por ejemplo, acceder al índice 3 en un array de tamaño 3. Esto se conoce como \u0026ldquo;index out of bounds\u0026rdquo;.\nRecorrer un array # Podemos recorrer todos los elementos usando un ciclo for:\nletras = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] for i in range(len(letras)): print(letras[i]) Esto imprime cada elemento en orden. len() devuelve la longitud total del array.\nOtra forma es iterando directamente sobre los elementos:\nletras = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] for letra in letras: print(letra) Buscar en un array # Podemos buscar un elemento en un array mediante un ciclo y comparando elemento por elemento:\nletras = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] def buscar_en_array(array, elemento): for i in range(len(array)): if array[i] == elemento: return i return False print(buscar_en_array(letras, \u0026#39;b\u0026#39;)) # 1 print(buscar_en_array(letras, \u0026#39;z\u0026#39;)) # False Devuelve el índice si se encuentra o False si no se encuentra.\nArray multidimensional # Los arrays pueden tener más de una dimensión, por ejemplo matrices 2D, cubos 3D, etc.\nUn array 2D se puede ver como una tabla con filas y columnas. Para acceder a un elemento se especifican dos índices, uno para la fila y otro para la columna:\nmatrix = [ [1, 2, 3], [4, 5, 6] ] print(matrix[0][2]) # 3 print(matrix[1][0]) # 4 Pueden tener más dimensiones, por ejemplo un array 3D para representar pixeles en una imagen.\nConclusión # Los arrays son estructuras de datos fundamentales en programación que proveen un acceso eficiente a elementos en memoria mediante índices numéricos. Tener un buen dominio de arrays, matrices y sus usos es indispensable para cualquier programador.\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"30 octubre 2023","externalUrl":null,"permalink":"/programming/data-structures/arrays/","section":"Programación","summary":"","title":"Arreglos","type":"programming"},{"content":" Anatomía de una clase # Una clase actúa como un plano o molde para construir objetos similares, definiendo sus características comunes y funcionalidades. Es similar al plano para construir casas de un mismo barrio: todas comparten ciertos atributos clave.\nLos componentes típicos de una clase son:\nAtributos (propiedades): Variables que caracterizan al objeto. Por ejemplo, para una clase Persona, atributos como nombre, edad, DNI, etc.\nclass Persona: dni = \u0026#34;\u0026#34; nombre = \u0026#34;\u0026#34; edad = 0 Métodos: Funciones que definen comportamientos. Por ejemplo, una Persona puede caminar(), hablar(), comer(), etc. Acceden a los atributos para implementar dicha funcionalidad.\nConstructor: Método especial __init__() que se ejecuta al instanciar la clase y permite inicializar los atributos.\nDestructor: Método __del__() que se ejecuta al eliminar la instancia liberando recursos. Opcional en algunos lenguajes.\nCreando objetos # A partir de la clase generamos objetos, que son instancias concretas con sus propios atributos definidos. Digamos que la clase Casa es el plano, y una casa específica en una calle determinada es el objeto.\nEn código creamos un objeto invocando la clase como si fuera un método:\n# Clase Persona class Persona: def __init__(self, n, e): self.nombre = n self.edad = e # Objeto Persona específico pepe = Persona(\u0026#34;Pepe\u0026#34;, 30) juan = Persona(\u0026#34;Juan\u0026#34;, 35) Cada objeto comparte la estructura y comportamiento general, pero puede almacenar distintos datos.\nUtilizando Propiedades y Métodos # Ya tenemos una clase Persona y un objeto pepe de tipo Persona. ¿Cómo interactuamos con el objeto?\nPropiedades: Es posible acceder al valor de un atributo del objeto utilizando la referencia al objeto (pepe) y el nombre del atributo. pepe.nombre # \u0026#34;Pepe\u0026#34; pepe.edad # 30 Métodos: De la misma manera en la que se accede a los atributos pero agregando un paréntesis dentro del cual se pasan los argumentos si es que recibe alguno. # Clase Persona class Persona: def __init__(self, n, e): self.nombre = n self.edad = e def comer(self, comida): print(f\u0026#34;Comiendo {comida}\u0026#34;) # Objeto Persona específico pepe = Persona(\u0026#34;Pepe\u0026#34;, 30) pepe.comer(\u0026#34;pizza\u0026#34;) # Imprime \u0026#34;Comiendo pizza\u0026#34; El objeto pepe tiene ahora estado (propiedades) y comportamiento (métodos) propios.\nSelf vs This # Un detalle importante en los métodos es cómo acceden a los atributos y otros métodos del objeto. Aquí entra otra diferencia entre lenguajes:\nSelf: En Python, los atributos y métodos se acceden dentro de la clase anteponiendo self. Esto apunta al objeto instanciado. class Persona: def __init__(self, nombre): self.nombre = nombre def saludar(self): print(f\u0026#34;Hola! Soy {self.nombre}\u0026#34;) juan = Persona(\u0026#34;Juan\u0026#34;) juan.saludar() # Imprime \u0026#34;Hola! Soy Juan\u0026#34; This: En Java o C#, se utiliza this en lugar de self. Cumple la misma funcionalidad de apuntar a los miembros del objeto. public class Person { private String nombre; public Person(String nombre) { this.nombre= nombre; } public void saludar() { System.out.println(\u0026#34;Hola! Soy \u0026#34; + this.nombre); } } Person juan = new Person(\u0026#34;Juan\u0026#34;); juan.saludar(); // Imprime \u0026#34;Hola! Soy Juan\u0026#34; Conclusión # Las clases y objetos son los conceptos clave de la POO, permitiendo modelar entidades de la realidad y generar componentes modulares y genéricos de nuestro sistema para construir programas más robustos y fáciles de entender y mantener.\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"02 octubre 2023","externalUrl":null,"permalink":"/programming/oop/classes-objects/","section":"Programación","summary":"","title":"Clases y Objetos","type":"programming"},{"content":" Salida a pantalla # Python también provee funciones para enviar la salida de un programa a la \u0026ldquo;salida estándar\u0026rdquo;, generalmente la pantalla o terminal1.\nLa función print() muestra el valor pasado como parámetro:\nnombre = \u0026#34;Eric\u0026#34; print(nombre) # muestra \u0026#34;Eric\u0026#34; Podemos imprimir múltiples valores separados por comas2:\nprint(\u0026#34;Hola\u0026#34;, nombre, \u0026#34;!\u0026#34;) # muestra \u0026#34;Hola Eric!\u0026#34; También podemos usar valores literales sin asignar a variables3:\nprint(\u0026#34;2 + 3 =\u0026#34;, 2 + 3) # muestra \u0026#34;2 + 3 = 5\u0026#34; Formateo de salida # Python provee varias formas de dar formato a la salida4:\nf-Strings: Permiten insertar variables dentro de una cadena:\nnombre = \u0026#34;Eric\u0026#34; print(f\u0026#34;Hola {nombre}\u0026#34;) # muestra \u0026#34;Hola Eric\u0026#34; %s: Inserta cadenas de texto en una cadena de formato:\nnombre = \u0026#34;Eric\u0026#34; print(\u0026#34;Hola %s\u0026#34; % nombre) # muestra \u0026#34;Hola Eric\u0026#34; %d: Inserta números enteros:\nvalor = 15 print(\u0026#34;El valor es %d\u0026#34; % valor) # muestra \u0026#34;El valor es 15\u0026#34; .format(): Inserta valores en una cadena de formato:\nnombre = \u0026#34;Eric\u0026#34; print(\u0026#34;Hola {}. Bienvenido\u0026#34;.format(nombre)) # muestra \u0026#34;Hola Eric. Bienvenido\u0026#34; Estas opciones de formateo nos permiten interpolar variables y valores en cadenas de texto para generar outputs personalizados. Podemos combinar múltiples valores y formateos en una sola cadena de salida2.\nEntrada desde el teclado # Python provee funciones incorporadas para leer datos ingresados por el usuario en tiempo de ejecución. Esto se conoce como \u0026ldquo;entrada estándar\u0026rdquo;4.\nLa función input() permite leer un valor ingresado por el usuario y asignarlo a una variable. Por ejemplo:\nnombre = input(\u0026#34;Ingresa tu nombre: \u0026#34;) Esto muestra el mensaje \u0026ldquo;Ingresa tu nombre: \u0026quot; y espera a que el usuario escriba un texto y presione Enter. Ese valor se asigna a la variable nombre2.\nLa función input() siempre regresa una cadena de texto. Si queremos pedir un número u otro tipo de dato, debemos convertirlo usando int(), float(), etc1:\nedad = int(input(\u0026#34;Ingresa tu edad: \u0026#34;)) pi = float(input(\u0026#34;Ingresa el valor de pi: \u0026#34;)) Leyendo múltiples valores # Podemos pedir y leer varios valores en una misma línea separándolos con comas3:\nnombre, edad = input(\u0026#34;Ingresa nombre y edad: \u0026#34;).split() El método split() divide la entrada en partes y retorna una lista de cadenas. Luego asignamos los elementos de la lista a variables separadas.\nTambién podemos leer varias líneas de entrada con un ciclo4:\nnombres = [] # lista vacía for x in range(3): nombre = input(\u0026#34;Ingresa un nombre: \u0026#34;) nombres.append(nombre) Este código lee 3 nombres ingresados por el usuario y los agrega a una lista.\nSalida a un archivo # Además de imprimir a pantalla, podemos escribir la salida a un archivo usando la función open()1:\narchivo = open(\u0026#34;datos.txt\u0026#34;, \u0026#34;w\u0026#34;) Esto abre datos.txt para escritura (\u0026ldquo;w\u0026rdquo;) y retorna un objeto archivo.\nLuego usamos archivo.write() para escribir a ese archivo3:\narchivo.write(\u0026#34;Hola mundo!\u0026#34;) archivo.write(\u0026#34;Este texto va al archivo\u0026#34;) Debemos cerrar el archivo con archivo.close() cuando terminamos4:\narchivo.close() También podemos usar with para abrir y cerrar automáticamente2:\nwith open(\u0026#34;datos.txt\u0026#34;, \u0026#34;w\u0026#34;) as archivo: archivo.write(\u0026#34;Hola mundo!\u0026#34;) # no hace falta cerrar, es automático Lectura de archivos # Para leer un archivo usamos open() con modo \u0026ldquo;r\u0026rdquo; y iteramos sobre el objeto archivo1:\nwith open(\u0026#34;datos.txt\u0026#34;, \u0026#34;r\u0026#34;) as archivo: for linea in archivo: print(linea) # muestra cada línea del archivo Esto imprime cada línea, incluyendo los saltos de línea.\nPodemos leer todas las líneas a una lista con readlines()3:\nlinenas = archivo.readlines() print(linenas) Para leer el contenido completo a una cadena usamos read()4:\ntexto = archivo.read() print(texto) También podemos leer un número determinado de bytes o caracteres con read(n)2.\nOperaciones para el manejo de archivos # Existen varias funciones incorporadas para manipular archivos en Python1:\nopen() - Abre un archivo y retorna un objeto archivo close() - Cierra el archivo write() - Escribe datos al archivo read() - Lee datos del archivo readline() - Lee una línea del archivo truncate() - Vacía el archivo seek() - Mueve la posición de lectura/escritura rename() - Renombra el archivo remove() - Elimina el archivo Estas funciones nos permiten efectuar operaciones avanzadas para leer, escribir y mantener archivos.\nConclusión # En este artículo explicamos en detalle operaciones de entrada y salida en Python, incluyendo leer de entrada estándar y escribir a salida estándar o archivos. Manejar correctamente la entrada y salida es esencial para muchas aplicaciones de Python. Recomiendo practicar con ejemplos propios para dominar estas funciones3.\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\nReferencias # McKinney, W. (2018). Python for data analysis: Data wrangling with Pandas, NumPy, and IPython. O\u0026rsquo;Reilly Media.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMatthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. No Starch Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDowney, A. B. (2015). Think Python: How to think like a computer scientist. Needham, Massachusetts: Green Tea Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"19 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/io-operations/","section":"Programación","summary":"","title":"Operaciones de Entrada y Salida","type":"programming"},{"content":"Si alguna vez te has preguntado qué es lo que hace \u0026ldquo;tictac\u0026rdquo; dentro de esa caja metálica que llamamos computadora, estás en el lugar indicado. En esencia, una computadora es una combinación de hardware y software que trabajan juntos para llevar a cabo tareas específicas.\nEl hardware es toda la parte física de la computadora: el CPU (que es como el cerebro de la máquina), la RAM (donde la computadora guarda la información con la que está trabajando en un momento determinado), dispositivos de almacenamiento (donde se guardan los datos de forma permanente) y periféricos (como el teclado, el mouse o la pantalla)1.\nPor otro lado, el software es el conjunto de instrucciones que le dice al hardware qué hacer. Hay varios tipos de software, desde el software del sistema, como el sistema operativo que coordina todas las acciones de la máquina, hasta software de aplicación que nos permite hacer cosas como escribir documentos o jugar videojuegos2.\nEl papel del sistema operativo es crucial. Es el mediador entre el usuario y el hardware, asegurando que todo funcione armónicamente. Si el hardware fuera una orquesta, el sistema operativo sería el director que asegura que cada instrumento toque en el momento y de la manera correcta.\nEl sistema binario: el lenguaje secreto de las computadoras # A diferencia de nosotros, que usamos un sistema decimal basado en diez dígitos (del 0 al 9), las computadoras usan el sistema binario, que solo tiene dos dígitos: 0 y 1. ¿Por qué? Bueno, en el nivel más básico, una computadora está hecha de millones de transistores que pueden estar en uno de dos estados: encendido o apagado. Estos estados se representan con esos dígitos: 0 para apagado y 1 para encendido3.\nLos términos \u0026ldquo;bit\u0026rdquo; y \u0026ldquo;byte\u0026rdquo; son fundamentales aquí. Un bit es la unidad más pequeña de datos en una computadora y puede tener un valor de 0 o 1. Un byte, por otro lado, es un conjunto de 8 bits y puede representar 256 valores diferentes (desde \\(00000000\\) hasta \\(11111111\\) en binario)4.\nEste sistema binario no solo representa números, sino también texto, imágenes y cualquier tipo de dato. Por ejemplo, en el código ASCII (un estándar de codificación de caracteres), la letra \u0026ldquo;A\u0026rdquo; se representa como \\(01000001\\) en binario.\nEn un artículo posterior, vamos a hablar en detalle acerca del sistema binario y otro sistema muy utilizado en el ambiente de la computación, el hexadecimal.\nMemoria y almacenamiento: donde residen nuestros datos # La memoria y el almacenamiento son dos conceptos cruciales en la informática. Si bien a menudo se usan indistintamente, tienen roles muy diferentes.\nLa memoria, específicamente la RAM, es volátil. Esto significa que la información se pierde cuando apagamos la computadora. La RAM es esencialmente el \u0026ldquo;espacio de trabajo\u0026rdquo; de la computadora, donde almacena datos e instrucciones mientras está en uso. Hay varios tipos de RAM, siendo DRAM y SRAM los más comunes5.\nPor otro lado, tenemos la ROM (Memoria de Solo Lectura). A diferencia de la RAM, la ROM no es volátil y se utiliza para almacenar firmware, es decir, software que está íntimamente ligado al hardware y que no necesita cambios frecuentes.\nEn cuanto al almacenamiento, dispositivos como discos duros, SSDs y unidades flash nos permiten guardar información de manera permanente. Estos dispositivos forman parte de lo que se conoce como la jerarquía de memoria, que va desde la memoria caché (rápida pero pequeña) hasta el almacenamiento secundario (más lento pero con gran capacidad)6.\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\nReferencias # Patterson, D. \u0026amp; Hennessy, J. (2014). Arquitectura de Computadoras. Buenos Aires: Ediciones Omega.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSilberschatz, A., Galvin, P. B., \u0026amp; Gagne, G. (2009). Fundamentos de Sistemas Operativos. Buenos Aires: Ediciones M.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A. (2012). Estructura de Computadoras. Buenos Aires: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBrookshear, J. G. (2011). Ciencia de la Computación: Una visión general. Buenos Aires: Pearson Educación.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nJacob, B., Ng, S. W., \u0026amp; Wang, D. T. (2007). Arquitecturas de memoria en sistemas de computadoras. Buenos Aires: Wiley-Interscience.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSiewiorek, D. P. \u0026amp; Swarz, R. S. (2017). Principios de diseño de sistemas computacionales. Buenos Aires: Morgan Kaufmann.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"02 septiembre 2023","externalUrl":null,"permalink":"/programming/intro/computers/","section":"Programación","summary":"","title":"Computadoras","type":"programming"},{"content":"","externalUrl":null,"permalink":"/programming/starting-concepts/","section":"Programación","summary":"","title":"Conceptos Iniciales","type":"programming"},{"content":"","externalUrl":null,"permalink":"/ai/module2/","section":"Inteligencia Artificial","summary":"","title":"Matemática para Machine Learning","type":"ai"},{"content":" Ahora vamos a crear un clasificador de texto básico usando técnicas estadísticas simples. Esto te muestra los conceptos fundamentales detrás de algoritmos más complejos como Naive Bayes. Imaginá que trabajás en una empresa de software y cada día llegan cientos de tickets de soporte técnico. Algunos reportan errores (bugs), otros solicitan nuevas funcionalidades, y otros simplemente piden ayuda. Manualmente clasificar cada ticket tomaría horas de trabajo.\n¿Sería genial si pudiéramos enseñarle a una computadora a leer estos tickets y clasificarlos automáticamente? Este es exactamente el tipo de problema que resuelve el aprendizaje automático (machine learning).\nPara resolver este problema, implementaremos un Clasificador Bayesiano Ingenuo (Naive Bayes Classifier), uno de los algoritmos más elegantes y comprensibles del aprendizaje automático (machine learning). ¿Por qué es perfecto para empezar?\nEs intuitivo: funciona de manera similar a como los humanos categorizamos Es eficiente: requiere relativamente pocos datos de entrenamiento Es interpretable: podemos entender exactamente por qué toma cada decisión Fundamentos matemáticos: el teorema de Bayes # Antes de sumergirnos en el código, entendamos la base matemática. El teorema de Bayes es una regla matemática que nos para invertir probabilidades condicionadas, permitiendonos encontrar la probabilidad de una causa dado su efecto.\nLa probabilidad condicionada es una medida de la probabilidad de que ocurra un evento, dado que ya se sabe que ha ocurrido otro suceso. Si el suceso de interés es \\(A\\) y se sabe o se supone que ha ocurrido el suceso \\(B\\), la probabilidad condicional de \\(A\\) dado \\(B\\), suele escribirse como:\n$$P(A|B)$$Aunque las probabilidades condicionales pueden proporcionar información muy útil, a menudo se cuenta con información limitada. Por lo tanto, puede ser útil invertir la probabilidad condicional utilizando el teorema de Bayes:\n$$P(A|B) = \\frac{P(B|A) \\cdot P(A)}{P(B)}$$En nuestro contexto:\n\\(A\\) = la categoría (BUG, FEATURE, SUPPORT) \\(B\\) = el texto del ticket Entonces queremos calcular:\n$$P(\\text{categoría}|\\text{texto})$$Es decir, la probabilidad de la categoría de un ticket dado la probabilidad de un determinado texto.\nPara clasificación, podemos simplificar la fórmula a:\n$$P(\\text{categoría}|\\text{texto}) \\propto P(\\text{categoría}) \\cdot P(\\text{texto}|\\text{categoría})$$Siendo:\n\\(P(\\text{categoría}|\\text{texto})\\): la probabilidad de que un ticket corresponda a una determinada categoría dado un texto. \\(P(\\text{categoría})\\): la probabilidad de que un ticket sea clasificado como de una determinada categoría. \\(P(\\text{texto}|\\text{categoría})\\): la probabilidad de que el ticket contenta un determinado texto si pertenece a una categoría. En otras palabras, queremos conocer la probabilidad de que un ticket sea una categoría. Para ello, necesitamos saber la probabilidad de que dicha categoría aplique a un ticket, y la probabilidad con la que determinadas palabras aparecen en los tickets de una determinada categoría.\nEstructura básica del sistema # Comenzaremos definiendo la estructura del sistema, por lado, crearemos una clase que actuará como clasificador y una función main que será la encargada de entrenarlo y de enviarle nuevos tickets para determinar su categoría.\nfrom collections import defaultdict, Counter class ClasificadorTextoBasico: \u0026#34;\u0026#34;\u0026#34; Clasificador de texto usando probabilidades bayesianas básicas. Útil para clasificar emails, reseñas, tickets de soporte, etc. \u0026#34;\u0026#34;\u0026#34; def __init__(self): # Almacena las frecuencias de palabras por categoría self.palabras_por_categoria = defaultdict(Counter) # Almacena cuántos tickets hay por categoría self.tickets_por_categoria = defaultdict(int) # Lista de todas las categorías conocidas self.categorias = set() # Vocabulario total (todas las palabras únicas) self.vocabulario = set() def entrenar(self, datos): \u0026#34;\u0026#34;\u0026#34; Entrena el clasificador con ejemplos de texto etiquetados. Args: datos (list): Lista de tuplas cuyo primer valor es el contenido del ticket y el segundo valor, la categoría correspondiente. \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;Entrenando clasificador con {len(datos)} ejemplos...\u0026#34;) pass # Ejemplo práctico: Clasificador de tickets de soporte if __name__ == \u0026#34;__main__\u0026#34;: # Datos de entrenamiento simulando tickets de soporte técnico # Cada elemento de la lista contiene una tupla compuesta por # la descripción del ticket y la categoría a la que pertenece. datos_de_entrenamiento = [ (\u0026#34;La aplicación se cierra inesperadamente al hacer click en enviar\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;Error 500 al intentar subir archivo grande\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;El botón de guardar no funciona en Firefox\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;Pantalla en blanco después de iniciar sesión\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;Los datos no se actualizan correctamente en la tabla\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;Mensaje de error extraño al procesar el pago\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;Sería genial poder exportar reportes a Excel\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Necesitamos filtros avanzados en el listado de productos\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Propongo agregar notificaciones push para mensajes\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Falta la opción de cambiar el idioma de la interfaz\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Queremos integración con Google Calendar\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Deberíamos tener dashboard personalizable para cada usuario\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Cómo puedo cambiar mi contraseña\u0026#34;, \u0026#34;SUPPORT\u0026#34;), (\u0026#34;No entiendo cómo funciona el sistema de permisos\u0026#34;, \u0026#34;SUPPORT\u0026#34;), (\u0026#34;Necesito ayuda para configurar mi perfil\u0026#34;, \u0026#34;SUPPORT\u0026#34;), (\u0026#34;Dónde encuentro las estadísticas de ventas\u0026#34;, \u0026#34;SUPPORT\u0026#34;), (\u0026#34;Instrucciones para conectar con la API\u0026#34;, \u0026#34;SUPPORT\u0026#34;), (\u0026#34;Tutorial para usar las funciones avanzadas\u0026#34;, \u0026#34;SUPPORT\u0026#34;) ] # Crear y entrenar el clasificador clasificador = ClasificadorTextoBasico() clasificador.entrenar(datos_de_entrenamiento) El clasificador almacena los siguientes datos:\npalabras_por_categoria: automáticamente cuenta frecuencias de palabras que aparecen por categoría tickets_por_categoria: la cantidad de tickets conocidos en cada categoría. Necesario para calcular \\(P(\\text{categoría})\\) categorias: listado de las categorías conocidas vocabulario: conjunto de todas las palabras únicas que hemos visto Preprocesamiento del texto # Antes de continuar, es necesario incluir una función para preprocesar el texto. Los textos que escribimos pueden tener muchas variaciones, necesitamos convertirlo a una forma estándar, sin distinciones entre mayúsculas y minúsculas, signos de puntuación, tildes, etcétera.\ndef preprocesar_texto(self, texto): \u0026#34;\u0026#34;\u0026#34; Limpia y tokeniza el texto de entrada. Args: texto (str): Texto a procesar Returns: list: Lista de palabras limpias en minúsculas \u0026#34;\u0026#34;\u0026#34; # Convertir a minúsculas texto = texto.lower() # Separa las letras de sus diacríticos texto = unicodedata.normalize(\u0026#39;NFD\u0026#39;, texto) # Elimina los caracteres de tipo marca diacrítica (Mn), es decir, las tildes y diéresis texto = \u0026#39;\u0026#39;.join(c for c in texto if unicodedata.category(c) != \u0026#39;Mn\u0026#39;) # Tokenizar (dividir en palabras) palabras = texto.split() # Filtrar palabras muy cortas palabras = [p for p in palabras if len(p) \u0026gt;= 3] return palabras ¿Por qué estos pasos?\nMinúsculas: \u0026ldquo;Error\u0026rdquo; y \u0026ldquo;error\u0026rdquo; deben tratarse igual Sin puntuación: Nos enfocamos en las palabras, no en la estructura Filtrar palabras cortas: \u0026ldquo;el\u0026rdquo;, \u0026ldquo;de\u0026rdquo;, \u0026ldquo;un\u0026rdquo; aportan poco valor discriminativo Entrenando el sistema # El siguiente paso, es entrenar el sistema con datos conocidos para que aprenda a cuando aplicar una categoría u otra dependiendo del texto recibido. Durante el entrenamiento, el algoritmo \u0026ldquo;memoriza\u0026rdquo; qué palabras aparecen frecuentemente en cada categoría, y las agrupa según la categoría dada. Por ejemplo, si vemos \u0026ldquo;error\u0026rdquo; en 10 tickets con la categoría BUG y solo 1 perteneciente a FEATURE, el algoritmo aprende que \u0026ldquo;error\u0026rdquo; es una fuerte señal de BUG.\ndef entrenar(self, datos): \u0026#34;\u0026#34;\u0026#34; Entrena el clasificador con ejemplos de texto etiquetados. Args: datos (list): Lista de tuplas cuyo primer valor es el contenido del ticket y el segundo valor, la categoría correspondiente. \u0026#34;\u0026#34;\u0026#34; for texto, categoria in datos: palabras = self.preprocesar_texto(texto) # Actualizar contadores self.categorias.add(categoria) self.tickets_por_categoria[categoria] += 1 # Contar frecuencia de cada palabra en esta categoría for palabra in palabras: self.palabras_por_categoria[categoria][palabra] += 1 self.vocabulario.add(palabra) print(f\u0026#34;Entrenamiento completado:\u0026#34;) print(f\u0026#34; * Categorías: {sorted(self.categorias)}\u0026#34;) print(f\u0026#34; * Vocabulario: {len(self.vocabulario)} palabras únicas\u0026#34;) for cat in sorted(self.categorias): print(f\u0026#34; * \u0026#39;{cat}\u0026#39;: {self.tickets_por_categoria[cat]} tickets\u0026#34;) Hasta aquí obtendremos esto cuando ejecutamos el programa:\nEntrenando clasificador con 18 ejemplos... Entrenamiento completado: * Categorías: [\u0026#39;BUG\u0026#39;, \u0026#39;FEATURE\u0026#39;, \u0026#39;SUPPORT\u0026#39;] * Vocabulario: 80 palabras únicas * \u0026#39;BUG\u0026#39;: 6 tickets * \u0026#39;FEATURE\u0026#39;: 6 tickets * \u0026#39;SUPPORT\u0026#39;: 6 tickets Cálculo de probabilidades # Aquí presentamos el corazón del algoritmo, realizaremos los cálculos de probabilidades por palabra que luego servirán para clasificar tickets.\ndef calcular_probabilidad_palabra(self, palabra, categoria): \u0026#34;\u0026#34;\u0026#34; Calcula P(palabra|categoria) usando suavizado de Laplace. El suavizado evita probabilidades de 0 para palabras no vistas. Args: palabra (str): Palabra a evaluar categoria (str): Categoría a evaluar Returns: float: Probabilidad de la palabra dada la categoría \u0026#34;\u0026#34;\u0026#34; # Frecuencia de la palabra en esta categoría frecuencia_palabra = self.palabras_por_categoria[categoria][palabra] # Total de palabras en esta categoría total_palabras_categoria = sum(self.palabras_por_categoria[categoria].values()) # Suavizado de Laplace: sumamos 1 al numerador y |vocabulario| al denominador # Esto evita probabilidades de 0 para palabras nuevas probabilidad = (frecuencia_palabra + 1) / (total_palabras_categoria + len(self.vocabulario)) return probabilidad ¿Qué es el suavizado de Laplace?\nCon las técnicas de suavizado intentamos evitar las probabilidades cero producidas por palabras no vistas.\nSin suavizado, si una palabra nunca apareció en una categoría, su probabilidad sería \\(0\\), y todo el cálculo se volvería \\(0\\).\nCon la técnica de suavizado de Laplace, agregamos \\(1\\) al numerador y el tamaño del vocabulario al denominador. Esto da una probabilidad pequeña pero no nula a palabras no vistas.\n$$P(\\text{palabra}|\\text{categoría}) = \\frac{\\text{frecuencia} + 1}{\\text{palabras en categoría} + \\text{tamaño vocabulario}}$$ Clasificando nuevos tickets # Ahora sí llegó el momento de inyectar nuevos tickets y dejar que el algoritmo los clasifique utilizando las probabilidades calculadas antes.\ndef clasificar(self, texto): \u0026#34;\u0026#34;\u0026#34; Clasifica un texto usando el teorema de Bayes. P(categoria|texto) ∝ P(categoria) * ∏P(palabra|categoria) Args: texto (str): Texto a clasificar Returns: dict: Probabilidades por categoría \u0026#34;\u0026#34;\u0026#34; palabras = self.preprocesar_texto(texto) # Calculamos log-probabilidades para evitar underflow # (multiplicar muchas probabilidades pequeñas da números muy pequeños) log_probabilidades = {} for categoria in sorted(self.categorias): # P(categoria) = tickets_categoria / total_tickets total_tickets = sum(self.tickets_por_categoria.values()) prob_categoria = self.tickets_por_categoria[categoria] / total_tickets # Empezamos con log(P(categoria)) log_prob = math.log(prob_categoria) # Multiplicamos por P(palabra|categoria) para cada palabra # En log-space: log(a*b) = log(a) + log(b) for palabra in palabras: prob_palabra = self.calcular_probabilidad_palabra(palabra, categoria) log_prob += math.log(prob_palabra) log_probabilidades[categoria] = log_prob # Convertir de vuelta a probabilidades normales # Usamos el truco: exp(log_prob - max_log_prob) para estabilidad numérica max_log_prob = max(log_probabilidades.values()) probabilidades = {} for categoria, log_prob in log_probabilidades.items(): probabilidades[categoria] = math.exp(log_prob - max_log_prob) # Normalizar para que sumen 1 total = sum(probabilidades.values()) for categoria in probabilidades: probabilidades[categoria] /= total return probabilidades Te estarás preguntando, ¿por qué usar logaritmos?, lo que sucede es que multiplicar muchas probabilidades pequeñas puede resultar en números extremadamente pequeños, esto puede conducir a lo que en computación se denomina underflow. Esto significa que la computadora no puede representar un número tan pequeño y se pueden producir errores inesperados o excepciones.\nLos logaritmos transforman multiplicaciones en sumas y así evitamos el underflow.\n$$\\log(a \\times b \\times c) = \\log(a) + \\log(b) + \\log(c)$$ Probando el clasificador # Agregamos el siguiente código a la función main para ejecutar el clasificador en tickets diferentes utilizados en el entrenamiento.\n# Probar con tickets nuevos print(\u0026#34;\\n\\nPROBANDO CLASIFICADOR CON TICKETS NUEVOS:\u0026#34;) print(\u0026#34;=\u0026#34; * 60) tickets_prueba = [ \u0026#34;La pagina queda en blanco cuando cargo muchos productos\u0026#34;, \u0026#34;Me gustaría poder ordenar la lista por fecha de creación\u0026#34;, \u0026#34;No sé cómo resetear mi cuenta de usuario\u0026#34; ] for i, ticket in enumerate(tickets_prueba, 1): print(f\u0026#34;\\n#{i}: \u0026#39;{ticket}\u0026#39;\u0026#34;) resultados = clasificador.clasificar(ticket) # Mostrar probabilidades ordenadas for categoria, prob in sorted(resultados.items(), key=lambda x: x[1], reverse=True): print(f\u0026#34; {categoria}: {prob:.1%}\u0026#34;) # Mostrar predicción final mejor_categoria = max(resultados.items(), key=lambda x: x[1]) print(f\u0026#34; -\u0026gt; CLASIFICACIÓN: {mejor_categoria[0]} ({mejor_categoria[1]:.1%} confianza)\u0026#34;) Obtenemos la siguiente respuesta:\nPROBANDO CLASIFICADOR CON TICKETS NUEVOS: ============================================================ #1: \u0026#39;La pagina queda en blanco cuando cargo muchos productos\u0026#39; BUG: 41.9% FEATURE: 32.6% SUPPORT: 25.5% -\u0026gt; CLASIFICACIÓN: BUG (41.9% confianza) #2: \u0026#39;Me gustaría poder ordenar la lista por fecha de creación\u0026#39; FEATURE: 42.5% SUPPORT: 31.2% BUG: 26.4% -\u0026gt; CLASIFICACIÓN: FEATURE (42.5% confianza) #3: \u0026#39;No sé cómo resetear mi cuenta de usuario\u0026#39; SUPPORT: 55.1% FEATURE: 28.5% BUG: 16.4% -\u0026gt; CLASIFICACIÓN: SUPPORT (55.1% confianza) Entendiendo las decisiones (interpretabilidad) # Una ventaja clave de Naive Bayes es que podemos inspeccionar lo qué aprendió:\ndef palabras_mas_representativas(self, n=10): \u0026#34;\u0026#34;\u0026#34; Encuentra las palabras que mejor distinguen entre categorías. Útil para entender lo que aprendió el modelo. \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\nTOP {n} PALABRAS MÁS REPRESENTATIVAS POR CATEGORÍA:\u0026#34;) print(\u0026#34;=\u0026#34; * 60) for categoria in sorted(self.categorias): # Calculamos la \u0026#34;representatividad\u0026#34; de cada palabra # usando la frecuencia relativa en esta categoría vs otras scores = {} for palabra in sorted(self.vocabulario): freq_categoria = self.palabras_por_categoria[categoria][palabra] total_categoria = sum(self.palabras_por_categoria[categoria].values()) # Frecuencia en otras categorías freq_otras = 0 total_otras = 0 for otra_cat in self.categorias: if otra_cat != categoria: freq_otras += self.palabras_por_categoria[otra_cat][palabra] total_otras += sum(self.palabras_por_categoria[otra_cat].values()) if total_otras \u0026gt; 0: # Relación de frecuencias relativas rel_freq_cat = (freq_categoria + 1) / (total_categoria + len(self.vocabulario)) rel_freq_otras = (freq_otras + 1) / (total_otras + len(self.vocabulario)) scores[palabra] = rel_freq_cat / rel_freq_otras # Mostrar palabras mas representativas top_palabras = sorted(scores.items(), key=lambda x: (-x[1], x[0]))[:n] print(f\u0026#34;\\n {categoria.upper()}:\u0026#34;) for palabra, score in top_palabras: print(f\u0026#34; • {palabra:\u0026lt;15} (score: {score:.2f})\u0026#34;) Esto nos muestra qué palabras son más características de cada categoría.\nDesde la función main consultamos las palabras más representativas.\n# Mostrar palabras más representativas clasificador.palabras_mas_representativas(15) Obteniendo:\nTOP 15 PALABRAS MÁS REPRESENTATIVAS POR CATEGORÍA: ============================================================ BUG: * error (score: 3.83) * actualizan (score: 2.55) * aplicacion (score: 2.55) * archivo (score: 2.55) * blanco (score: 2.55) * boton (score: 2.55) * cierra (score: 2.55) * click (score: 2.55) * correctamente (score: 2.55) * datos (score: 2.55) * despues (score: 2.55) * enviar (score: 2.55) * extrano (score: 2.55) * firefox (score: 2.55) * grande (score: 2.55) FEATURE: * agregar (score: 2.39) * avanzados (score: 2.39) * cada (score: 2.39) * calendar (score: 2.39) * dashboard (score: 2.39) * deberiamos (score: 2.39) * excel (score: 2.39) * exportar (score: 2.39) * falta (score: 2.39) * filtros (score: 2.39) * genial (score: 2.39) * google (score: 2.39) * idioma (score: 2.39) * integracion (score: 2.39) * interfaz (score: 2.39) SUPPORT: * como (score: 4.02) * avanzadas (score: 2.68) * ayuda (score: 2.68) * conectar (score: 2.68) * configurar (score: 2.68) * contrasena (score: 2.68) * donde (score: 2.68) * encuentro (score: 2.68) * entiendo (score: 2.68) * estadisticas (score: 2.68) * funciones (score: 2.68) * instrucciones (score: 2.68) * necesito (score: 2.68) * perfil (score: 2.68) * permisos (score: 2.68) Análisis y extensiones # ¿Por qué se llama Naive (Ingenuo)? Porque asume que todas las palabras son independientes entre sí. En realidad, sabemos que esto no es cierto, \u0026ldquo;no funciona\u0026rdquo; tiene un significado diferente que \u0026ldquo;no\u0026rdquo; y \u0026ldquo;funciona\u0026rdquo; por separado.\nSin embargo, esta simplicidad es también su fortaleza:\nEficiencia: requiere menos datos y cómputo Robustez: funciona bien incluso cuando la suposición no se cumple perfectamente Interpretabilidad: fácil de entender y depurar Ventajas Limitaciones Rápido de entrenar y clasificar Asume independencia de palabras Funciona bien con pocos datos Sensible a características irrelevantes Maneja bien múltiples categorías Puede dar probabilidades mal calibradas Probabilidades interpretables No captura orden de palabras Resistente al sobreajuste Extensiones posibles # Una vez que domines este clasificador básico, puedes explorar:\nN-gramas: Considerar procesar grupos de dos, tres o \\(N\\) palabras TF-IDF: Pesar palabras por su importancia relativa Validación cruzada: Evaluar mejor el rendimiento Características adicionales: Longitud del texto, mayúsculas, etc. ¿Qué aprendemos de este ejemplo? # El preprocesamiento es crucial: Limpiar y normalizar el texto afecta directamente la calidad del modelo.\nTeorema de Bayes en acción: Combinamos la probabilidad previa P(categoría) con la evidencia P(palabras|categoría).\nSuavizado de Laplace: Técnica esencial para manejar palabras que no vimos durante el entrenamiento.\nLog-probabilidades: Truco numérico para evitar underflow al multiplicar muchas probabilidades pequeñas.\nInterpretabilidad: Podemos entender qué palabras son más importantes para cada categoría.\nCódigo completo # Aquí tienes el código completo del sistema. También puedes encontrarlo en el repositorio de ejemplos haciendo click en el siguiente enlace.\nlearn-software-engineering/examples Programming Course - Examples Python 1 0 Conclusión # ¡Has construido tu primer clasificador de Machine Learning desde cero! Este clasificador Bayesiano Ingenuo (Naive Bayes) demuestra algunos conceptos fundamentales:\nAprendizaje supervisado: Aprender de ejemplos etiquetados Probabilidad: Cuantificar incertidumbre Generalización: Aplicar lo aprendido a casos nuevos Interpretabilidad: Entender las decisiones del modelo Aunque se vea simple, este tipo de clasificador se usa en aplicaciones reales como filtros de spam, análisis de sentimientos, clasificación de documentos, moderación de contenido, entre otros.\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"26 agosto 2025","externalUrl":null,"permalink":"/ai/module1/sample2/","section":"Inteligencia Artificial","summary":"","title":"Machine Learning Ejemplo 2: Sistema de Clasificación","type":"ai"},{"content":"In Object-Oriented Programming, classes don\u0026rsquo;t exist in isolation. They interact and relate to each other in various ways to model complex systems and relationships. Understanding these relationships is crucial for designing effective and maintainable object-oriented systems.\nThe main types of class relationships we\u0026rsquo;ll explore in depth are:\nAssociation (\u0026ldquo;uses-a\u0026rdquo;) Aggregation (weak \u0026ldquo;has-a\u0026rdquo; relationship) Composition (strong \u0026ldquo;has-a\u0026rdquo; relationship) Inheritance (\u0026ldquo;is-a\u0026rdquo; relationship) Realisation (Implementation) Dependency Each of these relationships represents a different way that classes can be connected and interact with each other. They vary in terms of the strength of the coupling between classes, the lifecycle dependencies, and the nature of the relationship.\nBefore we dive into each type of relationship, let\u0026rsquo;s visualise them using a UML class diagram:\nclassDiagram class ClassA class ClassB class ClassC class ClassD class ClassE class ClassF class InterfaceG ClassA --\u003e ClassB : Association ClassC o-- ClassD : Aggregation ClassE *-- ClassF : Composition ClassB --|\u003e ClassA : Inheritance ClassE ..|\u003e InterfaceG : Realisation ClassA ..\u003e ClassF : Dependency end This diagram provides a high-level overview of the different types of class relationships. In the following sections, we\u0026rsquo;ll explore each of these relationships in detail, providing explanations, examples, and more specific UML diagrams.\n","date":"07 diciembre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-introduction/","section":"Programming","summary":"","title":"Class relations","type":"programming"},{"content":"Un diccionario, o mapa, consiste en una colección de pares clave-valor. La clave se utiliza para acceder al valor asociado. Las claves deben ser únicas dentro de un diccionario. Los valores pueden repetirse.\nDiagrama de un diccionario Operaciones principales # Añadir/actualizar: Inserta un par clave-valor. Si la clave existía, su valor es reemplazado. diccionario[\u0026#39;clave\u0026#39;] = \u0026#39;valor\u0026#39; Obtener valor: Acceder al valor dada una clave. valor = diccionario[\u0026#39;clave\u0026#39;] Eliminar: Remueve un par clave-valor del diccionario. del diccionario[\u0026#39;clave\u0026#39;] Recorrer: Iterar sobre las claves, valores o pares del diccionario. for clave in diccionario: print(clave, diccionario[clave]) # clave, valor Creación de un diccionario o mapa # La sintaxis para crear mapas o diccionarios en Python es la siguiente:\ndiccionario_vacio = {} persona = { \u0026#39;nombre\u0026#39;: \u0026#39;Juan\u0026#39;, \u0026#39;edad\u0026#39;: 25 } Ejemplos de uso # Los diccionarios son útiles en muchos casos. A continuación se mencionan algunos de ellos.\nObjetos y mapeos # Podemos modelar objetos y entidades con atributos clave-valor:\nproducto = { \u0026#39;nombre\u0026#39;: \u0026#39;Smartphone\u0026#39;, \u0026#39;precio\u0026#39;: 500, \u0026#39;marca\u0026#39;: \u0026#39;XYZ\u0026#39; } Conteos y frecuencias # Contar ocurrencias de elementos en secuencias:\ntexto = \u0026#34;Hola mundo mundo\u0026#34; frecuencias = {} for palabra in texto.split(): if palabra in frecuencias: frecuencias[palabra] += 1 else: frecuencias[palabra] = 1 print(frecuencias) # {\u0026#39;Hola\u0026#39;: 1, \u0026#39;mundo\u0026#39;: 2} Almacenar y acceder a datos # Como alternativa de alta performance a lists y arrays.\nConclusión # Los diccionarios son estructuras de datos versátiles gracias a su rápido acceso basado en claves únicas. Tienen usos en casi todos los programas, por lo que dominar diccionarios es indispensable en cualquier lenguaje.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrarás en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\n","date":"30 octubre 2023","externalUrl":null,"permalink":"/programming/data-structures/maps/","section":"Programación","summary":"","title":"Mapas (Diccionarios)","type":"programming"},{"content":" Condiciones: tomando decisiones en el código # La vida está llena de decisiones: \u0026ldquo;Si llueve, llevaré un paraguas. De lo contrario, usaré anteojos de sol\u0026rdquo;. Estas decisiones también están presentes en el mundo de la programación. Las condiciones son como preguntas que la computadora se hace. Nos permiten tomar decisiones y ejecutar código específico dependiendo de una condición1. Pueden ser simples como \u0026ldquo;¿Está lloviendo?\u0026rdquo; o complejas como \u0026ldquo;¿Es fin de semana y tengo menos de $100 en mi cuenta bancaria?\u0026rdquo;.\nif # La estructura if nos permite evaluar condiciones y tomar decisiones basadas en el resultado de esa evaluación.\nedad = 15 if edad \u0026gt;= 18: print(\u0026#34;Eres mayor de edad\u0026#34;) El código anterior permite ejecutar una porción de código si la edad de una persona es mayo o igual a 18 años.\nif-else # Cuando se desea ejecutar un código alternativo si la condición es falsa, utilizamos la estructura if-else\nedad = 21 if edad \u0026gt;= 18: print(\u0026#34;Eres mayor de edad\u0026#34;) else: print(\u0026#34;Eres menor de edad\u0026#34;) En este caso, se determina si la persona es mayor de edad, o menor de edad, el mensaje mostrado es diferente\nif-elif-else # Cuando las condiciones son múltiples y no es suficientes con dos caminos, se utiliza la estructura if-elif-else para evaluarlas forma encadenada.\nedad = 5 if edad \u0026lt;= 13: print(\u0026#34;Eres un niño\u0026#34;) elif edad \u0026gt; 13 and edad \u0026lt; 18: print(\u0026#34;Eres un adolescente\u0026#34;) else: print(\u0026#34;Eres un adulto\u0026#34;) En el código anterior se observan tres caminos claros, uno para cuando la edad es menor o igual a 13 años, otro para cuando la edad esta entre 13 y 18 y otro para cuando es mayor o igual a 18.\nOtra manera de resolver este problema es mediante la estructura switch-case, que, aunque Python no incorpora de manera nativa, como si lo hacen otros lenguajes como Java o C++, es una herramienta importante para conocer. Esta estructura permite a los programadores manejar múltiples condiciones de manera más organizada que una serie de if-elif-else.\nEn Java, por ejemplo:\nint dia = 3; switch(dia) { case 1: System.out.println(\u0026#34;Lunes\u0026#34;); break; case 2: System.out.println(\u0026#34;Martes\u0026#34;); break; case 3: System.out.println(\u0026#34;Miércoles\u0026#34;); break; // ... y así sucesivamente default: System.out.println(\u0026#34;Día no válido\u0026#34;); } En el ejemplo anterior, dependiendo del valor de dia, se imprimirá el día correspondiente2.\nBucles: repitiendo acciones # A veces, en programación, necesitamos repetir una acción varias veces. En lugar de escribir el mismo código varias veces, podemos usar bucles. Estos, permiten repetir la ejecución de un bloque de código mientras se cumpla una condición3.\nwhile # El bucle while es útil cuando queremos repetir una acción basada en una condición.\n# Imprime del 1 al 5 i = 1 while i \u0026lt;= 5: print(i) i = i + 1 do-while # Similar a while pero garantiza al menos una ejecución dado que primero se ejecuta el bloque de código y luego se evalúa la condición. Python no implementa esta estructura, pero otros lenguajes como Java y C++ sí lo hacen.\nint i = 1; do { System.out.println(i); i++; } while(i \u0026lt;= 5); int numero = 0; do { std::cout \u0026lt;\u0026lt; \u0026#34;Hola, mundo!\u0026#34; \u0026lt;\u0026lt; std::endl; numero++; } while (numero \u0026lt; 5); for # El bucle for es útil cuando sabemos cuántas veces queremos repetir una acción.\nfor i in range(5): print(\u0026#34;Hola, mundo!\u0026#34;) El código anterior imprimirá \u0026ldquo;Hola, mundo!\u0026rdquo; cinco veces.\nTambién podemos iterar sobre los elementos de una lista u objeto iterable:\nnombres = [\u0026#34;María\u0026#34;, \u0026#34;Florencia\u0026#34;, \u0026#34;Julián\u0026#34;] for nombre in nombres: print(f\u0026#34;Hola {nombre}\u0026#34;) # Imprime # Hola María # Hola Florencia # Hola Julián Las sentencias break y continue # Podemos usar break para terminar el bucle y continue para saltar a la siguiente iteración.\nEl break se usa para terminar completamente el bucle cuando se cumple una condición, en el ejemplo siguiente, cuando i llega a 5.\n# Ejemplo de break i = 0 while i \u0026lt; 10: print(i) if i == 5: break i += 1 # Imprime: # 0 # 1 # 2 # 3 # 4 # 5 El continue se usa para saltarse una iteración del bucle y continuar con la siguiente cuando se cumple una condición. Aquí lo usamos para saltarnos los números pares.\n# Ejemplo de continue i = 0 while i \u0026lt; 10: i += 1 if i % 2 == 0: continue print(i) # Imprime: # 1 # 3 # 5 # 7 # 9 Anidamiento: combinando estructuras # Las estructuras de control de flujo pueden anidarse dentro de otras. Por ejemplo, podemos tener bucles dentro de bucles o condiciones dentro de bucles.\nfor i in range(5): for j in range(10): if (i % 2 == 0 and j % 3 == 0): print(f\u0026#34;i = {i}, j = {j}\u0026#34;) Este código imprimirá combinaciones de i y j sólo cuando i sea divisible por 2 y j sea divisible por 3, demostrando cómo los bucles se anidan y se ejecutan3.\nPatrones de uso comunes # Existen patrones específicos para resolver necesidades habituales con control de flujo.\nBúsqueda # Buscar un valor en una colección:\nfrutas = [\u0026#34;manzana\u0026#34;, \u0026#34;naranja\u0026#34;] buscando = \u0026#34;naranja\u0026#34; encontrado = False for fruta in frutas: if fruta == buscando: encontrado = True break if encontrado: print(\u0026#34;Fruta encontrada!\u0026#34;) Acumulación # Acumular valores incrementales en un bucle.\ntotal = 0 for i in range(10): total += i print(total) # Suma de 0..9 = 45 Diagramas de flujo: la ruta visual hacia el entendimiento del código # Los programadores, sin importar si son principiantes o expertos, a menudo se encuentran enfrentando desafíos que requieren una planificación detallada antes de sumergirse en el código. Aquí es donde los diagramas de flujo entran en juego como una herramienta esencial. Estos diagramas son representaciones gráficas de los procesos y la lógica detrás de un programa o sistema. En este artículo, desentrañaremos el mundo de los diagramas de flujo, desde sus conceptos básicos hasta las técnicas avanzadas, y cómo pueden beneficiar a programadores de todos los niveles.\nUn diagrama de flujo es una representación gráfica de un proceso. Utiliza símbolos específicos para representar diferentes tipos de instrucciones o acciones. Su objetivo principal es simplificar la comprensión de un proceso, mostrando paso a paso cómo fluye la información o las decisiones. Estos diagramas:\nFacilitan la comprensión de procesos complejos. Ayudan en la fase de diseño y planificación de un programa. Sirven como documentación y referencia para futuros desarrollos. Los diagramas de flujo son una herramienta poderosa que no solo beneficia a los principiantes, sino también a los programadores experimentados. Ofrecen una visión clara y estructurada de un proceso o programa, facilitando la planificación, el diseño y la comunicación entre los miembros del equipo.\nElementos básicos # Los diagramas de flujo constan de varios símbolos, cada uno con un significado específico:\nOvalo: Representa el inicio o el fin de un proceso. Rectángulo: Denota una operación o instrucción. Diamante: Indica una decisión basada en una condición. Flechas: Muestran la dirección del flujo. graph TD; start((Inicio)) process[Proceso] decision{¿Repetir?} final((Final)) start --\u003e process; process --\u003e decision; decision --\u003e |Si| process decision --\u003e |No| final end Ejemplos # Vamos a diseñar un diagrama de flujo para un programa que pida un número y nos diga si es par o impar.\ngraph TB inicio((Inicio)) entrada[Ingresar número] decision{¿Es par?} esPar[Es par] esImpar[Es impar] final((Final)) inicio --\u003e entrada entrada --\u003e decision decision --\u003e |Si| esPar decision --\u003e |No| esImpar esPar --\u003e final esImpar --\u003e final end Conforme los programas se vuelven más complejos, es posible que necesites incorporar bucles, múltiples condiciones y otros elementos avanzados en tu diagrama de flujo. Por ejemplo, aquí diagramamos un programa que sume los números desde el 1 al número ingresado por el usuario.\ngraph TD inicio((Inicio)) entrada[Ingresar número] setVariables[Establecer suma=0 y contador=1] bucle_condicion{¿contador \u003c= N?} bucle_codigo[Sumar valor e incrementar el contador] resultado[Mostrar suma] final((Final)) inicio --\u003e entrada entrada --\u003e setVariables setVariables --\u003e bucle_condicion bucle_condicion --\u003e |Si| bucle_codigo bucle_codigo --\u003e bucle_condicion bucle_condicion --\u003e |No| resultado resultado --\u003e final end Conclusión # El control de flujo es el corazón de la programación. Sin él, los programas serían secuencias lineales de acciones sin la capacidad de tomar decisiones o repetir tareas. Al dominar estas estructuras, no solo mejoras tu capacidad para escribir código, sino también tu capacidad para pensar lógicamente y resolver problemas complejos.\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\nReferencias # Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDeitel, P., \u0026amp; Deitel, H. (2012). Java: How to program. Upper Saddle River, NJ: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMatthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. San Francisco, CA: No Starch Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"27 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/flow-control-structures/","section":"Programación","summary":"","title":"Control de Flujo","type":"programming"},{"content":" El sistema decimal: la base de nuestra cotidianidad # Desde pequeños, nos enseñan a contar usando diez dígitos: del 0 al 9. Este sistema, conocido como decimal, es la base de casi todas nuestras actividades matemáticas y financieras, desde sumar cuentas hasta calcular intereses en el banco1. Tiene su origen en la cantidad de dedos que tenemos en las manos, lo que lo convierte en el sistema más intuitivo y natural para nosotros. Pero lo que lo hace especial es su naturaleza posicional.\nPara comprender este concepto, consideremos el número 237:\nEl 7, situado a la derecha, está en la posición de las unidades. Es decir, \\(7 \\times 10^0\\) (cualquier número elevado a la potencia de 0 es 1). Por lo tanto, su valor es simplemente 7. El 3, en la posición del medio, representa las decenas, es decir, \\(3 \\times 10^1 = 3 \\times 10 = 30\\). El 2, el número más a la izquierda, está en la posición de las centenas, traduciéndose a \\(2 \\times 10^2 = 2 \\times 100 = 200\\). Si sumamos estos valores,\n2 \\times 10^2 + 3 \\times 10^1 + 7 \\times 10^0 = 200 + 30 + 7 = 237 El sistema binario: el lenguaje secreto de las computadoras # Si bien el sistema decimal domina nuestra vida cotidiana, las máquinas que usamos todos los días, desde nuestros celulares hasta las computadoras, operan en un mundo completamente diferente: el mundo binario. En este sistema, solo existen dos dígitos: 0 y 1. A primera vista, puede parecer limitante, pero este sistema es la esencia de la electrónica digital. Los dispositivos electrónicos, con sus millones de transistores, operan usando estos dos estados: encendido (1) y apagado (0)2.\nA pesar de su aparente simplicidad, el sistema binario puede representar cualquier cantidad o información que el sistema decimal pueda expresar. Por ejemplo, el número decimal 5 se representa como 101 en binario.\nEl sistema binario, con sus unos y ceros, opera de manera similar al sistema decimal, pero en lugar de potencias de 10, usa potencias de 2.\nTomemos el número binario 1011:\nEl bit más a la derecha representa \\(1 \\times 2^0 = 1\\) El siguiente bit representa \\(1 \\times 2^1 = 2\\) Luego viene \\(0 \\times 2^2 = 0\\) El bit más a la izquierda en este número representa \\(1 \\times 2^3 = 8\\) Entonces, 1011 en binario se traduce a decimal de la siguiente manera:\n1011 = 1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 = 8 + 0 + 2 + 1 = 11 El sistema hexadecimal: un puente entre humanos y máquinas # Mientras que el sistema binario es perfecto para las máquinas, puede ser un poco engorroso para nosotros, especialmente cuando tratamos con números binarios largos. Aquí es donde entra el sistema hexadecimal, que utiliza dieciséis dígitos distintos: 0-9 y A-F, donde A representa 10, B es 11, y así sucesivamente hasta F que es 153.\nEl hexadecimal es especialmente útil porque proporciona una forma más compacta de representar números binarios. Cada dígito hexadecimal corresponde a exactamente cuatro dígitos binarios (bits). Por ejemplo pensemos en la representación en binario del número 41279 y como el sistema hexadecimal consigue una representación más compacta:\n41279 = 1010 0001 0011 1111 = A13F Pero el sistema hexadecimal es más que una representación compacta de números binarios, es un sistema de numeración posicional como el decimal o binario con base 16 en lugar de 10 o 2. Veamos como conseguir la representación decimal del número del ejemplo anterior (A13F).\nEl dígito más a la derecha representa \\(F \\times 16^0 = 15 \\times 16^0 = 15\\) El siguiente representa \\(3 \\times 16^1 = 48\\) Luego viene \\(1 \\times 16^2 = 256\\) El dígito más a la izquierda en este número representa \\(A \\times 16^3 = 10 \\times 16^3 = 40960\\) Entonces, A13F en hexadecimal se traduce a decimal de la siguiente manera:\nA13F = A \\times 16^3 + 1 \\times 16^2 + 3 \\times 16^1 + F \\times 16^0 = 10 \\times 4096 + 1 \\times 256 + 3 \\times 16 + 15 \\times 1 = 40960 + 256 + 48 + 15 = 41279 Conclusión # Los sistemas de numeración son como lentes a través de los cuales vemos y entendemos el mundo de las matemáticas y la computación. Aunque en nuestra vida diaria el sistema decimal sea el rey, es esencial apreciar y comprender los sistemas binario y hexadecimal, especialmente en esta era digital.\nAsí que, la próxima vez que estés frente a tu computadora o usando una app en tu celular, recordá que detrás de esa interfaz amigable, hay un mundo binario en pleno funcionamiento, y que el sistema hexadecimal actúa como un traductor entre ese mundo y nosotros.\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\nReferencias # Ifrah, G. (2000). Historia universal de las cifras. Buenos Aires: Editorial Taurus.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A. (2012). Estructura de Computadoras. Buenos Aires: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKnuth, D. (2007). El Arte de Programar Computadoras: Sistemas de numeración. Buenos Aires: Ediciones Omega.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"05 septiembre 2023","externalUrl":null,"permalink":"/programming/intro/numeral-systems/","section":"Programación","summary":"","title":"Sistemas de Numeración","type":"programming"},{"content":"","externalUrl":null,"permalink":"/programming/oop/","section":"Programación","summary":"","title":"Programación Orientada a Objetos","type":"programming"},{"content":" Para consolidar todo lo aprendido, vamos a crear un sistema de recomendaciones usando reglas lógicas. Este tipo de sistema es común en e-commerce, plataformas de contenido y aplicaciones móviles. Problema a resolver # Eres un ingeniero de software trabajando para una empresa de e-commerce que necesita implementar un sistema de recomendaciones para mejorar la experiencia de sus usuarios y aumentar las ventas.\nTu misión es desarrollar un sistema que pueda sugerir productos relevantes a los usuarios basándose en:\nSu perfil demográfico (edad, ubicación, intereses) Su historial de compras y navegación El comportamiento de usuarios similares Características de los productos Reglas específicas del negocio Datos disponibles # Para el desarrollo del sistema tenemos preparados un conjunto de datos que podés usar para verificar el funcionamiento de tu código.\nUsuarios: datos/usuarios.json\nDatos demográficos: edad, género, ubicación Intereses: lista de categorías preferidas Nivel de gasto: bajo, medio, alto Historial de actividad: compras, visualizaciones, ratings Productos: datos/productos.json\nInformación básica: nombre, categoría, precio Métricas de calidad: rating promedio, popularidad Metadatos: tags descriptivos, público objetivo Características comerciales: disponibilidad, promociones Interacciones: datos/interacciones.json\nTipos de interacción: compra, visualización, rating, wishlist Datos temporales: fecha y hora Valoraciones: puntuaciones de 1-5 estrellas Contexto: dispositivo, ubicación, sesión Requerimientos Funcionales # Calcular similitud entre usuarios ENTRADA: ID de usuario PROCESO: Calcular similitud con otros usuarios basándose en: - Productos en común que han comprado o visto - Similitud demográfica (edad, género, ubicación) - Intereses compartidos SALIDA: Lista de usuarios similares ordenada por similitud Generar recomendaciones por filtrado colaborativo ENTRADA: ID de usuario, número de recomendaciones deseadas PROCESO: - Encontrar usuarios similares - Identificar productos que les gustaron a esos usuarios - Filtrar productos ya conocidos por el usuario objetivo - Puntuar por similitud de usuarios y ratings SALIDA: Lista de productos recomendados con scores Generar recomendaciones por contenido ENTRADA: ID de usuario, número de recomendaciones deseadas PROCESO: - Analizar perfil del usuario (intereses, demografía) - Evaluar cada producto por compatibilidad: * Matching con intereses del usuario * Adecuación por edad y demografía * Calidad del producto (rating, popularidad) * Precio apropiado para nivel de gasto SALIDA: Lista de productos recomendados con scores Procesar reglas de negocio ENTRADA: Usuario, lista de recomendaciones preliminares PROCESO: Aplicar reglas como: - Boost a productos tech para usuarios jóvenes - Promocionar productos premium a usuarios de gasto alto - Priorizar productos económicos para presupuesto bajo - Aplicar preferencias regionales SALIDA: Recomendaciones ajustadas por reglas de negocio Generar explicaciones para las recomendaciones ENTRADA: Usuario, producto recomendado PROCESO: Generar explicación legible de por qué se recomienda: - \u0026#34;Coincide con tus intereses en tecnología\u0026#34; - \u0026#34;A usuarios similares también les gustó\u0026#34; - \u0026#34;Excelente rating (4.8/5)\u0026#34; - \u0026#34;Precio apropiado para tu perfil\u0026#34; SALIDA: Lista de razones explicativas Métricas de evaluación # Evalúa tu sistema considerando:\nPrecisión\n¿Las recomendaciones son relevantes para cada usuario? ¿Evita recomendar productos ya conocidos? Diversidad\n¿Ofrece variedad de categorías y precios? ¿Evita el sesgo hacia productos populares únicamente? Explicabilidad\n¿Las razones son claras y convincentes? Eficiencia\n¿Responde en tiempo razonable? Solución # Haciendo click en el siguiente enlace, puedes encontrar una posible solución para este problema. Incluye explicaciones detalladas.\n¡Intentá resolverlo por tu cuenta primero! 😀😀😀 Ejecución # Aquí hay algunos ejemplos de ejecución:\nDemostración completa # \u0026gt; python main.py Selecciona el tipo de demostración: 1- Demostración completa 2- Comparación de algoritmos 3- Usuario específico Opción (1-3): 1 Sistema de Recomendaciones - Demostración Completa ================================================== Cargando la configuración desde config.yaml Configuración cargada desde config.yaml Configuración validada exitosamente Inicializando Sistema de Recomendaciones * 6 usuarios cargados * 12 productos cargados * 22 interacciones cargadas Sistema listo! ======================== Estadísticas del Sistema ======================== Analizando sistema Usuarios: 6 * Por género: {\u0026#39;F\u0026#39;: 3, \u0026#39;M\u0026#39;: 3} * Por ubicación: {\u0026#39;Buenos Aires\u0026#39;: 2, \u0026#39;Córdoba\u0026#39;: 1, \u0026#39;Rosario\u0026#39;: 1, \u0026#39;Mendoza\u0026#39;: 1, \u0026#39;La Plata\u0026#39;: 1} * Por nivel de gasto: {\u0026#39;medio\u0026#39;: 3, \u0026#39;alto\u0026#39;: 2, \u0026#39;bajo\u0026#39;: 1} * Edad promedio: 31.5 años Productos: 12 * Por categoría: {\u0026#39;tecnologia\u0026#39;: 4, \u0026#39;lectura\u0026#39;: 2, \u0026#39;gaming\u0026#39;: 2, \u0026#39;hogar\u0026#39;: 1, \u0026#39;fitness\u0026#39;: 2, \u0026#39;cocina\u0026#39;: 1} * Precio promedio: $37,950 * Calificación promedio: 4.36/5 Interacciones: 22 * Por tipo: {\u0026#39;compra\u0026#39;: 11, \u0026#39;view\u0026#39;: 9, \u0026#39;wishlist\u0026#39;: 2} * Por usuario: {\u0026#39;user_001\u0026#39;: 4, \u0026#39;user_002\u0026#39;: 4, \u0026#39;user_003\u0026#39;: 4, \u0026#39;user_004\u0026#39;: 4, \u0026#39;user_005\u0026#39;: 3, \u0026#39;user_006\u0026#39;: 3} * Usuarios activos: 6 Similitudes: * Promedio: 0.162 * Máxima: 0.398 * Mínima: 0.000 ============================= Reporte Detallado - ANA LÓPEZ ============================= Perfil del usuario * Edad: 28 años * Género: F * Ubicación: Buenos Aires * Intereses: tecnologia, fitness, lectura * Nivel de gasto: medio Historial de actividad (4 interacciones): • 2024-08-17: WISHLIST - Cámara DSLR Canon EOS Rebel T7 • 2024-08-10: COMPRA - Proteína Whey Gold Standard (Calificación: 4/5) • 2024-08-05: VIEW - Auriculares Bluetooth Sport Pro • 2024-08-01: COMPRA - Smartphone Samsung Galaxy S24 (Calificación: 5/5) 3 usuarios más similares * Diego Silva: 0.398 (39.8% similar) * Roberto García: 0.322 (32.2% similar) * Laura Martínez: 0.246 (24.6% similar) Generando recomendaciones para Ana López ======================================== Aplicando filtrado colaborativo para Ana López... Usuarios similares encontrados: 5 6 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Ana López... 8 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 8 Aplicando reglas de negocio * Los usuarios jóvenes (\u0026lt;35) prefieren productos tecnológicos: 1 productos afectados 1 reglas aplicadas: boost_tecnologia_jovenes Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Tablet Samsung Galaxy Tab S9 Precio: $95,000 Calificación: 4.4/5 Puntuación: 3.214 Explicación: Te gusta la categoría tecnologia; Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.4/5); Producto muy popular #2 - Set Pesas Ajustables 40kg Precio: $15,000 Calificación: 4.1/5 Puntuación: 3.179 Explicación: Coincide con tu interés en fitness; Te gusta la categoría fitness; Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.1/5); A usuarios con perfil similar también les gustó #3 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificación: 4.5/5 Puntuación: 2.808 Explicación: Coincide con tu interés en tecnologia; Te gusta la categoría lectura; Apropiado para tu grupo de edad; Excelente valoración (4.5/5) #4 - Libro: Cocina Mediterránea Saludable Precio: $3,500 Calificación: 4.8/5 Puntuación: 2.14 Explicación: Te gusta la categoría lectura; Apropiado para tu grupo de edad; Excelente valoración (4.8/5) #5 - Cafetera Espresso DeLonghi Precio: $32,000 Calificación: 4.2/5 Puntuación: 1.792 Explicación: Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.2/5); A usuarios con perfil similar también les gustó ================================= Reporte Detallado - CARLOS MENDEZ ================================= Perfil del usuario * Edad: 35 años * Género: M * Ubicación: Córdoba * Intereses: deportes, gaming, musica * Nivel de gasto: alto Historial de actividad (4 interacciones): • 2024-08-18: VIEW - Tablet Samsung Galaxy Tab S9 • 2024-08-12: COMPRA - Auriculares Gaming HyperX Cloud III (Calificación: 5/5) • 2024-08-07: VIEW - Smartphone Samsung Galaxy S24 • 2024-08-03: COMPRA - Juego: Call of Duty Modern Warfare III (Calificación: 4/5) 3 usuarios más similares * Roberto García: 0.192 (19.2% similar) * Laura Martínez: 0.168 (16.8% similar) * Diego Silva: 0.120 (12.0% similar) Generando recomendaciones para Carlos Mendez ============================================ Aplicando filtrado colaborativo para Carlos Mendez... Usuarios similares encontrados: 5 6 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Carlos Mendez... 8 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 8 Aplicando reglas de negocio * Usuarios con gasto alto ven productos premium primero: 8 productos afectados 1 reglas aplicadas: usuarios_premium Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Auriculares Bluetooth Sport Pro Precio: $25,000 Calificación: 4.2/5 Puntuación: 2.392 Explicación: Coincide con tu interés en deportes; Apropiado para tu grupo de edad; Buena valoración (4.2/5); Producto muy popular #2 - Cámara DSLR Canon EOS Rebel T7 Precio: $85,000 Calificación: 4.3/5 Puntuación: 1.949 Explicación: Apropiado para tu grupo de edad; Producto premium que se ajusta a tu perfil; Buena valoración (4.3/5) #3 - Proteína Whey Gold Standard Precio: $7,200 Calificación: 4.6/5 Puntuación: 1.697 Explicación: Apropiado para tu grupo de edad; Excelente valoración (4.6/5); Producto muy popular #4 - Cafetera Espresso DeLonghi Precio: $32,000 Calificación: 4.2/5 Puntuación: 1.689 Explicación: Apropiado para tu grupo de edad; Buena valoración (4.2/5) #5 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificación: 4.5/5 Puntuación: 1.633 Explicación: Apropiado para tu grupo de edad; Excelente valoración (4.5/5) =================================== Reporte Detallado - MARÍA RODRIGUEZ =================================== Perfil del usuario * Edad: 42 años * Género: F * Ubicación: Rosario * Intereses: cocina, jardineria, arte * Nivel de gasto: bajo Historial de actividad (4 interacciones): • 2024-08-20: VIEW - Cámara DSLR Canon EOS Rebel T7 • 2024-08-15: COMPRA - Cafetera Espresso DeLonghi (Calificación: 3/5) • 2024-08-06: VIEW - Kit Herramientas Jardín Premium • 2024-08-02: COMPRA - Libro: Cocina Mediterránea Saludable (Calificación: 5/5) 3 usuarios más similares * Roberto García: 0.193 (19.3% similar) * Laura Martínez: 0.120 (12.0% similar) * Ana López: 0.060 (6.0% similar) Generando recomendaciones para María Rodriguez ============================================== Aplicando filtrado colaborativo para María Rodriguez... Usuarios similares encontrados: 5 7 recomendaciones colaborativas generadas Aplicando filtrado por contenido para María Rodriguez... 8 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 8 Aplicando reglas de negocio * Usuarios con presupuesto bajo ven productos económicos: 2 productos afectados 1 reglas aplicadas: productos_economicos Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Proteína Whey Gold Standard Precio: $7,200 Calificación: 4.6/5 Puntuación: 2.432 Explicación: Apropiado para tu grupo de edad; Precio económico y accesible; Excelente valoración (4.6/5); Producto muy popular #2 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificación: 4.5/5 Puntuación: 2.313 Explicación: Apropiado para tu grupo de edad; Precio económico y accesible; Excelente valoración (4.5/5) #3 - Set Pesas Ajustables 40kg Precio: $15,000 Calificación: 4.1/5 Puntuación: 1.588 Explicación: Apropiado para tu grupo de edad; Precio económico y accesible; Buena valoración (4.1/5) #4 - Smartphone Samsung Galaxy S24 Precio: $150,000 Calificación: 4.5/5 Puntuación: 1.572 Explicación: Apropiado para tu grupo de edad; Excelente valoración (4.5/5); Producto muy popular #5 - Tablet Samsung Galaxy Tab S9 Precio: $95,000 Calificación: 4.4/5 Puntuación: 1.352 Explicación: Apropiado para tu grupo de edad; Buena valoración (4.4/5); Producto muy popular =============================== Reporte Detallado - DIEGO SILVA =============================== Perfil del usuario * Edad: 24 años * Género: M * Ubicación: Buenos Aires * Intereses: tecnologia, gaming, fitness * Nivel de gasto: medio Historial de actividad (4 interacciones): • 2024-08-19: WISHLIST - Smartphone Samsung Galaxy S24 • 2024-08-14: COMPRA - Set Pesas Ajustables 40kg (Calificación: 4/5) • 2024-08-08: VIEW - Juego: Call of Duty Modern Warfare III • 2024-08-04: COMPRA - Auriculares Bluetooth Sport Pro (Calificación: 4/5) 3 usuarios más similares * Ana López: 0.398 (39.8% similar) * Roberto García: 0.310 (31.0% similar) * Carlos Mendez: 0.120 (12.0% similar) Generando recomendaciones para Diego Silva ========================================== Aplicando filtrado colaborativo para Diego Silva... Usuarios similares encontrados: 5 5 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Diego Silva... 8 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 8 Aplicando reglas de negocio * Los usuarios jóvenes (\u0026lt;35) prefieren productos tecnológicos: 2 productos afectados 1 reglas aplicadas: boost_tecnologia_jovenes Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Tablet Samsung Galaxy Tab S9 Precio: $95,000 Calificación: 4.4/5 Puntuación: 3.214 Explicación: Te gusta la categoría tecnologia; Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.4/5); Producto muy popular #2 - Cámara DSLR Canon EOS Rebel T7 Precio: $85,000 Calificación: 4.3/5 Puntuación: 3.151 Explicación: Te gusta la categoría tecnologia; Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.3/5) #3 - Auriculares Gaming HyperX Cloud III Precio: $18,000 Calificación: 4.4/5 Puntuación: 3.124 Explicación: Coincide con tu interés en gaming; Te gusta la categoría gaming; Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.4/5) #4 - Proteína Whey Gold Standard Precio: $7,200 Calificación: 4.6/5 Puntuación: 2.979 Explicación: Coincide con tu interés en fitness; Te gusta la categoría fitness; Apropiado para tu grupo de edad; Excelente valoración (4.6/5); A usuarios con perfil similar también les gustó; Producto muy popular #5 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificación: 4.5/5 Puntuación: 1.592 Explicación: Coincide con tu interés en tecnologia; Excelente valoración (4.5/5) ================================== Reporte Detallado - LAURA MARTÍNEZ ================================== Perfil del usuario * Edad: 31 años * Género: F * Ubicación: Mendoza * Intereses: lectura, arte, musica * Nivel de gasto: medio Historial de actividad (3 interacciones): • 2024-08-13: VIEW - Cámara DSLR Canon EOS Rebel T7 • 2024-08-11: COMPRA - Libro: El Arte de la Guerra Digital (Calificación: 5/5) • 2024-08-09: VIEW - Libro: Cocina Mediterránea Saludable 3 usuarios más similares * Ana López: 0.246 (24.6% similar) * Carlos Mendez: 0.168 (16.8% similar) * Roberto García: 0.144 (14.4% similar) Generando recomendaciones para Laura Martínez ============================================= Aplicando filtrado colaborativo para Laura Martínez... Usuarios similares encontrados: 5 7 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Laura Martínez... 9 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 9 Aplicando reglas de negocio * Los usuarios jóvenes (\u0026lt;35) prefieren productos tecnológicos: 3 productos afectados 1 reglas aplicadas: boost_tecnologia_jovenes Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Auriculares Bluetooth Sport Pro Precio: $25,000 Calificación: 4.2/5 Puntuación: 2.186 Explicación: Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.2/5); Producto muy popular #2 - Tablet Samsung Galaxy Tab S9 Precio: $95,000 Calificación: 4.4/5 Puntuación: 2.174 Explicación: Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.4/5); Producto muy popular #3 - Smartphone Samsung Galaxy S24 Precio: $150,000 Calificación: 4.5/5 Puntuación: 2.15 Explicación: Apropiado para tu grupo de edad; Excelente valoración (4.5/5); Producto muy popular #4 - Juego: Call of Duty Modern Warfare III Precio: $12,000 Calificación: 4.3/5 Puntuación: 1.785 Explicación: Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.3/5); Producto muy popular #5 - Auriculares Gaming HyperX Cloud III Precio: $18,000 Calificación: 4.4/5 Puntuación: 1.753 Explicación: Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoración (4.4/5) ================================== Reporte Detallado - ROBERTO GARCÍA ================================== Perfil del usuario * Edad: 29 años * Género: M * Ubicación: La Plata * Intereses: deportes, tecnologia, cocina * Nivel de gasto: alto Historial de actividad (3 interacciones): • 2024-08-16: VIEW - Tablet Samsung Galaxy Tab S9 • 2024-08-09: COMPRA - Cafetera Espresso DeLonghi (Calificación: 4/5) • 2024-08-05: COMPRA - Smartphone Samsung Galaxy S24 (Calificación: 5/5) 3 usuarios más similares * Ana López: 0.322 (32.2% similar) * Diego Silva: 0.310 (31.0% similar) * María Rodriguez: 0.193 (19.3% similar) Generando recomendaciones para Roberto García ============================================= Aplicando filtrado colaborativo para Roberto García... Usuarios similares encontrados: 5 7 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Roberto García... 9 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 9 Aplicando reglas de negocio * Los usuarios jóvenes (\u0026lt;35) prefieren productos tecnológicos: 2 productos afectados * Usuarios con gasto alto ven productos premium primero: 9 productos afectados 2 reglas aplicadas: boost_tecnologia_jovenes, usuarios_premium Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Auriculares Bluetooth Sport Pro Precio: $25,000 Calificación: 4.2/5 Puntuación: 4.5 Explicación: Coincide con tu interés en deportes; Te gusta la categoría tecnologia; Apropiado para tu grupo de edad; Buena valoración (4.2/5); A usuarios con perfil similar también les gustó; Producto muy popular #2 - Cámara DSLR Canon EOS Rebel T7 Precio: $85,000 Calificación: 4.3/5 Puntuación: 3.781 Explicación: Te gusta la categoría tecnologia; Apropiado para tu grupo de edad; Producto premium que se ajusta a tu perfil; Buena valoración (4.3/5) #3 - Libro: Cocina Mediterránea Saludable Precio: $3,500 Calificación: 4.8/5 Puntuación: 2.424 Explicación: Coincide con tu interés en cocina; Apropiado para tu grupo de edad; Excelente valoración (4.8/5) #4 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificación: 4.5/5 Puntuación: 2.336 Explicación: Coincide con tu interés en tecnologia; Apropiado para tu grupo de edad; Excelente valoración (4.5/5) #5 - Proteína Whey Gold Standard Precio: $7,200 Calificación: 4.6/5 Puntuación: 1.851 Explicación: Apropiado para tu grupo de edad; Excelente valoración (4.6/5); A usuarios con perfil similar también les gustó; Producto muy popular ===================================== Demostración Completada Exitosamente! Revisa los reportes anteriores para entender cómo funciona cada componente ===================================== Comparación de algoritmos # \u0026gt; python main.py Selecciona el tipo de demostración: 1- Demostración completa 2- Comparación de algoritmos 3- Usuario específico Opción (1-3): 2 ========================= Comparación de Algoritmos ========================= Cargando la configuración desde config.yaml Configuración cargada desde config.yaml Configuración validada exitosamente Inicializando Sistema de Recomendaciones * 6 usuarios cargados * 12 productos cargados * 22 interacciones cargadas Sistema listo! Usuario de prueba: Ana López Recomendaciones por filtrado colaborativo: Aplicando filtrado colaborativo para Ana López... Usuarios similares encontrados: 5 5 recomendaciones colaborativas generadas 1. Set Pesas Ajustables 40kg (Puntuación: 0.318) 2. Cafetera Espresso DeLonghi (Puntuación: 0.294) 3. Libro: El Arte de la Guerra Digital (Puntuación: 0.246) 4. Libro: Cocina Mediterránea Saludable (Puntuación: 0.060) 5. Auriculares Gaming HyperX Cloud III (Puntuación: 0.054) Recomendaciones por filtrado por contenido: Aplicando filtrado por contenido para Ana López... 5 recomendaciones por contenido generadas 1. Set Pesas Ajustables 40kg (Puntuación: 7.470) 2. Libro: El Arte de la Guerra Digital (Puntuación: 6.650) 3. Tablet Samsung Galaxy Tab S9 (Puntuación: 6.180) 4. Libro: Cocina Mediterránea Saludable (Puntuación: 5.260) 5. Juego: Call of Duty Modern Warfare III (Puntuación: 4.260) Sistema híbrido Generando recomendaciones para Ana López ======================================== Aplicando filtrado colaborativo para Ana López... Usuarios similares encontrados: 5 6 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Ana López... 8 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 8 Aplicando reglas de negocio * Los usuarios jóvenes (\u0026lt;35) prefieren productos tecnológicos: 1 productos afectados 1 reglas aplicadas: boost_tecnologia_jovenes Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 1. Tablet Samsung Galaxy Tab S9 (Puntuación: 3.214) 2. Set Pesas Ajustables 40kg (Puntuación: 3.179) 3. Libro: El Arte de la Guerra Digital (Puntuación: 2.808) 4. Libro: Cocina Mediterránea Saludable (Puntuación: 2.14) 5. Cafetera Espresso DeLonghi (Puntuación: 1.792) Observaciones * Colaborativo: Basado en usuarios similares * Contenido: Basado en perfil del usuario * Híbrido: Combina ambos enfoques Usuario específico # \u0026gt; python main.py Selecciona el tipo de demostración: 1- Demostración completa 2- Comparación de algoritmos 3- Usuario específico Opción (1-3): 3 Cargando la configuración desde config.yaml Configuración cargada desde config.yaml Configuración validada exitosamente Inicializando Sistema de Recomendaciones * 6 usuarios cargados * 12 productos cargados * 22 interacciones cargadas Sistema listo! Usuarios disponibles: user_001: Ana López user_002: Carlos Mendez user_003: María Rodriguez user_004: Diego Silva user_005: Laura Martínez user_006: Roberto García Ingresa ID de usuario: user_002 ================================= Reporte Detallado - CARLOS MENDEZ ================================= Perfil del usuario * Edad: 35 años * Género: M * Ubicación: Córdoba * Intereses: deportes, gaming, musica * Nivel de gasto: alto Historial de actividad (4 interacciones): • 2024-08-18: VIEW - Tablet Samsung Galaxy Tab S9 • 2024-08-12: COMPRA - Auriculares Gaming HyperX Cloud III (Calificación: 5/5) • 2024-08-07: VIEW - Smartphone Samsung Galaxy S24 • 2024-08-03: COMPRA - Juego: Call of Duty Modern Warfare III (Calificación: 4/5) 3 usuarios más similares * Roberto García: 0.192 (19.2% similar) * Laura Martínez: 0.168 (16.8% similar) * Diego Silva: 0.120 (12.0% similar) Generando recomendaciones para Carlos Mendez ============================================ Aplicando filtrado colaborativo para Carlos Mendez... Usuarios similares encontrados: 5 6 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Carlos Mendez... 8 recomendaciones por contenido generadas Combinando estrategias de recomendación * Productos únicos después de combinar: 8 Aplicando reglas de negocio * Usuarios con gasto alto ven productos premium primero: 8 productos afectados 1 reglas aplicadas: usuarios_premium Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Auriculares Bluetooth Sport Pro Precio: $25,000 Calificación: 4.2/5 Puntuación: 2.392 Explicación: Coincide con tu interés en deportes; Apropiado para tu grupo de edad; Buena valoración (4.2/5); Producto muy popular #2 - Cámara DSLR Canon EOS Rebel T7 Precio: $85,000 Calificación: 4.3/5 Puntuación: 1.949 Explicación: Apropiado para tu grupo de edad; Producto premium que se ajusta a tu perfil; Buena valoración (4.3/5) #3 - Proteína Whey Gold Standard Precio: $7,200 Calificación: 4.6/5 Puntuación: 1.697 Explicación: Apropiado para tu grupo de edad; Excelente valoración (4.6/5); Producto muy popular #4 - Cafetera Espresso DeLonghi Precio: $32,000 Calificación: 4.2/5 Puntuación: 1.689 Explicación: Apropiado para tu grupo de edad; Buena valoración (4.2/5) #5 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificación: 4.5/5 Puntuación: 1.633 Explicación: Apropiado para tu grupo de edad; Excelente valoración (4.5/5) ¿Qué nos aporta esta solución? # Sistema híbrido: Combinamos múltiples estrategias de recomendación para obtener mejores resultados. Reglas de negocio: Implementamos lógica específica del dominio que puede adaptarse fácilmente. Explicabilidad: El sistema puede explicar por qué recomienda cada producto, generando confianza. Escalabilidad: La arquitectura permite agregar nuevas fuentes de datos y reglas fácilmente. Ejercicios para profundizar # A continuación tienes algunos ejercicios que te ayudarán a profundizar tus conocimientos.\nEjercicio 1: Implementa una nueva regla de negocio que dé boost a productos en oferta durante los fines de semana. Ejercicio 2: Implementa un sistema de feedback que aprenda de las interacciones del usuario (like/dislike). Por supuesto, no tienes porque detenerte en estas recomendaciones, dejá volar tu imaginación y utilizá los conceptos aprendidos para otros casos.\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"03 septiembre 2025","externalUrl":null,"permalink":"/ai/module1/project/","section":"Inteligencia Artificial","summary":"","title":"Proyecto usando Machine Learning: Sistema de Recomendaciones","type":"ai"},{"content":"Key characteristics of association:\nIt represents a loose coupling between classes. The associated classes can exist independently of each other. The lifetime of one class is not tied to the lifetime of the other. It can be unidirectional or bidirectional. There are two main types of association:\nUnidirectional Association Bidirectional Association Let\u0026rsquo;s explore each of these in more detail.\nUnidirectional association # In a unidirectional association, one class knows about and can interact with another class, but not vice versa. This is a one-way relationship.\nHere\u0026rsquo;s an example in Python:\nclass Customer: def __init__(self, name): self.name = name class Order: def __init__(self, order_number, customer): self.order_number = order_number self.customer = customer # This creates an association def display_info(self): return f\u0026#34;Order {self.order_number} placed by {self.customer.name}\u0026#34; # Creating instances customer = Customer(\u0026#34;John Doe\u0026#34;) order = Order(\u0026#34;12345\u0026#34;, customer) print(order.display_info()) # Output: Order 12345 placed by John Doe In this example, the Order class has a unidirectional association with the Customer class. An Order knows about its associated Customer, but a Customer doesn\u0026rsquo;t know about its Orders.\nHere\u0026rsquo;s a UML diagram representing this relationship:\nclassDiagram class Customer { +name: string } class Order { +order_number: string +customer: Customer +display_info() } Order --\u003e Customer : places end The arrow in the diagram points from Order to Customer, indicating that Order knows about Customer, but not the other way around.\nBidirectional association # In a bidirectional association, both classes are aware of each other and can interact with each other. This is a two-way relationship.\nHere\u0026rsquo;s an example in Python:\nclass Student: def __init__(self, name): self.name = name self.courses = [] def enrol(self, course): self.courses.append(course) course.add_student(self) def display_courses(self): return f\u0026#34;{self.name} is enrolled in: {\u0026#39;, \u0026#39;.join(course.name for course in self.courses)}\u0026#34; class Course: def __init__(self, name): self.name = name self.students = [] def add_student(self, student): self.students.append(student) def display_students(self): return f\u0026#34;{self.name} has students: {\u0026#39;, \u0026#39;.join(student.name for student in self.students)}\u0026#34; # Creating instances student1 = Student(\u0026#34;Alice\u0026#34;) student2 = Student(\u0026#34;Bob\u0026#34;) math_course = Course(\u0026#34;Mathematics\u0026#34;) physics_course = Course(\u0026#34;Physics\u0026#34;) # enrolling students in courses student1.enrol(math_course) student1.enrol(physics_course) student2.enrol(math_course) print(student1.display_courses()) print(math_course.display_students()) In this example, there\u0026rsquo;s a bidirectional association between Student and Course. A Student knows about their Courses, and a Course knows about its Students.\nHere\u0026rsquo;s a UML diagram representing this relationship:\nclassDiagram class Student { +name: string +courses: list +enrol(course) +display_courses() } class Course { +name: string +students: list +add_student(student) +display_students() } Student \"0..*\" \u003c--\u003e \"0..*\" Course : enrols in \u003e end The double-headed arrow in the diagram indicates that both Student and Course are aware of each other. The \u0026ldquo;0..*\u0026rdquo; notation indicates that a Student can be enrolled in zero or more Courses, and a Course can have zero or more Students.\nAssociation is a flexible relationship that can represent many real-world connections between objects. It\u0026rsquo;s important to choose between unidirectional and bidirectional associations carefully, as bidirectional associations can introduce more complexity and potential for errors if not managed properly.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-association/","section":"Programming","summary":"","title":"Class relations: Association","type":"programming"},{"content":"Una lista enlazada se compone de nodos donde cada nodo tiene dos partes:\nDato o información Referencia al siguiente nodo Los nodos se organizan de forma secuencial, cada uno apuntando al siguiente. El último nodo apunta a nulo para indicar el final.\nEsta estructura dinámica permite inserción y eliminación eficiente de nodos.\nTipos de listas enlazadas # Existen varios tipos:\nSimplemente enlazada: Cada nodo apunta al siguiente. Son útiles para colas (queues) y pilas (stacks). Diagrama de una lista simplemente enlazada Doblemente enlazada: Cada nodo tiene referencia al siguiente y al anterior. Permiten recorrer en ambos sentidos. Diagrama de una lista doblemente enlazada Circular: El último nodo apunta al primero formando un ciclo. Útiles para buffers circulares. Diagrama de una lista circular Operaciones comunes # Insertar: Agregar nodos al inicio, final o medio de la lista.\nEliminar: Quitar nodos por valor o posición.\nBuscar: Encontrar nodos por valor recorriendo la lista.\nRecorrer: Iterar los nodos accediendo por las referencias.\nImplementación # Las listas enlazadas se pueden implementar de la siguiente manera:\nUsa la clase ListNode para representar nodos:\nclass ListNode: def __init__(self, value): self.value = value self.next = None Luego para crear y usar una lista se define una clase LinkedList con métodos para las operaciones.\nclass LinkedList: def __init__(self): self.head = None def add_to_start(self, new_value): new_node = ListNode(new_value) new_node.next = self.head self.head = new_node def print(self): current = self.head while current != None: print(current.value) current = current.next def search(self, searched_value): current = self.head while current != None: if current.value == searched_value: return True current = current.next return False #...other methods Con esta clase LinkedList podemos crear una lista, agregar nodos, imprimirla, buscar elementos, etc.\nSe podrían agregar otros métodos como insertar al final, eliminar por valor, obtener por índice, etc. Pero esto da una idea de cómo encapsular la funcionalidad de la lista enlazada en una clase. Como práctica, podés intentar agregar estos métodos por tu cuenta, ¡no dudes en dejar tus comentarios y contactarte si necesitas ayuda!\nVentajas y desventajas # Ventajas:\nInsertar y eliminar nodos es eficiente. No requiere definir tamaño fijo como los arrays. Estructura dinámica y flexible. Desventajas:\nMayor uso de memoria por tener que almacenar referencias. El acceso a elementos por índice es más costoso al ser secuencial. Ejemplos de uso # Implementar estructuras como pilas (stacks) y colas (queues). En listas doblemente enlazadas, recorrer la lista en el sentido ambos sentidos. Blockchains como la de Bitcoin. Reproducir elementos en orden como playlists de música. Conclusión # Las listas enlazadas son una estructura de datos versátil para almacenar secuencias dinámicas de elementos. Tener un buen manejo de estas listas, sus operaciones y usos es indispensable para cualquier programador.\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"01 noviembre 2023","externalUrl":null,"permalink":"/programming/data-structures/linked-lists/","section":"Programación","summary":"","title":"Listas Enlazadas","type":"programming"},{"content":" ¿Qué son las funciones? # Una función, en términos simples, es un bloque de código que se ejecuta sólo cuando es llamado. Puedes pensar en ella como un pequeño programa dentro de tu programa principal, diseñado para realizar una tarea específica1. Una función también puede verse como una caja negra: le pasamos una entrada (parámetros), ocurre algún procesamiento interno, y produce una salida (retorno).\nLas funciones nos permiten segmentar nuestro código en partes lógicas, donde cada parte realiza una única acción. Esto brinda varios beneficios2:\nReutilización: Una vez definida la función, podemos ejecutar (llamar) ese código desde cualquier lugar de nuestro programa cuantas veces sea necesario. Organización: Permite dividir un programa grande en partes más pequeñas y manejables. Encapsulamiento: Las funciones reducen la complejidad escondiendo los detalles de implementación internos. Mantenimiento: Si necesitamos realizar cambios, solo debemos modificar el código en un lugar (la función) en lugar de rastrear todas las instancias de ese código. Procedimientos vs. Funciones\nEs vital distinguir entre estos dos conceptos. Mientras que una función siempre devuelve un valor, un procedimiento realiza una tarea pero no devuelve nada. En algunos lenguajes, esta diferencia es más clara que en otros. Python, por ejemplo, tiene funciones que pueden o no devolver valores.\nAnatomía de una función # En Python, una función se declara usando la palabra clave def, seguida del nombre de la función y paréntesis. El código dentro de la función se denomina el cuerpo de la función3 y contiene el conjunto de instrucciones a ejecutar para cumplir con su tarea..\ndef mi_funcion(): print(\u0026#34;¡Hola desde mi función!\u0026#34;) Para llamar o invocar una función, simplemente usamos su nombre seguido de paréntesis:\nmi_funcion() # Salida: ¡Hola desde mi función! Parámetros y argumentos # Las funciones se vuelven aún más poderosas cuando les pasamos información, conocida como parámetros. Estos actúan como \u0026ldquo;variables\u0026rdquo; dentro de la función y permiten que la función trabaje con diferentes datos cada vez que se llama.\nMientras que los parámetros son variables definidas en la definición de la función. Los argumentos son los valores reales pasados al llamar a la función.\ndef saludo(nombre): print(f\u0026#34;¡Hola {nombre}!\u0026#34;) saludo(\u0026#34;María\u0026#34;) # Salida: # ¡Hola María! Podemos definir valores por defecto para los parámetros Python permite parámetros por defecto, que tienen un valor predeterminado, lo cual hace opcional pasar esos argumentos al llamar la función. También permite parámetros nombrados que permiten pasar los argumentos en cualquier orden, especificando su nombre.\ndef saludo(nombre=\u0026#34;María\u0026#34;, repeticiones=3): repeticion = 1 while repeticion \u0026lt;= repeticiones: print(f\u0026#34;¡Hola {nombre}!\u0026#34;) repeticion += 1 saludo() # Salida: # ¡Hola María! # ¡Hola María! # ¡Hola María! saludo(\u0026#34;Florencia\u0026#34;, 4) # Salida: # ¡Hola Florencia! # ¡Hola Florencia! # ¡Hola Florencia! # ¡Hola Florencia! saludo(repeticiones=2, nombre=\u0026#34;Julián\u0026#34;) # Salida # ¡Hola Julián! # ¡Hola Julián! Retorno de valores # Las funciones pueden devolver un resultado o valor de retorno usando la palabra reservada return.\ndef area_circulo(radio): return 3.14 * (radio ** 2) resultado = area_circulo(10) print(resultado) # Salida: 314 El valor de retorno se pasa de vuelta a donde se llamó la función y se puede asignar a una variable para usarlo.\nLas funciones también pueden ejecutar alguna tarea sin devolver nada explícitamente. En Python esto se conoce como retornar None.\nVariables locales y globales # Las variables locales se definen dentro de una función y solo existen en ese ámbito, mientras que las variables globales están definidas fuera y pueden ser accedidas desde cualquier parte del código. Es crucial entender su alcance (dónde puede ser accesible una variable) y duración (cuánto tiempo vive una variable).\nx = 10 # x es global def suma(): y = 5 # y es local return x + y suma() # Salida: 15 print(y) # Error, y no existe fuera de la función Podemos leer variables globales desde una función, pero si necesitamos modificarla debemos declararla global.\nx = 10 def suma(): global x x = x + 5 suma() print(x) # 15 ","date":"29 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/functions/","section":"Programación","summary":"","title":"Funciones","type":"programming"},{"content":"La lógica booleana, nombrada en honor a George Boole, un matemático inglés del siglo XIX, es un sistema matemático que se ocupa de operaciones que tienen solo dos resultados posibles: verdadero o falso, representados generalmente como 1 y 0, respectivamente1. En su obra \u0026ldquo;An Investigation of the Laws of Thought\u0026rdquo;, Boole estableció las bases de esta lógica, presentando un sistema algebraico que podría utilizarse para representar estructuras lógicas.\nOperaciones Booleanas # Dentro de la lógica booleana, existen operaciones fundamentales que permiten manipular y combinar estas expresiones binarias:\nAND (Y): Esta operación devuelve verdadero (1) solo si ambas entradas son verdaderas. Por ejemplo, si tenemos dos interruptores, ambos deben estar en la posición encendido para que una luz se encienda.\nOR (O): Devuelve verdadero si al menos una de las entradas es verdadera. Siguiendo con el ejemplo de los interruptores, con que uno de ellos esté encendido, la luz se iluminará.\nNOT (NO): Es una operación unaria, lo que significa que solo tiene una entrada. Simplemente invierte el valor de entrada. Si le das un 1, devuelve un 0 y viceversa.\nNAND (NO Y): Es la negación de AND. Solo devuelve falso si ambas entradas son verdaderas.\nNOR (NO O): Es la negación de OR. Devuelve verdadero solo si ambas entradas son falsas.\nXOR (O exclusivo): Devuelve verdadero si las entradas son diferentes. Si ambas son iguales, devuelve falso.\nXNOR (NO O exclusivo): Es la negación de XOR. Devuelve verdadero si ambas entradas son iguales.\nLa importancia de esta lógica en computación y programación # La computación moderna, en su esencia, es la manipulación de bits, esos unos y ceros que mencionamos. Cada operación que realiza una computadora, desde simples cálculos hasta la renderización de gráficos complejos, implica operaciones booleanas en algún nivel2.\nEn programación, la lógica booleana se utiliza en estructuras de control, como condiciones (if, else) y bucles, permitiendo a los programas tomar decisiones basadas en ciertas condiciones.\nTablas de verdad: el mapa de la lógica Booleana # Una tabla de verdad es una representación gráfica de una operación booleana. Enumera todas las combinaciones posibles de entradas y muestra el resultado de la operación para cada combinación3.\nPor ejemplo,\nA B A AND B A OR B A XOR B A NOR B A NAND B NOT A A NXOR B 1 1 1 1 0 0 0 0 1 1 0 0 1 1 0 1 0 0 0 1 0 1 1 0 1 1 0 0 0 0 0 0 1 1 1 1 Conclusiones # La lógica booleana es mucho más que un conjunto de reglas matemáticas abstractas. Es el lenguaje fundamental de las máquinas, el código que subyace a la era digital en la que vivimos. Al comprender sus principios, no solo nos volvemos más adeptos a trabajar con tecnología, sino que también adquirimos una apreciación más profunda de las estructuras que sustentan nuestro mundo digital.\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\nReferencias # Boole, G. (1854). An Investigation of the Laws of Thought. Londres: Walton and Maberly.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A. (2012). Estructura de Computadoras. Buenos Aires: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMinsky, M. (1967). Computation: Finite and Infinite Machines. Buenos Aires: Prentice-Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"09 septiembre 2023","externalUrl":null,"permalink":"/programming/intro/boolean-logic/","section":"Programación","summary":"","title":"Lógica Booleana","type":"programming"},{"content":"","externalUrl":null,"permalink":"/programming/data-structures/","section":"Programación","summary":"","title":"Estructuras de Datos","type":"programming"},{"content":" Llegó el momento de cerrar nuestro paso por los fundamentos de la Inteligencia Artificial. Ahora vamos a repasar lo aprendido, aclarar algunas dudas y prepararnos para el próximo módulo. FAQ: Dudas domunes # 1. ¿Por qué empezamos con reglas en lugar de Machine Learning avanzado? # Las reglas lógicas son la base de todo sistema inteligente. Antes de usar algoritmos complejos, necesitas entender:\nCómo estructurar el conocimiento Cómo manejar incertidumbre Cómo combinar múltiples fuentes de información Cómo hacer sistemas explicables Estos conceptos se aplican igual en Deep Learning.\n2. ¿Cuándo usar IA clásica vs Machine Learning? # IA Clásica (reglas, sistemas expertos):\n✅ Conocimiento del dominio bien definido ✅ Reglas claras y estables ✅ Necesitas explicabilidad total ✅ Pocos datos disponibles ❌ Patrones muy complejos ❌ Necesitas adaptación automática Machine Learning:\n✅ Muchos datos disponibles ✅ Patrones complejos o desconocidos ✅ El dominio cambia frecuentemente ✅ Necesitas adaptación automática ❌ Pocos datos de entrenamiento ❌ Explicabilidad crítica para el negocio 3. ¿Los sistemas de reglas son obsoletos? # No, para nada. Muchos sistemas en producción combinan ambos enfoques:\nNetflix: Usa ML para analizar patrones de viewing, pero reglas de negocio para decidir qué mostrar en diferentes contextos Sistemas médicos: Usan ML para análisis de imágenes, pero reglas expertas para diagnósticos críticos Trading algorítmico: Combina ML para predicciones con reglas de gestión de riesgos 4. ¿Por qué no usar directamente bibliotecas como scikit-learn? # En este primer módulo, la idea es que entiendas qué está pasando por debajo. Una vez que domines los conceptos fundamentales, las bibliotecas serán herramientas poderosas, no cajas negras.\nPiénsalo así: puedes usar un framework web como Django, pero es porque entiendes HTTP, requests, responses, etc.\n5. ¿Cómo sé si mi sistema de IA está funcionando bien? # Para sistemas de reglas:\nPrecisión: ¿Las predicciones son correctas? Cobertura: ¿El sistema puede manejar todos los casos? Consistencia: ¿Las reglas se contradicen entre sí? Performance: ¿Es lo suficientemente rápido para producción? Más adelante veremos métricas específicas para ML.\nPróximos pasos: módulo 2 # En el próximo módulo nos sumergiremos en las matemáticas esenciales para entender Machine Learning. No te preocupes, no vamos a ser académicos aburridos. Vamos a cubrir solo las matemáticas que realmente necesitas:\nÁlgebra Lineal práctica\nVectores y matrices (¿por qué importan?) Operaciones esenciales Representación de datos como matrices Estadística\nProbabilidades básicas Distribuciones importantes Correlación vs causalidad Cálculo para optimización\nDerivadas (solo las que necesitas) Gradientes y optimización ¿Por qué necesitas estas matemáticas? # Cada algoritmo de ML es fundamentalmente:\nUna función matemática que mapea entradas a salidas Un proceso de optimización que encuentra los mejores parámetros Un framework estadístico que maneja incertidumbre Sin entender esto, estarás ajustando hiperparámetros al azar y rogando que funcione.\nReflexión final # Has completado tu primer módulo en el camino a convertirte en un ingeniero en IA. Cubriste mucho terreno:\n✅ Desmitificaste la IA: ya sabes la diferencia real entre IA, ML y DL ✅ Implementaste sistemas inteligentes: desde cero, sin bibliotecas mágicas ✅ Entendiste los fundamentos: que se aplicarán a todo lo que aprendas después ✅ Construiste un proyecto real: sistema de recomendaciones funcional Pero esto es solo el comienzo. La IA no es magia, es ingeniería sistemática aplicada a problemas complejos. Como cualquier habilidad de ingeniería, se domina con práctica y fundamentos sólidos.\nEn el próximo módulo agregaremos las matemáticas que necesitas. No para ser un académico, sino para ser un practicante efectivo que entiende sus herramientas.\nRecuerda: Cada experto fue alguna vez un principiante. La diferencia está en la consistencia y la profundidad de comprensión, no en la velocidad.\n¡Nos vemos en el siguiente módulo! 🚀\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"04 septiembre 2025","externalUrl":null,"permalink":"/ai/module1/conclusion/","section":"Inteligencia Artificial","summary":"","title":"Fundamentos de Inteligencia Artificial: Conclusión","type":"ai"},{"content":"Key characteristics of aggregation:\nIt\u0026rsquo;s a stronger relationship than a simple association, but weaker than composition. The \u0026ldquo;part\u0026rdquo; object can exist independently of the \u0026ldquo;whole\u0026rdquo; object. Multiple \u0026ldquo;whole\u0026rdquo; objects can share the same \u0026ldquo;part\u0026rdquo; object. If the \u0026ldquo;whole\u0026rdquo; object is destroyed, the \u0026ldquo;part\u0026rdquo; object continues to exist. Let\u0026rsquo;s look at an example to illustrate aggregation:\nclass Department: def __init__(self, name): self.name = name self.employees = [] def add_employee(self, employee): self.employees.append(employee) def remove_employee(self, employee): self.employees.remove(employee) def list_employees(self): return f\u0026#34;Department {self.name} has employees: {\u0026#39;, \u0026#39;.join(emp.name for emp in self.employees)}\u0026#34; class Employee: def __init__(self, name, id): self.name = name self.id = id def __str__(self): return f\u0026#34;Employee(name={self.name}, id={self.id})\u0026#34; # Creating instances hr_dept = Department(\u0026#34;Human Resources\u0026#34;) it_dept = Department(\u0026#34;Information Technology\u0026#34;) emp1 = Employee(\u0026#34;Alice\u0026#34;, \u0026#34;E001\u0026#34;) emp2 = Employee(\u0026#34;Bob\u0026#34;, \u0026#34;E002\u0026#34;) emp3 = Employee(\u0026#34;Charlie\u0026#34;, \u0026#34;E003\u0026#34;) # Adding employees to departments hr_dept.add_employee(emp1) hr_dept.add_employee(emp2) it_dept.add_employee(emp2) # Note: Bob works in both HR and IT it_dept.add_employee(emp3) print(hr_dept.list_employees()) print(it_dept.list_employees()) # If we remove the HR department, the employees still exist del hr_dept print(emp1) # Employee still exists In this example, we have an aggregation relationship between Department and Employee. A Department has Employees, but Employees can exist independently of any particular Department. Also, an Employee can belong to multiple Departments (as we see with Bob).\nHere\u0026rsquo;s a UML diagram representing this aggregation relationship:\nclassDiagram class Department { +name: string +employees: list +add_employee(employee) +remove_employee(employee) +list_employees() } class Employee { +name: string +id: string +__str__() } Department o-- Employee : has end In this diagram, the open diamond on the Department side of the relationship indicates aggregation. This shows that Department is the \u0026ldquo;whole\u0026rdquo; and Employee is the \u0026ldquo;part\u0026rdquo; in this relationship.\nIt\u0026rsquo;s important to note that while aggregation implies a whole-part relationship, the \u0026ldquo;part\u0026rdquo; (in this case, Employee) can exist independently and can even be part of multiple \u0026ldquo;wholes\u0026rdquo; (multiple Departments).\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-aggregation/","section":"Programming","summary":"","title":"Class relations: Aggregation","type":"programming"},{"content":"La naturaleza LIFO de las pilas se debe a que sólo se puede acceder y manipular el elemento superior. La operación de colocar un elemento sobre la pila se conoce como \u0026ldquo;push\u0026rdquo;, mientras que sacar un elemento de la pila es un \u0026ldquo;pop\u0026rdquo;. El funcionamiento LIFO provoca que el último elemento colocado en una pila sea el primero en ser retirado.\nDiagrama de una pila Operaciones principales # Las operaciones primarias que soporta una estructura de pila son:\nPush: agrega un elemento encima de la pila. Pop: saca el elemento de la pila que se encuentra en la cima. Peek: permite acceder al elemento de la cima sin sacarlo de la pila. isEmpty: consulta si la pila se encuentra vacía. La mayoría de los lenguajes como Python y Java proveen implementaciones de pilas en sus librerías estándar.\nImplementación # Una pila puede implementarse utilizando una lista enlazada de manera que cada node apunte al nodo anterior.\nclass Node: def __init__(self, value): self.value = value self.previous = None class Stack: def __init__(self): self.top = None self.size = 0 def push(self, value): new_node = Node(value) if self.top is None: self.top = new_node else: new_node.previous = self.top self.top = new_node self.size += 1 def pop(self): if self.top is None: return None top_node = self.top self.top = self.top.previous self.size -= 1 return top_node.value def peek(self): if self.top is None: return None return self.top.value def is_empty(self): return self.top is None # Returns true if top is None def __len__(self): return self.size def __str__(self): values = [] current = self.top while current: values.append(str(current.value)) current = current.previous return \u0026#34;\\n\u0026#34;.join(values) print(\u0026#34;Creating a new stack\u0026#34;) stack = Stack() print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if stack is empty\u0026#34;) print(f\u0026#34;Is stack empty? {stack.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Push first element\u0026#34;) print(\u0026#34; stack.push(\\\u0026#34;First\\\u0026#34;)\u0026#34;) stack.push(\u0026#34;First\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print stack:\u0026#34;) print(stack) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print top element using peek\u0026#34;) print(f\u0026#34;stack.peek() =\u0026gt; {stack.peek()}\u0026#34;) print(\u0026#34;Add two more elements: stack.push(\\\u0026#34;\\\u0026#34;):\u0026#34;) print(\u0026#34; stack.push(\\\u0026#34;Second\\\u0026#34;)\u0026#34;) print(\u0026#34; stack.push(\\\u0026#34;Third\\\u0026#34;)\u0026#34;) stack.push(\u0026#34;Second\u0026#34;) stack.push(\u0026#34;Third\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print stack:\u0026#34;) print(stack) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print top element using peek\u0026#34;) print(f\u0026#34;stack.peek() =\u0026gt; {stack.peek()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if stack is empty\u0026#34;) print(f\u0026#34;Is stack empty? {stack.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get top element using pop\u0026#34;) print(f\u0026#34;stack.pop() =\u0026gt; {stack.pop()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print top element using peek\u0026#34;) print(f\u0026#34;stack.peek() =\u0026gt; {stack.peek()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get top element using pop\u0026#34;) print(f\u0026#34;stack.pop() =\u0026gt; {stack.pop()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get top element using pop\u0026#34;) print(f\u0026#34;stack.pop() =\u0026gt; {stack.pop()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if stack is empty\u0026#34;) print(f\u0026#34;Is stack empty? {stack.is_empty()}\u0026#34;) Ejemplos de uso # Las pilas tienen muchos usos en programación:\nPila de ejecución (call stack): registra las llamadas a funciones pendientes de resolver. Implementa el comportamiento LIFO esperado.\nPila de navegador: permite volver atrás (undo) en el historial de navegación de forma similar a una pila LIFO.\nEjecución de expresiones matemáticas: mediante una pila se puede verificar paréntesis, corchetes, llaves, etc.\nAlgoritmos y estructuras de datos: como en el algoritmo quicksort y en la implementación de buses de datos (datapaths).\nConclusión # Las pilas son estructuras de datos versátiles gracias a su principio de funcionamiento LIFO. Tener un buen dominio de pilas, sus usos y aplicaciones es esencial en la ciencia de la computación.\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"02 noviembre 2023","externalUrl":null,"permalink":"/programming/data-structures/stacks/","section":"Programación","summary":"","title":"Pilas","type":"programming"},{"content":" Recursión: el arte de llamarse a sí mismo # Imagina una caja de espejos donde cada espejo refleja lo que ve en el siguiente, creando una serie infinita de reflejos. La recursión en programación es algo similar. Es una técnica donde una función se llama a sí misma directa o indirectamente[^1^]. Esto crea un ciclo en el cual la función resuelve un problema dividiéndolo en instancias más pequeñas del mismo problema, hasta llegar a un caso base sencillo de resolver.\nPor ejemplo, imaginemos una función que imprime un contador regresivo:\ndef cuenta_regresiva(numero): if numero \u0026gt; 0: print(numero) cuenta_regresiva(numero - 1) else: print(\u0026#34;¡Despegue!\u0026#34;) cuenta_regresiva(5) Esta función se llama recursivamente reduciendo el número cada vez hasta llegar a 0, y luego imprime el mensaje de despegue.\nLa recursión es un enfoque declarativo donde se enfoca en dividir un problema en casos recursivos sin necesidad de controlar explícitamente el bucle usando iteradores o contadores como en la programación imperativa.\nLa estructura de una función recursiva # El poder de la recursión radica en su simplicidad. Sin embargo, es esencial entender su estructura para evitar caer en trampas comunes. Una función recursiva típica tiene dos partes principales1:\nCaso base: El caso más simple con una solución conocida que no requiere recursión. Es la condición de parada, que detiene la recursión. Sin el caso base, caeríamos en una recursión infinita que eventualmente desborda la pila de llamadas. Caso recursivo: Es donde ocurre la mágica llamada recursiva. En este punto, la función se llama a sí misma con un argumento modificado, generalmente una versión reducida del problema original. Ejemplos clásicos de recursión # Factorial # El factorial de un entero positivo \\(n\\) es el producto de todos los enteros positivos menores o iguales a \\(n\\). Por ejemplo:\n\\(5! = 5 * 4 * 3 * 2 * 1 = 120\\) \\(4! = 4 * 3 * 2 * 1 = 24\\) \\(3! = 3 * 2 * 1 = 6\\) Aquí está el código en Python para calcular el factorial usando recursión:\ndef factorial(n): if n == 1: return 1 # Caso base return n * factorial(n-1) # Caso recursivo Caso base: El caso base es la instancia más simple y pequeña del problema que puede responderse directamente. Para el factorial, cuando \\(n = 1\\), el resultado es \\(1\\). Caso recursivo: Si \\(n\\) es mayor que \\(1\\), la función se llama a sí misma con \\(n-1\\), y multiplica el resultado por \\(n\\). Digamos que quieres calcular el factorial de \\(5\\), así que llamas a factorial(5).\nEsto es lo que sucede:\nPaso 1: Como \\(n = 5\\) no es \\(1\\), la función llama a factorial(4), luego multiplica el resultado por \\(5\\). Paso 2: Ahora, dentro de factorial(4), \\(n = 4\\), entonces la función llama a factorial(3), luego multiplica el resultado por \\(4\\). Paso 3: Dentro de factorial(3), \\(n = 3\\), así que llama a factorial(2), luego multiplica el resultado por \\(3\\). Paso 4: Dentro de factorial(2), \\(n = 2\\), así que llama a factorial(1), luego multiplica el resultado por \\(2\\). Paso 5: Finalmente, factorial(1) alcanza el caso base, donde \\(n = 1\\), así que retorna \\(1\\). Ahora los resultados se desenrollan:\nfactorial(2) retorna \\(2 * 1 = 2\\) factorial(3) retorna \\(3 * 2 = 6\\) factorial(4) retorna \\(4 * 6 = 24\\) factorial(5) retorna \\(5 * 24 = 120\\) El resultado final es \\(120\\), que es el valor de \\(5!\\).\nAquí hay una representación visual de la pila de llamadas:\nfactorial(5) -\u0026gt; factorial(4) -\u0026gt; factorial(3) -\u0026gt; factorial(2) -\u0026gt; factorial(1) return 1 return 2 return 6 return 24 return 120 Serie de Fibonacci # La serie de Fibonacci es una secuencia de números donde cada número es la suma de los dos anteriores. Comienza con \\(0\\) y \\(1\\), y cada número posterior es la suma de los dos números anteriores. Los primeros números de la secuencia son: \\(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \u0026hellip;\\)\nAquí está el código en Python para calcular el \\(n^th\\) número de Fibonacci usando recursión de cola:\ndef fibonacci(n, a=0, b=1): if n == 0: return a return fibonacci(n-1, b, a+b) La función toma tres parámetros:\n\\(n\\): La posición del número deseado en la secuencia. \\(a\\) y \\(b\\): Dos números que ayudan en el cálculo de la secuencia. Aquí hay un desglose de cómo funciona la función:\nCaso Base: Si \\(n\\) es \\(0\\), la función devuelve \\(a\\). Este es el valor del \\(n^th\\) número en la secuencia.\nCaso Recursivo: Si \\(n\\) no es \\(0\\), la función se llama a sí misma con \\(n-1\\), \\(b\\), y \\(a+b\\). Estos parámetros cambian la posición en la secuencia y preparan los siguientes números para la suma.\nSupongamos que queremos encontrar el \\(5^th\\) número en la secuencia de Fibonacci llamando a fibonacci(5).\nEsto es lo que sucede:\nPaso 1: Dado que \\(n = 5\\), llama a fibonacci(4, 1, 1) (porque \\(a = 0\\), \\(b = 1\\), \\(a + b = 1\\)). Paso 2: Dado que \\(n = 4\\), llama a fibonacci(3, 1, 2) (porque \\(a = 1\\), \\(b = 1\\), \\(a + b = 2\\)). Paso 3: Dado que \\(n = 3\\), llama a fibonacci(2, 2, 3) (porque \\(a = 1\\), \\(b = 2\\), \\(a + b = 3\\)). Paso 4: Dado que \\(n = 2\\), llama a fibonacci(1, 3, 5) (porque \\(a = 2\\), \\(b = 3\\), \\(a + b = 5\\)). Paso 5: Dado que \\(n = 1\\), llama a fibonacci(0, 5, 8) (porque \\(a = 3\\), \\(b = 5\\), \\(a + b = 8\\)). Paso 6: Dado que \\(n = 0\\), devuelve \\(a\\), que es \\(5\\). El resultado es \\(5\\), que es el \\(5^th\\) número en la secuencia de Fibonacci.\nAquí hay una representación visual de la pila de llamadas:\nfibonacci(5, 0, 1) -\u0026gt; fibonacci(4, 1, 1) -\u0026gt; fibonacci(3, 1, 2) -\u0026gt; fibonacci(2, 2, 3) -\u0026gt; fibonacci(1, 3, 5) -\u0026gt; fibonacci(0, 5, 8) return 5 Ventajas y desventajas # La recursión tiene ciertas ventajas2:\nPuede resultar en soluciones simples y elegantes para problemas que se dividen fácilmente en subproblemas. Elimina la necesidad de control de bucles explícito. Sigue la estructura matemática de una definición recursiva. Las desventajas incluyen:\nPuede ser menos eficiente (alto consumo de memoria) que la iteración debido a las llamadas repetidas y creación de marcos de pila. Demasiada recursión puede desbordar la pila de llamadas y causar errores. Puede ser más difícil de depurar y analizar que la iteración. Por lo tanto, la recursión es una herramienta poderosa que debe usarse con discreción en los casos apropiados.\nRecursión vs Iteración # La recursión y la iteración (usando ciclos) son paralelos y podemos usar cualquiera para resolver muchos problemas. Ambas técnicas tienen el potencial de resolver los mismos problemas, pero su implementación y eficiencia pueden variar. Tomemos el ejemplo del factorial:\nIterativo\ndef factorial_iterativo(n): resultado = 1 for i in range(1, n+1): resultado *= i return resultado Recursivo\ndef factorial_recursivo(n): if n == 1: return 1 return n * factorial(n-1) La versión iterativa es más eficiente en términos de espacio, pero la recursiva es más limpia y fácil de entender. La elección entre recursión e iteración a menudo depende del problema específico, las restricciones de memoria y las preferencias del programador.\nConclusión # La recursión es una técnica clave que permite escribir algoritmos elegante, naturales y eficientes si se utiliza adecuadamente. Entender cómo dividir un problema en casos recursivos es esencial para dominar esta habilidad. La recursión ofrece una alternativa declarativa única para resolver problemas complejos sin necesidad de administrar bucles explícitos. Sin embargo, es crucial recordar siempre definir un caso base adecuado y ser consciente de las limitaciones de la recursión en términos de eficiencia y uso de memoria. Saber combinar recursión e iteración nos da flexibilidad al crear soluciones óptimas.\nComo siempre, la clave está en encontrar el equilibrio adecuado y utilizar la herramienta correcta para el trabajo adecuado.\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\nReferencias # Kindler, E., \u0026amp; Krivy, I. (2011). Object-Oriented Simulation of systems with Java: A working introduction. BoD–Books on Demand.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"30 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/recursive-functions/","section":"Programación","summary":"","title":"Funciones Recursivas","type":"programming"},{"content":" Elegir un lenguaje de programación # La elección del lenguaje de programación es el primer y quizás el más crucial paso en el proceso de aprendizaje. Hay varios factores a considerar al seleccionar un lenguaje, incluyendo:\nPropósito: ¿Para qué quieres programar? Si es para desarrollo web, JavaScript o PHP podrían ser buenas opciones. Si estás interesado en la ciencia de datos, R o Python podrían ser más adecuados. Comunidad: Un lenguaje con una comunidad activa puede ser esencial para los principiantes. Una comunidad vibrante generalmente significa más recursos, tutoriales y soluciones disponibles en línea. Curva de aprendizaje: Algunos lenguajes son más fáciles de aprender que otros. Es fundamental elegir uno que coincida con tu nivel de experiencia y paciencia. Oportunidades de trabajo: Si estás buscando una carrera en programación, investigar la demanda del mercado para diferentes lenguajes puede ser útil. Aunque hay muchos lenguajes valiosos y poderosos, para este curso, hemos elegido Python. Este lenguaje es conocido por su simplicidad y legibilidad, lo que lo hace ideal para aquellos que están empezando. Además, Python cuenta con una comunidad activa y una amplia gama de aplicaciones, desde desarrollo web hasta inteligencia artificial1.\nInstalación de Python # Para usuarios de Windows: # Descargar el instalador: Visita el sitio web oficial de Python en https://www.python.org/downloads/windows/ Haz clic en el enlace de descarga para la última versión de Python 3.x. Ejecuta el instalador: Una vez completada la descarga, localiza y ejecuta el archivo instalador .exe. Asegúrate de marcar la casilla que dice \u0026ldquo;Agregar Python al PATH\u0026rdquo; durante la instalación. Este paso es crucial para hacer que Python sea accesible desde el Símbolo del Sistema. Sigue las indicaciones de instalación. Verifica la instalación: Abre el Símbolo del Sistema y escribe: python --version Esto debería mostrar la versión de Python que acabas de instalar. Para usuarios de Mac: # Descargar el instalador: Visita el sitio web oficial de Python en https://www.python.org/downloads/mac-osx/ Haz clic en el enlace de descarga para la última versión de Python 3.x. Ejecuta el instalador: Una vez descargado, localiza y ejecuta el archivo .pkg. Sigue las indicaciones de instalación. Verifica la instalación: Abre la Terminal y escribe: python3 --version Esto debería mostrar la versión de Python que acabas de instalar. Para usuarios de Linux (Ubuntu/Debian): # Actualiza los paquetes: sudo apt update Instala Python: sudo apt install python3 Verifica la instalación: Después de la instalación, puedes comprobar la versión de Python instalada escribiendo: python3 --version Entornos de Desarrollo Integrado (IDEs) # Un IDE es una herramienta que facilita el desarrollo de aplicaciones al combinar comúnmente utilizadas en un solo software: editor de código, compilador, depurador, entre otros. Elegir el IDE adecuado puede hacer que el proceso de programación sea más fluido y eficiente.\nAl evaluar IDEs, considera:\nCompatibilidad con el lenguaje: No todos los IDEs son compatibles con todos los lenguajes de programación. Características: Algunos IDEs ofrecen funcionalidades como autocompletado, resaltado de sintaxis y herramientas de depuración. Extensiones y plugins: La posibilidad de personalizar y extender tu IDE a través de plugins puede ser muy útil. Precio: Hay IDEs gratuitos y otros de pago. Evalúa si las características adicionales de un IDE de pago justifican el costo. Para este curso, hemos seleccionado Visual Studio Code (VS Code). Es un IDE popular que es gratuito y de código abierto. Es conocido por su interfaz sencilla, amplia gama de plugins y capacidad para manejar múltiples lenguajes de programación2. Su comunidad activa garantiza actualizaciones regulares y una amplia gama de recursos de aprendizaje.\nInstalación de Visual Studio Code # Para usuarios de Windows: # Descargar el instalador: Visita el sitio web oficial de VS Code en https://code.visualstudio.com/ Haz clic en el botón \u0026ldquo;Descargar para Windows\u0026rdquo;. Ejecuta el instalador: Una vez completada la descarga, localiza y ejecuta el archivo instalador .exe. Sigue las indicaciones de instalación, incluyendo aceptar el acuerdo de licencia y elegir la ubicación de instalación. Inicia VS Code: Tras la instalación, puedes encontrar VS Code en tu menú de inicio. Lánzalo, ¡y estarás listo para comenzar a programar! Para usuarios de Mac: # Descargar el instalador: Visita el sitio web oficial de VS Code en https://code.visualstudio.com/ Haz clic en el botón \u0026ldquo;Descargar para Mac\u0026rdquo;. Instala VS Code: Una vez descargado, abre el archivo .zip. Arrastra la aplicación Visual Studio Code .app a la carpeta Aplicaciones, para que esté disponible en el Launchpad. Inicia VS Code: Usa la búsqueda de Spotlight o navega hasta tu carpeta de Aplicaciones para iniciar VS Code. Para usuarios de Linux (Ubuntu/Debian): # Actualiza los paquetes e instala las dependencias: sudo apt update sudo apt install software-properties-common apt-transport-https wget **Descarga e instala la claves necesarias: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Añade el repositorio de VS Code: sudo add-apt-repository \u0026#34;deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main\u0026#34; Instala Visual Studio Code: sudo apt update sudo apt install code Inicia VS Code: Puedes iniciar VS Code desde la terminal escribiendo code o encontrarlo en tu lista de aplicaciones instaladas. Escribe y ejecuta tu primer programa # Una vez que hayas configurado tu entorno de programación, es hora de sumergirse en la codificación.\n¡Hola mundo! # Este es posiblemente el programa más icónico para principiantes. Es simple, pero te introduce al proceso de escribir y ejecutar código.\nprint(\u0026#34;¡Hola mundo!\u0026#34;) Ejecución del programa Hola Mundo Cálculo de área y perímetro de un triángulo # Este programa es un poco más complejo. No solo imprime un mensaje, sino que también realiza cálculos matemáticos.\n# Entrada del usuario lado1 = float(input(\u0026#34;Introduce la longitud del primer lado: \u0026#34;)) lado2 = float(input(\u0026#34;Introduce la longitud del segundo lado: \u0026#34;)) lado3 = float(input(\u0026#34;Introduce la longitud del tercer lado: \u0026#34;)) # Cálculo del perímetro perimetro = lado1 + lado2 + lado3 # Cálculo del área usando la fórmula de Herón s = perimetro / 2 area = (s*(s-lado1)*(s-lado2)*(s-lado3)) ** 0.5 print(f\u0026#34;El perímetro del triángulo es: {perimetro}\u0026#34;) print(f\u0026#34;El área del triángulo es: {area:.2f}\u0026#34;) Ejecución del programa Triangulo Conclusión # Configurar un entorno de programación puede parecer desalentador al principio, pero con las herramientas y recursos adecuados, se convierte en una tarea manejable y gratificante. Esperamos que este artículo te haya proporcionado una base sólida para comenzar tu viaje en programación. ¡Feliz codificación!\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\nReferencias # Lutz, M. (2013). Learning Python. O\u0026rsquo;Reilly Media.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMicrosoft. (2020). Visual Studio Code Documentation. Microsoft Docs.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"10 septiembre 2023","externalUrl":null,"permalink":"/programming/intro/setup-dev-environment/","section":"Programación","summary":"","title":"Configura tu Entorno de Desarrollo","type":"programming"},{"content":"Key characteristics of composition:\nIt represents a strong \u0026ldquo;has-a\u0026rdquo; relationship. The \u0026ldquo;part\u0026rdquo; object cannot exist independently of the \u0026ldquo;whole\u0026rdquo; object. When the \u0026ldquo;whole\u0026rdquo; object is destroyed, all its \u0026ldquo;part\u0026rdquo; objects are also destroyed. A \u0026ldquo;part\u0026rdquo; object belongs to only one \u0026ldquo;whole\u0026rdquo; object at a time. Let\u0026rsquo;s look at an example to illustrate composition:\nclass Engine: def __init__(self, horsepower): self.horsepower = horsepower def start(self): return \u0026#34;Engine started\u0026#34; class Car: def __init__(self, make, model, horsepower): self.make = make self.model = model self.engine = Engine(horsepower) # Composition: Car creates its own Engine def start_car(self): return f\u0026#34;{self.make} {self.model}: {self.engine.start()}\u0026#34; def __del__(self): print(f\u0026#34;{self.make} {self.model} is being destroyed, and so is its engine.\u0026#34;) # Creating a Car instance my_car = Car(\u0026#34;Toyota\u0026#34;, \u0026#34;Corolla\u0026#34;, 150) print(my_car.start_car()) # Output: Toyota Corolla: Engine started # When we delete the Car, its Engine is also deleted del my_car # This will print: Toyota Corolla is being destroyed, and so is its engine. In this example, we have a composition relationship between Car and Engine. A Car has an Engine, and the Engine cannot exist independently of the Car. When a Car object is created, it creates its own Engine. When the Car object is destroyed, its Engine is also destroyed.\nHere\u0026rsquo;s a UML diagram representing this composition relationship:\nclassDiagram class Car { +make: string +model: string -engine: Engine +start_car() +__del__() } class Engine { -horsepower: int +start() } Car *-- Engine : has end In this diagram, the filled diamond on the Car side of the relationship indicates composition. This shows that Car is the \u0026ldquo;whole\u0026rdquo; and Engine is the \u0026ldquo;part\u0026rdquo; in this relationship, and that the Engine\u0026rsquo;s lifetime is tied to the Car\u0026rsquo;s lifetime.\nThe key difference between aggregation and composition is the strength of the relationship and the lifecycle dependency. In aggregation, the \u0026ldquo;part\u0026rdquo; can exist independently of the \u0026ldquo;whole\u0026rdquo;, while in composition, the \u0026ldquo;part\u0026rdquo; cannot exist without the \u0026ldquo;whole\u0026rdquo;.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-composition/","section":"Programming","summary":"","title":"Class relations: Composition","type":"programming"},{"content":"La naturaleza FIFO (first in, first out) de las colas se debe a que sólo se puede acceder y manipular el elemento inicial. Cuando se agrega un elemento a la cola se conoce como \u0026ldquo;enqueue\u0026rdquo;, mientras que eliminar un elemento se denomina \u0026ldquo;dequeue\u0026rdquo;.\nEsto hace que el primer elemento en ser añadido a la cola también sea el primero en ser retirado, de ahí su comportamiento FIFO.\nDiagrama de una cola Operaciones principales # Las operaciones básicas de una cola son:\nEnqueue: Agrega un elemento al final de la cola. Dequeue: Saca el elemento del frente de la cola. Peek: Obtiene el elemento al frente sin sacarlo. isEmpty: Consulta si la cola está vacía. Implementación # Al igual que las pilas, las colas se pueden implementar usando listas enlazadas. Se agrega al final y se saca del frente manteniendo referencias a ambos extremos.\nclass Node: def __init__(self, value): self.value = value self.next = None class Queue: def __init__(self): self.front = None self.end = None self.size = 0 def enqueue(self, value): new_node = Node(value) if self.end is None: self.end = new_node self.front = new_node return self.end.next = new_node self.end = new_node self.size += 1 def dequeue(self): if self.is_empty(): return None value = self.front.value self.front = self.front.next if self.front is None: self.end = None self.size -= 1 return value def peek(self): if self.is_empty(): return None return self.front.value def is_empty(self): return self.front is None # Returns true if front is None def __len__(self): return self.size def __str__(self): values = [] current = self.front while current: values.append(str(current.value)) current = current.next return \u0026#34;\\n\u0026#34;.join(values) print(\u0026#34;Creating a new queue\u0026#34;) queue = Queue() print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if queue is empty\u0026#34;) print(f\u0026#34;Is queue empty? {queue.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Enqueue three elements\u0026#34;) queue.enqueue(\u0026#34;ABC\u0026#34;) queue.enqueue(\u0026#34;DEF\u0026#34;) queue.enqueue(\u0026#34;GHI\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after enqueuing elements:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get front element using dequeue\u0026#34;) print(f\u0026#34;queue.dequeue() =\u0026gt; {queue.dequeue()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after dequeue element:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print front element using peek\u0026#34;) print(f\u0026#34;queue.peek() =\u0026gt; {queue.peek()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after peek:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get front element using dequeue\u0026#34;) print(f\u0026#34;queue.dequeue() =\u0026gt; {queue.dequeue()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after dequeue element:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if queue is empty\u0026#34;) print(f\u0026#34;Is queue empty? {queue.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get front element using dequeue\u0026#34;) print(f\u0026#34;queue.dequeue() =\u0026gt; {queue.dequeue()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after dequeue element:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if queue is empty\u0026#34;) print(f\u0026#34;Is queue empty? {queue.is_empty()}\u0026#34;) Ejemplos de uso # Algunos usos comunes de colas:\nColas de impresión donde primero en entrar, primero en imprimir. Colas de tareas en sistemas operativos para orden de ejecución. Simulaciones donde se debe respetar orden de llegada como en bancos. Canales de mensajes como los de RabbitMQ o Kafka. Buffers circulares en audio para streaming. Conclusión # Las colas son estructuras versátiles gracias a su principio FIFO. Tener un buen manejo de colas, implementación y aplicaciones reforzará tus habilidades como programador.\n¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"03 noviembre 2023","externalUrl":null,"permalink":"/programming/data-structures/queues/","section":"Programación","summary":"","title":"Colas","type":"programming"},{"content":"Key characteristics of inheritance:\nIt promotes code reuse and establishes a hierarchy between classes. The subclass inherits all public and protected members from the superclass. The subclass can add its own members and override inherited members. It supports the concept of polymorphism. Let\u0026rsquo;s look at an example to illustrate inheritance:\nclass Animal: def __init__(self, name): self.name = name def speak(self): pass class Dog(Animal): def speak(self): return f\u0026#34;{self.name} says Woof!\u0026#34; class Cat(Animal): def speak(self): return f\u0026#34;{self.name} says Meow!\u0026#34; # Creating instances dog = Dog(\u0026#34;Buddy\u0026#34;) cat = Cat(\u0026#34;Whiskers\u0026#34;) print(dog.speak()) # Output: Buddy says Woof! print(cat.speak()) # Output: Whiskers says Meow! # Demonstrating polymorphism def animal_sound(animal): print(animal.speak()) animal_sound(dog) # Output: Buddy says Woof! animal_sound(cat) # Output: Whiskers says Meow! In this example, we have a base class Animal and two derived classes Dog and Cat. Both Dog and Cat inherit from Animal and override the speak method.\nHere\u0026rsquo;s a UML diagram representing this inheritance relationship:\nclassDiagram class Animal { +name: string +speak() } class Dog { +speak() } class Cat { +speak() } Animal \u003c|-- Dog Animal \u003c|-- Cat end In this diagram, the arrows pointing from Dog and Cat to Animal indicate inheritance. This shows that Dog and Cat are subclasses of Animal.\nInheritance is a powerful feature of OOP, but it should be used judiciously. Overuse of inheritance can lead to complex class hierarchies that are difficult to understand and maintain. The principle of \u0026ldquo;composition over inheritance\u0026rdquo; suggests that it\u0026rsquo;s often better to use composition (has-a relationship) rather than inheritance (is-a relationship) when designing class relationships.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-inheritance/","section":"Programming","summary":"","title":"Class relations: Inheritance","type":"programming"},{"content":"Key characteristics of realisation:\nIt represents a contract that the implementing class must fulfil. The class must provide implementations for all methods declared in the interface. It allows for polymorphism through interfaces. Python doesn\u0026rsquo;t have a built-in interface concept like some other languages (e.g., Java), but we can simulate interfaces using abstract base classes. Here\u0026rsquo;s an example:\nfrom abc import ABC, abstractmethod class Drawable(ABC): @abstractmethod def draw(self): pass class Circle(Drawable): def draw(self): return \u0026#34;Drawing a circle\u0026#34; class Square(Drawable): def draw(self): return \u0026#34;Drawing a square\u0026#34; def draw_shape(shape: Drawable): print(shape.draw()) # Creating instances circle = Circle() square = Square() # Using polymorphism through the interface draw_shape(circle) # Output: Drawing a circle draw_shape(square) # Output: Drawing a square In this example, Drawable is an abstract base class that acts like an interface. Both Circle and Square implement the Drawable interface by providing their own implementation of the draw method.\nHere\u0026rsquo;s a UML diagram representing this realisation relationship:\nclassDiagram class Drawable { \u003c\u003e +draw() } class Circle { +draw() } class Square { +draw() } Drawable \u003c|.. Circle Drawable \u003c|.. Square end In this diagram, the dashed arrows pointing from Circle and Square to Drawable indicate realisation. This shows that Circle and Square implement the Drawable interface.\nRealisation is a powerful concept that allows for designing loosely coupled systems. By programming to interfaces rather than concrete implementations, we can create more flexible and extensible software.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-realisation/","section":"Programming","summary":"","title":"Class relations: Realisation (Implementation)","type":"programming"},{"content":"Key characteristics of dependency:\nIt represents a \u0026ldquo;uses\u0026rdquo; relationship between classes. It\u0026rsquo;s a weaker relationship compared to association, aggregation, or composition. Changes in the used class may affect the using class. Here\u0026rsquo;s an example to illustrate dependency:\nclass Printer: def print_document(self, document): return f\u0026#34;Printing: {document.get_content()}\u0026#34; class PDFDocument: def get_content(self): return \u0026#34;PDF content\u0026#34; class WordDocument: def get_content(self): return \u0026#34;Word document content\u0026#34; # Using the Printer printer = Printer() pdf = PDFDocument() word = WordDocument() print(printer.print_document(pdf)) # Output: Printing: PDF content print(printer.print_document(word)) # Output: Printing: Word document content In this example, the Printer class has a dependency on both PDFDocument and WordDocument classes. The Printer uses these classes in its print_document method, but it doesn\u0026rsquo;t maintain a long-term relationship with them.\nHere\u0026rsquo;s a UML diagram representing these dependency relationships:\nclassDiagram class Printer { +print_document(document) } class PDFDocument { +get_content() } class WordDocument { +get_content() } Printer ..\u003e PDFDocument : uses Printer ..\u003e WordDocument : uses end In this diagram, the dashed arrows pointing from Printer to PDFDocument and WordDocument indicate dependency. This shows that Printer uses these classes, but doesn\u0026rsquo;t have a stronger relationship with them.\nDependency is often used to reduce coupling between classes. By depending on abstractions (like interfaces) rather than concrete classes, we can make our code more flexible and easier to change.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-dependency/","section":"Programming","summary":"","title":"Class relations: Dependency","type":"programming"},{"content":" Comparing and contrasting relations # Now that we\u0026rsquo;ve explored the various types of class relations, let\u0026rsquo;s compare and contrast them to better understand when to use each:\nAssociation vs Aggregation vs Composition\nAssociation is the most general relationship, representing any connection between classes. Aggregation is a specialised association representing a whole-part relationship where the part can exist independently. Composition is the strongest whole-part relationship where the part cannot exist independently of the whole. Inheritance vs Composition\nInheritance represents an \u0026ldquo;is-a\u0026rdquo; relationship (e.g., a Dog is an Animal). Composition represents a \u0026ldquo;has-a\u0026rdquo; relationship (e.g., a Car has an Engine). The principle of \u0026ldquo;composition over inheritance\u0026rdquo; suggests favouring composition for more flexible designs. Realisation vs Inheritance\nRealisation is about implementing an interface, focusing on behaviour. Inheritance is about extending a class, inheriting both state and behaviour. Dependency vs Association\nDependency is a weaker, often temporary relationship (e.g., a method parameter). Association implies a more permanent relationship, often represented by a class attribute. Here\u0026rsquo;s a comparison table summarising these relationships:\nRelationship Strength Lifecycle Binding \u0026ldquo;Is-a\u0026rdquo; or \u0026ldquo;Has-a\u0026rdquo; Symbol in UML Dependency Weakest None Uses - - - - \u0026gt; Association Weak Independent Has-a (loose) ———\u0026gt; Aggregation Medium Independent Has-a ◇———\u0026gt; Composition Strong Dependent Has-a (strong) ♦———\u0026gt; Inheritance Strong N/A Is-a ——— Realisation Medium N/A Behaves-as - - - Common pitfalls # While class relationships are powerful tools in OOP, they can also lead to common pitfalls if not used carefully. Here are some common issues and how to avoid them:\nOveruse of inheritance\nProblem: Creating deep inheritance hierarchies that are hard to understand and maintain. Solution: Prefer composition over inheritance. Use inheritance only for genuine \u0026ldquo;is-a\u0026rdquo; relationships. Tight coupling\nProblem: Creating strong dependencies between classes, making the system rigid and hard to change. Solution: Use interfaces and dependency injection to reduce coupling. Depend on abstractions rather than concrete classes. God objects\nProblem: Creating classes that try to do too much, violating the Single Responsibility Principle. Solution: Break large classes into smaller, more focused classes. Use composition to bring functionality together. Circular dependencies\nProblem: Creating mutual dependencies between classes, leading to complex and hard-to-maintain code. Solution: Refactor to remove circular dependencies. Consider using interfaces or introducing a new class to break the cycle. Leaky abstractions\nProblem: Exposing implementation details through interfaces or base classes. Solution: Design interfaces and base classes carefully. Hide implementation details and expose only what\u0026rsquo;s necessary. Inappropriate intimacy\nProblem: Classes that know too much about each other\u0026rsquo;s internal details. Solution: Encapsulate data and behaviour. Use public interfaces to interact between classes. Brittle base classes\nProblem: Changes to base classes breaking derived classes in unexpected ways. Solution: Design base classes for extension. Document how derived classes should interact with base classes. Diamond problem in multiple inheritance\nProblem: Ambiguity in method resolution when a class inherits from two classes with a common ancestor. Solution: Avoid multiple inheritance if possible. Use interfaces or mixins instead. Overuse of getters and setters\nProblem: Breaking encapsulation by providing unrestricted access to internal state. Solution: Use meaningful methods that represent behaviors rather than exposing internal data directly. Violation of Liskov Substitution Principle\nProblem: Derived classes that can\u0026rsquo;t be used interchangeably with their base classes. Solution: Ensure that derived classes truly represent specialisations of their base classes. Use composition if the \u0026ldquo;is-a\u0026rdquo; relationship doesn\u0026rsquo;t hold. By being aware of these pitfalls and following best practices, you can create more robust and maintainable object-oriented designs.\nConclusion # Key takeaways:\nAssociation is a general relationship between classes. Aggregation represents a whole-part relationship where parts can exist independently. Composition is a stronger whole-part relationship where parts cannot exist independently. Inheritance represents an \u0026ldquo;is-a\u0026rdquo; relationship and promotes code reuse. Realisation is about implementing interfaces and focusing on behaviour. Dependency is a weak, often temporary relationship between classes. Remember that good object-oriented design is not just about using these relationships, but about using them appropriately. Always consider the SOLID principles and the \u0026ldquo;composition over inheritance\u0026rdquo; guideline.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy – drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-conclusion/","section":"Programming","summary":"","title":"Class relations: Conclusion","type":"programming"},{"content":"En el corazón de la Programación Orientada a Objetos (POO) se encuentran cuatro conceptos fundamentales: Encapsulamiento, Herencia, Polimorfismo y Abstracción. Estos conceptos, conocidos como los \u0026ldquo;cuatro pilares\u0026rdquo; de la POO, constituyen la base sobre la cual se construyen sistemas de software complejos. En esta guía, profundizaremos en cada uno de estos conceptos, explorando sus definiciones, implementaciones y aplicaciones prácticas. Utilizaremos Python, un lenguaje reconocido por su claridad y versatilidad, para demostrar estos conceptos en acción. Ya seas un principiante que comienza su viaje en la programación o un profesional experimentado que busca refrescar sus conocimientos, este artículo tiene como objetivo proporcionar información valiosa y una comprensión más profunda de los principios de la POO.\nEl encapsulamiento nos permite agrupar datos y métodos, ocultando detalles internos y protegiendo la integridad de los datos. La herencia permite la reutilización de código y la creación de relaciones jerárquicas entre clases. El polimorfismo proporciona una forma de usar objetos de diferentes tipos a través de una interfaz común, mejorando la flexibilidad y extensibilidad. La abstracción nos permite crear modelos simplificados de sistemas complejos, enfocándonos en las características esenciales y ocultando los detalles innecesarios. A medida que continúes tu viaje en el desarrollo de software, descubrirás que dominar estos conceptos abre nuevas formas de pensar y resolver problemas. Recuerda que la POO no se trata solo de sintaxis o características del lenguaje; es una mentalidad para modelar sistemas complejos y gestionar la complejidad en el software.\n","date":"07 diciembre 2024","externalUrl":null,"permalink":"/programming/oop/the-four-pillars-introduction/","section":"Programación","summary":"","title":"Los Cuatro Pilares","type":"programming"},{"content":"La importancia del encapsulamiento radica en varios aspectos clave:\nProtección de datos: Al controlar el acceso a los datos del objeto a través de métodos, podemos asegurar que los datos se mantengan consistentes y válidos. Modularidad: El encapsulamiento permite que los objetos sean autocontenidos, facilitando la comprensión y el mantenimiento del código. Flexibilidad: La implementación interna puede ser modificada sin afectar otras partes del código que utilizan el objeto. Reducción de complejidad: Al ocultar los detalles del funcionamiento interno, el encapsulamiento reduce la complejidad del sistema desde una perspectiva externa. Implementación en Python # Python ofrece varios mecanismos para implementar el encapsulamiento. Exploremos estos con ejemplos:\n1. Uso de atributos privados # En Python, podemos crear atributos privados prefijando el nombre del atributo con doble guion bajo (__). Esto activa el \u0026ldquo;name mangling\u0026rdquo;, que hace que el atributo sea más difícil de acceder desde fuera de la clase.\nclass CuentaBancaria: def __init__(self, numero_cuenta, saldo): self.__numero_cuenta = numero_cuenta # Atributo privado self.__saldo = saldo # Atributo privado def depositar(self, cantidad): if cantidad \u0026gt; 0: self.__saldo += cantidad return True return False def retirar(self, cantidad): if 0 \u0026lt; cantidad \u0026lt;= self.__saldo: self.__saldo -= cantidad return True return False def obtener_saldo(self): return self.__saldo # Uso cuenta = CuentaBancaria(\u0026#34;1234567890\u0026#34;, 1000) print(cuenta.obtener_saldo()) # Salida: 1000 cuenta.depositar(500) print(cuenta.obtener_saldo()) # Salida: 1500 cuenta.retirar(200) print(cuenta.obtener_saldo()) # Salida: 1300 # Esto generará un AttributeError # print(cuenta.__saldo) En este ejemplo:\n__numero_cuenta y __saldo son atributos privados. Proporcionamos métodos públicos (depositar, retirar, obtener_saldo) para interactuar con estos atributos privados. El acceso directo a __saldo desde fuera de la clase generará una excepción AttributeError. 2. Uso de propiedades # El decorador @property de Python nos permite definir métodos que pueden ser accedidos como atributos, proporcionando una forma más pythonica de implementar getters y setters.\nclass Circulo: def __init__(self, radio): self._radio = radio @property def radio(self): return self._radio @radio.setter def radio(self, valor): if valor \u0026gt; 0: self._radio = valor else: raise ValueError(\u0026#34;El radio debe ser positivo\u0026#34;) @property def area(self): return 3.14159 * self._radio ** 2 # Uso circulo = Circulo(5) print(circulo.radio) # Salida: 5 print(circulo.area) # Salida: 78.53975 circulo.radio = 7 print(circulo.radio) # Salida: 7 print(circulo.area) # Salida: 153.93791 # Esto generará un ValueError # circulo.radio = -1 En este ejemplo:\n_radio es un atributo protegido (el guion bajo simple es una convención para atributos protegidos en Python). La propiedad radio proporciona acceso de lectura y escritura a _radio con validación. La propiedad area es de solo lectura y se calcula al vuelo. Beneficios y mejores prácticas # Los beneficios del encapsulamiento son numerosos:\nMejora de la mantenibilidad: Los cambios en la implementación interna no afectan al código externo que utiliza la clase. Mayor seguridad: Los atributos privados no pueden ser modificados accidentalmente desde fuera de la clase. Flexibilidad en la implementación: Puedes cambiar cómo se almacenan o calculan los datos sin cambiar la interfaz pública. Mejor abstracción: Los usuarios de la clase no necesitan conocer su funcionamiento interno. Las mejores prácticas para el encapsulamiento en Python incluyen:\nUsar atributos privados (prefijo de doble guion bajo) para datos que no deben ser accedidos directamente desde fuera de la clase. Proporcionar métodos públicos o propiedades para el acceso controlado a los datos internos. Usar propiedades en lugar de métodos get/set para un enfoque más propio del paradigma Python. Documentar claramente la interfaz pública, incluyendo cualquier efecto secundario de los métodos. Veamos un ejemplo más complejo que demuestra estas prácticas:\nclass Empleado: def __init__(self, nombre, salario): self.__nombre = nombre self.__salario = salario self.__proyectos = [] @property def nombre(self): return self.__nombre @property def salario(self): return self.__salario @salario.setter def salario(self, valor): if valor \u0026gt; 0: self.__salario = valor else: raise ValueError(\u0026#34;El salario debe ser positivo\u0026#34;) def agregar_proyecto(self, proyecto): \u0026#34;\u0026#34;\u0026#34; Agrega un proyecto a la lista de proyectos del empleado. :param proyecto: cadena que representa el nombre del proyecto \u0026#34;\u0026#34;\u0026#34; self.__proyectos.append(proyecto) def eliminar_proyecto(self, proyecto): \u0026#34;\u0026#34;\u0026#34; Elimina un proyecto de la lista de proyectos del empleado. :param proyecto: cadena que representa el nombre del proyecto :return: True si el proyecto fue eliminado, False si no se encontró \u0026#34;\u0026#34;\u0026#34; if proyecto in self.__proyectos: self.__proyectos.remove(proyecto) return True return False @property def cantidad_proyectos(self): return len(self.__proyectos) def __str__(self): return f\u0026#34;Empleado: {self.__nombre}, Salario: ${self.__salario}, Proyectos: {self.cantidad_proyectos}\u0026#34; # Uso emp = Empleado(\u0026#34;Juan Pérez\u0026#34;, 50000) print(emp.nombre) # Salida: Juan Pérez print(emp.salario) # Salida: 50000 emp.agregar_proyecto(\u0026#34;Proyecto A\u0026#34;) emp.agregar_proyecto(\u0026#34;Proyecto B\u0026#34;) print(emp.cantidad_proyectos) # Salida: 2 emp.salario = 55000 print(emp) # Salida: Empleado: Juan Pérez, Salario: $55000, Proyectos: 2 emp.eliminar_proyecto(\u0026#34;Proyecto A\u0026#34;) print(emp.cantidad_proyectos) # Salida: 1 # Esto generará un AttributeError # print(emp.__proyectos) Este ejemplo demuestra:\nAtributos privados (__nombre, __salario, __proyectos) Propiedades para acceso controlado (nombre, salario, cantidad_proyectos) Métodos públicos para manipular datos privados (agregar_proyecto, eliminar_proyecto) Documentación clara del comportamiento de los métodos Un método __str__ personalizado para una representación de cadena agradable del objeto Siguiendo estas prácticas, creamos una clase que es flexible y robusta, encarnando el principio de encapsulamiento.\nReferencias # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ ¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/programming/oop/the-four-pillars-encapsulation/","section":"Programación","summary":"","title":"Los Cuatro Pilares: Encapsulamiento","type":"programming"},{"content":"Los aspectos clave de la herencia incluyen:\nReutilización de código: La herencia permite reutilizar código de clases existentes, reduciendo la redundancia y promoviendo un desarrollo eficiente. Clasificación jerárquica: Permite la creación de jerarquías de clases, representando relaciones y características comunes entre objetos. Extensibilidad: Se puede agregar nueva funcionalidad a las clases existentes sin modificarlas, siguiendo el principio abierto-cerrado. Polimorfismo: La herencia es un prerrequisito para el polimorfismo en tiempo de ejecución (que discutiremos en detalle más adelante). Tipos de herencia # Existen varios tipos de herencia, aunque no todos los lenguajes de programación admiten todos los tipos. Los principales tipos son:\nHerencia simple: Una clase derivada hereda de una sola clase base. Herencia múltiple: Una clase derivada hereda de múltiples clases base. Herencia multinivel: Una clase derivada hereda de otra clase derivada. Herencia jerárquica: Múltiples clases derivadas heredan de una sola clase base. Herencia híbrida: Una combinación de dos o más tipos de herencia. Python admite todos estos tipos de herencia. Exploremos cada uno con ejemplos.\nHerencia simple # La herencia simple es la forma más básica de herencia, donde una clase hereda de una sola clase base.\nclass Animal: def __init__(self, especie): self.especie = especie def hacer_sonido(self): pass class Perro(Animal): def __init__(self, nombre): super().__init__(\u0026#34;Canino\u0026#34;) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¡Guau!\u0026#34; # Uso perro = Perro(\u0026#34;Buddy\u0026#34;) print(f\u0026#34;{perro.nombre} es un {perro.especie}\u0026#34;) # Salida: Buddy es un Canino print(perro.hacer_sonido()) # Salida: ¡Guau! En este ejemplo:\nAnimal es la clase base con un método genérico hacer_sonido. Perro es derivado de Animal, heredando sus atributos y métodos. Perro sobrescribe el método hacer_sonido con su propia implementación. Usamos super().__init__() para llamar al inicializador de la clase base. Herencia múltiple # La herencia múltiple permite que una clase herede de múltiples clases base. Algunos lenguajes no permiten este tipo de herencia.\nclass Volador: def volar(self): return \u0026#34;¡Puedo volar!\u0026#34; class Nadador: def nadar(self): return \u0026#34;¡Puedo nadar!\u0026#34; class Pato(Animal, Volador, Nadador): def __init__(self, nombre): Animal.__init__(self, \u0026#34;Ave\u0026#34;) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¡Cuac!\u0026#34; # Uso pato = Pato(\u0026#34;Donald\u0026#34;) print(f\u0026#34;{pato.nombre} es un {pato.especie}\u0026#34;) # Salida: Donald es un Ave print(pato.hacer_sonido()) # Salida: ¡Cuac! print(pato.volar()) # Salida: ¡Puedo volar! print(pato.nadar()) # Salida: ¡Puedo nadar! Aquí, Pato hereda de Animal, Volador y Nadador, combinando atributos y métodos de las tres clases.\nHerencia multinivel # En la herencia multinivel, una clase derivada hereda de otra clase derivada.\nclass Mamifero(Animal): def __init__(self, especie, es_de_sangre_caliente=True): super().__init__(especie) self.es_de_sangre_caliente = es_de_sangre_caliente def dar_a_luz(self): return \u0026#34;Dando a luz crías vivas\u0026#34; class Gato(Mamifero): def __init__(self, nombre): super().__init__(\u0026#34;Felino\u0026#34;) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¡Miau!\u0026#34; # Uso gato = Gato(\u0026#34;Bigotes\u0026#34;) print(f\u0026#34;{gato.nombre} es un {gato.especie}\u0026#34;) # Salida: Bigotes es un Felino print(gato.hacer_sonido()) # Salida: ¡Miau! print(gato.dar_a_luz()) # Salida: Dando a luz crías vivas print(f\u0026#34;¿Es de sangre caliente? {gato.es_de_sangre_caliente}\u0026#34;) # Salida: ¿Es de sangre caliente? True En este ejemplo, Gato hereda de Mamifero, que a su vez hereda de Animal, formando una cadena de herencia multinivel.\nHerencia jerárquica # La herencia jerárquica implica múltiples clases derivadas heredando de una sola clase base.\nclass Ave(Animal): def __init__(self, especie, puede_volar=True): super().__init__(especie) self.puede_volar = puede_volar class Loro(Ave): def __init__(self, nombre): super().__init__(\u0026#34;Psitácido\u0026#34;, puede_volar=True) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¡Squawk!\u0026#34; class Pinguino(Ave): def __init__(self, nombre): super().__init__(\u0026#34;Esfenisciforme\u0026#34;, puede_volar=False) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¡Honk!\u0026#34; # Uso loro = Loro(\u0026#34;Polly\u0026#34;) pinguino = Pinguino(\u0026#34;Pingu\u0026#34;) print(f\u0026#34;{loro.nombre} puede volar: {loro.puede_volar}\u0026#34;) # Salida: Polly puede volar: True print(f\u0026#34;{pinguino.nombre} puede volar: {pinguino.puede_volar}\u0026#34;) # Salida: Pingu puede volar: False Aquí, tanto Loro como Pinguino heredan de Ave, lo que demuestra la herencia jerárquica.\nHerencia híbrida # La herencia híbrida es una combinación de múltiples tipos de herencia. Veamos un ejemplo más complejo para ilustrar esto:\nclass Terrestre: def caminar(self): return \u0026#34;Caminando en tierra\u0026#34; class Acuatico: def nadar(self): return \u0026#34;Nadando en el agua\u0026#34; class Anfibio(Animal, Terrestre, Acuatico): def __init__(self, especie): Animal.__init__(self, especie) def adaptarse(self): return \u0026#34;Puede sobrevivir tanto en tierra como en agua\u0026#34; class Rana(Anfibio): def __init__(self, nombre): super().__init__(\u0026#34;Anuro\u0026#34;) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¡Croac!\u0026#34; # Uso rana = Rana(\u0026#34;Kermit\u0026#34;) print(f\u0026#34;{rana.nombre} es un {rana.especie}\u0026#34;) # Salida: Kermit es un Anuro print(rana.hacer_sonido()) # Salida: ¡Croac! print(rana.caminar()) # Salida: Caminando en tierra print(rana.nadar()) # Salida: Nadando en el agua print(rana.adaptarse()) # Salida: Puede sobrevivir tanto en tierra como en agua Este ejemplo demuestra la herencia híbrida:\nRana hereda de Anfibio Anfibio hereda de Animal, Terrestre, y Acuatico Esto crea una combinación de herencia multinivel y múltiple Consideraciones # La herencia ofrece varias ventajas. Sin embargo, también hay consideraciones importantes:\nComplejidad: Las jerarquías de herencia profundas pueden volverse difíciles de entender y mantener. Acoplamiento fuerte: La herencia crea un acoplamiento fuerte entre las clases base y derivadas. Problema de la clase base frágil: Los cambios en la clase base pueden afectar inesperadamente a las clases derivadas. Problema del diamante: En la herencia múltiple, pueden surgir conflictos si dos clases base tienen métodos con el mismo nombre. Para abordar estas consideraciones:\nPrefiere la composición sobre la herencia cuando sea posible. Mantén las jerarquías de herencia poco profundas y enfocadas. Utiliza clases base abstractas para definir interfaces claras. Ten cuidado con la herencia múltiple y resuelve los conflictos explícitamente. Visualicemos las relaciones de herencia que hemos discutido utilizando un diagrama de clases UML:\nclassDiagram Animal \u0026lt;|-- Mamífero Animal \u0026lt;|-- Ave Mamífero \u0026lt;|-- Perro Mamífero \u0026lt;|-- Gato Ave \u0026lt;|-- Loro Ave \u0026lt;|-- Pingüino Animal \u0026lt;|-- Anfibio Terrestre \u0026lt;|-- Anfibio Acuático \u0026lt;|-- Anfibio Anfibio \u0026lt;|-- Rana class Animal { +especie: str +hacer_sonido() } class Mamífero { +es_de_sangre_caliente: bool +dar_a_luz() } class Ave { +puede_volar: bool } class Anfibio { +adaptarse() } class Terrestre { +caminar() } class Acuático { +nadar() } Este diagrama ilustra las relaciones de herencia entre las clases que hemos discutido, mostrando tanto la herencia simple como la múltiple.\nReferencias # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ ¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/programming/oop/the-four-pillars-inheritance/","section":"Programación","summary":"","title":"Los Cuatro Pilares: Herencia","type":"programming"},{"content":"El polimorfismo permite escribir código flexible y reutilizable al permitirnos trabajar con objetos a un nivel más abstracto, sin necesidad de conocer sus tipos específicos.\nExisten dos tipos principales de polimorfismo en la programación orientada a objetos:\nPolimorfismo en tiempo de compilación (Polimorfismo estático)\nSe logra a través de la sobrecarga de métodos. Se resuelve en tiempo de compilación. Polimorfismo en tiempo de ejecución (Polimorfismo dinámico)\nSe logra a través de la sobrescritura de métodos. Se resuelve en tiempo de ejecución. Python admite principalmente el polimorfismo en tiempo de ejecución, ya que es un lenguaje de tipado dinámico. Sin embargo, podemos demostrar conceptos similares al polimorfismo en tiempo de compilación también.\nExploremos diferentes aspectos del polimorfismo en Python:\nDuck typing # Python utiliza el duck typing, que es una forma de polimorfismo. La idea es: \u0026ldquo;Si camina como un pato y grazna como un pato, entonces debe ser un pato\u0026rdquo;. En otras palabras, Python se preocupa más por los métodos que tiene un objeto que por el tipo del objeto en sí.\nclass Pato: def hablar(self): return \u0026#34;¡Cuac cuac!\u0026#34; class Perro: def hablar(self): return \u0026#34;¡Guau guau!\u0026#34; class Gato: def hablar(self): return \u0026#34;¡Miau miau!\u0026#34; def sonido_animal(animal): return animal.hablar() # Uso pato = Pato() perro = Perro() gato = Gato() print(sonido_animal(pato)) # Salida: ¡Cuac cuac! print(sonido_animal(perro)) # Salida: ¡Guau guau! print(sonido_animal(gato)) # Salida: ¡Miau miau! En este ejemplo, sonido_animal() funciona con cualquier objeto que tenga un método hablar(), independientemente de su clase.\nSobrescritura de métodos # La sobrescritura de métodos es un aspecto clave del polimorfismo en tiempo de ejecución. Ocurre cuando una clase derivada define un método con el mismo nombre que un método en su clase base.\nclass Figura: def area(self): pass class Rectangulo(Figura): def __init__(self, ancho, alto): self.ancho = ancho self.alto = alto def area(self): return self.ancho * self.alto class Circulo(Figura): def __init__(self, radio): self.radio = radio def area(self): return 3.14159 * self.radio ** 2 # Uso figuras = [Rectangulo(5, 4), Circulo(3)] for figura in figuras: print(f\u0026#34;Área: {figura.area()}\u0026#34;) # Salida: # Área: 20 # Área: 28.27431 Aquí, Rectangulo y Circulo sobrescriben el método area() de la clase Figura.\nSobrecarga de operadores # Python permite la sobrecarga de operadores, que es una forma de polimorfismo en tiempo de compilación. Permite que el mismo operador tenga diferentes significados según los operandos.\nclass Vector: def __init__(self, x, y): self.x = x self.y = y def __add__(self, otro): return Vector(self.x + otro.x, self.y + otro.y) def __str__(self): return f\u0026#34;Vector({self.x}, {self.y})\u0026#34; # Uso v1 = Vector(2, 3) v2 = Vector(3, 4) v3 = v1 + v2 print(v3) # Salida: Vector(5, 7) Aquí, hemos sobrecargado el operador + para nuestra clase Vector.\nClases base abstractas # El módulo abc de Python proporciona infraestructura para definir clases base abstractas, que son una forma poderosa de definir interfaces en Python.\nfrom abc import ABC, abstractmethod class Animal(ABC): @abstractmethod def hacer_sonido(self): pass class Perro(Animal): def hacer_sonido(self): return \u0026#34;¡Guau!\u0026#34; class Gato(Animal): def hacer_sonido(self): return \u0026#34;¡Miau!\u0026#34; # Uso def sonido_animal(animal): return animal.hacer_sonido() perro = Perro() gato = Gato() print(sonido_animal(perro)) # Salida: ¡Guau! print(sonido_animal(gato)) # Salida: ¡Miau! # Esto generará un TypeError # animal = Animal() Las clases base abstractas no pueden ser instanciadas y obligan a las clases derivadas a implementar ciertos métodos, asegurando una interfaz consistente.\nAplicaciones en el mundo real # El polimorfismo se utiliza ampliamente en aplicaciones del mundo real:\nFrameworks de GUI: Diferentes widgets (botones, cajas de texto) pueden responder a eventos comunes (clic, hover) de sus propias maneras. Interfaces de bases de datos: Diferentes sistemas de bases de datos pueden implementar una interfaz común para consultas, permitiendo que las aplicaciones trabajen con varias bases de datos sin cambiar el código. Sistemas de plugins: Las aplicaciones pueden trabajar con plugins a través de una interfaz común, independientemente de la implementación específica de cada plugin. Desarrollo de juegos: Diferentes entidades del juego pueden compartir comportamientos comunes (mover, colisionar) pero implementarlos de manera diferente. Aquí hay un ejemplo simple de un sistema de plugins:\nclass Plugin(ABC): @abstractmethod def procesar(self, datos): pass class PluginMayusculas(Plugin): def procesar(self, datos): return datos.upper() class PluginInvertir(Plugin): def procesar(self, datos): return datos[::-1] class Aplicacion: def __init__(self): self.plugins = [] def agregar_plugin(self, plugin): self.plugins.append(plugin) def procesar_datos(self, datos): for plugin in self.plugins: datos = plugin.procesar(datos) return datos # Uso app = Aplicacion() app.agregar_plugin(PluginMayusculas()) app.agregar_plugin(PluginInvertir()) resultado = app.procesar_datos(\u0026#34;Hola, Mundo!\u0026#34;) print(resultado) # Salida: !ODNUM ,ALOH Este ejemplo demuestra cómo el polimorfismo permite que la clase Aplicacion trabaje con diferentes plugins a través de una interfaz común.\nReferencias # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ ¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/programming/oop/the-four-pillars-polymorphism/","section":"Programación","summary":"","title":"Los Cuatro Pilares: Polimorfismo","type":"programming"},{"content":"Los aspectos clave de la abstracción incluyen:\nSimplificación: La abstracción reduce la complejidad ocultando detalles innecesarios. Enfoque en características esenciales: Enfatiza lo que hace un objeto en lugar de cómo lo hace. Separación de preocupaciones: Permite separar la interfaz de una clase de su implementación. Modularidad: La abstracción promueve el diseño modular al definir límites claros entre componentes. Clases abstractas e interfaces # En muchos lenguajes orientados a objetos, la abstracción se implementa a través de clases abstractas e interfaces. Aunque Python no tiene un concepto integrado de interfaz, podemos lograr una funcionalidad similar usando clases base abstractas. El módulo abc de Python proporciona infraestructura para definir clases base abstractas:\nfrom abc import ABC, abstractmethod class Figura(ABC): @abstractmethod def area(self): pass @abstractmethod def perimetro(self): pass class Rectangulo(Figura): def __init__(self, ancho, alto): self.ancho = ancho self.alto = alto def area(self): return self.ancho * self.alto def perimetro(self): return 2 * (self.ancho + self.alto) class Circulo(Figura): def __init__(self, radio): self.radio = radio def area(self): return 3.14159 * self.radio ** 2 def perimetro(self): return 2 * 3.14159 * self.radio # Uso # figuras = [Figura()] # Esto generaría TypeError figuras = [Rectangulo(5, 4), Circulo(3)] for figura in figuras: print(f\u0026#34;Área: {figura.area()}, Perímetro: {figura.perimetro()}\u0026#34;) # Salida: # Área: 20, Perímetro: 18 # Área: 28.27431, Perímetro: 18.84954 En este ejemplo:\nFigura es una clase base abstracta que define la interfaz para todas las figuras. Rectangulo y Circulo son clases concretas que implementan la interfaz Figura. No podemos instanciar Figura directamente, pero podemos usarla como un tipo común para todas las figuras. Implementando abstracción en Python # Aunque Python proporciona clases base abstractas para definir interfaces formalmente, también podemos lograr la abstracción mediante convenciones y documentación. Veamos un ejemplo sin utilizar ABC:\nclass BaseDeDatos: def conectar(self): raise NotImplementedError(\u0026#34;La subclase debe implementar este método abstracto\u0026#34;) def ejecutar(self, consulta): raise NotImplementedError(\u0026#34;La subclase debe implementar este método abstracto\u0026#34;) class BaseDeDatosMySQL(BaseDeDatos): def conectar(self): print(\u0026#34;Conectando a la base de datos MySQL...\u0026#34;) def ejecutar(self, consulta): print(f\u0026#34;Ejecutando consulta MySQL: {consulta}\u0026#34;) class BaseDeDatosPostgreSQL(BaseDeDatos): def conectar(self): print(\u0026#34;Conectando a la base de datos PostgreSQL...\u0026#34;) def ejecutar(self, consulta): print(f\u0026#34;Ejecutando consulta PostgreSQL: {consulta}\u0026#34;) def realizar_operacion_en_bd(base_de_datos): base_de_datos.conectar() base_de_datos.ejecutar(\u0026#34;SELECT * FROM usuarios\u0026#34;) # Uso bd_mysql = BaseDeDatosMySQL() bd_postgres = BaseDeDatosPostgreSQL() realizar_operacion_en_bd(bd_mysql) realizar_operacion_en_bd(bd_postgres) # Salida: # Conectando a la base de datos MySQL... # Ejecutando consulta MySQL: SELECT * FROM usuarios # Conectando a la base de datos PostgreSQL... # Ejecutando consulta PostgreSQL: SELECT * FROM usuarios En este ejemplo:\nBaseDeDatos es una clase base abstracta (aunque no usa ABC) que define la interfaz para todos los tipos de bases de datos. BaseDeDatosMySQL y BaseDeDatosPostgreSQL son implementaciones concretas. realizar_operacion_en_bd trabaja con cualquier objeto que cumpla con la interfaz de BaseDeDatos. Principios de diseño y patrones # La abstracción es un componente clave de varios principios y patrones de diseño importantes:\nPrincipios SOLID:\nPrincipio de Responsabilidad Única (SRP). Principio de Abierto/Cerrado (OCP). Principio de Sustitución de Liskov (LSP). Principio de Segregación de Interfaces (ISP). Principio de Inversión de Dependencias (DIP). Patrones de Diseño:\nPatrón método de fábrica. Patrón fábrica abstracta. Patrón estrategia. Patrón método plantilla. Veamos una implementación del patrón estrategia:\nfrom abc import ABC, abstractmethod class EstrategiaOrdenamiento(ABC): @abstractmethod def ordenar(self, datos): pass class OrdenamientoBurbuja(EstrategiaOrdenamiento): def ordenar(self, datos): print(\u0026#34;Realizando ordenamiento de burbuja\u0026#34;) return sorted(datos) # Usamos sorted() de Python por simplicidad class OrdenamientoRapido(EstrategiaOrdenamiento): def ordenar(self, datos): print(\u0026#34;Realizando ordenamiento rápido\u0026#34;) return sorted(datos) # Usamos sorted() de Python por simplicidad class Ordenador: def __init__(self, estrategia): self.estrategia = estrategia def ordenar(self, datos): return self.estrategia.ordenar(datos) # Uso datos = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] ordenador_burbuja = Ordenador(OrdenamientoBurbuja()) print(ordenador_burbuja.ordenar(datos)) ordenador_rapido = Ordenador(OrdenamientoRapido()) print(ordenador_rapido.ordenar(datos)) # Salida: # Realizando ordenamiento de burbuja # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Realizando ordenamiento rápido # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] Este ejemplo del Patrón Estrategia muestra cómo la abstracción nos permite definir una familia de algoritmos, encapsular cada uno y hacerlos intercambiables. La clase Ordenador no necesita conocer los detalles de cómo funciona cada algoritmo de ordenamiento; solo sabe que puede llamar al método ordenar en cualquier objeto EstrategiaOrdenamiento.\nReferencias # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ ¡Gracias por haber llegado hasta acá!\nSi te gustó el artículo, por favor ¡no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, envía tus comentarios, sugerencias, críticas a nuestro mail o por redes sociales, nos ayudarías a generar mejor contenido y sobretodo más relevante para vos.\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/programming/oop/the-four-pillars-abstraction/","section":"Programación","summary":"","title":"Los Cuatro Pilares: Abstracción","type":"programming"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/%C3%A1lgebra-lineal/","section":"Etiquetas","summary":"","title":"Álgebra Lineal","type":"tags"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/aprendizaje-autom%C3%A1tico/","section":"Etiquetas","summary":"","title":"Aprendizaje Automático","type":"tags"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/inteligencia-artificial/","section":"Etiquetas","summary":"","title":"Inteligencia Artificial","type":"tags"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/machine-learning/","section":"Etiquetas","summary":"","title":"Machine Learning","type":"tags"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/matem%C3%A1tica/","section":"Etiquetas","summary":"","title":"Matemática","type":"tags"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/series/matem%C3%A1tica-para-machine-learning/","section":"Series","summary":"","title":"Matemática Para Machine Learning","type":"series"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/matrices/","section":"Etiquetas","summary":"","title":"Matrices","type":"tags"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/recomendaciones/","section":"Etiquetas","summary":"","title":"Recomendaciones","type":"tags"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/vectores/","section":"Etiquetas","summary":"","title":"Vectores","type":"tags"},{"content":"","date":"04 septiembre 2025","externalUrl":null,"permalink":"/series/fundamentos-de-ia-para-programadores/","section":"Series","summary":"","title":"Fundamentos De IA Para Programadores","type":"series"},{"content":"","date":"26 agosto 2025","externalUrl":null,"permalink":"/tags/clasificaci%C3%B3n/","section":"Etiquetas","summary":"","title":"Clasificación","type":"tags"},{"content":"","date":"22 agosto 2025","externalUrl":null,"permalink":"/tags/sistema-experto/","section":"Etiquetas","summary":"","title":"Sistema Experto","type":"tags"},{"content":"","date":"05 agosto 2025","externalUrl":null,"permalink":"/tags/kubernetes/","section":"Etiquetas","summary":"","title":"Kubernetes","type":"tags"},{"content":" Luego de desplegar una aplicación en Kubernetes, independientemente del método elegido para ello, si queremos que sea alcanzable por otras aplicaciones necesitamos crear un servicio. En este artículo vamos a explicar que es un servicio, como se utilizan y a repasar los cuatro tipos de servicios que están disponibles en Kubernetes, ClusterIP, NodePort, LoadBalancer y ExternalName, revisaremos sus detalles y cuando se debe utilizar cada uno. Al desplegar una aplicación en Kubernetes utilizando un objeto del tipo Deployment, los pods pertenecientes a dicho Deployment pueden ser creados y destruidos en cualquier momento en base a su funcionamiento, por ejemplo si en nuestro Deployment pedimos que existan 3 réplicas y por cualquier razón alguna de ellas deja de funcionar, una nueva réplica será creada automáticamente para reemplazar a la que falló.\nCada pod tiene su propia dirección IP dentro del cluster. En general, las demás aplicaciones que necesitan interactuar con nuestra aplicación desconocen el nombre de cada una de sus replicas, su estado y su dirección IP para iniciar una comunicación. Kubernetes nos provee el objeto Service como una forma nativa de Service Discovery sin que necesitemos hacer cambios en nuestra aplicación o en las que necesitan comunicarse con ella. Entonces, el fin para el cual creamos un servicio es para exponer una aplicación que puede estar constituida por múltiples pods a traves de un único punto de acceso. De esta manera otras aplicación contactaran al Service y este redirigirá la comunicación a alguno de los pods de nuestra aplicación.\nPods detrás de un servicio en Kubernetes Creando un servicio # Un Service puede crearse mediante una declaración en un archivo .yaml al igual que otros objetos de Kubernetes. Por ejemplo:\napiVersion: v1 kind: Service metadata: name: servicio-de-prueba spec: type: ClusterIP selector: app_name: mi-aplicacion ports: - protocol: TCP port: 8080 targetPort: 1234 En dicho ejemplo, estaremos creando un servicio llamado my-service del tipo ClusterIP que redirige las comunicaciones que llegan al puerto 8080 hacia el puerto 1234 de cualquier Pod que tenga la etiqueta app-name: my-app.\nEl nombre del servicio debe ser una etiqueta válida bajo las reglas de RFC 1035 Como se ve en el archivo, el campo ports es del tipo array, lo que significa que pueden mapearse múltiples puertos.\nCada definición de un puerto debe contener los siguientes campos:\nport: es el puerto en el que el servicio estará accesible dentro del cluster. No puede omitirse. targetPort: es un valor opcional, indica el puerto en el cual el pod estará recibiendo las comunicaciones. Si se omite, se asume que es el mismo valor que el indicado en el campo port. Puede ser un número o el nombre del puerto si es que en el pod se especificaron nombres. Se recomienda utilizarlo sólo cuando difiere del valor de port. protocol: establece el protocolo utilizado para las comunicaciones, los valores válidos son: SCTP, TCP y UDP. En caso de no indicarse explícitamente, el valor por defecto es TCP. name: permite darle un nombre al puerto. Es útil para referenciar por DNS o en situaciones donde hay múltiples puertos en un mismo servicio. Es un valor opcional, pero dentro de un mismo servicio, cada puerto debe tener un nombre único. Tipos de servicios # Como se muestra en la sección anterior, el tipo de servicio se especifica mediante el valor spec.type:\napiVersion: v1 kind: Service metadata: name: servicio-de-prueba spec: ... type: \u0026lt;TIPO_DE_SERVICIO\u0026gt; ... A continuación veremos cada uno de ellos.\nClusterIP # Es el tipo de servicio por defecto. Kubernetes asigna una dirección IP al servicio que las demás aplicaciones pueden utilizar para comunicarse. La dirección asignada proviene de un grupo de direcciones reservadas para este fin mediante el valor service-cluster-ip-range en el servidor de API de Kubernetes.\nCuando se crea un servicio del tipo ClusterIP el servicio no es accesible desde el exterior y los pods detrás de este servicio solo pueden ser contactados por otros pods del mismo cluster. Si se desea exponer el servicio al exterior se debe utilizar un objeto del tipo Ingress.\nEsquema de un servicio del tipo ClusterIP NodePort # En este caso, Kubernetes asigna al servicio un puerto del rango definido en la configuración service-node-port-range, usualmente entre los puertos 30000 y 32767. Luego, cada nodo abre dicho puerto para las comunicaciones hacia el servicio.\nEste tipo de servicio, permite un rápido acceso desde el exterior sin necesidad de infraestructura adicional, pero no contempla un mecanismo de balance de carga (load balancing), lo que puede provocar la saturación de alguno de ellos. Por otro lado, en un sistema donde existan múltiples servicios, la gestión de puertos puede volverse demasiado compleja.\nEsquema de un servicio del tipo NodePort LoadBalancer # En proveedores de servicios en la nube que soporten load balancers como Amazon Web Services, Google Cloud Platform o Microsoft Azure, crear un servicio de este tipo dispara la creación de un load balancer externo en la platform de nube utilizada. La creación ocurre de manera asíncrona e información sobre su estado es publicada en el estado del servicio (.status.loadbalancer).\nEl proveedor de servicios en la nube decide como se balancea la carga.\nLa gran ventaja de este tipo de servicio es que mediante el uso de servicios en la nube se obtiene un balanceo de carga automático y de alta disponibilidad. La desventaja es que puede generar costos adicionales.\nEsquema de un servicio del tipo LoadBalancer ExternalName # Este tipo de servicio redirecciona el tráfico a un nombre de DNS en lugar de a un conjunto de pods. El DNS al cual se apunta, se indica mediante el campo .spec.externalName\nPor ejemplo, redirige las comunicaciones hacia la dirección learn-software.com.\napiVersion: v1 kind: Service metadata: name: mi-servicio spec: type: ExternalName externalName: learn-software.com Esquema de un servicio del tipo ExternalName Headless Services # Existen casos en los que, por ejemplo, es necesario utilizar otros mecanismos de Service Discovery o en los que necesitemos conocer las direcciones IP de todos aquellos pods que podríamos contactar. Para ello existen los headless services. Se crean indicando el valor None en el campo .spec.clusterIP.\nUn headless service no tiene asignada una dirección IP única del cluster. Retorna directamente las direcciones IPs de pods en una respuesta DNS. Esto es útil para descubrimiento de servicios personalizados, bases de datos distribuidas o control detallado del balanceo. La desventaja es que el cliente del servicio debe ser capaz de resolver y gestionar por sí mismo una respuesta DNS conteniendo múltiples direcciones.\nEsquema de un Headless Service Referencias # Puedes leer más sobre el tema en la documentación oficial de Kubernetes ","date":"05 agosto 2025","externalUrl":null,"permalink":"/blog/k8s-services/","section":"Blog","summary":"","title":"Kubernetes Services","type":"blog"},{"content":"","date":"05 agosto 2025","externalUrl":null,"permalink":"/tags/service-discovery/","section":"Etiquetas","summary":"","title":"Service Discovery","type":"tags"},{"content":"","date":"05 agosto 2025","externalUrl":null,"permalink":"/tags/services/","section":"Etiquetas","summary":"","title":"Services","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/en/tags/data-structures/","section":"Tags","summary":"","title":"Data Structures","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/tags/estructuras-de-datos/","section":"Etiquetas","summary":"","title":"Estructuras De Datos","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/en/tags/object-oriented-programming/","section":"Tags","summary":"","title":"Object-Oriented Programming","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/tags/programaci%C3%B3n/","section":"Etiquetas","summary":"","title":"Programación","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/tags/programaci%C3%B3n-orientada-a-objetos/","section":"Etiquetas","summary":"","title":"Programación Orientada a Objetos","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/series/programaci%C3%B3n-aprendiendo-estructuras-de-datos/","section":"Series","summary":"","title":"Programación: Aprendiendo Estructuras De Datos","type":"series"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/series/programaci%C3%B3n-aprendiendo-orientaci%C3%B3n-a-objetos/","section":"Series","summary":"","title":"Programación: Aprendiendo Orientación a Objetos","type":"series"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/en/tags/programming/","section":"Tags","summary":"","title":"Programming","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/en/series/programming-learning-data-structures/","section":"Series","summary":"","title":"Programming: Learning Data Structures","type":"series"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/en/series/programming-learning-object-oriented-concepts/","section":"Series","summary":"","title":"Programming: Learning Object-Oriented Concepts","type":"series"},{"content":"","date":"03 agosto 2025","externalUrl":null,"permalink":"/series/programaci%C3%B3n-aprendiendo-las-bases/","section":"Series","summary":"","title":"Programación: Aprendiendo Las Bases","type":"series"},{"content":"","date":"03 agosto 2025","externalUrl":null,"permalink":"/en/series/programming-learning-the-bases/","section":"Series","summary":"","title":"Programming: Learning the Bases","type":"series"},{"content":"","date":"07 diciembre 2024","externalUrl":null,"permalink":"/en/tags/class-relations/","section":"Tags","summary":"","title":"Class Relations","type":"tags"},{"content":"","date":"07 diciembre 2024","externalUrl":null,"permalink":"/tags/los-cuatro-pilares/","section":"Etiquetas","summary":"","title":"Los Cuatro Pilares","type":"tags"},{"content":"","date":"07 diciembre 2024","externalUrl":null,"permalink":"/tags/oop/","section":"Etiquetas","summary":"","title":"OOP","type":"tags"},{"content":"","date":"07 diciembre 2024","externalUrl":null,"permalink":"/en/tags/the-four-pillars/","section":"Tags","summary":"","title":"The Four Pillars","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/tags/abstracci%C3%B3n/","section":"Etiquetas","summary":"","title":"Abstracción","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/abstraction/","section":"Tags","summary":"","title":"Abstraction","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/aggregation/","section":"Tags","summary":"","title":"Aggregation","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/association/","section":"Tags","summary":"","title":"Association","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/composition/","section":"Tags","summary":"","title":"Composition","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/dependency/","section":"Tags","summary":"","title":"Dependency","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/tags/encapsulamiento/","section":"Etiquetas","summary":"","title":"Encapsulamiento","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/encapsulation/","section":"Tags","summary":"","title":"Encapsulation","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/tags/herencia/","section":"Etiquetas","summary":"","title":"Herencia","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/implementation/","section":"Tags","summary":"","title":"Implementation","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/inheritance/","section":"Tags","summary":"","title":"Inheritance","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/tags/polimorfismo/","section":"Etiquetas","summary":"","title":"Polimorfismo","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/polymorphism/","section":"Tags","summary":"","title":"Polymorphism","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/realisation/","section":"Tags","summary":"","title":"Realisation","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/tags/colas/","section":"Etiquetas","summary":"","title":"Colas","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/en/tags/linked-lists/","section":"Tags","summary":"","title":"Linked Lists","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/tags/listas/","section":"Etiquetas","summary":"","title":"Listas","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/tags/listas-enlazadas/","section":"Etiquetas","summary":"","title":"Listas Enlazadas","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/en/tags/lists/","section":"Tags","summary":"","title":"Lists","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/en/tags/queues/","section":"Tags","summary":"","title":"Queues","type":"tags"},{"content":"","date":"02 noviembre 2023","externalUrl":null,"permalink":"/tags/pilas/","section":"Etiquetas","summary":"","title":"Pilas","type":"tags"},{"content":"","date":"02 noviembre 2023","externalUrl":null,"permalink":"/en/tags/stacks/","section":"Tags","summary":"","title":"Stacks","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/en/tags/arrays/","section":"Tags","summary":"","title":"Arrays","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/tags/arreglos/","section":"Etiquetas","summary":"","title":"Arreglos","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/tags/diccionarios/","section":"Etiquetas","summary":"","title":"Diccionarios","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/en/tags/dictionaries/","section":"Tags","summary":"","title":"Dictionaries","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/tags/mapas/","section":"Etiquetas","summary":"","title":"Mapas","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/en/tags/maps/","section":"Tags","summary":"","title":"Maps","type":"tags"},{"content":"","date":"02 octubre 2023","externalUrl":null,"permalink":"/tags/clases/","section":"Etiquetas","summary":"","title":"Clases","type":"tags"},{"content":"","date":"02 octubre 2023","externalUrl":null,"permalink":"/en/tags/classes/","section":"Tags","summary":"","title":"Classes","type":"tags"},{"content":"","date":"02 octubre 2023","externalUrl":null,"permalink":"/en/tags/objects/","section":"Tags","summary":"","title":"Objects","type":"tags"},{"content":"","date":"02 octubre 2023","externalUrl":null,"permalink":"/tags/objetos/","section":"Etiquetas","summary":"","title":"Objetos","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/tags/conceptos-iniciales/","section":"Etiquetas","summary":"","title":"Conceptos Iniciales","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/tags/funciones/","section":"Etiquetas","summary":"","title":"Funciones","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/en/tags/functions/","section":"Tags","summary":"","title":"Functions","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/en/tags/methods/","section":"Tags","summary":"","title":"Methods","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/tags/m%C3%A9todos/","section":"Etiquetas","summary":"","title":"Métodos","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/series/programaci%C3%B3n-aprendiendo-los-conceptos-iniciales/","section":"Series","summary":"","title":"Programación: Aprendiendo Los Conceptos Iniciales","type":"series"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/en/series/programming-learning-the-starting-concepts/","section":"Series","summary":"","title":"Programming: Learning the Starting Concepts","type":"series"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/en/tags/recursion/","section":"Tags","summary":"","title":"Recursion","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/tags/recursi%C3%B3n/","section":"Etiquetas","summary":"","title":"Recursión","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/en/tags/starting-concepts/","section":"Tags","summary":"","title":"Starting Concepts","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/en/tags/boolean-logic/","section":"Tags","summary":"","title":"Boolean Logic","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/tags/bucles/","section":"Etiquetas","summary":"","title":"Bucles","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/tags/condicionales/","section":"Etiquetas","summary":"","title":"Condicionales","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/en/tags/conditionals/","section":"Tags","summary":"","title":"Conditionals","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/tags/control-de-flujo/","section":"Etiquetas","summary":"","title":"Control De Flujo","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/en/tags/flow-control/","section":"Tags","summary":"","title":"Flow Control","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/tags/l%C3%B3gica-booleana/","section":"Etiquetas","summary":"","title":"Lógica Booleana","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/en/tags/loops/","section":"Tags","summary":"","title":"Loops","type":"tags"},{"content":"","date":"19 septiembre 2023","externalUrl":null,"permalink":"/tags/entrada/salida/","section":"Etiquetas","summary":"","title":"Entrada/Salida","type":"tags"},{"content":"","date":"19 septiembre 2023","externalUrl":null,"permalink":"/tags/i/o/","section":"Etiquetas","summary":"","title":"I/O","type":"tags"},{"content":"","date":"19 septiembre 2023","externalUrl":null,"permalink":"/en/tags/input/output/","section":"Tags","summary":"","title":"Input/Output","type":"tags"},{"content":"","date":"18 septiembre 2023","externalUrl":null,"permalink":"/en/tags/data-types/","section":"Tags","summary":"","title":"Data Types","type":"tags"},{"content":"","date":"18 septiembre 2023","externalUrl":null,"permalink":"/tags/tipos-de-datos/","section":"Etiquetas","summary":"","title":"Tipos De Datos","type":"tags"},{"content":"","date":"18 septiembre 2023","externalUrl":null,"permalink":"/tags/variables/","section":"Etiquetas","summary":"","title":"Variables","type":"tags"},{"content":"","date":"10 septiembre 2023","externalUrl":null,"permalink":"/tags/herramientas/","section":"Etiquetas","summary":"","title":"Herramientas","type":"tags"},{"content":"","date":"10 septiembre 2023","externalUrl":null,"permalink":"/tags/ide/","section":"Etiquetas","summary":"","title":"IDE","type":"tags"},{"content":"","date":"10 septiembre 2023","externalUrl":null,"permalink":"/tags/python/","section":"Etiquetas","summary":"","title":"Python","type":"tags"},{"content":"","date":"10 septiembre 2023","externalUrl":null,"permalink":"/en/tags/tools/","section":"Tags","summary":"","title":"Tools","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/tags/binario/","section":"Etiquetas","summary":"","title":"Binario","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/en/tags/binary/","section":"Tags","summary":"","title":"Binary","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/tags/decimal/","section":"Etiquetas","summary":"","title":"Decimal","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/tags/hexadecimal/","section":"Etiquetas","summary":"","title":"Hexadecimal","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/en/tags/numeral-systems/","section":"Tags","summary":"","title":"Numeral Systems","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/tags/sistemas-de-numeraci%C3%B3n/","section":"Etiquetas","summary":"","title":"Sistemas De Numeración","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/tags/cd/","section":"Tags","summary":"","title":"CD","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/tags/computadoras/","section":"Etiquetas","summary":"","title":"Computadoras","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/tags/computers/","section":"Tags","summary":"","title":"Computers","type":"tags"},{"content":"Continuous Delivery (CD) is deeply rooted in the first principle of the Agile Manifesto posted in 20011:\nOur highest priority is to satisfy the customer through early and continuous delivery of valuable software.\nAccording to Martin Fowler2, a project is truly embracing Continuous Delivery when:\nThe software can be deployed at any stage of its lifecycle. The team values keeping the software deployment-ready over adding new features. Any software version can be deployed to any environment on-demand. In many ways, Continuous Delivery is the next step from Continuous Integration, seamlessly automating processes all the way to the software\u0026rsquo;s end user.\nMuch like in Continuous Integration, the pipeline stands as the cornerstone of Continuous Delivery. However, it\u0026rsquo;s not just about integrating code, testing it, and generating a deliverable artifact. With CD, this artifact progresses through a series of test phases in environments that increasingly resemble production settings. After passing through the Continuous Integration pipeline, what emerges is a potentially deployable artifact. CD then takes this artifact and puts it through the necessary tests, ensuring it\u0026rsquo;s primed for a live deployment.\nThe delivery process # The following figure illustrates the fundamental steps of a Continuous Delivery (CD) process. It\u0026rsquo;s vital to note that an effective CD process presupposes a well-oiled Continuous Integration (CI) system as its foundation.\nCD process flowchart The CD process adds two distinct phases to the CI system: deployment stages and system validation and verification testing. A critical premise is that the deployment process is paramount to product delivery. Thus, automating and frequently testing it is essential. Ideally, testing should also be automated to facilitate execution, especially if you aim for Continuous Deployment. However, it\u0026rsquo;s not imperative to automate all tests, especially at the beginning of the CD process implementation.\nUpon creating a potentially deliverable artifact in the CI pipeline, the initial step is to deploy it in a testing or QA environment. The primary goal of this environment is to offer a space where software tests, both automatic and manual, can be run. The only possible variations between the QA and actual production environment (the one used by customers) may pertain to its capacity or resource size. This scaled-down capacity, whether in processing, memory, storage, or database size, is typically a cost-saving measure.\nIf system and acceptance tests are successful in the QA environment, the next phase is to deploy the artifact in a staging environment. This environment should be an exact replica of the production setting. Its purpose is to facilitate performance and load testing on the system, effectively putting it under stress to validate its functionality under high loads and assess its processing and response times.\nWhen the previous tests are satisfactory, the artifact is ready to be deployed in a production environment. This space is also referred to as the live environment, where users interact with the system.\nAs evident, the product deployment method is exercised at least twice before the final production deployment, considerably reducing risks associated with potential errors as the final delivery approaches.\nCore principles and practices # One of CD\u0026rsquo;s primary objectives is to boost delivery frequency. This naturally means that each release should minimize its size. A smaller delivery not only implies fewer potential errors but also facilitates their identification and resolution2. To achieve this, the code must always be in a deploy-ready state.\nRapid automated testing is crucial for today\u0026rsquo;s software development3. In the context of CD, automated tests are of utmost importance as they must ensure comprehensive system quality without hampering the delivery cycle\u0026rsquo;s speed4. Lengthy test runs force the team to await results, leading to wasted time3. If these tests aren\u0026rsquo;t parallelized and optimized, developers may start sidelining them5. To ensure test optimization, it\u0026rsquo;s recommended to fail tests that exceed a reasonable limit6.\nThe software should always be potentially deliverable. It\u0026rsquo;s essential for the software\u0026rsquo;s build status to remain \u0026lsquo;green\u0026rsquo; consistently. This means if a new repository commit breaks the build, this error must be rectified before any new commit is made. Adhering to this practice simplifies error tracing, while deviating may condition developers to overlook a broken or \u0026lsquo;red\u0026rsquo; build6. Broken builds signify product flaws and render it undeliverable.\nIn using CD, the aim is to ensure each commit results in a production-ready artifact. If this artifact is rebuilt at every process stage, there\u0026rsquo;s no guarantee of their identical nature, and validation and verification test results from one artifact cannot be applied to others. This could lead to deploying untested artifacts6. Hence, artifacts should be produced only once and undergo all tests on that single artifact before deploying that very software piece to production.\nSoftware should always be deployed identically across all environments. Otherwise, there\u0026rsquo;s no assurance of the deployment process\u0026rsquo;s efficacy. If environment differences exist, they should be managed using configuration files, but the deployment process should remain consistent6.\nDeployment should be achievable with a mere button press. The ability to deploy the latest product version anytime with a single button press is a robust indicator of CD implementation2. This not only requires the aforementioned steps but also mandates version-controlled software deployment scripts that are regularly checked and validated6.\nAs mentioned earlier, CD\u0026rsquo;s main objective is to ascertain the product\u0026rsquo;s readiness post each commit2. For this, aside from ensuring a swift compilation and testing process, process outcomes should be visible and shared with the team. Display screens showcasing the current status, build times, test coverage, and more, offer a way to maintain constant visibility6. Presenting these results not only supports CD but, as some authors suggest, also bolsters team motivation4.\nBenefits of Continuous Delivery # With the rise of Continuous Delivery (CD) practices, businesses are realizing numerous advantages:\nSwift value delivery: the adoption of CD practices facilitates a faster rollout of features and error rectifications to end users7. This speed is attributed to the code becoming potentially deployable to users as it traverses through the Continuous Integration (CI) pipeline4.\nDiminished delivery failures: frequent releases lead to fewer delivery risks since each release embodies fewer changes. This, in turn, means there\u0026rsquo;s a reduced margin for errors2. Even if an error emerges, its origin is easier to trace and correct. Plus, reverting to a previous version in the face of complications becomes straightforward8. A delightful by-product of this streamlined process is the diminished stress levels amongst stakeholders7 5. Furthermore, the consistency and quality in the delivery process cement trust between the development team and clients7.\nProductivity amplification: Chen\u0026rsquo;s study reveals that, in the absence of CD practices, teams spent nearly \\(20%\\) of their time setting up and maintaining environments7. The introduction of CD automates this ordeal, which translates to heightened productivity by phasing out manual, non-value-add tasks6.\nPrompt feedback: a consensus among experts highlights the value of early feedback during the development phase2 7 4. Regular releases not only fetch this feedback promptly but also ensure that the developed product aligns seamlessly with customer requirements2. The agility to swiftly address customer needs, fix reported bugs, and introduce demanded features can significantly elevate customer satisfaction4.\nEnhanced software quality: the rigorous automation of software tests (unit, integration, and system), essential for implementing CD, combined with more frequent software deliveries encapsulating fewer changes, culminates in a notable boost in software quality4.\nTransparency in progress: thanks to frequent releases, clients find it easier to stay abreast of the latest product updates, embracing novel features and bug fixes with open arms.\nChallenges in adopting Continuous Delivery # The journey to incorporate Continuous Delivery (CD) isn’t without its hurdles. Here\u0026rsquo;s a look at some of the key challenges faced by businesses:\nProduct complexity: certain products consist of myriad interconnected modules or possess dependencies with other projects. This can create bottlenecks when automating CD pipelines4. Such complexities might frustrate teams, pushing them to retain manual processes or longer integration procedures.\nTest suite creation: crafting a comprehensive test suite to ensure product quality is labour-intensive. All team members must allocate significant time to pen tests, which might require extra training. Besides, tests can be time-consuming, so the trick lies in devising effective yet swift tests4.\nLegacy code: systems that have been in development for an extended period and weren\u0026rsquo;t designed with automated testing in mind can pose a significant challenge. Transitioning such systems to CD is not only a technical endeavour but also a social and cultural shift4.\nEnvironmental discrepancies: all environments in the CI pipeline should mirror the production setting (\u0026lsquo;production-like\u0026rsquo;)6. If not, unforeseen errors can arise, demanding valuable time on non-value-add tasks4. Ensuring multiple deployment stages in similar environments means that the deployment process is tested repetitively.\nClient restrictions: not every client might desire or require a shortened product delivery cycle4. Such client limitations aren\u0026rsquo;t direct obstacles to CD implementation but play a pivotal role when aiming for Continuous Deployment. This could potentially sideline some CD benefits, like swift client feedback or minimal change deliveries. Moreover, the domain itself can act as a bottleneck. Software related to heavily-regulated sectors like healthcare and defence may find CD implementation challenging, if not nearly impossible4.\nTransparency and reporting: a successful CD adoption hinges on collaboration and transparency, introducing challenges tied to providing effective status reports to stakeholders9. This encompasses technical hurdles around automated report generation and analytics challenges to pinpoint essential information.\nResistance to change: any transformative change, like adopting CD, faces the innate human trait of resistance. Convincing the team to adapt to new practices and modify their workflow is a task. On a higher level, management might also be hesitant to experiment with fresh processes.\nContinuous Deployment # The notion of Continuous Deployment was popularized by Fitz10. The standout distinction between this method and Continuous Delivery (CD) is that, once the product is deemed ready for release, there\u0026rsquo;s no waiting for manual intervention to launch it into production11 6. If CD is properly executed, the step towards Continuous Deployment should demand no extra efforts from the development perspective8. In essence, the core difference lies in decision-making: with CD, releasing the product to production remains a business decision, whereas with Continuous Deployment, the launch is automated.\nIt\u0026rsquo;s worth noting that when we discuss CD, it inherently includes Continuous Delivery but may or may not encompass Continuous Deployment.\nReferences # Beck, Kent, Mike Beedle, Arie van Bennekum, Alistair Cockburn, Ward Cunningham, Martin Fowler, James Grenning, Jim Highsmith, Andrew Hunt, Ron Jeffries, Jon Kern, Brian Marick, Robert C. Martin, Steve Mellor, Ken Schwaber, Jeff Sutherland, and Dave Thomas. Manifesto for Agile Software Development, 2001.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, Martin. Continuous Delivery, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUdd, Raoul. Adopting Continuous Delivery: A Case Study, 2016.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLeppanen, Marko, Simo Makinen, Max Pagels, Veli-Pekka Eloranta, Juha Itkonen, Mika V. Mantyla, and Tomi Mannisto. The highways and country roads to continuous deployment. IEEE Software, 32(2):64-72, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNeely, Steve, and Steve Stolt. Continuous delivery? Easy! Just change everything (well, maybe it is not that easy). Proceedings - AGILE 2013, pp.121-128, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez, and David Farley. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChen, Lianping. Continuous Delivery: Huge Benefits, but Challenges Too. IEEE Software, 32(2):50-54, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez. Continuous Delivery vs Continuous Deployment, 2010.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOlsson, Helena Holmstrom, Hiva Alahyari, and Jan Bosch. Climbing the \u0026ldquo;Stairway to Heaven\u0026rdquo; \u0026ndash; A Multiple-Case Study Exploring Barriers in the Transition from Agile Development towards Continuous Deployment of Software. 2012 38th Euromicro Conference on Software Engineering and Advanced Applications, pp.392-399, 2012.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFitz, Timothy. Continuous Deployment, 2009.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPulkkinen, Ville. Continuous Deployment of Software. Proceedings of Cloud-Based Software Engineering, pp.46-52, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/blog/continuous-delivery/","section":"Blog","summary":"","title":"Continuous Delivery","type":"blog"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/tags/continuous-delivery/","section":"Tags","summary":"","title":"Continuous Delivery","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/tags/continuous-deployment/","section":"Tags","summary":"","title":"Continuous Deployment","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/tags/cpu/","section":"Etiquetas","summary":"","title":"CPU","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/tags/hardware/","section":"Etiquetas","summary":"","title":"Hardware","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/tags/memoria/","section":"Etiquetas","summary":"","title":"Memoria","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/tags/memory/","section":"Tags","summary":"","title":"Memory","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/tags/software/","section":"Etiquetas","summary":"","title":"Software","type":"tags"},{"content":"","date":"19 agosto 2023","externalUrl":null,"permalink":"/en/tags/ci/","section":"Tags","summary":"","title":"CI","type":"tags"},{"content":"One of the most pivotal challenges in the realm of software development is effectively integrating changes 1. In a small-scale project steered by a single developer, this challenge might appear to be trivial. However, as the magnitude of the project escalates and more individuals join the development fold, the significance of seamless integration becomes paramount.\nHistorically, integration was often an afterthought, relegated to the tail end of the software development process 2. Postponing it to such a late stage not only amplifies the risk of complex, undetected errors but also heightens the tension as delivery dates loom.\nHowever, the paradigm shifted around the turn of the millennium. Continuous Integration (CI) was formally introduced in 2000 by Kent Beck as an intrinsic part of the \u0026lsquo;Extreme Programming\u0026rsquo; methodology 3. CI emphasizes the frequent and early-stage integration of code. By continuously amalgamating new code into the system, developers can gauge its impact promptly. This approach streamlines error detection, enabling developers to tackle issues as they emerge 2. The ability to tie an error to a specific code change reduces error complexity and promotes efficient troubleshooting. Today, CI has become an indispensable practice in software development projects 4.\nMartin Fowler, a luminary in the field, eloquently defined CI as:\nContinuous Integration is a software development practice where team members integrate their work frequently, typically multiple times a day. Each integration is verified by an automated build system that runs test suites to swiftly detect any integration anomalies. Teams adopting this methodology often witness a significant reduction in integration hiccups, empowering them to produce cohesive software at an accelerated pace2.\nBuilding upon Fowler’s definition, Duvall 5 underscored several vital facets:\nDevelopers must maintain a conducive local environment for code construction and testing, ensuring their updates do not disrupt the established integration. Team members should commit their code to the Version Control System (VCS) daily. The integration process must be undertaken on a distinct machine, aptly termed the CI server. Only builds that pass all tests can be deemed deliverable. Error resolution is of paramount importance. A central repository displaying build and test results—often a website—is essential. Most CI tools readily offer such platforms. Furthermore, Patrick Cauldwell 6 advocates for frequent and early integration. The rationale? The more regular the integration, the less overhead for the team down the line. He distilled the primary goals of CI into:\nEnsuring a consistently available, tested version of the product with the latest modifications. Keeping the team abreast of any integration issues as early as possible. The impetus behind CI is to maintain an error-free, tested product throughout the development life cycle. This avoids the pitfalls of a last-minute integration phase, which is often fraught with errors and consumes both time and resources. More crucially, if project components aren\u0026rsquo;t integrated during their development, there\u0026rsquo;s no guarantee they\u0026rsquo;ll gel cohesively in the final product 7.\nTechnical implementation of CI revolves around two core components: process automation and a system to showcase results, thereby fuelling the developmental feedback loop 7.\nIn summing up the tenets of CI, Martin Fowler 1 emphasizes:\nRetaining code in a singular repository. Streamlining software construction through automation. Implementing automated testing processes. Ensuring new code additions undergo integration and construction on the CI system\u0026rsquo;s machine. Keeping the build process agile and swift. Providing easy access to the product\u0026rsquo;s latest executable version. Ensuring product status transparency for all stakeholders. Elements of a CI system # A basic Continuous Integration (CI) pipeline initiates when a new code change is pushed to the repository. The CI server, linked to the repository, gets notified of every new change, subsequently downloading the latest version to initiate the integration process, which will be elaborated on in the subsequent section. Once completed, it communicates the system\u0026rsquo;s status to the team members.\nIn computer science, a \u0026ldquo;pipeline\u0026rdquo; refers to a sequence of processes or tasks linked such that the output of one becomes the input for the next.\nFigure 1: Basic elements of CI The system\u0026rsquo;s primary component consists of the developers. After making code modifications, they run tests locally and compile the code to ensure that they haven\u0026rsquo;t introduced new errors.\nAn essential part of every CI system is the Version Control System (VCS). It oversees the changes made to the code and other significant elements. This system establishes a unified access point for all source code, enabling the CI system to fetch the most recent version for integration. Most software development projects utilize a VCS even if they don\u0026rsquo;t implement CI processes.\nThe CI Server is responsible for initiating a new build (comprising both compilation and tests) every time a change is added to the repository. They offer configurations to simplify the creation of integration pipelines. Additionally, most come with a web interface to display the build status and previous results. Currently, numerous powerful options are available, both free and paid. It\u0026rsquo;s worth noting that the CI server should operate on a dedicated machine and not on team members\u0026rsquo; computers.\nThe CI server must automatically conduct software tests, source code analysis, and compile to produce the deliverable product. Therefore, build and test execution scripts are vital. These scripts outline the necessary steps to be executed. Popular tools for this purpose include Make, Ant, Maven, Gradle, among others.\nEvery CI system should have a notification mechanism to relay results to the team. This mechanism ensures that in the event of an error, the team becomes aware as soon as possible, enabling them to address the issue. While most CI tools offer a web interface to view results, they also support other notification methods like emails, messaging applications, etc.\nThe integration process # The figure below broadly illustrates the stages of the integration process taking place within the Continuous Integration (CI) system.\nFigure 2: CI process flowchart Initially, the system must retrieve the latest source code version each time a new change is pushed to the Version Control System (VCS). Two mechanisms facilitate this. The first involves setting up the CI server to periodically check the VCS for updates. The alternative is to establish a commit hook within the VCS, ensuring that the CI server receives notifications whenever changes are made.\nAfter obtaining the code, the CI server can be configured to scrutinize the source code for potential undetected errors, be they syntactic, logical, or patterns that might lead to faults. Various tools aid this process. For instance, Java boasts utilities like FindBugs, CheckStyle, and PMD, while Python has Pylint. JavaScript can be analysed with tools like JSLint or JSHint. An example of a code analysis criterion could be ensuring every developed method has a cyclomatic complexity8 under 10. By employing automated source code inspection, one can assess code correctness, spot duplicate portions, and expedite the time between error detection and rectification. While automated inspection might not catch every error, the results can approximate those of peer reviews, thereby lightening the team\u0026rsquo;s review load.\nThe subsequent step revolves around automated test execution on the product. This automation is paramount to successfully implementing a CI system. Thus, developers can confidently make alterations, knowing a robust testing framework safeguards against compromising existing functionalities. Some popular tools in this domain include Junit, JBehave, and Selenium, which not only facilitate test drafting but also generate comprehensive reports, often as visualizations or web pages. Several software testing levels exist, such as unit tests, integration tests, and system tests. In the CI pipeline context, the focus rests on automating unit and integration tests, with system tests\u0026rsquo; automation being recommended but not mandatory.\nOnce the tests pass, the CI pipeline advances to compiling the source code. During this phase, the source code morphs into one or multiple files or packages, ready for distribution and user execution. This process\u0026rsquo;s specifics hinge on the employed programming language. For instance, languages like Java necessitate code compilation, resulting in an executable. Conversely, languages like Python might involve stricter code structure checks without generating any binary files.\nThroughout this integration journey, the team should steadfastly adhere to three fundamental rules:\nLocally run tests and compile software before integrating it into the VCS to minimize error introduction chances (avoiding \u0026ldquo;breaking the build\u0026rdquo;). Avoid pushing new code to the VCS if the CI server flags errors (indicative of a \u0026ldquo;broken build\u0026rdquo;). Should the CI server report faults, code modifications should exclusively aim at rectifying them. Core principles and practices # Martin Fowler2 identifies a set of foundational elements intrinsic to every Continuous Integration (CI) system. While some of these have been touched upon earlier in this chapter, we will succinctly encapsulate them here for clarity:\nCentralized Code Repository: Retain all code within a singular, unified repository. Streamlined Compilation and Build Process: Entirely automate the compilation and construction workflows, negating manual intervention. Full-Spectrum Automated Testing: Ensure all software tests are automated, driving efficiency and precision. Daily Commitment: Encourage the team to consistently merge their changes to the repository on a daily basis. Stringent Integration Checks: Each alteration made to the Version Control System (VCS) undergoes rigorous integration processes within the CI system. Prompt Error Rectification: Should the CI system flag any issues (indicative of a \u0026ldquo;broken build\u0026rdquo;), immediate action is imperative. Either rectify the flaw or reverse the change to ensure the repository\u0026rsquo;s latest version remains operational. Swift CI Procedures: Aim to complete the CI process rapidly—ideally within 15 minutes or less. This approach ensures timely integration and facilitates the expedited delivery of results. Universal Access to Latest Executables: Always provide the team with access to the most recent executable or deliverable package, promoting transparency. Real-time Product Status Visibility: Grant every team member the ability to monitor the product\u0026rsquo;s status at any given moment, fostering informed decision-making. Benefits # The overarching consensus within the software community is that the implementation of a Continuous Integration (CI) process yields an array of substantial advantages. Duvall5 outlines these core benefits in his publication.\nRisk Mitigation: Adopting frequent integration minimizes project risks. It facilitates early detection of issues and offers a continuous snapshot of the product\u0026rsquo;s health. By identifying these issues early in the development cycle, there\u0026rsquo;s a consequent reduction in both the cost of fixes and the risk of releasing a subpar product. Furthermore, automated inspections provide real-time insights into the product\u0026rsquo;s size, code complexity, and other metrics. This automation diminishes the chance of human-induced errors.\nMinimization of Manual Repetitive Tasks: Automation curtails the need for recurring manual tasks such as compilation, inspection, test execution, and report generation. This efficiency not only leads to significant time and cost savings but also allows teams to focus on activities that directly enhance product value. It liberates team members to dedicate more time to addressing new requirements or rectifying existing product issues.\nOn-Demand Availability of a Functional Product: A hallmark of CI is its ability to deliver a functional software product at any given moment. This is invaluable for stakeholders, offering them a rapid glance into product development progress. By leveraging CI, errors can be swiftly detected and remedied soon after a new change is introduced. This is far more efficient than uncovering them close to the release date when they are more expensive and challenging to amend. Such issues, if left unchecked, can lead to delivery delays, unsatisfied clients, escalated costs, and more. This ties back to the concept of the \u0026ldquo;Broken Window Theory\u0026rdquo;9, which, in essence, postulates that a product marred by numerous issues or perceived disorder can demotivate teams from addressing them.\nEnhanced Project Transparency: Implementing CI augments visibility into the project, rendering the development process more transparent. It aids project management with up-to-the-minute information, making it straightforward to gauge product quality, error trends, and more.\nElevated Product Confidence: The CI environment bolsters confidence in the product. Team members gain immediate insights into the ramifications of their changes, enabling them to promptly rectify any emergent issues.\nChallenges # While Duvall5 has extolled the virtues of Continuous Integration (CI) in his works, he also highlights potential challenges that might deter development teams from embracing it fully or realizing its benefits.\nBias: A widespread misconception is that CI system implementation is exorbitant and would escalate development costs due to its prolonged setup and maintenance. Contrarily, most software development projects already involve phases like inspection, testing, compilation, and integration, even if they don’t explicitly use a CI system. A common refrain is that there\u0026rsquo;s insufficient time or funds for CI system implementation, but the reality is that far more resources are spent performing redundant manual tasks throughout the development cycle. Furthermore, an automated CI system is infinitely more manageable and consistent compared to disparate manual processes.\nDisruption Fears: Projects in advanced development stages often fret that integrating a CI system would overhaul their established workflows, spawning significant delays. It’s pivotal to recognize that CI system implementation can be incremental. Teams can address one integration stage at a time, gradually ramping up the integration frequency as confidence builds.\nOverwhelming Failed Integrations: When CI practices aren’t diligently applied, there\u0026rsquo;s a risk of encountering an excessive number of failed integrations or \u0026ldquo;broken builds.\u0026rdquo; This could stem from developers bypassing local tests before uploading their changes to the Version Control System (VCS). A surge in failed integrations can erode trust in the CI system, reminiscent of the \u0026ldquo;Broken Window Theory\u0026rdquo;9.\nPerceived Additional Costs: There\u0026rsquo;s an apprehension among organizations about incurring extra expenses either for procuring CI product licenses or securing hardware to support these systems. However, this expenditure pales in comparison to the latent costs of late-stage integrations, where issues are discovered near the release date, far removed from their inception. On a brighter note, the current landscape is rife with a myriad of free and open-source alternatives, obviating any additional costs.\nReferences # Continuous integration. ThoughtWorks, 2018.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, Martin. Continuous Integration. 2006.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBeck, Kent. Embrace Change with Extreme Programming. IEEE Computer Magazine, (c), 70-77. 1999.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRodriguez Pilar, Markkula, Jouni, Oivo, Markku, \u0026amp; Turula, Kimmo. Survey on agile and lean usage in Finnish software industry. In Proceedings of the ACM-IEEE international symposium on Empirical software engineering and measurement - ESEM \u0026lsquo;12 (p. 139). ACM Press. DOI: 10.1145/2372251.2372275. 2012.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDuvall, Paul M., Matyas, Steve, \u0026amp; Glover, Andrew. Continuous integration: improving software quality and reducing risk. Pearson Education, Inc., 2007.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCauldwell, Patrick. Code Leader: Using people, tools and processes to build successful software. Wiley Publishing, Inc., 2008.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez \u0026amp; Farley, David. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCyclomatic Complexity Explanation\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe Broken Window Theory in Software Development\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"19 agosto 2023","externalUrl":null,"permalink":"/en/blog/continuous-integration/","section":"Blog","summary":"","title":"Continuous Integration","type":"blog"},{"content":"","date":"19 agosto 2023","externalUrl":null,"permalink":"/en/tags/continuous-integration/","section":"Tags","summary":"","title":"Continuous Integration","type":"tags"},{"content":"","date":"10 agosto 2023","externalUrl":null,"permalink":"/en/series/learning-software-engineering/","section":"Series","summary":"","title":"Learning Software Engineering","type":"series"},{"content":"","date":"10 agosto 2023","externalUrl":null,"permalink":"/en/tags/software-engineering/","section":"Tags","summary":"","title":"Software Engineering","type":"tags"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/en/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/en/tags/revert/","section":"Tags","summary":"","title":"Revert","type":"tags"},{"content":" Reverting a commit before pushing # When we have created a commit locally but have not published it to the remote yet, we can use git reset to undo the commit and, if we wish, discard the changes. Although there are several options for git reset the most used are:\n--soft: Does not touch the index file or the working tree at all (but resets the head to , just like all modes do). This leaves all your changed files \u0026ldquo;Changes to be committed\u0026rdquo;, as git status would put it. --hard: Resets the index and working tree. Any changes to tracked files in the working tree since are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted. Git reset documentation {: style=\u0026ldquo;text-align: right;\u0026rdquo;}\nHere there is an example about using git reset. We start by changing a file and creating a commit with the change.\nbash-3.2$ cat README.md # Index 1 bash-3.2$ bash-3.2$ cat README.md # Index 1 2 bash-3.2$ bash-3.2$ git add README.md bash-3.2$ bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md\u0026#34; [main 3734fd5] Add number 2 in README.md 1 file changed, 1 insertion(+) git status shows there is one commit pending to be published.\nbash-3.2$ git status On branch main Your branch is ahead of \u0026#39;origin/main\u0026#39; by 1 commit. (use \u0026#34;git push\u0026#34; to publish your local commits) nothing to commit, working tree clean Using git reflog to see the history.\n3734fd5 (HEAD -\u0026gt; main) HEAD@{0}: commit: Add number 2 in README.md 866bfa8 (origin/main) HEAD@{1}: revert: Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; e2f6d08 HEAD@{2}: merge feature-1: Merge made by the \u0026#39;ort\u0026#39; strategy. 23644da HEAD@{3}: checkout: moving from feature-1 to main Now we can use git reset --soft \u0026lt;COMMIT_ID\u0026gt; to undo the commit but keep the changes.\nbash-3.2$ git reset --soft 866bfa8 bash-3.2$ bash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: README.md git log after using git reset\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. We create a new commit so we can test the git reset --hard command.\nbash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: README.md bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md - NEW COMMIT\u0026#34; [main 2e7193d] Add number 2 in README.md - NEW COMMIT 1 file changed, 1 insertion(+) git log now shows the new commit.\ncommit 2e7193db650b9ba0762fe73525df599a08f8577d (HEAD -\u0026gt; main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Thu Jan 19 08:32:57 2023 -0300 Add number 2 in README.md - NEW COMMIT commit 866bfa8a952d11240707ebfc87f3266034d42443 (origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. Now we can use git reset --hard \u0026lt;COMMIT_ID\u0026gt; to undo the commit and discard all the changes.\nbash-3.2$ git reset --hard 866bfa8 HEAD is now at 866bfa8 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; bash-3.2$ bash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean git log remains as it nothing had happened.\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. Reverting a commit after it was pushed # When we realized that the last commit was a mistake but we already published it, the command to use is git revert \u0026lt;COMMIT_HASH\u0026gt;.\nFirst we need to locate the ID of the commit we want to revert, it can be done with git log or git reflog commands. Then, run the git revert \u0026lt;COMMIT_HASH\u0026gt; command using the ID obtained in the previous step. Use the options -e or --edit to edit the commit message if we like. Push our changes so the revert is available for everyone in our group. Reverting multiple commits # If we need to revert multiple commits we can revert them one by one using the --no-commit option in order to create a single revert commit at the end.\nImagine the history is like the following and we need to go back to COMMIT-3.\nCOMMIT-1 -\u0026gt; COMMIT-2 -\u0026gt; COMMIT-3 -\u0026gt; COMMIT-4 -\u0026gt; COMMIT-5 -\u0026gt; COMMIT-6 -\u0026gt; HEAD This sequence of commands will get our files to the version of COMMIT-3:\nbash-3.2$ git revert --no-commit COMMIT-6 bash-3.2$ git revert --no-commit COMMIT-5 bash-3.2$ git revert --no-commit COMMIT-4 bash-3.2$ git commit -m \u0026#34;Revert to version in COMMIT-3\u0026#34; bash-3.2$ git push Reverting a merge commit # -m parent-number, \u0026ndash;mainline parent-number\nUsually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.\nGit revert documentation {: style=\u0026ldquo;text-align: right;\u0026rdquo;}\nWhen we need to revert a merge commit git revert command needs to be run with the -m or --mainline option to indicate the parent number because a merge commit has more than one parent and Git does not know which parent was target branch and which was the branch with the changes that should be reverted.\nHere there is an example showing how to revert a merge commit.\nCreate the first commit in main branch.\nbash-3.2$ cat README.md # Index 1 bash-3.2$ bash-3.2$ git commit -m \u0026#34;Add number 1 in README.md - main branch\u0026#34; [main (root-commit) 23644da] Add number 1 in README.md - main branch 1 file changed, 3 insertions(+) create mode 100644 README.md bash-3.2$ bash-3.2$ git push -u origin main Enumerating objects: 3, done. Counting objects: 100% (3/3), done. Writing objects: 100% (3/3), 254 bytes | 254.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git * [new branch] main -\u0026gt; main branch \u0026#39;main\u0026#39; set up to track \u0026#39;origin/main\u0026#39;. bash-3.2$ The state of the README.md file in main branch.\nbash-3.2$git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 Branch feature-1 created and added one commit.\nbash-3.2$ git checkout -b feature-1 Switched to a new branch \u0026#39;feature-1\u0026#39; bash-3.2$ bash-3.2$ cat README.md # Index 1 2 bash-3.2$ bash-3.2$ git add README.md bash-3.2$ bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md - feature-1 branch\u0026#34; [feature-1 83ea1a3] Add number 2 in README.md - feature-1 branch 1 file changed, 1 insertion(+) bash-3.2$ bash-3.2$ git push --set-upstream origin feature-1 Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 292 bytes | 292.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 remote: remote: Create a pull request for \u0026#39;feature-1\u0026#39; on GitHub by visiting: remote: https://github.com/jnonino/test-repo/pull/new/feature-1 remote: To github.com:jnonino/test-repo.git * [new branch] feature-1 -\u0026gt; feature-1 branch \u0026#39;feature-1\u0026#39; set up to track \u0026#39;origin/feature-1\u0026#39;. bash-3.2$ The state of README.md in the feature-1 branch.\nbash-3.2$ git status On branch feature-1 Your branch is up to date with \u0026#39;origin/feature-1\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 2 Merge the feature-1 branch into the main branch.\nbash-3.2$ git checkout main Switched to branch \u0026#39;main\u0026#39; Your branch is up to date with \u0026#39;origin/main\u0026#39;. bash-3.2$ bash-3.2$ git merge --no-ff feature-1 Merge made by the \u0026#39;ort\u0026#39; strategy. README.md | 1 + 1 file changed, 1 insertion(+) bash-3.2$ bash-3.2$ git push Enumerating objects: 1, done. Counting objects: 100% (1/1), done. Writing objects: 100% (1/1), 233 bytes | 233.00 KiB/s, done. Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git 23644da..e2f6d08 main -\u0026gt; main bash-3.2$ Current state of README.md in main branch.\nbash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 2 git log after merging feature-1 into main branch.\ncommit e2f6d08d3b38a02a1c026cfb879f3131536757ac (HEAD -\u0026gt; main, origin/main) Merge: 23644da 83ea1a3 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:58:19 2023 -0300 Merge branch \u0026#39;feature-1\u0026#39; commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:53:38 2023 -0300 Add number 2 in README.md - feature-1 branch commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:48:37 2023 -0300 Add number 1 in README.md - main branch To revert the merge commit, as it was stated above we need to pay attention to the merge field.\nMerge: 23644da 83ea1a3 Running git revert e2f6d08 -m 1 will reinstate the tree as it was in 23644da, and git revert e2f6d08 -m 2 will set the tree as it was in 83ea1a3. In this example we would like to leave the main branch as it was before the merge commit. For doing that, we need to run git revert e2f6d08 -m 1.\nbash-3.2$ git revert e2f6d08 -m 1 [main 866bfa8] Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 1 file changed, 1 deletion(-) bash-3.2$ bash-3.2$ git status On branch main Your branch is ahead of \u0026#39;origin/main\u0026#39; by 1 commit. (use \u0026#34;git push\u0026#34; to publish your local commits) nothing to commit, working tree clean bash-3.2$ bash-3.2$ git push Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 344 bytes | 344.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git e2f6d08..866bfa8 main -\u0026gt; main git log after reverting the merge commit.\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. commit e2f6d08d3b38a02a1c026cfb879f3131536757ac Merge: 23644da 83ea1a3 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:58:19 2023 -0300 Merge branch \u0026#39;feature-1\u0026#39; commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:53:38 2023 -0300 Add number 2 in README.md - feature-1 branch commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:48:37 2023 -0300 Add number 1 in README.md - main branch Current state of README.md in main branch.\nbash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 ","date":"18 enero 2023","externalUrl":null,"permalink":"/en/blog/git-revert/","section":"Blog","summary":"","title":"Reverting changes in Git","type":"blog"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/en/tags/vcs/","section":"Tags","summary":"","title":"VCS","type":"tags"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/en/tags/version-control/","section":"Tags","summary":"","title":"Version Control","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Autores","summary":"","title":"Autores","type":"authors"},{"content":" Ultimas noticias y tutoriales sobre programación, ingeniería de software, DevOps, y ¡mucho más! ","externalUrl":null,"permalink":"/blog/","section":"Blog","summary":"","title":"Blog","type":"blog"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Etiquetas","summary":"","title":"Etiquetas","type":"tags"},{"content":"","externalUrl":null,"permalink":"/software-engineering/","section":"Ingeniería de Software","summary":"","title":"Ingeniería de Software","type":"software-engineering"},{"content":" Te invito a acompañarme en un recorrido claro y concreto: pasar de saber programar en Python a desempeñarte como ingeniero en Inteligencia Artificial. Vamos a ir publicando módulos con ejemplos reales, código funcional y un desafío que podés resolver en tu propio entorno. El objetivo es avanzar sin saturarte, aprendiendo de verdad y disfrutando cada paso.\nEste espacio es para vos, que estás comenzando, y también para aquellos profesionales que quieren refrescar ideas, encontrar recursos útiles o incluso descubrir soluciones que no se usaron en el día a día. Cada artículo es una pieza autónoma, directa y práctica: te sirve tanto si necesitás cimentar tu aprendizaje como si venís con experiencia y querés repasar o inspirarte. Arrancamos desde Python y caminaremos juntos hasta llegar al mundo profesional de IA.\nEn los ejemplos, no se hace mención a las prácticas esenciales para desarrollar software, como por ejemplo, utilizar un sistema de control de versiones, generar casos de prueba, etcétera.\nEsto se debe a que la intención es hacer foco en los conceptos de IA y ML, pero a la hora de encarar un proyecto real siempre debes tener en cuenta las mejores prácticas y proceso para el desarrollo profesional de software.\n","externalUrl":null,"permalink":"/ai/","section":"Inteligencia Artificial","summary":"","title":"Inteligencia Artificial","type":"ai"},{"content":"","externalUrl":null,"permalink":"/authors/jnonino/","section":"Autores","summary":"","title":"Julián Nonino","type":"authors"},{"content":"","externalUrl":null,"permalink":"/","section":"Learn-Software.com","summary":"","title":"Learn-Software.com","type":"page"},{"content":"","externalUrl":null,"permalink":"/programming/","section":"Programación","summary":"","title":"Programación","type":"programming"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]