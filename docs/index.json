[{"content":" En el m√≥dulo anterior exploramos los fundamentos conceptuales de la Inteligencia Artificial. Ahora es momento de sumergirnos en una de las √°reas de la matem√°tica que hacen posible que los algoritmos de Machine Learning funcionen: el √°lgebra lineal.\nSi eres como la mayor√≠a de los ingenieros de software, probablemente te preguntes: \u0026ldquo;¬øpor qu√© necesito √°lgebra lineal para programar IA?\u0026rdquo; La respuesta es simple pero profunda: el √°lgebra lineal es el lenguaje nativo del machine learning.\n¬øPor qu√© el √Ålgebra Lineal es crucial en IA? # Imagina que est√°s desarrollando un sistema de recomendaciones para Netflix. Cada usuario tiene preferencias (acci√≥n, comedia, drama) que pueden representarse como un vector. Cada pel√≠cula tambi√©n tiene caracter√≠sticas (g√©nero, a√±o, rating) que forman otro vector. El problema de recomendar pel√≠culas se convierte en encontrar similitudes entre vectores: √°lgebra lineal.\nO considera una red neuronal procesando una imagen de \\(224x224\\) p√≠xeles. Esa imagen se convierte en una matriz de \\(50176\\) elementos. Las operaciones de la red (convoluciones, transformaciones) son multiplicaciones de matrices. El entrenamiento optimiza estas matrices, otra vez: √°lgebra lineal.\nLos tres pilares del ML que dependen del √Ålgebra Lineal # Representaci√≥n de Datos: Todo en ML se convierte en vectores y matrices Transformaciones: Los algoritmos manipulan datos mediante operaciones lineales Optimizaci√≥n: Los m√©todos de entrenamiento usan gradientes (derivadas de operaciones matriciales) Como programadores, estamos acostumbrados a pensar en estructuras de datos como arrays, listas o objetos. En machine learning, pensamos en vectores y matrices. En este m√≥dulo aprenderemos a hacer esa transici√≥n mental.\nVectores: m√°s que arrays # Un vector no es simplemente un array de n√∫meros. Es una entidad matem√°tica que representa tanto magnitud como direcci√≥n. En el contexto de machine learning, un vector es una forma de codificar informaci√≥n.\nDefinici√≥n formal # Un vector \\(v\\) en el espacio \\(R^n\\) es una tupla ordenada de \\(n\\) n√∫meros reales:\n$$v = \\begin{pmatrix} v_1 \\\\ v_2 \\\\ \\vdots \\\\ v_n \\end{pmatrix}$$Pero m√°s importante que la definici√≥n formal es la interpretaci√≥n pr√°ctica:\nEn un sistema de recomendaciones: $$v = \\begin{pmatrix} rating_{accion} \\\\ rating_{comedia} \\\\ rating_{drama} \\end{pmatrix}$$ En procesamiento de texto: $$v = \\begin{pmatrix} frecuencia_{palabra1} \\\\ frecuencia_{palabra2} \\\\ frecuencia_{palabra3} \\\\ \\vdots \\end{pmatrix}$$ En visi√≥n por computadora: $$v = \\begin{pmatrix} pixel_1 \\\\ pixel_2 \\\\ pixel_3 \\\\ \\vdots \\end{pmatrix}$$ Interpretaci√≥n geom√©trica # Un vector en dos dimensiones (2D) se puede visualizar como una flecha desde el origen \\((0,0)\\) hasta el punto \\((v_1, v_2)\\). Esta visualizaci√≥n es clave para entender las operaciones vectoriales.\nimport matplotlib.pyplot as plt import numpy as np def dibujar_vector(vector, color=\u0026#39;blue\u0026#39;, label=\u0026#39;Vector\u0026#39;): plt.quiver(0, 0, vector[0], vector[1], angles=\u0026#39;xy\u0026#39;, scale_units=\u0026#39;xy\u0026#39;, scale=1, color=color, label=label, width=0.005) plt.xlim(-1, 5) plt.ylim(-1, 5) plt.grid(True) plt.axhline(y=0, color=\u0026#39;k\u0026#39;, linewidth=0.5) plt.axvline(x=0, color=\u0026#39;k\u0026#39;, linewidth=0.5) # Ejemplo: vector que representa preferencias de usuario preferencias_usuario = np.array([3, 4]) # [acci√≥n: 3, comedia: 4] plt.figure(figsize=(8, 6)) dibujar_vector(preferencias_usuario, \u0026#39;blue\u0026#39;, \u0026#39;Preferencias Usuario\u0026#39;) plt.xlabel(\u0026#39;Rating Acci√≥n\u0026#39;) plt.ylabel(\u0026#39;Rating Comedia\u0026#39;) plt.title(\u0026#39;Vector de Preferencias de Usuario\u0026#39;) plt.legend() plt.show() Al ejecutar el c√≥digo anterior obtenemos:\nInterpretaci√≥n geom√©trica de un vector en Machine Learning Suma de vectores # La suma vectorial es componente a componente:\n$$\\mathbf{u} + \\mathbf{v} = \\begin{pmatrix} u_1 + v_1 \\\\ u_2 + v_2 \\\\ \\vdots \\\\ u_n + v_n \\end{pmatrix}$$Interpretaci√≥n en ML: Si tenemos las preferencias de dos usuarios similares, podemos promediar sus vectores para encontrar preferencias \u0026ldquo;t√≠picas\u0026rdquo; de ese segmento.\nMultiplicaci√≥n por escalar # $$c \\cdot \\mathbf{v} = \\begin{pmatrix} c \\cdot v_1 \\\\ c \\cdot v_2 \\\\ \\vdots \\\\ c \\cdot v_n \\end{pmatrix}$$Interpretaci√≥n en ML: Amplificar o reducir la importancia de ciertas caracter√≠sticas.\nProducto Punto # El producto punto es quiz√°s la operaci√≥n m√°s importante en ML:\n$$\\mathbf{u} \\cdot \\mathbf{v} = \\sum_{i=1}^{n} u_i v_i = u_1 v_1 + u_2 v_2 + ... + u_n v_n$$¬øPor qu√© es tan importante?\nSimilitud: Vectores similares tienen productos punto altos Proyecci√≥n: Mide cu√°nto un vector \u0026ldquo;apunta\u0026rdquo; en la direcci√≥n de otro Redes neuronales: La base de las operaciones en cada neurona La interpretaci√≥n geom√©trica es crucial, el producto punto es igual al producto entre las magnitudes de cada vector y el coseno del √°ngulo entre ellos:\n$$\\mathbf{u} \\cdot \\mathbf{v} = ||\\mathbf{u}|| \\cdot ||\\mathbf{v}|| \\cdot \\cos(\\theta)$$Donde \\(\\theta\\) es el √°ngulo entre los vectores.\nO de otra manera:\n$$\\cos(\\theta) = \\frac{\\mathbf{u} \\cdot \\mathbf{v}}{||\\mathbf{u}|| \\cdot ||\\mathbf{v}||}$$$$\\theta = \\arccos(\\frac{\\mathbf{u} \\cdot \\mathbf{v}}{||\\mathbf{u}|| \\cdot ||\\mathbf{v}||})$$Conocer el √°ngulo entre los vectores permite determinar que tan alineados est√°n.\nImplementaci√≥n desde cero: clase Vector # Antes de usar NumPy, implementemos nuestras propias operaciones vectoriales para entender qu√© sucede en el detr√°s de escena:\nimport math from typing import List class Vector: \u0026#34;\u0026#34;\u0026#34; Implementaci√≥n b√°sica de un vector matem√°tico. Esta clase nos ayuda a entender las operaciones vectoriales antes de usar bibliotecas optimizadas como NumPy. \u0026#34;\u0026#34;\u0026#34; def __init__(self, componentes: List[float]): \u0026#34;\u0026#34;\u0026#34; Inicializa un vector con una lista de componentes. Args: componentes: Lista de n√∫meros que forman el vector \u0026#34;\u0026#34;\u0026#34; if not componentes: raise ValueError(\u0026#34;Un vector debe tener al menos un componente\u0026#34;) self.componentes = componentes self.dimension = len(componentes) def __repr__(self): return f\u0026#34;Vector({self.componentes})\u0026#34; def __len__(self): return self.dimension def __getitem__(self, index): return self.componentes[index] def __add__(self, otro_vector): \u0026#34;\u0026#34;\u0026#34; Suma vectorial: componente por componente. Ejemplo: v1 = Vector([1, 2, 3]) v2 = Vector([4, 5, 6]) v3 = v1 + v2 # Vector([5, 7, 9]) \u0026#34;\u0026#34;\u0026#34; if self.dimension != otro_vector.dimension: raise ValueError(\u0026#34;Los vectores deben tener la misma dimensi√≥n\u0026#34;) componentes_resultado = [ a + b for a, b in zip(self.componentes, otro_vector.componentes) ] return Vector(componentes_resultado) def __sub__(self, otro_vector): \u0026#34;\u0026#34;\u0026#34;Resta vectorial.\u0026#34;\u0026#34;\u0026#34; if self.dimension != otro_vector.dimension: raise ValueError(\u0026#34;Los vectores deben tener la misma dimensi√≥n\u0026#34;) componentes_resultado = [ a - b for a, b in zip(self.componentes, otro_vector.componentes) ] return Vector(componentes_resultado) def __mul__(self, escalar): \u0026#34;\u0026#34;\u0026#34; Multiplicaci√≥n por escalar. Ejemplo: v = Vector([1, 2, 3]) v_scaled = v * 2 # Vector([2, 4, 6]) \u0026#34;\u0026#34;\u0026#34; return Vector([escalar * componente for componente in self.componentes]) def producto_punto(self, otro_vector): \u0026#34;\u0026#34;\u0026#34; Producto punto: la operaci√≥n m√°s importante en Machine Learning. El producto punto mide la similitud direccional entre vectores. - Producto alto: vectores apuntan en direcciones similares - Producto cero: vectores perpendiculares - Producto negativo: vectores apuntan en direcciones opuestas Args: otro_vector: Otro vector de la misma dimensi√≥n Returns: float: El producto punto \u0026#34;\u0026#34;\u0026#34; if self.dimension != otro_vector.dimension: raise ValueError(\u0026#34;Los vectores deben tener la misma dimensi√≥n\u0026#34;) return sum(a * b for a, b in zip(self.componentes, otro_vector.componentes)) def magnitud(self): \u0026#34;\u0026#34;\u0026#34; Calcula la magnitud (norma) del vector. La magnitud representa la \u0026#34;longitud\u0026#34; del vector. Es importante para normalizaci√≥n y c√°lculo de distancias. Returns: float: La magnitud del vector \u0026#34;\u0026#34;\u0026#34; return math.sqrt(sum(componente ** 2 for componente in self.componentes)) def normalizar(self): \u0026#34;\u0026#34;\u0026#34; Normaliza el vector (magnitud = 1). Los vectores normalizados son cruciales en Machine Learning porque: - Eliminan el efecto de la escala - Facilitan la comparaci√≥n de direcciones - Son requeridos en muchos algoritmos Returns: Vector: Nuevo vector normalizado \u0026#34;\u0026#34;\u0026#34; mag = self.magnitud() if mag == 0: raise ValueError(\u0026#34;No se puede normalizar el vector cero\u0026#34;) return Vector([componente / mag for componente in self.componentes]) def similitud_coseno(self, otro_vector): \u0026#34;\u0026#34;\u0026#34; Calcula la similitud coseno entre dos vectores. La similitud coseno es fundamental en: - Sistemas de recomendaci√≥n - Procesamiento de lenguaje natural - B√∫squeda sem√°ntica Retorna valores entre -1 y 1: - 1: Vectores id√©nticos en direcci√≥n - 0: Vectores perpendiculares - -1: Vectores opuestos Args: otro_vector: Otro vector Returns: float: Similitud coseno \u0026#34;\u0026#34;\u0026#34; dot_prod = self.producto_punto(otro_vector) producto_magnitudes = self.magnitud() * otro_vector.magnitud() if producto_magnitudes == 0: return 0 return dot_prod / producto_magnitudes # Ejemplos de uso def demo_operaciones_vectoriales(): \u0026#34;\u0026#34;\u0026#34; Prueba las operaciones vectoriales con ejemplos de Machine Learning. \u0026#34;\u0026#34;\u0026#34; mensaje = \u0026#34;Ejemplos de Operaciones Vectoriales\u0026#34; print(\u0026#34;#\u0026#34; * len(mensaje)) print(mensaje) print(\u0026#34;#\u0026#34; * len(mensaje)) print(\u0026#34;\\n\u0026#34;) # Ejemplo 1: Preferencias de usuarios print(\u0026#34;=== Ejemplo 1: Preferencias de usuarios ===\u0026#34;) print(\u0026#34; Cada usuario se corresponde con un vector que mapea sus preferencias en pel√≠culas\u0026#34;) print(\u0026#34; Vector([acci√≥n, comedia, drama])\u0026#34;) print(\u0026#34;\\n\u0026#34;) usuarios = [ Vector([4, 2, 5]), Vector([3, 4, 2]), Vector([9, 1, 2]), Vector([3, 8, 1]), Vector([1, 2, 9]) ] for index_i, usuario_i in enumerate(usuarios): print(f\u0026#34; Usuario {index_i}: {usuario_i}\u0026#34;) for index_j in range(index_i + 1, len(usuarios)): usuario_j = usuarios[index_j] print(f\u0026#34; C√°lculos de similitud con el usuario {index_j}\u0026#34;) combinadas = usuario_i + usuario_j print(f\u0026#34; Suma: preferencias combinadas: {combinadas}\u0026#34;) similitud_producto_punto = usuario_i.producto_punto(usuario_j) print(f\u0026#34; Similitud (producto punto): {similitud_producto_punto}\u0026#34;) similitud_coseno = usuario_i.similitud_coseno(usuario_j) print(f\u0026#34; Similitud coseno: {similitud_coseno:.3f}\u0026#34;) print(\u0026#34;\\n\u0026#34;) # Ejemplo 2: Vectores de caracter√≠sticas print(\u0026#34;=== Ejemplo 2: An√°lisis de Documentos ===\u0026#34;) print(\u0026#34; Cada documento se corresponde con un vector que mapea las frecuencias de las palabras que contiene\u0026#34;) print(\u0026#34; Vector([frecuencia_palabra_1, frecuencia_palabra_2, frecuencia_palabra_3, frecuencia_palabra_4])\u0026#34;) documento_1 = Vector([2, 1, 0, 3]) # Frecuencias de palabras documento_2 = Vector([1, 2, 1, 2]) # Frecuencias de palabras print(f\u0026#34; Documento 1: {documento_1}\u0026#34;) print(f\u0026#34; Documento 2: {documento_2}\u0026#34;) similitud_documentos_producto_punto = documento_1.producto_punto(documento_2) print(f\u0026#34; Similitud (producto punto): {similitud_documentos_producto_punto}\u0026#34;) similitud_documentos_coseno = documento_1.similitud_coseno(documento_2) print(f\u0026#34; Similitud entre documentos (coseno): {similitud_documentos_coseno:.3f}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: demo_operaciones_vectoriales() Al ejecutar el c√≥digo anterior obtenemos:\n\u0026gt; python vector.py ################################### Ejemplos de Operaciones Vectoriales ################################### === Ejemplo 1: Preferencias de usuarios === Cada usuario se corresponde con un vector que mapea sus preferencias en pel√≠culas Vector([acci√≥n, comedia, drama]) Usuario 0: Vector([4, 2, 5]) C√°lculos de similitud con el usuario 1 Suma: preferencias combinadas: Vector([7, 6, 7]) Similitud (producto punto): 30 Similitud coseno: 0.830 C√°lculos de similitud con el usuario 2 Suma: preferencias combinadas: Vector([13, 3, 7]) Similitud (producto punto): 48 Similitud coseno: 0.772 C√°lculos de similitud con el usuario 3 Suma: preferencias combinadas: Vector([7, 10, 6]) Similitud (producto punto): 33 Similitud coseno: 0.572 C√°lculos de similitud con el usuario 4 Suma: preferencias combinadas: Vector([5, 4, 14]) Similitud (producto punto): 53 Similitud coseno: 0.852 Usuario 1: Vector([3, 4, 2]) C√°lculos de similitud con el usuario 2 Suma: preferencias combinadas: Vector([12, 5, 4]) Similitud (producto punto): 35 Similitud coseno: 0.701 C√°lculos de similitud con el usuario 3 Suma: preferencias combinadas: Vector([6, 12, 3]) Similitud (producto punto): 43 Similitud coseno: 0.928 C√°lculos de similitud con el usuario 4 Suma: preferencias combinadas: Vector([4, 6, 11]) Similitud (producto punto): 29 Similitud coseno: 0.581 Usuario 2: Vector([9, 1, 2]) C√°lculos de similitud con el usuario 3 Suma: preferencias combinadas: Vector([12, 9, 3]) Similitud (producto punto): 37 Similitud coseno: 0.464 C√°lculos de similitud con el usuario 4 Suma: preferencias combinadas: Vector([10, 3, 11]) Similitud (producto punto): 29 Similitud coseno: 0.337 Usuario 3: Vector([3, 8, 1]) C√°lculos de similitud con el usuario 4 Suma: preferencias combinadas: Vector([4, 10, 10]) Similitud (producto punto): 28 Similitud coseno: 0.351 Usuario 4: Vector([1, 2, 9]) === Ejemplo 2: An√°lisis de Documentos === Cada documento se corresponde con un vector que mapea las frecuencias de las palabras que contiene Vector([frecuencia_palabra_1, frecuencia_palabra_2, frecuencia_palabra_3, frecuencia_palabra_4]) Documento 1: Vector([2, 1, 0, 3]) Documento 2: Vector([1, 2, 1, 2]) Similitud (producto punto): 10 Similitud entre documentos (coseno): 0.845 Matrices: transformaciones de datos # Si los vectores representan datos, las matrices representan transformaciones de esos datos. Una matriz es una tabla rectangular de n√∫meros organizados en filas y columnas.\n$$\\mathbf{A} = \\begin{pmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ a_{m1} \u0026 a_{m2} \u0026 \\cdots \u0026 a_{mn} \\end{pmatrix}$$En machine learning, las matrices son omnipresentes:\nDataset: Cada fila es un ejemplo, cada columna una caracter√≠stica Pesos de red neuronal: Transforman entradas en salidas Transformaciones: Rotaci√≥n, escalado, proyecci√≥n de datos Multiplicaci√≥n Matriz-Vector # Esta es la operaci√≥n m√°s com√∫n en ML. Transforma un vector usando una matriz:\n$$\\mathbf{A}\\mathbf{v} = \\begin{pmatrix} \\sum_{i=1}^{n} a_{1i} v_i \\\\ \\sum_{i=1}^{n} a_{2i} v_i \\\\ \\sum_{i=1}^{n} a_{3i} v_i \\\\ \\vdots \\\\ \\sum_{i=1}^{n} a_{mi} v_i \\\\ \\end{pmatrix}$$$$\\mathbf{A}\\mathbf{v} = \\begin{pmatrix} a_{11} \u0026 a_{12} \u0026 a_{13} \u0026 \\cdots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 a_{33} \u0026 \\cdots \u0026 a_{2n} \\\\ a_{31} \u0026 a_{32} \u0026 a_{33} \u0026 \\cdots \u0026 a_{3n} \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ a_{m1} \u0026 a_{m2} \u0026 a_{m3} \u0026 \\cdots \u0026 a_{mn} \\\\ \\end{pmatrix} \\cdot \\begin{pmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ \\vdots \\\\ v_n \\end{pmatrix}$$$$\\mathbf{A}\\mathbf{v} = \\begin{pmatrix} a_{11} \\cdot v_1 + a_{12} \\cdot v_2 + a_{13} \\cdot v_3 + \\cdots + a_{1n} \\cdot v_n \\\\ a_{21} \\cdot v_1 + a_{22} \\cdot v_2 + a_{23} \\cdot v_3 + \\cdots + a_{2n} \\cdot v_n \\\\ a_{31} \\cdot v_1 + a_{32} \\cdot v_2 + a_{33} \\cdot v_3 + \\cdots + a_{3n} \\cdot v_n \\\\ \\vdots \\\\ a_{m1} \\cdot v_1 + a_{m2} \\cdot v_2 + a_{m3} \\cdot v_3 + \\cdots + a_{mn} \\cdot v_n \\\\ \\end{pmatrix}$$Cuando se multiplica una matriz por un vector, es necesario que el n√∫mero de elementos del vector coincida con el n√∫mero de columnas de la matriz. Si no es as√≠, la multiplicaci√≥n no est√° definida.\nEjemplo pr√°ctico: En una red neuronal, cada capa aplica una transformaci√≥n lineal:\nsalida = pesos √ó entrada + sesgo Si a√∫n no lo notaste, se puede establecer una conexi√≥n entre la multiplicaci√≥n de una matriz por un vector y el producto punto entre vectores.\nLa conexi√≥n es directa: multiplicar una matriz por un vector es, en el fondo, hacer varios productos punto seguidos.\nSi \\(A\\) es una matriz de \\(m \\times n\\) y \\(v\\) es un vector de dimensi√≥n \\(n\\), el resultado de \\(A \\ v\\) es un vector de dimensi√≥n \\(m\\) donde cada componente se obtiene haciendo el producto punto de una fila de la matriz con el vector.\n$$(A \\ v)_j = fila_j(A) \\cdot v$$ Multiplicaci√≥n Matriz-Matriz # Para que el producto de dos matrices \\(A\\) y \\(B\\) es decir, \\(AB\\) est√© definido, la matriz \\(A\\) debe tener el mismo n√∫mero de columnas que la matriz \\(B\\) tenga de filas. Si \\(A\\) es de tama√±o \\(m x n\\) y \\(B\\) es de tama√±o \\(n x p\\), entonces el resultado \\(C = AB\\) ser√° una matriz de tama√±o \\(m x p\\).\n$$\\mathbf{C} = \\mathbf{A}\\mathbf{B} = \\begin{pmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\\\ a_{31} \u0026 a_{32} \u0026 \\cdots \u0026 a_{3n} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ a_{m1} \u0026 a_{m2} \u0026 \\cdots \u0026 a_{mn} \\\\ \\end{pmatrix} \\cdot \\begin{pmatrix} b_{11} \u0026 b_{12} \u0026 \\cdots \u0026 b_{1p} \\\\ b_{21} \u0026 b_{22} \u0026 \\cdots \u0026 b_{2p} \\\\ b_{31} \u0026 b_{32} \u0026 \\cdots \u0026 b_{3p} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ b_{n1} \u0026 b_{n2} \u0026 \\cdots \u0026 b_{np} \\\\ \\end{pmatrix}$$$$\\mathbf{C} = \\mathbf{A}\\mathbf{B} = \\begin{pmatrix} \\sum_{k=1}^{n} a_{1k} b_{k1} \u0026 \\sum_{k=1}^{n} a_{1k} b_{k2} \u0026 \\cdots \u0026 \\sum_{k=1}^{n} a_{1k} b_{kp} \\\\ \\sum_{k=1}^{n} a_{2k} b_{k1} \u0026 \\sum_{k=1}^{n} a_{2k} b_{k2} \u0026 \\cdots \u0026 \\sum_{k=1}^{n} a_{2k} b_{kp} \\\\ \\sum_{k=1}^{n} a_{3k} b_{k1} \u0026 \\sum_{k=1}^{n} a_{3k} b_{k2} \u0026 \\cdots \u0026 \\sum_{k=1}^{n} a_{3k} b_{kp} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\sum_{k=1}^{n} a_{mk} b_{k1} \u0026 \\sum_{k=1}^{n} a_{mk} b_{k2} \u0026 \\cdots \u0026 \\sum_{k=1}^{n} a_{mk} b_{kp} \\\\ \\end{pmatrix}$$Es decir, cada elemento \\(ij\\) de la matriz resultado (\\(C\\)) ser√°:\n$$\\mathbf{C}_{ij} = (\\mathbf{AB})_{ij} = \\sum_{k=1}^{n} a_{ik} b_{kj}$$Esta operaci√≥n permite componer transformaciones lineales.\nNuevamente, la multiplicaci√≥n de matrices est√° muy relacionada con el producto punto de vectores.\nEn la multiplicaci√≥n entre las matrices \\(A(m \\times n)\\) por \\(B(n \\times p)\\), el elemento \\(c_{ij}\\) de la matriz resultado \\(C\\) se obtiene como:\n$$\\mathbf{C}_{ij} = \\sum_{k=1}^{n} a_{ik} b_{kj}$$Esto es exactamente el producto punto entre la fila \\(i\\) de \\(A\\) y la columna \\(j\\) de \\(B\\).\n$$\\mathbf{C}_{ij} = a_{i} \\cdot b_{j}$$ Implementaci√≥n desde cero: clase Matriz # import math from typing import List from vector import Vector class Matriz: \u0026#34;\u0026#34;\u0026#34; Implementaci√≥n b√°sica de una matriz matem√°tica. Esta clase nos ayuda a entender las operaciones matriciales fundamentales en Machine Learning. \u0026#34;\u0026#34;\u0026#34; def __init__(self, datos: List[List[float]]): \u0026#34;\u0026#34;\u0026#34; Inicializa una matriz con una lista de listas. Args: datos: Lista de filas, donde cada fila es una lista de n√∫meros \u0026#34;\u0026#34;\u0026#34; if not datos or not datos[0]: raise ValueError(\u0026#34;La matriz debe tener al menos un elemento\u0026#34;) # Verificar que todas las filas tengan la misma longitud longitud_fila = len(datos[0]) for fila in datos: if len(fila) != longitud_fila: raise ValueError(\u0026#34;Todas las filas deben tener la misma longitud\u0026#34;) self.datos = datos self.filas = len(datos) self.columnas = len(datos[0]) self.forma = (self.filas, self.columnas) def __repr__(self): \u0026#34;\u0026#34;\u0026#34;Representaci√≥n legible de la matriz.\u0026#34;\u0026#34;\u0026#34; filas = [] for fila in self.datos: row_str = \u0026#34; \u0026#34;.join(f\u0026#34;{x:8.3f}\u0026#34; for x in fila) filas.append(f\u0026#34;[{row_str}]\u0026#34;) return f\u0026#34;Matriz(\\n \u0026#34; + \u0026#34;\\n \u0026#34;.join(filas) + \u0026#34;\\n)\u0026#34; def __getitem__(self, indices): \u0026#34;\u0026#34;\u0026#34;Permite acceso con matriz[i][j] o matriz[i, j].\u0026#34;\u0026#34;\u0026#34; if isinstance(indices, tuple): fila, columna = indices return self.datos[fila][columna] else: return self.datos[indices] def __setitem__(self, indices, value): \u0026#34;\u0026#34;\u0026#34;Permite asignaci√≥n con matriz[i][j] = value.\u0026#34;\u0026#34;\u0026#34; if isinstance(indices, tuple): fila, columna = indices self.datos[fila][columna] = value else: fila = indices self.datos[fila] = value def __add__(self, otra): \u0026#34;\u0026#34;\u0026#34;Suma de matrices (elemento por elemento).\u0026#34;\u0026#34;\u0026#34; if self.forma != otra.shape: raise ValueError(\u0026#34;Las matrices deben tener la misma forma\u0026#34;) datos_resultado = [ [self.datos[i][j] + otra.datos[i][j] for j in range(self.columnas)] for i in range(self.filas) ] return Matriz(datos_resultado) def trasponer(self): \u0026#34;\u0026#34;\u0026#34; Calcula la transpuesta de la matriz. La transpuesta intercambia filas por columnas. Es fundamental en √°lgebra lineal y en Machine Learning. Returns: Matriz: Nueva matriz transpuesta \u0026#34;\u0026#34;\u0026#34; datos_transpuestos = [ [self.datos[fila][columna] for fila in range(self.filas)] for columna in range(self.columnas) ] return Matriz(datos_transpuestos) def multiplicar_por_escalar(self, escalar): \u0026#34;\u0026#34;\u0026#34;Multiplicaci√≥n por escalar.\u0026#34;\u0026#34;\u0026#34; datos_resultado = [ [escalar * self.datos[i][j] for j in range(self.columnas)] for i in range(self.filas) ] return Matriz(datos_resultado) def multiplicar_por_vector(self, vector: Vector): \u0026#34;\u0026#34;\u0026#34; Multiplica la matriz por un vector. Esta es la operaci√≥n fundamental en redes neuronales: cada capa aplica una transformaci√≥n lineal Ax + b. Args: vector: Vector a multiplicar Returns: Vector: Resultado de la multiplicaci√≥n \u0026#34;\u0026#34;\u0026#34; if self.columnas != len(vector): raise ValueError(f\u0026#34;Dimensiones incompatibles: matriz {self.forma} * vector {len(vector)}\u0026#34;) componentes_resultado = [] for index_fila in range(self.filas): fila = [ self.datos[index_fila][columna] for columna in range(self.columnas) ] producto_punto = Vector(fila).producto_punto(vector) componentes_resultado.append(producto_punto) return Vector(componentes_resultado) def multiplicar_matrices(self, otra): \u0026#34;\u0026#34;\u0026#34; Multiplica dos matrices. La multiplicaci√≥n de matrices permite componer transformaciones. En deep learning, representa la composici√≥n de capas. Args: otra: Otra matriz Returns: Matriz: Resultado de la multiplicaci√≥n \u0026#34;\u0026#34;\u0026#34; if self.columnas != otra.filas: raise ValueError(f\u0026#34;Dimensiones incompatibles: {self.forma} * {otra.forma}\u0026#34;) print(f\u0026#34; Forma matriz A: {self.forma}\u0026#34;) print(f\u0026#34; Forma matriz B: {otra.forma}\u0026#34;) datos_resultado = [] for index_fila in range(self.filas): fila_i_matriz = [ self.datos[index_fila][columna] for columna in range(self.columnas) ] vector_fila_i_matriz = Vector(fila_i_matriz) fila_resultado = [] for index_columna_otra in range(otra.columnas): columna_j_matriz_otra = [ otra.datos[fila][index_columna_otra] for fila in range(otra.filas) ] vector_columna_j_matriz_otra = Vector(columna_j_matriz_otra) fila_resultado.append(vector_fila_i_matriz.producto_punto(vector_columna_j_matriz_otra)) datos_resultado.append(fila_resultado) return Matriz(datos_resultado) @staticmethod def identidad(tamano: int): \u0026#34;\u0026#34;\u0026#34; Crea una matriz identidad de tama√±o size * size. La matriz identidad es el \u0026#34;1\u0026#34; de las matrices: A * I = I * A = A Args: tamano: Tama√±o de la matriz cuadrada Returns: Matriz: Matriz identidad \u0026#34;\u0026#34;\u0026#34; datos = [ [1.0 if i == j else 0.0 for j in range(tamano)] for i in range(tamano) ] return Matriz(datos) def rotar_vector(vector: Vector, angulo: int): \u0026#34;\u0026#34;\u0026#34;Rotar vector\u0026#34;\u0026#34;\u0026#34; angulo_radianes = angulo * math.pi / 180 # angulo en grados convertido a radianes matriz_transformacion = Matriz([ [math.cos(angulo_radianes), -math.sin(angulo_radianes)], [math.sin(angulo_radianes), math.cos(angulo_radianes)] ]) return { \u0026#34;matriz_transformacion\u0026#34;: matriz_transformacion, \u0026#34;vector_rotado\u0026#34;: matriz_transformacion.multiplicar_por_vector(vector) } # Ejemplos de uso def demo_operaciones_matriciales(): \u0026#34;\u0026#34;\u0026#34; Demuestra las operaciones matriciales con ejemplos de Machine Learning. \u0026#34;\u0026#34;\u0026#34; mensaje = \u0026#34;Ejemplos de Operaciones Matriciales\u0026#34; print(\u0026#34;#\u0026#34; * len(mensaje)) print(mensaje) print(\u0026#34;#\u0026#34; * len(mensaje)) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;=== Ejemplo 1: Transponer ===\u0026#34;) datos = Matriz([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0] ]) print(datos) print(\u0026#34;Transponer...\u0026#34;) print(datos.trasponer()) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;=== Ejemplo 2: Multiplicaci√≥n matriz por escalar ===\u0026#34;) print(datos) escalar = 3 print(f\u0026#34;Multiplicaci√≥n por el escalar: {escalar}...\u0026#34;) print(datos.multiplicar_por_escalar(escalar)) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;=== Ejemplo 3: Multiplicaci√≥n matriz por vector ===\u0026#34;) print(datos) vector = Vector([1.0, 2.0, 3.0]) print(f\u0026#34;Multiplicaci√≥n por el vector: {vector}...\u0026#34;) print(datos.multiplicar_por_vector(vector)) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;=== Ejemplo 4: Multiplicaci√≥n matriz por matriz ===\u0026#34;) print(datos) otra = Matriz([ [9.0, 8.0, 7.0], [6.0, 5.0, 4.0], [3.0, 2.0, 1.0] ]) print(f\u0026#34;Multiplicaci√≥n por la matriz: {otra}...\u0026#34;) print(datos.multiplicar_matrices(otra)) print(\u0026#34;\\n\u0026#34;) print(\u0026#34;=== Ejemplo 5: Rotaci√≥n de un vector en 2D ===\u0026#34;) vector_original = Vector([1.0, 0.0]) print(\u0026#34;\\n\u0026#34;) angulo = 45 rotacion = rotar_vector(vector_original, angulo) print(f\u0026#34;Vector original en 2D: {vector_original}\u0026#34;) print(f\u0026#34;Matriz de rotacion en {angulo} grados: {rotacion[\u0026#34;matriz_transformacion\u0026#34;]}\u0026#34;) print(f\u0026#34;Vector rotado en {angulo} grados: {rotacion[\u0026#34;vector_rotado\u0026#34;]}\u0026#34;) print(\u0026#34;\\n\u0026#34;) angulo = 90 rotacion = rotar_vector(vector_original, angulo) print(f\u0026#34;Vector original en 2D: {vector_original}\u0026#34;) print(f\u0026#34;Matriz de rotacion en {angulo} grados: {rotacion[\u0026#34;matriz_transformacion\u0026#34;]}\u0026#34;) print(f\u0026#34;Vector rotado en {angulo} grados: {rotacion[\u0026#34;vector_rotado\u0026#34;]}\u0026#34;) print(\u0026#34;\\n\u0026#34;) angulo = 180 rotacion = rotar_vector(vector_original, angulo) print(f\u0026#34;Vector original en 2D: {vector_original}\u0026#34;) print(f\u0026#34;Matriz de rotacion en {angulo} grados: {rotacion[\u0026#34;matriz_transformacion\u0026#34;]}\u0026#34;) print(f\u0026#34;Vector rotado en {angulo} grados: {rotacion[\u0026#34;vector_rotado\u0026#34;]}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: demo_operaciones_matriciales() Al ejecutar el c√≥digo anterior obtenemos:\n\u0026gt; python matriz.py ################################### Ejemplos de Operaciones Matriciales ################################### === Ejemplo 1: Transponer === Matriz( [ 1.000 2.000 3.000] [ 4.000 5.000 6.000] [ 7.000 8.000 9.000] ) Transponer... Matriz( [ 1.000 4.000 7.000] [ 2.000 5.000 8.000] [ 3.000 6.000 9.000] ) === Ejemplo 2: Multiplicaci√≥n matriz por escalar === Matriz( [ 1.000 2.000 3.000] [ 4.000 5.000 6.000] [ 7.000 8.000 9.000] ) Multiplicaci√≥n por el escalar: 3... Matriz( [ 3.000 6.000 9.000] [ 12.000 15.000 18.000] [ 21.000 24.000 27.000] ) === Ejemplo 3: Multiplicaci√≥n matriz por vector === Matriz( [ 1.000 2.000 3.000] [ 4.000 5.000 6.000] [ 7.000 8.000 9.000] ) Multiplicaci√≥n por el vector: Vector([1.0, 2.0, 3.0])... Vector([14.0, 32.0, 50.0]) === Ejemplo 4: Multiplicaci√≥n matriz por matriz === Matriz( [ 1.000 2.000 3.000] [ 4.000 5.000 6.000] [ 7.000 8.000 9.000] ) Multiplicaci√≥n por la matriz: Matriz( [ 9.000 8.000 7.000] [ 6.000 5.000 4.000] [ 3.000 2.000 1.000] )... Forma matriz A: (3, 3) Forma matriz B: (3, 3) Matriz( [ 30.000 24.000 18.000] [ 84.000 69.000 54.000] [ 138.000 114.000 90.000] ) === Ejemplo 5: Rotaci√≥n de un vector en 2D === Vector original en 2D: Vector([1.0, 0.0]) Matriz de rotacion en 45 grados: Matriz( [ 0.707 -0.707] [ 0.707 0.707] ) Vector rotado en 45 grados: Vector([0.7071067811865476, 0.7071067811865475]) Vector original en 2D: Vector([1.0, 0.0]) Matriz de rotacion en 90 grados: Matriz( [ 0.000 -1.000] [ 1.000 0.000] ) Vector rotado en 90 grados: Vector([6.123233995736766e-17, 1.0]) Vector original en 2D: Vector([1.0, 0.0]) Matriz de rotacion en 180 grados: Matriz( [ -1.000 -0.000] [ 0.000 -1.000] ) Vector rotado en 180 grados: Vector([-1.0, 1.2246467991473532e-16]) Espacios Vectoriales y Transformaciones Lineales # Un espacio vectorial (o espacio lineal) es un conjunto no vac√≠o de vectores, en el que se han definido dos operaciones: la suma de vectores y la multiplicaci√≥n de un vector por un escalar (n√∫mero real o complejo). Para que un conjunto sea considerado un espacio vectorial, debe cumplir con ciertos axiomas fundamentales.\nConmutatividad: \\(u + v = v + u\\)\nAsociatividad: \\((u + v) + w = u + (v + w)\\)\nExistencia del vector nulo: \\(\\exists \\ v_0 \\in V \\ \\;|\\; \\ v_0 + u = u \\ \\forall \\ u \\in V \\)\nExistencia del opuesto: \\(\\forall \\ v_i \\in V \\ \\exists \\ -v_i \\in V \\ \\;|\\; \\ v_i + (-v_i) = 0\\)\nDistributividad del producto respecto a la suma vectorial: \\(\\alpha (u + v) = \\alpha u + \\alpha v\\)\nDistributividad del producto respecto a la suma escalar: \\((\\alpha + \\beta) u = \\alpha u + \\beta u\\)\nAsociatividad del producto de escalares: \\(\\alpha (\\beta u) = (\\alpha \\beta) u\\)\nElemento neutro: \\(1 u = u \\ \\forall \\ u \\in V\\)\nEntre algunos ejemplos de espacios vectoriales podemos mencionar:\nVectores en el plano: Los vectores en \\(\\mathbb{R}^2\\) son un ejemplo cl√°sico de espacio vectorial, donde cada vector se representa como un par ordenado \\((x,y)\\) Vectores en el espacio tridimensional: En \\(\\mathbb{R}^3\\), un vector se puede escribir como \\(V = \\alpha i + \\beta j + \\gamma k \\) donde \\(i\\), \\(j\\) y \\(k\\) son vectores base. Los espacios vectoriales son fundamentales en diversas √°reas, incluyendo matem√°ticas, f√≠sica, ingenier√≠a y ciencias de la computaci√≥n, ya que permiten modelar y resolver problemas complejos mediante el uso de vectores y matrices.\n¬øPor qu√© importa en Machine Learning?\nCaracter√≠sticas: Cada dataset define un espacio vectorial Modelos: Los algoritmos de Machine Learning operan en estos espacios Transformaciones: Cambiamos de un espacio a otro para facilitar el aprendizaje Transformaciones lineales # Una transformaci√≥n \\(T: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m\\) se define como una funci√≥n que asigna a cada vector \\(v\\) en un espacio vectorial \\(V\\) un √∫nico vector \\(w\\) en otro espacio vectorial \\(W\\).\nPara que \\(T\\) sea considerada lineal, debe cumplir dos condiciones fundamentales:\nAdici√≥n: Para cualquier par de vectores \\(u\\) y \\(v\\) en \\(V\\), se cumple que: $$ T(u + v) = T(u) + T(v) $$ Homogeneidad: Para cualquier escalar \\(c\\) y cualquier vector \\(v\\) en \\(V\\) se cumple que: $$ T(c \\ v) = c \\ T(v) $$ Toda transformaci√≥n lineal entre espacios vectoriales de dimensi√≥n finita puede representarse mediante una matriz, por ejemplo:\nImaginemos una transformaci√≥n \\(T: \\mathbb{R}^2 \\rightarrow \\mathbb{R}^2\\) definida por:\n$$T(x,y) = (2x+y,3x-4y)$$En base can√≥nica:\n\\(T(1,0) = (2,3) \\rightarrow \\) primera columna \\(\\begin{pmatrix} 2 \\\\ 3 \\end{pmatrix}\\) \\(T(0,1) = (1,-4) \\rightarrow \\) segunda columna \\(\\begin{pmatrix} 1 \\\\ -4 \\end{pmatrix}\\) La matriz asociada a la transformaci√≥n \\(T\\) es:\n$$|\\mathbf{T}| = \\begin{pmatrix} 2 \u0026 1 \\\\ 3 \u0026 -4 \\end{pmatrix}$$ La base can√≥nica es un conjunto de vectores que forma una base ortonormal en un espacio vectorial. En el plano, la base can√≥nica est√° compuesta por los vectores \\(i\\) y \\(j\\), que representan las direcciones de los ejes \\(x\\) e \\(y\\), respectivamente. Estos vectores se utilizan para expresar otros vectores como combinaciones lineales de la base can√≥nica. Adem√°s, la base can√≥nica es fundamental para entender la dimensi√≥n y la estructura de los espacios vectoriales.\nVectores y valores propios # Los valores propios o autovalores y los vectores propios o autovectores revelan las direcciones \u0026ldquo;especiales\u0026rdquo; de una transformaci√≥n lineal.\nLos vectores propios o autovectores de una transformaci√≥n lineal son los vectores no nulos que, cuando son transformados, dan lugar a un m√∫ltiplo escalar de s√≠ mismos, con lo que no cambian su direcci√≥n. Este escalar \\(\\lambda\\) recibe el nombre de valor propio o autovalor. En muchos casos, una transformaci√≥n queda completamente determinada por sus vectores propios y valores propios. Un espacio propio o autoespacio asociado al valor propio \\(\\lambda\\) es el conjunto de vectores propios con un valor propio com√∫n.\nPara una transformaci√≥n lineal representada por la matriz \\(\\mathbf{A}\\), un vector \\(\\mathbf{v}\\) es un vector propio con valor propio \\(\\lambda\\) si:\n$$\\mathbf{A}\\mathbf{v} = \\lambda \\mathbf{v}$$Interpretaci√≥n: La transformaci√≥n \\(\\mathbf{A}\\) solo escala el vector \\(\\mathbf{v}\\) por el factor \\(\\lambda\\), sin cambiar su direcci√≥n.\nImagen de J. Finkelstein y Vb on Wikimedia Commons, dominio p√∫blico En esta transformaci√≥n de la Mona Lisa, la imagen se ha deformado de tal forma que su eje vertical no ha cambiado. El vector azul, representado por la flecha azul que va desde el pecho hasta el hombro, ha cambiado de direcci√≥n, mientras que el rojo, representado por la flecha roja, no ha cambiado. El vector rojo es entonces un vector propio o autovector de la transformaci√≥n, mientras que el azul no lo es. Dado que el vector rojo no ha cambiado de longitud, su valor propio o autovalor es \\(1\\). Todos los vectores de esta misma direcci√≥n son vectores propios, con el mismo valor propio. Forman un subespacio del espacio propio de este valor propio.\n‚Äî Vector, valor y espacio propios. Wikipedia\nAplicaciones en Machine Learning # PCA (An√°lisis de Componentes Principales): Los vectores propios de la matriz de covarianza muestran las direcciones de mayor varianza en los datos.\nReducci√≥n de dimensionalidad: Proyectar datos en los vectores propios principales.\nEstabilidad de sistemas: Los valores propios indican si un sistema din√°mico es estable.\nVisualizando valores y vectores propios # Crea un archivo Python con el siguiente contenido:\ndef ver_valores_propios(): \u0026#34;\u0026#34;\u0026#34; Visualiza conceptualmente los valores y los vectores propios. Esta es una simplificaci√≥n para matrices 2x2. \u0026#34;\u0026#34;\u0026#34; import matplotlib.pyplot as plt import numpy as np # Matriz de ejemplo A = np.array([[3, 1], [0, 2]]) # Calcular valores y vectores propios usando NumPy valores_propios, vectores_propios = np.linalg.eig(A) # Crear varios vectores para mostrar la transformaci√≥n angles = np.linspace(0, 2*np.pi, 16) vectores_originales = np.array([[np.cos(a), np.sin(a)] for a in angles]) vectores_transformados = np.array([A @ v for v in vectores_originales]) fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5)) # Vectores originales ax1.set_aspect(\u0026#39;equal\u0026#39;) for v in vectores_originales: ax1.arrow(0, 0, v[0], v[1], head_width=0.05, head_length=0.1, fc=\u0026#39;blue\u0026#39;, ec=\u0026#39;blue\u0026#39;, alpha=0.6) # Vectores propios originales for i, (val, vec) in enumerate(zip(valores_propios, vectores_propios.T)): ax1.arrow(0, 0, vec[0], vec[1], head_width=0.1, head_length=0.15, fc=\u0026#39;red\u0026#39;, ec=\u0026#39;red\u0026#39;, linewidth=3, label=f\u0026#39;Vector propio {i+1}\u0026#39;) ax1.set_xlim(-2, 2) ax1.set_ylim(-2, 2) ax1.set_title(\u0026#39;Vectores Originales\u0026#39;) ax1.grid(True) ax1.legend() # Vectores transformados ax2.set_aspect(\u0026#39;equal\u0026#39;) for v in vectores_transformados: ax2.arrow(0, 0, v[0], v[1], head_width=0.05, head_length=0.1, fc=\u0026#39;green\u0026#39;, ec=\u0026#39;green\u0026#39;, alpha=0.6) # Vectores propios transformados (escalados por valor propio) for i, (val, vec) in enumerate(zip(valores_propios, vectores_propios.T)): vectores_propios_transformados = val * vec ax2.arrow(0, 0, vectores_propios_transformados[0], vectores_propios_transformados[1], head_width=0.1, head_length=0.15, fc=\u0026#39;red\u0026#39;, ec=\u0026#39;red\u0026#39;, linewidth=3, label=f\u0026#39;Œª{i+1}={val:.1f} √ó eigenvec{i+1}\u0026#39;) ax2.set_xlim(-4, 4) ax2.set_ylim(-4, 4) ax2.set_title(\u0026#39;Vectores Transformados por A\u0026#39;) ax2.grid(True) ax2.legend() plt.tight_layout() plt.show() print(f\u0026#34;Valores propios: {valores_propios}\u0026#34;) print(f\u0026#34;Vectores propios:\\n{vectores_propios}\u0026#34;) ver_valores_propios() Lo ejecutamos\u0026hellip;\nvirtualenv venv source venv/bin/activate pip install numpy pip install matplotlib python valores_vectores_propios.py y obtenemos:\nVisualizando vectores propios con Python Implementaci√≥n pr√°ctica: un sistema de recomendaciones usando √°lgebra lineal # En el siguiente art√≠culo de este m√≥dulo, vamos a actualizar nuestro sistema de recomendaciones para utilizar los conceptos de √°lgebra lineal que aprendimos hasta ac√°.\n¬°Nos vemos all√≠! üöÄ\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"12 septiembre 2025","externalUrl":null,"permalink":"/ai/module2/algebra/","section":"Inteligencia Artificial","summary":"","title":"√Ålgebra Lineal para Machine Learning: vectores y matrices que todo ingeniero en IA debe conocer","type":"ai"},{"content":" Bienvenido al primer m√≥dulo para convertirte en un ingeniero en IA. Si llegaste hasta aqu√≠, es porque ya dominas Python y tienes experiencia como software engineer, pero el mundo de la inteligencia artificial te resulta un territorio desconocido. No te preocupes: est√°s exactamente donde necesitas estar.\nDurante los pr√≥ximos m√≥dulos, vamos a transformar tus habilidades de programaci√≥n en expertise en inteligencia artificial. No vamos a tomar atajos ni a usar \u0026ldquo;soluciones m√°gicas\u0026rdquo;, cada concepto ser√° explicado desde sus fundamentos hasta su implementaci√≥n pr√°ctica.\n¬øPor qu√© necesitas entender los fundamentos? # Como programador, probablemente has escuchado t√©rminos como \u0026ldquo;IA\u0026rdquo;, \u0026ldquo;Machine Learning\u0026rdquo; y \u0026ldquo;Deep Learning\u0026rdquo; lanzados como sin√≥nimos. Tal vez has visto demos impresionantes de ChatGPT o has le√≠do sobre coches aut√≥nomos. Pero hay una diferencia enorme entre usar una API y realmente entender c√≥mo funciona la tecnolog√≠a por debajo.\nUn ingeniero en IA no es solo alguien que conecta APIs de OpenAI. Es un profesional que:\nEntiende cu√°ndo y por qu√© usar cada t√©cnica de IA Puede diagnosticar y resolver problemas en sistemas de ML Dise√±a arquitecturas de datos y modelos desde cero Eval√∫a cr√≠ticamente el rendimiento y las limitaciones Implementa soluciones √©ticas y responsables Objetivos de este primer m√≥dulo # Al finalizar este m√≥dulo, vas a poder:\nDistinguir claramente entre IA, Machine Learning y Deep Learning Identificar qu√© tipo de problema requiere cada enfoque Implementar tu primer sistema inteligente usando l√≥gica de reglas Entender los fundamentos te√≥ricos que sustentan todas las t√©cnicas avanzadas Crear un sistema de recomendaciones b√°sico desde cero No vamos a usar bibliotecas complejas como TensorFlow o PyTorch todav√≠a. Vamos a construir todo con Python puro para que entiendas realmente qu√© est√° pasando.\nTeor√≠a fundamental: desenmascarando la IA # IA, Machine Learning y Deep Learning: aclarando la confusi√≥n # Empecemos destruyendo algunos mitos. Estos tres t√©rminos no son sin√≥nimos, aunque a menudo se usan como si lo fueran.\nInteligencia Artificial (IA): el concepto m√°s amplio # La Inteligencia Artificial es cualquier t√©cnica que permite a las m√°quinas imitar el comportamiento inteligente humano. Esto incluye desde un simple sistema de reglas hasta las redes neuronales m√°s complejas.\nImagina que est√°s construyendo un sistema para diagnosticar enfermedades. Si escribes:\ndef diagnosticar_gripe(temperatura: float, dolor_cabeza: bool, fatiga: bool): if temperatura \u0026gt; 38.0 and dolor_cabeza and fatiga: return \u0026#34;Posible gripe\u0026#34; return \u0026#34;S√≠ntomas insuficientes\u0026#34; ¬°Felicitaciones! Acabas de crear un sistema de IA. Es simple, pero es IA porque simula el proceso de razonamiento de un m√©dico.\nMachine Learning: IA que aprende de los datos # Machine Learning es un subconjunto de la IA donde el sistema aprende patrones de los datos en lugar de seguir reglas programadas expl√≠citamente.\nEn lugar de escribir reglas manualmente, le damos al sistema ejemplos:\nPaciente A: temperatura=38.5¬∞, dolor=s√≠, fatiga=s√≠ ‚Üí Gripe Paciente B: temperatura=36.8¬∞, dolor=no, fatiga=no ‚Üí No gripe [\u0026hellip; m√°s ejemplos \u0026hellip;] El sistema aprende autom√°ticamente a identificar los patrones que distinguen gripe de no-gripe.\nDeep Learning: Machine Learning con redes neuronales profundas # Deep Learning es un subconjunto de Machine Learning que usa redes neuronales con m√∫ltiples capas (de ah√≠ \u0026ldquo;profundo\u0026rdquo;). Es especialmente poderoso para datos complejos como im√°genes, texto y audio.\nUna historia muy breve (pero necesaria) de la IA # Conocer y comprender la historia te ayuda a ver y entender el estado actual del desarrollo de la IA y su futuro.\nLos pioneros 1950s - 1960s Alan Turing propone el Test de Turing (1950) John McCarthy acu√±a el t√©rmino Artificial Intelligence (1956) Primeros programas que juegan ajedrez y demuestran teoremas El primer invierno de la IA 1970s - 1980s Las expectativas eran demasiado altas. Los computadores eran lentos y la memoria limitada. La financiaci√≥n se redujo dr√°sticamente. El renacimiento con Machine Learning 1990s - 2000s Mejores algoritmos (Support Vector Machines, Random Forest) M√°s datos disponibles con internet Computadoras m√°s poderosas La explosi√≥n del Deep Learning 2010s - Presente GPUs permiten entrenar redes neuronales gigantes Big Data proporciona millones de ejemplos de entrenamiento Nuevos Avances como ImageNet (2012) y GPT (2018) Tipos de aprendizaje autom√°tico # Como programador, necesitas entender cu√°ndo usar cada enfoque. No existe una soluci√≥n √∫nica para todos los problemas.\nAprendizaje Supervisado # Tienes ejemplos de entrada y salida conocida. El algoritmo aprende a mapear entradas a salidas correctas. Se utiliza cuando tienes datos hist√≥ricos con respuestas correctas. Algunos ejemplos comunes de uso:\nClasificaci√≥n de emails (spam/no spam) Predicci√≥n de precios de viviendas Diagn√≥stico m√©dico Reconocimiento de objetos en im√°genes La matem√°tica b√°sica: Buscamos una funci√≥n \\(f\\) tal que \\(f(x) \\approx y\\), donde:\n\\(x\\) = datos de entrada (features) \\(y\\) = resultado conocido (label/target) Aprendizaje No Supervisado # En este caso, solo tienes datos de entrada, sin respuestas correctas. El algoritmo busca patrones ocultos. Se usa cuando quieres explorar datos o encontrar estructura desconocida. Algunos ejemplos comunes:\nSegmentaci√≥n de clientes Detecci√≥n de anomal√≠as Compresi√≥n de datos Sistemas de recomendaci√≥n Aprendizaje por Refuerzo # Aqu√≠, el algoritmo aprende mediante prueba y error, recibiendo recompensas o castigos por sus acciones. Se utiliza en problemas secuenciales donde las decisiones afectan el futuro. Por ejemplo:\nJuegos (ajedrez, Go, videojuegos) Trading algor√≠tmico Robots aut√≥nomos Optimizaci√≥n de rutas Implementaci√≥n pr√°ctica: tus primeros sistemas inteligentes # En los siguientes art√≠culos de este m√≥dulo, veremos algunos ejemplos para que te vayas adentrando en el mundo de la inteligencia artificial y el aprendizaje autom√°tico.\n¬°Nos vemos all√≠! üöÄ\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"22 agosto 2025","externalUrl":null,"permalink":"/ai/module1/intro/","section":"Inteligencia Artificial","summary":"","title":"Introducci√≥n","type":"ai"},{"content":"Las estructuras de datos son formas de organizar y almacenar informaci√≥n en un programa de computadora para que pueda ser accedida y modificada de manera eficiente. Como programadores, es esencial entender las distintas estructuras de datos disponibles y saber cu√°ndo aplicar cada una para optimizar el rendimiento y la utilidad de nuestros programas.\nUna estructura de datos es una forma particular de organizar datos en la memoria de la computadora para que puedan ser usados de manera eficiente. Las estructuras de datos vienen en muchas formas, como arrays, listas, pilas, colas, grafos, √°rboles, hashes, etc.\nCada estructura organiza los datos de acuerdo a un modelo l√≥gico espec√≠fico y soporta operaciones eficientes para acceder, modificar, agregar y borrar elementos seg√∫n ese modelo. Por ejemplo, un array organiza los elementos de manera secuencial en memoria para facilitar el acceso aleatorio por √≠ndices. Una lista enlazada conecta elementos en memoria usando \u0026ldquo;nodos\u0026rdquo; con referencias al siguiente nodo para facilitar la inserci√≥n y eliminaci√≥n.\nAl elegir la estructura de datos apropiada para la tarea a resolver, podemos escribir programas m√°s eficientes y reducir la complejidad computacional, utilizando menos recursos como memoria y procesamiento.\nLas estructuras de datos nos ayudan a:\nOrganizar grandes cantidades de datos para que sean m√°s f√°ciles de acceder y modificar.\nModelar relaciones complejas entre datos, como con grafos y √°rboles.\nAcceder y modificar datos de manera eficiente, optimizando el rendimiento.\nReutilizar c√≥digo y estructuras de datos existentes en lugar de tener que reescribir soluciones desde cero.\nPor ejemplo, un programa que debe almacenar miles de registros de usuarios se beneficia usando una estructura de datos hash para asociar cada usuario a datos como nombre, apellido, email, etc. De esta manera se pueden encontrar usuarios espec√≠ficos muy r√°pido sin tener que iterar sobre toda la colecci√≥n.\nOtro ejemplo son los √°rboles de b√∫squeda binaria, que permiten encontrar elementos muy r√°pido en conjuntos ordenados de millones de elementos. Esto se logra descartando mitades del √°rbol a medida que se busca el elemento deseado.\nTipos de estructuras de datos # Existen muchos tipos de estructuras de datos. A continuaci√≥n, se presentan algunas categor√≠as √∫tiles para clasificarlas.\nSeg√∫n relaci√≥n entre elementos # Lineales: Los elementos se organizan secuencialmente uno despu√©s del otro. Por ejemplo, arrays, listas, pilas, colas.\nNo lineales: Los elementos se organizan en una jerarqu√≠a o grafo. Este es el caso de los √°rboles y grafos.\nSeg√∫n tipo de elementos # Homog√©neas: Almacenan un solo tipo de datos. Por ejemplo, arrays en un lenguaje como Java.\nHeterog√©neas: Permiten diferentes tipos de datos. Objetos, registros son ejemplos de esta clasificaci√≥n.\nSeg√∫n modo de acceso # Acceso secuencial: S√≥lo se puede acceder a los elementos en orden secuencial. Por ejemplo, listas enlazadas.\nAcceso directo: Se puede acceder a cualquier elemento directamente por su posici√≥n. En este grupo se encuentran los arrays.\nAcceso asociativo: Se accede a elementos por una clave asociada. Aqu√≠ se encuentran los diccionarios, hashes.\nSeg√∫n su funcionalidad # Arrays: Acceso r√°pido a elementos por √≠ndice pero dif√≠cil insertar/eliminar.\nListas: F√°cil insertar/eliminar en cualquier posici√≥n pero acceso secuencial lento.\nPilas: Acceso LIFO (√∫ltimo en entrar, primero en salir). √ötil para deshacer/rehacer.\nColas: Acceso FIFO (primero en entrar, primero en salir). √ötil para procesamiento de eventos.\n√Årboles: Permiten modelar relaciones jer√°rquicas como con directorios de archivos o dependencias de tareas.\nGrafos: Permiten modelar redes de interconexi√≥n como mapas, relaciones sociales, etc.\nHashes / Diccionarios: Asocian elementos con claves √∫nicas para acceso ultra r√°pido.\nEsta clasificaci√≥n no es exhaustiva pero da una idea de la diversidad de estructuras de datos y sus diferentes propiedades que nos permiten modelar problemas complejos de manera eficiente.\nEjemplo # Veamos un ejemplo en Python para ver c√≥mo se crea y utiliza una estructura de datos. Supongamos que queremos representar una cola de impresi√≥n donde las impresiones se procesan en orden de llegada (FIFO).\nPrimero, definimos una clase PrintQueue para representar nuestra cola:\nclass PrintQueue: def __init__(self): self.items = [] def enqueue(self, item): self.items.append(item) def dequeue(self): return self.items.pop(0) def is_empty(self): return len(self.items) == 0 Luego la utilizamos para agregar impresiones y procesarlas en orden:\nprint_queue = PrintQueue() print_queue.enqueue(\u0026#34;documento1.doc\u0026#34;) print_queue.enqueue(\u0026#34;imagen3.jpg\u0026#34;) print_queue.enqueue(\u0026#34;presentacion.ppt\u0026#34;) while not print_queue.is_empty(): next_item = print_queue.dequeue() print(f\u0026#34;Imprimiendo {next_item}\u0026#34;) Esto imprimir√°:\nImprimiendo documento1.doc Imprimiendo imagen3.jpg Imprimiendo presentacion.ppt Con una estructura de datos como la cola implementamos la l√≥gica FIFO de una forma sencilla y reutilizable. ¬°Y esto es s√≥lo una muestra, las posibilidades son infinitas!\nConclusi√≥n # Las estructuras de datos son herramientas fundamentales en programaci√≥n que nos permiten organizar informaci√≥n de forma √≥ptima para resolver problemas complejos. Conocer los distintos tipos de estructuras disponibles, como arrays, listas, pilas, colas, hashes, grafos y √°rboles, nos permite construir programas m√°s eficientes. ¬°Espero que esta introducci√≥n te haya dado algunos conocimientos y herramientas para comenzar a dominar este apasionante tema!\n","date":"04 agosto 2025","externalUrl":null,"permalink":"/programming/data-structures/introduction/","section":"Programaci√≥n","summary":"","title":"Introducci√≥n","type":"programming"},{"content":"La Programaci√≥n Orientada a Objetos (POO) es un paradigma de programaci√≥n que se ha vuelto indispensable en la actualidad. Este enfoque modela elementos del mundo real como \u0026ldquo;objetos\u0026rdquo; que tienen propiedades y comportamientos, lo cual permite crear programas m√°s intuitivos y f√°ciles de mantener. En este art√≠culo veremos los conceptos b√°sicos de POO y sus ventajas frente a otros paradigmas como la programaci√≥n procedural. ¬°Empecemos!\nEste paradigma se basa en dos conceptos fundamentales:\nObjetos: entidades que combinan estado (datos) y comportamiento (operaciones) en una misma unidad. Por ejemplo, un objeto \u0026ldquo;coche\u0026rdquo; tendr√≠a propiedades como color, n√∫mero de puertas, velocidad m√°xima, etc. Y comportamientos como acelerar, frenar, girar, etc. Clases: especificaciones que definen la estructura y comportamiento com√∫n de un grupo de objetos. La clase \u0026ldquo;coche\u0026rdquo; servir√≠a como molde para crear objetos coche con las mismas caracter√≠sticas. Como explica el programador Alan Kay, uno de los creadores de la POO:\n\u0026ldquo;La idea central de POO es que los usuarios deben manipular objetos conceptuales m√°s que m√°quinas de Turing. Las interfaces con el mundo real deben, por lo tanto, ser construidas en t√©rminos de objetos conceptuales.\u0026rdquo;\nEs decir, la POO modela conceptualmente elementos del mundo real para hacer la programaci√≥n m√°s intuitiva.\nParadigmas de programaci√≥n # Antes de profundizar en la POO, conviene entender que existen diferentes paradigmas o enfoques para abordar la programaci√≥n. Los principales son:\nProgramaci√≥n procedural # Secuencia ordenada de instrucciones que el programa debe seguir paso a paso. El foco est√° en procedimientos y funciones. Por ejemplo, C es un lenguaje orientado a la programaci√≥n procedural.\nLa programaci√≥n procedural es mejor para:\nProblemas sencillos o algoritmos secuenciales. C√≥digo que no necesitar√° reusarse ni expandirse mucho. Casos donde el rendimiento y eficiencia son cr√≠ticos. Programaci√≥n orientada a objetos # Modelo basado en objetos que contienen datos y c√≥digo en unidades cohesivas. El foco est√° en las clases y en la interacci√≥n entre objetos. Por ejemplo, Java y Python son lenguajes orientados a objetos.\nLa POO permite modelar de forma m√°s directa elementos del mundo real, encapsular mejor los datos y reutilizar c√≥digo a trav√©s de la herencia entre clases.\nLas principales ventajas de POO frente a la programaci√≥n procedural son:\nModularidad: los objetos agrupan datos y operaciones relacionadas, encapsulando la complejidad interna. Esto permite trabajar con m√≥dulos independientes. Ocultaci√≥n de informaci√≥n: Los objetos pueden exponer una interfaz simple y ocultar detalles de implementaci√≥n internos. Esto reduce acoplamientos. Reusabilidad: Las clases permiten reuse de c√≥digo. Una clase abstracta puede heredar a m√∫ltiples subclases. Extensibilidad: Podemos extender el comportamiento de clases padres creando nuevas subclases. Mapeo conceptual: Los objetos representan entidades del mundo real, lo cual facilita la traducci√≥n de requerimientos a c√≥digo. Sin embargo, la POO tambi√©n tiene desventajas. Seg√∫n el programador Paul Graham:\n\u0026ldquo;La programaci√≥n orientada a objetos suele ser una molestia. Hace que las cosas sean m√°s dif√≠ciles de lo que deber√≠an ser.\u0026rdquo;\nPor ejemplo, para problemas simples la POO puede resultar excesiva. Y en proyectos grandes existe el riesgo de abusar de la herencia y el polimorfismo, volviendo el c√≥digo dif√≠cil de seguir.\nEn definitiva, la POO es m√°s adecuada cuando:\nEl problema a modelar tiene entidades claras y estructuradas. Queremos reutilizar c√≥digo encapsulado en clases modulares. Trabajamos en sistemas que deben extenderse y mantenerse con facilidad. ","date":"04 agosto 2025","externalUrl":null,"permalink":"/programming/oop/introduction/","section":"Programaci√≥n","summary":"","title":"Introducci√≥n","type":"programming"},{"content":"La programaci√≥n, en su esencia, es el acto de instruir a una m√°quina sobre c√≥mo realizar una tarea espec√≠fica. Es como si le estuvieras ense√±ando a tu perro a buscar la pelota, pero en este caso, el perro es tu computadora y la pelota es, por ejemplo, sumar dos valores.\nAhora, es posible que pienses que programar es simplemente escribir l√≠neas de c√≥digo. En realidad, la programaci√≥n es un proceso m√°s amplio que incluye no solo escribir c√≥digo, sino tambi√©n resolver problemas, dise√±ar sistemas y pensar l√≥gicamente.\nEn el universo de la programaci√≥n, hay lenguajes de alto nivel y lenguajes de bajo nivel. Un lenguaje de bajo nivel, como el ensamblador, est√° m√°s cerca de lo que la m√°quina entiende, mientras que un lenguaje de alto nivel, como Python o JavaScript, es m√°s amigable para nosotros, los humanos. Los lenguajes de bajo nivel permiten una manipulaci√≥n casi directa del hardware con instrucciones especificas para determinadas operaciones, como encender un determinado pixel de la pantalla. Mientras que los lenguajes de alto nivel permiten operaciones complejas en lenguaje casi natural, como por ejemplo mostrar una imagen en pantalla.\nAdem√°s, algunos lenguajes de programaci√≥n son compilados y otros son interpretados. Si un lenguaje es compilado, significa que se traduce a un lenguaje que la m√°quina entiende antes de ser ejecutado. Por otro lado, los lenguajes interpretados son traducidos en tiempo real, mientras se ejecutan.\nBreve historia de la programaci√≥n # La programaci√≥n no es un concepto nuevo. De hecho, ha estado con nosotros desde mucho antes de que las computadoras existieran en la forma que las conocemos hoy. Dispositivos como el √°baco y el astrolabio son ejemplos tempranos de herramientas que usamos para realizar c√°lculos complejos.\nPero fue con la llegada de las m√°quinas mec√°nicas, como la M√°quina Anal√≠tica de Charles Babbage, que se sentaron las bases para la programaci√≥n moderna. ¬°Estamos hablando del siglo XIX!\nCon el paso del tiempo, nacieron lenguajes que marcaron hitos, como Fortran y COBOL. Estos lenguajes sentaron las bases para las revoluciones tecnol√≥gicas que vendr√≠an. Con la evoluci√≥n de los lenguajes, tambi√©n surgieron nuevos paradigmas: primero el Procedural, luego el Orientado a Objetos y m√°s recientemente, el Funcional.\nHoy, estamos en una era moderna, dominada por la programaci√≥n para la web, m√≥viles y la nube. Cada vez que deslizas tu dedo por la pantalla de tu celular o compras algo online, hay l√≠neas y l√≠neas de c√≥digo trabajando detr√°s de escena.\nLa programaci√≥n hoy # La programaci√≥n es el motor de nuestra sociedad moderna. Desde aplicaciones para pedir comida hasta sistemas avanzados de inteligencia artificial que ayudan en investigaciones m√©dicas, la programaci√≥n est√° en todas partes.\nAdem√°s de simplificar nuestras vidas cotidianas, la programaci√≥n tiene un impacto profundo en la sociedad. Ha permitido avances en la automatizaci√≥n, el an√°lisis de datos y el entretenimiento. Y lo que es a√∫n m√°s emocionante, es que apenas estamos rasgu√±ando la superficie. Con los avances en inteligencia artificial, computaci√≥n cu√°ntica y el Internet de las Cosas (IoT), ¬øqui√©n sabe qu√© maravillas nos esperan en mundo de la programaci√≥n?\n","date":"03 agosto 2025","externalUrl":null,"permalink":"/programming/intro/introduction/","section":"Programaci√≥n","summary":"","title":"Introducci√≥n","type":"programming"},{"content":" Variables # Una variable es un contenedor para almacenar datos en la memoria de la computadora. Podemos pensar en ella como una caja con una etiqueta. La etiqueta es el nombre de la variable y dentro de la caja se almacena su valor.\nPara declarar una variable en Python solo escribimos el nombre y le asignamos un valor:\nedad = 28 precio = 19.95 soltero = True Los nombres de variables deben comenzar con letras o gui√≥n bajo, y s√≥lo pueden contener letras, n√∫meros y guiones bajos. Se recomienda usar nombres significativos que representen el prop√≥sito de la variable.\nEn Python las variables no necesitan ser declaradas con un tipo particular. El tipo se infiere autom√°ticamente al asignar el valor:\nedad = 28 # edad es de tipo entero (int) precio = 19.95 # precio es de tipo float estudiante = True # soltero es de tipo booleano Una vez asignada, una variable puede cambiar su valor en cualquier momento:\nedad = 30 # Cambiamos edad a 30 Alcance y tiempo de vida # El alcance de una variable se refiere a las partes del c√≥digo donde est√° disponible. Las variables declaradas fuera de funciones son globales y est√°n disponibles en todo el archivo. Las variables dentro de una funci√≥n son locales y solo visibles dentro de ella.\nEl tiempo de vida es el per√≠odo durante el cual existe la variable en memoria. Las variables locales existen mientras se ejecuta la funci√≥n, luego son destruidas. Las globales existen mientras el programa est√° en ejecuci√≥n.\nAsignaci√≥n # La asignaci√≥n con el operador = permite cambiar o inicializar el valor de una variable:\nnumero = 10 numero = 20 # Ahora numero vale 20 Tambi√©n existen los operadores de asignaci√≥n compuesta como += y -= que combinan una operaci√≥n y asignaci√≥n:\nnumero += 5 # Suma 5 a numero (numero = numero + 5) numero -= 2 # Resta 2 a numero Tipos de datos # Los tipos de datos definen el tipo de valor que puede almacenar una variable. Python tiene varios tipos incorporados, incluyendo:\nNum√©ricos: Para almacenar valores num√©ricos como enteros, flotantes, complejos:\nentero = 10 flotante = 10.5 complejo = 3 + 4j Cadenas: Para almacenar texto:\ntexto = \u0026#34;Hola Mundo\u0026#34; Booleano: Para valores l√≥gicos Verdadero o Falso:\nvariable_verdadera = True variable_falsa = False Colecciones: Para almacenar m√∫ltiples valores como listas, tuplas y diccionarios:\nListas: Secuencias mutables de valores:\nlista = [1, 2, 3] Tuplas: Secuencias inmutables de valores:\ntupla = (1, 2, 3) Diccionarios: Estructuras de pares llave-valor:\ndiccionario = {\u0026#34;nombre\u0026#34;:\u0026#34;Juan\u0026#34;, \u0026#34;edad\u0026#34;: 20} Es importante elegir el tipo de dato que mejor represente la informaci√≥n que queremos almacenar.\nOperadores # Los operadores nos permiten realizar operaciones con valores y variables en Python. Algunos operadores comunes son:\nAritm√©ticos: +, -, *, /, %, //, **\nComparaci√≥n: ==, !=, \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;=\nL√≥gicos: and, or, not\nAsignaci√≥n: =, +=, -=, *=, /=\nVeamos ejemplos concretos de expresiones usando estos operadores en Python:\n# Aritm√©ticos 5 + 4 # Suma, resultado 9 10 - 3 # Resta, resultado 7 4 * 5 # Multiplicaci√≥n, resultado 20 # Comparaci√≥n 5 \u0026gt; 4 # Mayor que, resultado Verdadero 7 \u0026lt; 10 # Menor que, resultado Verdadero # L√≥gicos True and False # Resultado False True or False # Resultado True not True # Resultado False # Asignaci√≥n numero = 10 numero += 5 # Suma 5 a numero, equivalente a numero = numero + 5 Cada tipo de operador trabaja con tipos de datos espec√≠ficos. Debemos usarlos de forma consistente seg√∫n el tipo de datos de nuestras variables.\nConversiones de tipo # A veces necesitamos convertir un tipo de dato a otro para realizar ciertas operaciones. En Python podemos convertir de forma expl√≠cita o impl√≠cita:\nExpl√≠cita: Usando funciones como int(), float(), str():\nflotante = 13.5 entero = int(flotante) # convierte 13.5 a 13 texto = \u0026#34;100\u0026#34; numero = int(texto) # convierte \u0026#34;100\u0026#34; a 100 Impl√≠cita: Python convierte autom√°ticamente en algunos casos:\nentero = 100 flotante = 3.5 resultado = entero + flotante # resultado es 103.5, entero se convirti√≥ a float Algunas conversiones pueden generar p√©rdida de datos o errores:\nflotante = 13.5 entero = int(flotante) print(entero) # 13, se pierden los decimales Para prevenir esto debemos elegir expl√≠citamente conversiones que tengan sentido para nuestros datos.\nConclusi√≥n # En este art√≠culo revisamos conceptos clave como variables, operadores, tipos de datos y conversiones en Python. Aplicar bien estos conceptos te permitir√° manipular datos de forma eficiente en tus programas. Recomiendo practicar con ejemplos propios para ganar experiencia en usar estas caracter√≠sticas. ¬°√âxitos en tu aprendizaje de Python!\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"18 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/variables-data-types/","section":"Programaci√≥n","summary":"","title":"Variables y Tipos de Datos","type":"programming"},{"content":" What is Software? # Several thought leaders in the world of computing have defined software in various ways:\nIan Sommerville1: Computer programs and associated documentation.\nRoger S. Pressman2: A collection of computer programs, procedures, rules, and associated documentation and data.\nAndrew S. Tanenbaum3: A series of instructions that tells a computer what to do.\nGrady Booch4: Set of items or objects that form a configuration that includes programs, documents, and data.\nPeter Denning5: Map of a machine, detailing its possible states, transitions, and the actions for these transitions.\nAnalysing these definitions, common themes emerge: software encompasses instructions, data, associated documentation, and serves as a guiding structure for computer operations. So we can conclude:\nSoftware is a meticulously structured collection of programs, data, and documentation that serves as a guiding blueprint, directing a computer\u0026rsquo;s operations and interactions with users and other systems.\nAlthough we can classify software in many different types, each with its specific function, we can define three primary categories:\nSystem Software: This forms the core of a computer\u0026rsquo;s operation. It includes operating systems like Windows, Linux, and macOS, which manage hardware resources and provide services for application software. Application Software: Tailored for end-users to perform specific tasks, this category ranges from word processors (like Microsoft Word) to graphic design tools (like Adobe Photoshop) and games. Embedded Software: Found within hardware devices such as washing machines, traffic lights, or digital watches, embedded software operates specific functions of these devices. Unlike general-purpose software, it\u0026rsquo;s dedicated to specific tasks or functions. What is Software Engineering? # Several prominent figures have also provided their perspectives on Software Engineering:\nIan Sommerville1: A discipline concerned with all aspects of software production.\nRoger S. Pressman2: Establishment and use of sound engineering principles to obtain economically software that is reliable and works efficiently on real machines.\nFrederick P. Brooks6: The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software.\nBarry W. Boehm7: Aims to produce quality software, software that is delivered on time, within budget, and that satisfies its requirements.\nFritz Bauer8: The establishment and use of sound engineering principles to economically obtain software that is reliable and works on real machines.\nFrom these definitions, we can discern that software engineering integrates principles of engineering, emphasizes systematic methods, seeks reliability and efficiency, and aims for the production of high-quality software that meets its specified requirements. Concluding that\nSoftware Engineering is the disciplined application of engineering principles and systematic methods to design, develop, and maintain reliable and efficient software that economically meets specified requirements and user needs.\nSoftware Engineering should not be confused with Computer Science. While the latter is a discipline that dives deep into the theoretical and mathematical aspects of computing, studying algorithms, computational theory, and more, the first one primarily focuses on designing and building large software systems. It emphasizes practical techniques and methodologies that ensure the production of high-quality, maintainable software.\nWhy it is important to develop quality software # Today, we\u0026rsquo;re surrounded by a digital ecosystem. Software runs our phones, cars, banks, hospitals, and even our homes. This ubiquity underscores its significance. That means that software flaws can have catastrophic outcomes. From banking systems to healthcare applications, the demand for faultless, efficient software is sky-high.\nSoftware Engineering, ensures this vast amount of software is reliable, efficient, and meets user needs. As technology advances at breakneck speed, the role of software engineers becomes even more pivotal, making sure innovations are safe and effective.\nWhether you\u0026rsquo;re using a social media app, making a bank transaction, or checking health diagnostics, remember there\u0026rsquo;s a meticulously engineered software system running behind the scenes, making it all possible.\nReferences # Sommerville, I., 2010. Software Engineering. 9th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPressman, R.S., 2010. Software Engineering: A Practitioner\u0026rsquo;s Approach. 7th ed. McGraw-Hill.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A.S., 2012. Structured Computer Organization. 6th ed. Pearson.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBooch, G., 2007. Object-Oriented Analysis and Design with Applications. 3rd ed. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDenning, P.J., 2009. The Profession of IT, Beyond Computational Thinking. Communications of the ACM, 52(6).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBrooks, F.P., 1995. The Mythical Man-Month: Essays on Software Engineering. Addison-Wesley.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBoehm, B.W., 1988. A Spiral Model of Software Development and Enhancement. Computer, 21(5).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBauer, F.L., 1972. Software Engineering. Information Processing, 71.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"10 agosto 2023","externalUrl":null,"permalink":"/en/software-engineering/introduction/","section":"Software Engineering","summary":"","title":"Introduction to Software Engineering","type":"software-engineering"},{"content":"","externalUrl":null,"permalink":"/ai/module1/","section":"Inteligencia Artificial","summary":"","title":"Fundamentos de Inteligencia Artificial para Programadores","type":"ai"},{"content":"","externalUrl":null,"permalink":"/programming/intro/","section":"Programaci√≥n","summary":"","title":"Introducci√≥n a la Programaci√≥n","type":"programming"},{"content":" Para consolidar los conceptos aprendidos, implementaremos un sistema de recomendaciones completo usando solo √°lgebra lineal. Este proyecto demuestra c√≥mo el √°lgebra lineal es fundamental en sistemas de machine learning reales. Objetivo del proyecto # Crear un sistema de recomendaciones que:\nRepresente usuarios y productos como vectores Calcule similitudes entre usuarios usando productos punto Haga recomendaciones de pel√≠culas no vistas basadas en usuarios similares Datos disponibles # Para el desarrollo del sistema tenemos preparados un conjunto de datos que pod√©s usar para verificar el funcionamiento de tu c√≥digo.\nUsuarios: datos/usuarios.json\nNombre del usuario Productos: datos/peliculas.json\nNombre de la pel√≠cula G√©nero de la pel√≠cula Interacciones: datos/interacciones.json\nID de la interacci√≥n ID del usuario ID de la pel√≠cula Valoraci√≥n: puntuaci√≥n de 1-5 estrellas Implementaci√≥n Completa # Haciendo click en el siguiente enlace, puedes encontrar una posible implementaci√≥n que cumple con los objetivos planteados. Incluye explicaciones detalladas.\n¬°Intent√° resolverlo por tu cuenta primero! üòÄüòÄüòÄ Al ejecutar el sistema obtenemos:\n\u0026gt; python main.py =========================================== === Prueba del Sistema de Recomendaci√≥n === =========================================== Inicializando el sistema * 13 peliculas cargadas * 6 usuarios cargados * 45 interacciones cargadas Procesando interacciones... Vectores de usuarios actualizados Matriz de puntuaciones construida: (6, 13) Calculando similitudes entre 6 usuarios Matriz de similitud entre usuarios construida: (6, 6) Sistema de recomendaciones inicializado correctamente **************************** Reporte completo del sistema **************************** Informaci√≥n del conjunto de datos: * Usuarios: 6 * Pel√≠culas: 13 * Interacciones totales: 45 * Calificaciones dadas: 45 de 78 * Sparsity (densidad): 42.3% An√°lisis de los usuario * Ana L√≥pez (ID: usuario_001): - Pel√≠culas vistas: 6 - Puntuaci√≥n promedio: 3.50 * Carlos Mendez (ID: usuario_002): - Pel√≠culas vistas: 7 - Puntuaci√≥n promedio: 3.57 * Mar√≠a Rodriguez (ID: usuario_003): - Pel√≠culas vistas: 8 - Puntuaci√≥n promedio: 3.00 * Diego Silva (ID: usuario_004): - Pel√≠culas vistas: 8 - Puntuaci√≥n promedio: 2.88 * Laura Mart√≠nez (ID: usuario_005): - Pel√≠culas vistas: 7 - Puntuaci√≥n promedio: 3.71 * Roberto Garc√≠a (ID: usuario_006): - Pel√≠culas vistas: 9 - Puntuaci√≥n promedio: 2.33 Matriz de puntuaciones (6, 13): +--------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+ | | Duro d | Termin | Matrix | El exo | Pesadi | El res | Mi pob | Forres | ¬øQu√© p | La m√°s | Eso | Hallow | El ori | +--------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+ | Ana L√≥ | 5.0 | 4.0 | 0.0 | 2.0 | 1.0 | 0.0 | 4.0 | 5.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | | Carlos | 4.0 | 5.0 | 4.0 | 3.0 | 2.0 | 0.0 | 3.0 | 4.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | | Mar√≠a | 1.0 | 2.0 | 0.0 | 5.0 | 4.0 | 5.0 | 2.0 | 1.0 | 4.0 | 0.0 | 0.0 | 0.0 | 0.0 | | Diego | 2.0 | 1.0 | 2.0 | 1.0 | 0.0 | 3.0 | 5.0 | 4.0 | 5.0 | 0.0 | 0.0 | 0.0 | 0.0 | | Laura | 4.0 | 3.0 | 0.0 | 4.0 | 4.0 | 0.0 | 3.0 | 3.0 | 5.0 | 0.0 | 0.0 | 0.0 | 0.0 | | Robert | 2.0 | 5.0 | 1.0 | 3.0 | 4.0 | 1.0 | 2.0 | 2.0 | 1.0 | 0.0 | 0.0 | 0.0 | 0.0 | +--------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------+ Matriz de similitud entre usuarios (6, 6): +-----------------+-----------+---------------+-----------------+-------------+----------------+----------------+ | | Ana L√≥pez | Carlos Mendez | Mar√≠a Rodriguez | Diego Silva | Laura Mart√≠nez | Roberto Garc√≠a | +-----------------+-----------+---------------+-----------------+-------------+----------------+----------------+ | Ana L√≥pez | 1.000 | 0.880 | 0.447 | 0.651 | 0.761 | 0.771 | | Carlos Mendez | 0.880 | 1.000 | 0.503 | 0.612 | 0.739 | 0.865 | | Mar√≠a Rodriguez | 0.447 | 0.503 | 1.000 | 0.656 | 0.782 | 0.750 | | Diego Silva | 0.651 | 0.612 | 0.656 | 1.000 | 0.727 | 0.538 | | Laura Mart√≠nez | 0.761 | 0.739 | 0.782 | 0.727 | 1.000 | 0.843 | | Roberto Garc√≠a | 0.771 | 0.865 | 0.750 | 0.538 | 0.843 | 1.000 | +-----------------+-----------+---------------+-----------------+-------------+----------------+----------------+ *************************************** Hacer recomendaciones para los usuarios *************************************** Recomendaciones para Ana L√≥pez: Pel√≠culas ya vistas: 6/13 Predicci√≥n para usuario_001 - \u0026#39;Matrix\u0026#39;: 2.43 - Basada en 3 usuarios similares Predicci√≥n para usuario_001 - \u0026#39;El resplandor\u0026#39;: 2.65 - Basada en 3 usuarios similares Predicci√≥n para usuario_001 - \u0026#39;¬øQu√© pas√≥ ayer?\u0026#39;: 3.66 - Basada en 4 usuarios similares No hay usuarios similares que hayan visto \u0026#39;La m√°scara\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Eso\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Halloween\u0026#39; No hay usuarios similares que hayan visto \u0026#39;El origen\u0026#39; 3 recomendaciones generadas 1- ¬øQu√© pas√≥ ayer? - Predicci√≥n de puntuaci√≥n 3.66 2- El resplandor - Predicci√≥n de puntuaci√≥n 2.65 3- Matrix - Predicci√≥n de puntuaci√≥n 2.43 Recomendaciones para Carlos Mendez: Pel√≠culas ya vistas: 7/13 Predicci√≥n para usuario_002 - \u0026#39;El resplandor\u0026#39;: 2.63 - Basada en 3 usuarios similares Predicci√≥n para usuario_002 - \u0026#39;¬øQu√© pas√≥ ayer?\u0026#39;: 3.54 - Basada en 4 usuarios similares No hay usuarios similares que hayan visto \u0026#39;La m√°scara\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Eso\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Halloween\u0026#39; No hay usuarios similares que hayan visto \u0026#39;El origen\u0026#39; 2 recomendaciones generadas 1- ¬øQu√© pas√≥ ayer? - Predicci√≥n de puntuaci√≥n 3.54 2- El resplandor - Predicci√≥n de puntuaci√≥n 2.63 Recomendaciones para Mar√≠a Rodriguez: Pel√≠culas ya vistas: 8/13 Predicci√≥n para usuario_003 - \u0026#39;Matrix\u0026#39;: 2.13 - Basada en 3 usuarios similares No hay usuarios similares que hayan visto \u0026#39;La m√°scara\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Eso\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Halloween\u0026#39; No hay usuarios similares que hayan visto \u0026#39;El origen\u0026#39; 1 recomendaciones generadas 1- Matrix - Predicci√≥n de puntuaci√≥n 2.13 Recomendaciones para Diego Silva: Pel√≠culas ya vistas: 8/13 Predicci√≥n para usuario_004 - \u0026#39;Pesadilla en la calle Elm\u0026#39;: 3.00 - Basada en 5 usuarios similares No hay usuarios similares que hayan visto \u0026#39;La m√°scara\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Eso\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Halloween\u0026#39; No hay usuarios similares que hayan visto \u0026#39;El origen\u0026#39; 1 recomendaciones generadas 1- Pesadilla en la calle Elm - Predicci√≥n de puntuaci√≥n 3.00 Recomendaciones para Laura Mart√≠nez: Pel√≠culas ya vistas: 7/13 Predicci√≥n para usuario_005 - \u0026#39;Matrix\u0026#39;: 2.27 - Basada en 3 usuarios similares Predicci√≥n para usuario_005 - \u0026#39;El resplandor\u0026#39;: 2.95 - Basada en 3 usuarios similares No hay usuarios similares que hayan visto \u0026#39;La m√°scara\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Eso\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Halloween\u0026#39; No hay usuarios similares que hayan visto \u0026#39;El origen\u0026#39; 2 recomendaciones generadas 1- El resplandor - Predicci√≥n de puntuaci√≥n 2.95 2- Matrix - Predicci√≥n de puntuaci√≥n 2.27 Recomendaciones para Roberto Garc√≠a: Pel√≠culas ya vistas: 9/13 No hay usuarios similares que hayan visto \u0026#39;La m√°scara\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Eso\u0026#39; No hay usuarios similares que hayan visto \u0026#39;Halloween\u0026#39; No hay usuarios similares que hayan visto \u0026#39;El origen\u0026#39; 0 recomendaciones generadas - No hay recomendaciones disponibles Pr√≥ximos pasos: optimizaciones y c√°lculo # El √°lgebra lineal que acabas de dominar es la base computacional del Machine Learning. En el pr√≥ximo art√≠culo exploraremos el c√°lculo. All√≠ podr√°s:\nEntender intuitivamente qu√© es una derivada y por qu√© es tan poderosa Calcular gradientes de funciones de m√∫ltiples variables Implementar descenso por gradiente desde cero en Python Visualizar c√≥mo los algoritmos \u0026ldquo;aprenden\u0026rdquo; navegando funciones de costo Optimizar modelos de Machine Learning usando estos conceptos Y lo m√°s importante: vas a ver el Machine Learning de una forma completamente nueva, entendiendo el motor matem√°tico que lo impulsa.\nReflexi√≥n final # Hasta aqu√≠ aprendiste:\n‚úÖ Conceptos fundamentales del √Ålgebra Lineal Vectores como representaci√≥n de datos Matrices como transformaciones Espacios vectoriales y transformaciones lineales Valores y vectores propios ‚úÖ Operaciones clave Producto punto para similitud Multiplicaci√≥n matriz-vector para transformaciones ‚úÖ Aplicaciones pr√°cticas Sistema de recomendaci√≥n completo ‚úÖ Herramientas Implementaci√≥n desde cero para comprensi√≥n NumPy para optimizaci√≥n Visualizaci√≥n de conceptos Para recordar\nEl √°lgebra lineal es el lenguaje del ML: Todo se reduce a vectores y matrices Las operaciones tienen significado: No son solo c√°lculos, representan conceptos La geometr√≠a importa: Visualizar ayuda a entender La optimizaci√≥n es crucial: NumPy vs implementaci√≥n casera La teor√≠a gu√≠a la pr√°ctica: entender el \u0026ldquo;por qu√©\u0026rdquo; antes del \u0026ldquo;c√≥mo\u0026rdquo; ¬°Nos vemos en el siguiente m√≥dulo! üöÄ\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"14 septiembre 2025","externalUrl":null,"permalink":"/ai/module2/algebra-project/","section":"Inteligencia Artificial","summary":"","title":"Proyecto usando √Ålgebra Lineal: Sistema de Recomendaciones","type":"ai"},{"content":" Vamos a crear un sistema de IA cl√°sica para diagnosticar problemas de rendimiento en aplicaciones web. Este ejemplo te muestra c√≥mo estructurar conocimiento en reglas l√≥gicas. Estructura del sistema # Como se mencion√≥, vamos a implementar un sistema que diagnostique problemas de rendimiento en aplicaciones web, el primer paso entonces es definir los s√≠ntomas que el sistema debe evaluar para emitir un diagn√≥stico.\nPara este caso sencillo se evaluar√°, el uso de CPU, uso de memoria RAM, cantidad de conexiones activas en simult√°neo, tiempo de respuesta y la cantidad de solicitudes (requests) lentas, por poner un l√≠mite, aquellas que demoren m√°s de un segundo en volver con una respuesta.\nCon ello, podemos generar una estructura inicial del sistema y ejecutarla. Es importante validar que el sistema continua funcionando luego de cada cambio.\nclass DiagnosticadorRendimiento: \u0026#34;\u0026#34;\u0026#34; Sistema experto para diagnosticar problemas de rendimiento en aplicaciones web usando reglas l√≥gicas. \u0026#34;\u0026#34;\u0026#34; def __init__(self): # Base de conocimiento: conjunto de reglas de diagn√≥stico self.reglas = [] def diagnosticar(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Diagnostica problemas bas√°ndose en los s√≠ntomas reportados. Args: sintomas (dict): Diccionario con m√©tricas del sistema - tiempo_respuesta: tiempo promedio en segundos - uso_memoria: porcentaje de memoria utilizada - queries_lentas: n√∫mero de queries que tardan \u0026gt;1s - conexiones_activas: n√∫mero de conexiones simult√°neas - uso_cpu: porcentaje de CPU utilizada Returns: list: Lista de diagn√≥sticos posibles con sus certezas \u0026#34;\u0026#34;\u0026#34; diagnosticos = [] # Evaluamos cada regla en nuestra base de conocimiento for regla in self.reglas: resultado = regla(sintomas) if resultado: diagnosticos.append(resultado) # Ordenamos por nivel de certeza (mayor a menor) diagnosticos.sort(key=lambda x: x[\u0026#39;certeza\u0026#39;], reverse=True) return diagnosticos # Ejemplo de uso del sistema experto if __name__ == \u0026#34;__main__\u0026#34;: # Creamos una instancia de nuestro diagnosticador diagnosticador = DiagnosticadorRendimiento() # Recibimos del usuario los valores de cada metrica print(\u0026#34;=\u0026#34; * 50) print(\u0026#34;Ingrese los valores de rendimiento del sistema\u0026#34;) cpu = int(input(\u0026#34;Porcentaje de CPU utilizada(int): \u0026#34;)) memoria = int(input(\u0026#34;Porcentaje de memoria utilizada(int): \u0026#34;)) tiempo_de_respuesta = float(input(\u0026#34;Cantidad de segundos en promedio para recibir una respuesta(float): \u0026#34;)) queries_lentas = int(input(\u0026#34;Cantidad de queries tardan m√°s de 1 segundo(int): \u0026#34;)) conexiones_activas = int(input(\u0026#34;Cantidad de conexiones simult√°neas(int): \u0026#34;)) # Simulamos m√©tricas de un servidor con problemas metricas_servidor = { \u0026#39;tiempo_respuesta\u0026#39;: tiempo_de_respuesta, \u0026#39;uso_memoria\u0026#39;: memoria, \u0026#39;queries_lentas\u0026#39;: queries_lentas, \u0026#39;conexiones_activas\u0026#39;: conexiones_activas, \u0026#39;uso_cpu\u0026#39;: cpu } # Realizamos el diagn√≥stico print(\u0026#34;=\u0026#34; * 50) print(\u0026#34;DIAGN√ìSTICO DEL SISTEMA\u0026#34;) print(\u0026#34;=\u0026#34; * 50) resultados = diagnosticador.diagnosticar(metricas_servidor) if not resultados: print(\u0026#34;No se detectaron problemas significativos\u0026#34;) else: for i, diagnostico in enumerate(resultados, 1): print(f\u0026#34;\\n#{i} - {diagnostico[\u0026#39;problema\u0026#39;]}\u0026#34;) print(f\u0026#34;Certeza: {diagnostico[\u0026#39;certeza\u0026#39;]:.1%}\u0026#34;) print(\u0026#34;Recomendaciones:\u0026#34;) for rec in diagnostico[\u0026#39;recomendaciones\u0026#39;]: print(f\u0026#34; ‚Ä¢ {rec}\u0026#34;) Al ejecutar el programa, vemos que el sistema dice que no hay problemas significativos. Esto se debe a que el DiagnosticadorRendimiento no tiene ninguna regla implementada, a continuaci√≥n veremos c√≥mo generar estas reglas que le dar√°n el conocimiento necesario al diagnosticador para emitir un diagn√≥stico.\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 92 Cantidad de segundos en promedio para recibir una respuesta(float): 4.2 Cantidad de queries tardan m√°s de 1 segundo(int): 15 Cantidad de conexiones simult√°neas(int): 800 ================================================== DIAGN√ìSTICO DEL SISTEMA ================================================== No se detectaron problemas significativos Reglas # Como se observa en el m√©todo diagnosticar de la clase DiagnosticadorRendimiento, las reglas son simplemente funciones o m√©todos de la misma clase, que reciben con argumento un diccionario llamado sintomas que contiene las m√©tricas del sistema definidas anteriormente.\n# Evaluamos cada regla en nuestra base de conocimiento for regla in self.reglas: resultado = regla(sintomas) if resultado: diagnosticos.append(resultado) Para que la funci√≥n diagnosticar eval√∫e la regla, esta debe ser incluida en el diccionario de reglas definido en el constructor de la clase.\ndef __init__(self): # Base de conocimiento: conjunto de reglas de diagn√≥stico self.reglas = [] Se espera adem√°s que cada regla retorne un mapa con los campos:\nproblema: posible causa de un mal rendimiento. certeza: nivel de probabilidad de que el problema definido sea el causante de deficiencias en el rendimiento. recomendaciones: acciones que se podr√≠an llevar a cabo para mejorar el rendimiento. Vale aclarar que estas reglas son ficticias y a la hora de generar un sistema experto de este tipo debes definirlas cuidadosamente en base al tipo de problema que intentas resolver y las condiciones de tu sistema.\nUso de CPU # La primera regla que implementaremos tendr√° a su cargo determinar si el nivel de uso de CPU representa un problema de rendimiento o no.\nEl primer factor a decidir es que nivel se considera alto para el uso de CPU, por ejemplo \\(80\\%\\). Tambi√©n definimos que cuando el valor supere este l√≠mite, la certeza de que el uso de CPU es un problem ser√° por los menos \\(0.85\\) y crecer√° hasta \\(1\\) mientras el uso de CPU crezca hasta el \\(100\\%\\).\ndef _regla_cpu(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Regla: Uso de CPU alto puede indicar procesamiento intensivo o algoritmos ineficientes. \u0026#34;\u0026#34;\u0026#34; if sintomas.get(\u0026#39;uso_cpu\u0026#39;, 0) \u0026gt; 80: certeza = min(0.85, sintomas[\u0026#39;uso_cpu\u0026#39;] / 100) return { \u0026#39;problema\u0026#39;: \u0026#39;Procesamiento intensivo o algoritmos ineficientes\u0026#39;, \u0026#39;certeza\u0026#39;: certeza, \u0026#39;recomendaciones\u0026#39;: [ \u0026#39;Analizar el c√≥digo para identificar cuellos de botella\u0026#39;, \u0026#39;Optimizar algoritmos, por ejemplo, aquellos O(n¬≤) o peores\u0026#39;, \u0026#39;Implementar una cache para c√°lculos repetitivos\u0026#39;, \u0026#39;Considerar procesamiento as√≠ncrono para tareas pesadas\u0026#39; ] } return None Ejecutando nuevamente el sistema con un valor de CPU del \\(93\\%\\) se obtiene:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 93 Porcentaje de memoria utilizada(int): 92 Cantidad de segundos en promedio para recibir una respuesta(float): 4.2 Cantidad de queries tardan m√°s de 1 segundo(int): 15 Cantidad de conexiones simult√°neas(int): 800 ================================================== DIAGN√ìSTICO DEL SISTEMA ================================================== #1 - Procesamiento intensivo o algoritmos ineficientes Certeza: 85.0% Recomendaciones: ‚Ä¢ Analizar el c√≥digo para identificar cuellos de botella ‚Ä¢ Optimizar algoritmos, por ejemplo, aquellos O(n¬≤) o peores ‚Ä¢ Implementar una cache para c√°lculos repetitivos ‚Ä¢ Considerar procesamiento as√≠ncrono para tareas pesadas Uso de memoria # Para el caso de la memoria RAM, no solo consideraremos su uso (superior al \\(85\\%\\)) sino que tambi√©n tenderemos en cuenta el tiempo de respuesta del sistema (mayor a \\(3.0\\) segundos).\ndef _regla_memoria(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Regla: Si el uso de memoria es alto Y el tiempo de respuesta es lento, probablemente hay una fuga (leak) de memoria. \u0026#34;\u0026#34;\u0026#34; if (sintomas.get(\u0026#39;uso_memoria\u0026#39;, 0) \u0026gt; 85 and sintomas.get(\u0026#39;tiempo_respuesta\u0026#39;, 0) \u0026gt; 3.0): # Calculamos certeza basada en qu√© tan extremos son los valores certeza = min(0.9, (sintomas[\u0026#39;uso_memoria\u0026#39;] / 100) * (sintomas[\u0026#39;tiempo_respuesta\u0026#39;] / 5)) return { \u0026#39;problema\u0026#39;: \u0026#39;Fuga de memoria o uso excesivo de memoria\u0026#39;, \u0026#39;certeza\u0026#39;: certeza, \u0026#39;recomendaciones\u0026#39;: [ \u0026#39;Revisar objetos no liberados en memoria\u0026#39;, \u0026#39;Implementar un grupo de conexiones para evitar abrir y cerrar nuevas\u0026#39;, \u0026#39;Analizar el consumo de memoria (memory_profiler)\u0026#39;, \u0026#39;Considerar aumentar la cantidad de RAM del servidor\u0026#39; ] } return None Veamos como funciona:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 92 Cantidad de segundos en promedio para recibir una respuesta(float): 4.2 Cantidad de queries tardan m√°s de 1 segundo(int): 15 Cantidad de conexiones simult√°neas(int): 800 ================================================== DIAGN√ìSTICO DEL SISTEMA ================================================== #1 - Fuga de memoria o uso excesivo de memoria Certeza: 77.3% Recomendaciones: ‚Ä¢ Revisar objetos no liberados en memoria ‚Ä¢ Implementar un grupo de conexiones para evitar abrir y cerrar nuevas ‚Ä¢ Analizar el consumo de memoria (memory_profiler) ‚Ä¢ Considerar aumentar la cantidad de RAM del servidor Si el tiempo de respuesta no se ve impactado aunque el consumo de memoria sea alto, obtenemos:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 92 Cantidad de segundos en promedio para recibir una respuesta(float): 2.8 Cantidad de queries tardan m√°s de 1 segundo(int): 15 Cantidad de conexiones simult√°neas(int): 800 ================================================== DIAGN√ìSTICO DEL SISTEMA ================================================== No se detectaron problemas significativos Nivel de concurrencia # De manera similar, implementaremos una regla para controlar la cantidad de conexiones simultaneas al servidor. Demasiadas conexiones pueden saturarlo y hacer que deje de responder. En este ejemplo, definiremos que \\(1000\\) conexiones simultaneas es el l√≠mite.\ndef _regla_concurrencia(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Regla: Muchas conexiones simult√°neas pueden saturar el servidor. \u0026#34;\u0026#34;\u0026#34; if sintomas.get(\u0026#39;conexiones_activas\u0026#39;, 0) \u0026gt; 1000: certeza = min(0.8, sintomas[\u0026#39;conexiones_activas\u0026#39;] / 2000) return { \u0026#39;problema\u0026#39;: \u0026#39;Sobrecarga por exceso de conexiones concurrentes\u0026#39;, \u0026#39;certeza\u0026#39;: certeza, \u0026#39;recomendaciones\u0026#39;: [ \u0026#39;Implementar rate limiting\u0026#39;, \u0026#39;Usar un balanceador de carga (load balancer) con m√∫ltiples instancias\u0026#39;, \u0026#39;Utilizar un grupo de conexiones preestablecidas\u0026#39;, \u0026#39;Implementar colas para procesos no cr√≠ticos\u0026#39; ] } return None Con la regla anterior, obtenemos los siguientes resultados:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 56 Cantidad de segundos en promedio para recibir una respuesta(float): 2.8 Cantidad de queries tardan m√°s de 1 segundo(int): 15 Cantidad de conexiones simult√°neas(int): 800 ================================================== DIAGN√ìSTICO DEL SISTEMA ================================================== No se detectaron problemas significativos \u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 56 Cantidad de segundos en promedio para recibir una respuesta(float): 2.8 Cantidad de queries tardan m√°s de 1 segundo(int): 15 Cantidad de conexiones simult√°neas(int): 1500 ================================================== DIAGN√ìSTICO DEL SISTEMA ================================================== #1 - Sobrecarga por exceso de conexiones concurrentes Certeza: 75.0% Recomendaciones: ‚Ä¢ Implementar rate limiting ‚Ä¢ Usar un balanceador de carga (load balancer) con m√∫ltiples instancias ‚Ä¢ Utilizar un grupo de conexiones preestablecidas ‚Ä¢ Implementar colas para procesos no cr√≠ticos Consultas a la base de datos # Una posible causa para recibir respuestas lentas puede ser el tiempo consumido en las consultas a la base de datos. Implementaremos una regla para que el sistema reconozca estos casos.\ndef _regla_base_datos(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Regla: Si hay muchas queries lentas, el problema est√° en la base de datos. \u0026#34;\u0026#34;\u0026#34; if sintomas.get(\u0026#39;queries_lentas\u0026#39;, 0) \u0026gt; 10: certeza = min(0.95, sintomas[\u0026#39;queries_lentas\u0026#39;] / 50) return { \u0026#39;problema\u0026#39;: \u0026#39;Queries de base de datos ineficientes\u0026#39;, \u0026#39;certeza\u0026#39;: certeza, \u0026#39;recomendaciones\u0026#39;: [ \u0026#39;Revisar √≠ndices en tablas frecuentemente consultadas\u0026#39;, \u0026#39;Optimizar queries con EXPLAIN ANALYZE\u0026#39;, \u0026#39;Implementar cache de queries (Redis)\u0026#39;, \u0026#39;Considerar particionado de tablas grandes\u0026#39; ] } return None Lo que nos da resultados como estos:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 56 Cantidad de segundos en promedio para recibir una respuesta(float): 1.5 Cantidad de queries tardan m√°s de 1 segundo(int): 17 Cantidad de conexiones simult√°neas(int): 800 ================================================== DIAGN√ìSTICO DEL SISTEMA ================================================== #1 - Queries de base de datos ineficientes Certeza: 34.0% Recomendaciones: ‚Ä¢ Revisar √≠ndices en tablas frecuentemente consultadas ‚Ä¢ Optimizar queries con EXPLAIN ANALYZE ‚Ä¢ Implementar cache de queries (Redis) ‚Ä¢ Considerar particionado de tablas grandes \u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 56 Cantidad de segundos en promedio para recibir una respuesta(float): 1.5 Cantidad de queries tardan m√°s de 1 segundo(int): 49 Cantidad de conexiones simult√°neas(int): 800 ================================================== DIAGN√ìSTICO DEL SISTEMA ================================================== #1 - Queries de base de datos ineficientes Certeza: 95.0% Recomendaciones: ‚Ä¢ Revisar √≠ndices en tablas frecuentemente consultadas ‚Ä¢ Optimizar queries con EXPLAIN ANALYZE ‚Ä¢ Implementar cache de queries (Redis) ‚Ä¢ Considerar particionado de tablas grandes Estado de la red # Si vemos que el tiempo de respuesta es alto pero CPU y memoria est√°n bien, puede ser un problema de red. A continuaci√≥n vemos el c√≥digo para implementar esta regla.\ndef _regla_red(self, sintomas): \u0026#34;\u0026#34;\u0026#34; Regla: Si el tiempo de respuesta es alto pero CPU y memoria est√°n bien, puede ser un problema de red. \u0026#34;\u0026#34;\u0026#34; if (sintomas.get(\u0026#39;tiempo_respuesta\u0026#39;, 0) \u0026gt; 2.0 and sintomas.get(\u0026#39;uso_cpu\u0026#39;, 0) \u0026lt; 50 and sintomas.get(\u0026#39;uso_memoria\u0026#39;, 0) \u0026lt; 70): certeza = 0.7 # Menos certeza porque es por descarte return { \u0026#39;problema\u0026#39;: \u0026#39;Latencia de red o problemas de conectividad\u0026#39;, \u0026#39;certeza\u0026#39;: certeza, \u0026#39;recomendaciones\u0026#39;: [ \u0026#39;Verificar latencia entre servidor y clientes\u0026#39;, \u0026#39;Implementar CDN para recursos est√°ticos\u0026#39;, \u0026#39;Optimizar tama√±o de respuestas (compresi√≥n)\u0026#39; ] } return None Con el siguiente resultado:\n\u0026gt; python sistema_experto_basico.py ================================================== Ingrese los valores de rendimiento del sistema Porcentaje de CPU utilizada(int): 45 Porcentaje de memoria utilizada(int): 56 Cantidad de segundos en promedio para recibir una respuesta(float): 2.8 Cantidad de queries tardan m√°s de 1 segundo(int): 15 Cantidad de conexiones simult√°neas(int): 800 ================================================== DIAGN√ìSTICO DEL SISTEMA ================================================== #1 - Latencia de red o problemas de conectividad Certeza: 70.0% Recomendaciones: ‚Ä¢ Verificar latencia entre servidor y clientes ‚Ä¢ Implementar CDN para recursos est√°ticos ‚Ä¢ Optimizar tama√±o de respuestas (compresi√≥n) ¬øQu√© aprendemos de este ejemplo? # Estructura del conocimiento: Las reglas est√°n separadas en m√©todos independientes, lo que hace el sistema modular y f√°cil de mantener.\nManejo de incertidumbre: Cada regla calcula una \u0026ldquo;certeza\u0026rdquo; basada en qu√© tan extremos son los valores.\nExplicaci√≥n del razonamiento: El sistema no solo da un diagn√≥stico, sino que explica por qu√© lleg√≥ a esa conclusi√≥n.\nEscalabilidad: Agregar nuevas reglas es tan simple como crear un nuevo m√©todo _regla_*.\nC√≥digo completo # Aqu√≠ tienes el c√≥digo completo del sistema. Tambi√©n puedes encontrarlo en el repositorio de ejemplos haciendo click en el siguiente enlace.\nlearn-software-engineering/examples Programming Course - Examples Python 1 0 ¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"22 agosto 2025","externalUrl":null,"permalink":"/ai/module1/sample1/","section":"Inteligencia Artificial","summary":"","title":"Machine Learning Ejemplo 1: Sistema Experto","type":"ai"},{"content":"Un array es una estructura de datos que representa un conjunto de elementos, los cuales se acceden a trav√©s de √≠ndices num√©ricos contiguos que van desde 0 hasta el tama√±o del array menos 1. Los arrays proveen acceso r√°pido y directo a los elementos en base a su posici√≥n.\nEn lenguajes como Python y Ruby, los arrays se conocen como \u0026rsquo;listas\u0026rsquo; (lists). En Javascript se les conoce como \u0026lsquo;arreglos\u0026rsquo; (arrays).\nLos arrays son t√≠picamente homog√©neos, almacenando elementos del mismo tipo como enteros, cadenas, etc. Algunos lenguajes permiten arrays heterog√©neos con valores de distintos tipos.\nDiagrama de un array Creaci√≥n de arrays # La manera de crear arrays var√≠a seg√∫n el lenguaje de programaci√≥n:\nMI_ARRAY = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] # array literal mi_array = list(range(5)) # array a partir de rango Al crear un array literal se inicializan sus elementos directamente. Al construir un array vac√≠o se especifica su tama√±o pero sus elementos son inicializados con un valor default (0 para n√∫meros, null para objetos, etc).\nAcceder y modificar elementos # Los elementos individuales se acceden r√°pidamente por su √≠ndice utilizando corchetes []:\nmy_array = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] print(my_array[0]) # \u0026#39;a\u0026#39; print(my_array[2]) # \u0026#39;c\u0026#39; my_array[2] = \u0026#39;z\u0026#39; print(my_array[2]) # \u0026#39;z\u0026#39; Los √≠ndices comienzan en 0, por lo que en un array de tama√±o N, los √≠ndices v√°lidos est√°n entre 0 y N-1.\nAcceder a un √≠ndice inv√°lido causa un error, por ejemplo, acceder al √≠ndice 3 en un array de tama√±o 3. Esto se conoce como \u0026ldquo;index out of bounds\u0026rdquo;.\nRecorrer un array # Podemos recorrer todos los elementos usando un ciclo for:\nletras = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] for i in range(len(letras)): print(letras[i]) Esto imprime cada elemento en orden. len() devuelve la longitud total del array.\nOtra forma es iterando directamente sobre los elementos:\nletras = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] for letra in letras: print(letra) Buscar en un array # Podemos buscar un elemento en un array mediante un ciclo y comparando elemento por elemento:\nletras = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] def buscar_en_array(array, elemento): for i in range(len(array)): if array[i] == elemento: return i return False print(buscar_en_array(letras, \u0026#39;b\u0026#39;)) # 1 print(buscar_en_array(letras, \u0026#39;z\u0026#39;)) # False Devuelve el √≠ndice si se encuentra o False si no se encuentra.\nArray multidimensional # Los arrays pueden tener m√°s de una dimensi√≥n, por ejemplo matrices 2D, cubos 3D, etc.\nUn array 2D se puede ver como una tabla con filas y columnas. Para acceder a un elemento se especifican dos √≠ndices, uno para la fila y otro para la columna:\nmatrix = [ [1, 2, 3], [4, 5, 6] ] print(matrix[0][2]) # 3 print(matrix[1][0]) # 4 Pueden tener m√°s dimensiones, por ejemplo un array 3D para representar pixeles en una imagen.\nConclusi√≥n # Los arrays son estructuras de datos fundamentales en programaci√≥n que proveen un acceso eficiente a elementos en memoria mediante √≠ndices num√©ricos. Tener un buen dominio de arrays, matrices y sus usos es indispensable para cualquier programador.\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"30 octubre 2023","externalUrl":null,"permalink":"/programming/data-structures/arrays/","section":"Programaci√≥n","summary":"","title":"Arreglos","type":"programming"},{"content":" Anatom√≠a de una clase # Una clase act√∫a como un plano o molde para construir objetos similares, definiendo sus caracter√≠sticas comunes y funcionalidades. Es similar al plano para construir casas de un mismo barrio: todas comparten ciertos atributos clave.\nLos componentes t√≠picos de una clase son:\nAtributos (propiedades): Variables que caracterizan al objeto. Por ejemplo, para una clase Persona, atributos como nombre, edad, DNI, etc.\nclass Persona: dni = \u0026#34;\u0026#34; nombre = \u0026#34;\u0026#34; edad = 0 M√©todos: Funciones que definen comportamientos. Por ejemplo, una Persona puede caminar(), hablar(), comer(), etc. Acceden a los atributos para implementar dicha funcionalidad.\nConstructor: M√©todo especial __init__() que se ejecuta al instanciar la clase y permite inicializar los atributos.\nDestructor: M√©todo __del__() que se ejecuta al eliminar la instancia liberando recursos. Opcional en algunos lenguajes.\nCreando objetos # A partir de la clase generamos objetos, que son instancias concretas con sus propios atributos definidos. Digamos que la clase Casa es el plano, y una casa espec√≠fica en una calle determinada es el objeto.\nEn c√≥digo creamos un objeto invocando la clase como si fuera un m√©todo:\n# Clase Persona class Persona: def __init__(self, n, e): self.nombre = n self.edad = e # Objeto Persona espec√≠fico pepe = Persona(\u0026#34;Pepe\u0026#34;, 30) juan = Persona(\u0026#34;Juan\u0026#34;, 35) Cada objeto comparte la estructura y comportamiento general, pero puede almacenar distintos datos.\nUtilizando Propiedades y M√©todos # Ya tenemos una clase Persona y un objeto pepe de tipo Persona. ¬øC√≥mo interactuamos con el objeto?\nPropiedades: Es posible acceder al valor de un atributo del objeto utilizando la referencia al objeto (pepe) y el nombre del atributo. pepe.nombre # \u0026#34;Pepe\u0026#34; pepe.edad # 30 M√©todos: De la misma manera en la que se accede a los atributos pero agregando un par√©ntesis dentro del cual se pasan los argumentos si es que recibe alguno. # Clase Persona class Persona: def __init__(self, n, e): self.nombre = n self.edad = e def comer(self, comida): print(f\u0026#34;Comiendo {comida}\u0026#34;) # Objeto Persona espec√≠fico pepe = Persona(\u0026#34;Pepe\u0026#34;, 30) pepe.comer(\u0026#34;pizza\u0026#34;) # Imprime \u0026#34;Comiendo pizza\u0026#34; El objeto pepe tiene ahora estado (propiedades) y comportamiento (m√©todos) propios.\nSelf vs This # Un detalle importante en los m√©todos es c√≥mo acceden a los atributos y otros m√©todos del objeto. Aqu√≠ entra otra diferencia entre lenguajes:\nSelf: En Python, los atributos y m√©todos se acceden dentro de la clase anteponiendo self. Esto apunta al objeto instanciado. class Persona: def __init__(self, nombre): self.nombre = nombre def saludar(self): print(f\u0026#34;Hola! Soy {self.nombre}\u0026#34;) juan = Persona(\u0026#34;Juan\u0026#34;) juan.saludar() # Imprime \u0026#34;Hola! Soy Juan\u0026#34; This: En Java o C#, se utiliza this en lugar de self. Cumple la misma funcionalidad de apuntar a los miembros del objeto. public class Person { private String nombre; public Person(String nombre) { this.nombre= nombre; } public void saludar() { System.out.println(\u0026#34;Hola! Soy \u0026#34; + this.nombre); } } Person juan = new Person(\u0026#34;Juan\u0026#34;); juan.saludar(); // Imprime \u0026#34;Hola! Soy Juan\u0026#34; Conclusi√≥n # Las clases y objetos son los conceptos clave de la POO, permitiendo modelar entidades de la realidad y generar componentes modulares y gen√©ricos de nuestro sistema para construir programas m√°s robustos y f√°ciles de entender y mantener.\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"02 octubre 2023","externalUrl":null,"permalink":"/programming/oop/classes-objects/","section":"Programaci√≥n","summary":"","title":"Clases y Objetos","type":"programming"},{"content":" Salida a pantalla # Python tambi√©n provee funciones para enviar la salida de un programa a la \u0026ldquo;salida est√°ndar\u0026rdquo;, generalmente la pantalla o terminal1.\nLa funci√≥n print() muestra el valor pasado como par√°metro:\nnombre = \u0026#34;Eric\u0026#34; print(nombre) # muestra \u0026#34;Eric\u0026#34; Podemos imprimir m√∫ltiples valores separados por comas2:\nprint(\u0026#34;Hola\u0026#34;, nombre, \u0026#34;!\u0026#34;) # muestra \u0026#34;Hola Eric!\u0026#34; Tambi√©n podemos usar valores literales sin asignar a variables3:\nprint(\u0026#34;2 + 3 =\u0026#34;, 2 + 3) # muestra \u0026#34;2 + 3 = 5\u0026#34; Formateo de salida # Python provee varias formas de dar formato a la salida4:\nf-Strings: Permiten insertar variables dentro de una cadena:\nnombre = \u0026#34;Eric\u0026#34; print(f\u0026#34;Hola {nombre}\u0026#34;) # muestra \u0026#34;Hola Eric\u0026#34; %s: Inserta cadenas de texto en una cadena de formato:\nnombre = \u0026#34;Eric\u0026#34; print(\u0026#34;Hola %s\u0026#34; % nombre) # muestra \u0026#34;Hola Eric\u0026#34; %d: Inserta n√∫meros enteros:\nvalor = 15 print(\u0026#34;El valor es %d\u0026#34; % valor) # muestra \u0026#34;El valor es 15\u0026#34; .format(): Inserta valores en una cadena de formato:\nnombre = \u0026#34;Eric\u0026#34; print(\u0026#34;Hola {}. Bienvenido\u0026#34;.format(nombre)) # muestra \u0026#34;Hola Eric. Bienvenido\u0026#34; Estas opciones de formateo nos permiten interpolar variables y valores en cadenas de texto para generar outputs personalizados. Podemos combinar m√∫ltiples valores y formateos en una sola cadena de salida2.\nEntrada desde el teclado # Python provee funciones incorporadas para leer datos ingresados por el usuario en tiempo de ejecuci√≥n. Esto se conoce como \u0026ldquo;entrada est√°ndar\u0026rdquo;4.\nLa funci√≥n input() permite leer un valor ingresado por el usuario y asignarlo a una variable. Por ejemplo:\nnombre = input(\u0026#34;Ingresa tu nombre: \u0026#34;) Esto muestra el mensaje \u0026ldquo;Ingresa tu nombre: \u0026quot; y espera a que el usuario escriba un texto y presione Enter. Ese valor se asigna a la variable nombre2.\nLa funci√≥n input() siempre regresa una cadena de texto. Si queremos pedir un n√∫mero u otro tipo de dato, debemos convertirlo usando int(), float(), etc1:\nedad = int(input(\u0026#34;Ingresa tu edad: \u0026#34;)) pi = float(input(\u0026#34;Ingresa el valor de pi: \u0026#34;)) Leyendo m√∫ltiples valores # Podemos pedir y leer varios valores en una misma l√≠nea separ√°ndolos con comas3:\nnombre, edad = input(\u0026#34;Ingresa nombre y edad: \u0026#34;).split() El m√©todo split() divide la entrada en partes y retorna una lista de cadenas. Luego asignamos los elementos de la lista a variables separadas.\nTambi√©n podemos leer varias l√≠neas de entrada con un ciclo4:\nnombres = [] # lista vac√≠a for x in range(3): nombre = input(\u0026#34;Ingresa un nombre: \u0026#34;) nombres.append(nombre) Este c√≥digo lee 3 nombres ingresados por el usuario y los agrega a una lista.\nSalida a un archivo # Adem√°s de imprimir a pantalla, podemos escribir la salida a un archivo usando la funci√≥n open()1:\narchivo = open(\u0026#34;datos.txt\u0026#34;, \u0026#34;w\u0026#34;) Esto abre datos.txt para escritura (\u0026ldquo;w\u0026rdquo;) y retorna un objeto archivo.\nLuego usamos archivo.write() para escribir a ese archivo3:\narchivo.write(\u0026#34;Hola mundo!\u0026#34;) archivo.write(\u0026#34;Este texto va al archivo\u0026#34;) Debemos cerrar el archivo con archivo.close() cuando terminamos4:\narchivo.close() Tambi√©n podemos usar with para abrir y cerrar autom√°ticamente2:\nwith open(\u0026#34;datos.txt\u0026#34;, \u0026#34;w\u0026#34;) as archivo: archivo.write(\u0026#34;Hola mundo!\u0026#34;) # no hace falta cerrar, es autom√°tico Lectura de archivos # Para leer un archivo usamos open() con modo \u0026ldquo;r\u0026rdquo; y iteramos sobre el objeto archivo1:\nwith open(\u0026#34;datos.txt\u0026#34;, \u0026#34;r\u0026#34;) as archivo: for linea in archivo: print(linea) # muestra cada l√≠nea del archivo Esto imprime cada l√≠nea, incluyendo los saltos de l√≠nea.\nPodemos leer todas las l√≠neas a una lista con readlines()3:\nlinenas = archivo.readlines() print(linenas) Para leer el contenido completo a una cadena usamos read()4:\ntexto = archivo.read() print(texto) Tambi√©n podemos leer un n√∫mero determinado de bytes o caracteres con read(n)2.\nOperaciones para el manejo de archivos # Existen varias funciones incorporadas para manipular archivos en Python1:\nopen() - Abre un archivo y retorna un objeto archivo close() - Cierra el archivo write() - Escribe datos al archivo read() - Lee datos del archivo readline() - Lee una l√≠nea del archivo truncate() - Vac√≠a el archivo seek() - Mueve la posici√≥n de lectura/escritura rename() - Renombra el archivo remove() - Elimina el archivo Estas funciones nos permiten efectuar operaciones avanzadas para leer, escribir y mantener archivos.\nConclusi√≥n # En este art√≠culo explicamos en detalle operaciones de entrada y salida en Python, incluyendo leer de entrada est√°ndar y escribir a salida est√°ndar o archivos. Manejar correctamente la entrada y salida es esencial para muchas aplicaciones de Python. Recomiendo practicar con ejemplos propios para dominar estas funciones3.\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\nReferencias # McKinney, W. (2018). Python for data analysis: Data wrangling with Pandas, NumPy, and IPython. O\u0026rsquo;Reilly Media.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMatthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. No Starch Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDowney, A. B. (2015). Think Python: How to think like a computer scientist. Needham, Massachusetts: Green Tea Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"19 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/io-operations/","section":"Programaci√≥n","summary":"","title":"Operaciones de Entrada y Salida","type":"programming"},{"content":"Si alguna vez te has preguntado qu√© es lo que hace \u0026ldquo;tictac\u0026rdquo; dentro de esa caja met√°lica que llamamos computadora, est√°s en el lugar indicado. En esencia, una computadora es una combinaci√≥n de hardware y software que trabajan juntos para llevar a cabo tareas espec√≠ficas.\nEl hardware es toda la parte f√≠sica de la computadora: el CPU (que es como el cerebro de la m√°quina), la RAM (donde la computadora guarda la informaci√≥n con la que est√° trabajando en un momento determinado), dispositivos de almacenamiento (donde se guardan los datos de forma permanente) y perif√©ricos (como el teclado, el mouse o la pantalla)1.\nPor otro lado, el software es el conjunto de instrucciones que le dice al hardware qu√© hacer. Hay varios tipos de software, desde el software del sistema, como el sistema operativo que coordina todas las acciones de la m√°quina, hasta software de aplicaci√≥n que nos permite hacer cosas como escribir documentos o jugar videojuegos2.\nEl papel del sistema operativo es crucial. Es el mediador entre el usuario y el hardware, asegurando que todo funcione arm√≥nicamente. Si el hardware fuera una orquesta, el sistema operativo ser√≠a el director que asegura que cada instrumento toque en el momento y de la manera correcta.\nEl sistema binario: el lenguaje secreto de las computadoras # A diferencia de nosotros, que usamos un sistema decimal basado en diez d√≠gitos (del 0 al 9), las computadoras usan el sistema binario, que solo tiene dos d√≠gitos: 0 y 1. ¬øPor qu√©? Bueno, en el nivel m√°s b√°sico, una computadora est√° hecha de millones de transistores que pueden estar en uno de dos estados: encendido o apagado. Estos estados se representan con esos d√≠gitos: 0 para apagado y 1 para encendido3.\nLos t√©rminos \u0026ldquo;bit\u0026rdquo; y \u0026ldquo;byte\u0026rdquo; son fundamentales aqu√≠. Un bit es la unidad m√°s peque√±a de datos en una computadora y puede tener un valor de 0 o 1. Un byte, por otro lado, es un conjunto de 8 bits y puede representar 256 valores diferentes (desde \\(00000000\\) hasta \\(11111111\\) en binario)4.\nEste sistema binario no solo representa n√∫meros, sino tambi√©n texto, im√°genes y cualquier tipo de dato. Por ejemplo, en el c√≥digo ASCII (un est√°ndar de codificaci√≥n de caracteres), la letra \u0026ldquo;A\u0026rdquo; se representa como \\(01000001\\) en binario.\nEn un art√≠culo posterior, vamos a hablar en detalle acerca del sistema binario y otro sistema muy utilizado en el ambiente de la computaci√≥n, el hexadecimal.\nMemoria y almacenamiento: donde residen nuestros datos # La memoria y el almacenamiento son dos conceptos cruciales en la inform√°tica. Si bien a menudo se usan indistintamente, tienen roles muy diferentes.\nLa memoria, espec√≠ficamente la RAM, es vol√°til. Esto significa que la informaci√≥n se pierde cuando apagamos la computadora. La RAM es esencialmente el \u0026ldquo;espacio de trabajo\u0026rdquo; de la computadora, donde almacena datos e instrucciones mientras est√° en uso. Hay varios tipos de RAM, siendo DRAM y SRAM los m√°s comunes5.\nPor otro lado, tenemos la ROM (Memoria de Solo Lectura). A diferencia de la RAM, la ROM no es vol√°til y se utiliza para almacenar firmware, es decir, software que est√° √≠ntimamente ligado al hardware y que no necesita cambios frecuentes.\nEn cuanto al almacenamiento, dispositivos como discos duros, SSDs y unidades flash nos permiten guardar informaci√≥n de manera permanente. Estos dispositivos forman parte de lo que se conoce como la jerarqu√≠a de memoria, que va desde la memoria cach√© (r√°pida pero peque√±a) hasta el almacenamiento secundario (m√°s lento pero con gran capacidad)6.\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\nReferencias # Patterson, D. \u0026amp; Hennessy, J. (2014). Arquitectura de Computadoras. Buenos Aires: Ediciones Omega.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSilberschatz, A., Galvin, P. B., \u0026amp; Gagne, G. (2009). Fundamentos de Sistemas Operativos. Buenos Aires: Ediciones M.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A. (2012). Estructura de Computadoras. Buenos Aires: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBrookshear, J. G. (2011). Ciencia de la Computaci√≥n: Una visi√≥n general. Buenos Aires: Pearson Educaci√≥n.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nJacob, B., Ng, S. W., \u0026amp; Wang, D. T. (2007). Arquitecturas de memoria en sistemas de computadoras. Buenos Aires: Wiley-Interscience.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSiewiorek, D. P. \u0026amp; Swarz, R. S. (2017). Principios de dise√±o de sistemas computacionales. Buenos Aires: Morgan Kaufmann.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"02 septiembre 2023","externalUrl":null,"permalink":"/programming/intro/computers/","section":"Programaci√≥n","summary":"","title":"Computadoras","type":"programming"},{"content":"","externalUrl":null,"permalink":"/programming/starting-concepts/","section":"Programaci√≥n","summary":"","title":"Conceptos Iniciales","type":"programming"},{"content":"","externalUrl":null,"permalink":"/ai/module2/","section":"Inteligencia Artificial","summary":"","title":"Matem√°tica para Machine Learning","type":"ai"},{"content":" Ahora vamos a crear un clasificador de texto b√°sico usando t√©cnicas estad√≠sticas simples. Esto te muestra los conceptos fundamentales detr√°s de algoritmos m√°s complejos como Naive Bayes. Imagin√° que trabaj√°s en una empresa de software y cada d√≠a llegan cientos de tickets de soporte t√©cnico. Algunos reportan errores (bugs), otros solicitan nuevas funcionalidades, y otros simplemente piden ayuda. Manualmente clasificar cada ticket tomar√≠a horas de trabajo.\n¬øSer√≠a genial si pudi√©ramos ense√±arle a una computadora a leer estos tickets y clasificarlos autom√°ticamente? Este es exactamente el tipo de problema que resuelve el aprendizaje autom√°tico (machine learning).\nPara resolver este problema, implementaremos un Clasificador Bayesiano Ingenuo (Naive Bayes Classifier), uno de los algoritmos m√°s elegantes y comprensibles del aprendizaje autom√°tico (machine learning). ¬øPor qu√© es perfecto para empezar?\nEs intuitivo: funciona de manera similar a como los humanos categorizamos Es eficiente: requiere relativamente pocos datos de entrenamiento Es interpretable: podemos entender exactamente por qu√© toma cada decisi√≥n Fundamentos matem√°ticos: el teorema de Bayes # Antes de sumergirnos en el c√≥digo, entendamos la base matem√°tica. El teorema de Bayes es una regla matem√°tica que nos para invertir probabilidades condicionadas, permitiendonos encontrar la probabilidad de una causa dado su efecto.\nLa probabilidad condicionada es una medida de la probabilidad de que ocurra un evento, dado que ya se sabe que ha ocurrido otro suceso. Si el suceso de inter√©s es \\(A\\) y se sabe o se supone que ha ocurrido el suceso \\(B\\), la probabilidad condicional de \\(A\\) dado \\(B\\), suele escribirse como:\n$$P(A|B)$$Aunque las probabilidades condicionales pueden proporcionar informaci√≥n muy √∫til, a menudo se cuenta con informaci√≥n limitada. Por lo tanto, puede ser √∫til invertir la probabilidad condicional utilizando el teorema de Bayes:\n$$P(A|B) = \\frac{P(B|A) \\cdot P(A)}{P(B)}$$En nuestro contexto:\n\\(A\\) = la categor√≠a (BUG, FEATURE, SUPPORT) \\(B\\) = el texto del ticket Entonces queremos calcular:\n$$P(\\text{categor√≠a}|\\text{texto})$$Es decir, la probabilidad de la categor√≠a de un ticket dado la probabilidad de un determinado texto.\nPara clasificaci√≥n, podemos simplificar la f√≥rmula a:\n$$P(\\text{categor√≠a}|\\text{texto}) \\propto P(\\text{categor√≠a}) \\cdot P(\\text{texto}|\\text{categor√≠a})$$Siendo:\n\\(P(\\text{categor√≠a}|\\text{texto})\\): la probabilidad de que un ticket corresponda a una determinada categor√≠a dado un texto. \\(P(\\text{categor√≠a})\\): la probabilidad de que un ticket sea clasificado como de una determinada categor√≠a. \\(P(\\text{texto}|\\text{categor√≠a})\\): la probabilidad de que el ticket contenta un determinado texto si pertenece a una categor√≠a. En otras palabras, queremos conocer la probabilidad de que un ticket sea una categor√≠a. Para ello, necesitamos saber la probabilidad de que dicha categor√≠a aplique a un ticket, y la probabilidad con la que determinadas palabras aparecen en los tickets de una determinada categor√≠a.\nEstructura b√°sica del sistema # Comenzaremos definiendo la estructura del sistema, por lado, crearemos una clase que actuar√° como clasificador y una funci√≥n main que ser√° la encargada de entrenarlo y de enviarle nuevos tickets para determinar su categor√≠a.\nfrom collections import defaultdict, Counter class ClasificadorTextoBasico: \u0026#34;\u0026#34;\u0026#34; Clasificador de texto usando probabilidades bayesianas b√°sicas. √ötil para clasificar emails, rese√±as, tickets de soporte, etc. \u0026#34;\u0026#34;\u0026#34; def __init__(self): # Almacena las frecuencias de palabras por categor√≠a self.palabras_por_categoria = defaultdict(Counter) # Almacena cu√°ntos tickets hay por categor√≠a self.tickets_por_categoria = defaultdict(int) # Lista de todas las categor√≠as conocidas self.categorias = set() # Vocabulario total (todas las palabras √∫nicas) self.vocabulario = set() def entrenar(self, datos): \u0026#34;\u0026#34;\u0026#34; Entrena el clasificador con ejemplos de texto etiquetados. Args: datos (list): Lista de tuplas cuyo primer valor es el contenido del ticket y el segundo valor, la categor√≠a correspondiente. \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;Entrenando clasificador con {len(datos)} ejemplos...\u0026#34;) pass # Ejemplo pr√°ctico: Clasificador de tickets de soporte if __name__ == \u0026#34;__main__\u0026#34;: # Datos de entrenamiento simulando tickets de soporte t√©cnico # Cada elemento de la lista contiene una tupla compuesta por # la descripci√≥n del ticket y la categor√≠a a la que pertenece. datos_de_entrenamiento = [ (\u0026#34;La aplicaci√≥n se cierra inesperadamente al hacer click en enviar\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;Error 500 al intentar subir archivo grande\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;El bot√≥n de guardar no funciona en Firefox\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;Pantalla en blanco despu√©s de iniciar sesi√≥n\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;Los datos no se actualizan correctamente en la tabla\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;Mensaje de error extra√±o al procesar el pago\u0026#34;, \u0026#34;BUG\u0026#34;), (\u0026#34;Ser√≠a genial poder exportar reportes a Excel\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Necesitamos filtros avanzados en el listado de productos\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Propongo agregar notificaciones push para mensajes\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Falta la opci√≥n de cambiar el idioma de la interfaz\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Queremos integraci√≥n con Google Calendar\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;Deber√≠amos tener dashboard personalizable para cada usuario\u0026#34;, \u0026#34;FEATURE\u0026#34;), (\u0026#34;C√≥mo puedo cambiar mi contrase√±a\u0026#34;, \u0026#34;SUPPORT\u0026#34;), (\u0026#34;No entiendo c√≥mo funciona el sistema de permisos\u0026#34;, \u0026#34;SUPPORT\u0026#34;), (\u0026#34;Necesito ayuda para configurar mi perfil\u0026#34;, \u0026#34;SUPPORT\u0026#34;), (\u0026#34;D√≥nde encuentro las estad√≠sticas de ventas\u0026#34;, \u0026#34;SUPPORT\u0026#34;), (\u0026#34;Instrucciones para conectar con la API\u0026#34;, \u0026#34;SUPPORT\u0026#34;), (\u0026#34;Tutorial para usar las funciones avanzadas\u0026#34;, \u0026#34;SUPPORT\u0026#34;) ] # Crear y entrenar el clasificador clasificador = ClasificadorTextoBasico() clasificador.entrenar(datos_de_entrenamiento) El clasificador almacena los siguientes datos:\npalabras_por_categoria: autom√°ticamente cuenta frecuencias de palabras que aparecen por categor√≠a tickets_por_categoria: la cantidad de tickets conocidos en cada categor√≠a. Necesario para calcular \\(P(\\text{categor√≠a})\\) categorias: listado de las categor√≠as conocidas vocabulario: conjunto de todas las palabras √∫nicas que hemos visto Preprocesamiento del texto # Antes de continuar, es necesario incluir una funci√≥n para preprocesar el texto. Los textos que escribimos pueden tener muchas variaciones, necesitamos convertirlo a una forma est√°ndar, sin distinciones entre may√∫sculas y min√∫sculas, signos de puntuaci√≥n, tildes, etc√©tera.\ndef preprocesar_texto(self, texto): \u0026#34;\u0026#34;\u0026#34; Limpia y tokeniza el texto de entrada. Args: texto (str): Texto a procesar Returns: list: Lista de palabras limpias en min√∫sculas \u0026#34;\u0026#34;\u0026#34; # Convertir a min√∫sculas texto = texto.lower() # Separa las letras de sus diacr√≠ticos texto = unicodedata.normalize(\u0026#39;NFD\u0026#39;, texto) # Elimina los caracteres de tipo marca diacr√≠tica (Mn), es decir, las tildes y di√©resis texto = \u0026#39;\u0026#39;.join(c for c in texto if unicodedata.category(c) != \u0026#39;Mn\u0026#39;) # Tokenizar (dividir en palabras) palabras = texto.split() # Filtrar palabras muy cortas palabras = [p for p in palabras if len(p) \u0026gt;= 3] return palabras ¬øPor qu√© estos pasos?\nMin√∫sculas: \u0026ldquo;Error\u0026rdquo; y \u0026ldquo;error\u0026rdquo; deben tratarse igual Sin puntuaci√≥n: Nos enfocamos en las palabras, no en la estructura Filtrar palabras cortas: \u0026ldquo;el\u0026rdquo;, \u0026ldquo;de\u0026rdquo;, \u0026ldquo;un\u0026rdquo; aportan poco valor discriminativo Entrenando el sistema # El siguiente paso, es entrenar el sistema con datos conocidos para que aprenda a cuando aplicar una categor√≠a u otra dependiendo del texto recibido. Durante el entrenamiento, el algoritmo \u0026ldquo;memoriza\u0026rdquo; qu√© palabras aparecen frecuentemente en cada categor√≠a, y las agrupa seg√∫n la categor√≠a dada. Por ejemplo, si vemos \u0026ldquo;error\u0026rdquo; en 10 tickets con la categor√≠a BUG y solo 1 perteneciente a FEATURE, el algoritmo aprende que \u0026ldquo;error\u0026rdquo; es una fuerte se√±al de BUG.\ndef entrenar(self, datos): \u0026#34;\u0026#34;\u0026#34; Entrena el clasificador con ejemplos de texto etiquetados. Args: datos (list): Lista de tuplas cuyo primer valor es el contenido del ticket y el segundo valor, la categor√≠a correspondiente. \u0026#34;\u0026#34;\u0026#34; for texto, categoria in datos: palabras = self.preprocesar_texto(texto) # Actualizar contadores self.categorias.add(categoria) self.tickets_por_categoria[categoria] += 1 # Contar frecuencia de cada palabra en esta categor√≠a for palabra in palabras: self.palabras_por_categoria[categoria][palabra] += 1 self.vocabulario.add(palabra) print(f\u0026#34;Entrenamiento completado:\u0026#34;) print(f\u0026#34; * Categor√≠as: {sorted(self.categorias)}\u0026#34;) print(f\u0026#34; * Vocabulario: {len(self.vocabulario)} palabras √∫nicas\u0026#34;) for cat in sorted(self.categorias): print(f\u0026#34; * \u0026#39;{cat}\u0026#39;: {self.tickets_por_categoria[cat]} tickets\u0026#34;) Hasta aqu√≠ obtendremos esto cuando ejecutamos el programa:\nEntrenando clasificador con 18 ejemplos... Entrenamiento completado: * Categor√≠as: [\u0026#39;BUG\u0026#39;, \u0026#39;FEATURE\u0026#39;, \u0026#39;SUPPORT\u0026#39;] * Vocabulario: 80 palabras √∫nicas * \u0026#39;BUG\u0026#39;: 6 tickets * \u0026#39;FEATURE\u0026#39;: 6 tickets * \u0026#39;SUPPORT\u0026#39;: 6 tickets C√°lculo de probabilidades # Aqu√≠ presentamos el coraz√≥n del algoritmo, realizaremos los c√°lculos de probabilidades por palabra que luego servir√°n para clasificar tickets.\ndef calcular_probabilidad_palabra(self, palabra, categoria): \u0026#34;\u0026#34;\u0026#34; Calcula P(palabra|categoria) usando suavizado de Laplace. El suavizado evita probabilidades de 0 para palabras no vistas. Args: palabra (str): Palabra a evaluar categoria (str): Categor√≠a a evaluar Returns: float: Probabilidad de la palabra dada la categor√≠a \u0026#34;\u0026#34;\u0026#34; # Frecuencia de la palabra en esta categor√≠a frecuencia_palabra = self.palabras_por_categoria[categoria][palabra] # Total de palabras en esta categor√≠a total_palabras_categoria = sum(self.palabras_por_categoria[categoria].values()) # Suavizado de Laplace: sumamos 1 al numerador y |vocabulario| al denominador # Esto evita probabilidades de 0 para palabras nuevas probabilidad = (frecuencia_palabra + 1) / (total_palabras_categoria + len(self.vocabulario)) return probabilidad ¬øQu√© es el suavizado de Laplace?\nCon las t√©cnicas de suavizado intentamos evitar las probabilidades cero producidas por palabras no vistas.\nSin suavizado, si una palabra nunca apareci√≥ en una categor√≠a, su probabilidad ser√≠a \\(0\\), y todo el c√°lculo se volver√≠a \\(0\\).\nCon la t√©cnica de suavizado de Laplace, agregamos \\(1\\) al numerador y el tama√±o del vocabulario al denominador. Esto da una probabilidad peque√±a pero no nula a palabras no vistas.\n$$P(\\text{palabra}|\\text{categor√≠a}) = \\frac{\\text{frecuencia} + 1}{\\text{palabras en categor√≠a} + \\text{tama√±o vocabulario}}$$ Clasificando nuevos tickets # Ahora s√≠ lleg√≥ el momento de inyectar nuevos tickets y dejar que el algoritmo los clasifique utilizando las probabilidades calculadas antes.\ndef clasificar(self, texto): \u0026#34;\u0026#34;\u0026#34; Clasifica un texto usando el teorema de Bayes. P(categoria|texto) ‚àù P(categoria) * ‚àèP(palabra|categoria) Args: texto (str): Texto a clasificar Returns: dict: Probabilidades por categor√≠a \u0026#34;\u0026#34;\u0026#34; palabras = self.preprocesar_texto(texto) # Calculamos log-probabilidades para evitar underflow # (multiplicar muchas probabilidades peque√±as da n√∫meros muy peque√±os) log_probabilidades = {} for categoria in sorted(self.categorias): # P(categoria) = tickets_categoria / total_tickets total_tickets = sum(self.tickets_por_categoria.values()) prob_categoria = self.tickets_por_categoria[categoria] / total_tickets # Empezamos con log(P(categoria)) log_prob = math.log(prob_categoria) # Multiplicamos por P(palabra|categoria) para cada palabra # En log-space: log(a*b) = log(a) + log(b) for palabra in palabras: prob_palabra = self.calcular_probabilidad_palabra(palabra, categoria) log_prob += math.log(prob_palabra) log_probabilidades[categoria] = log_prob # Convertir de vuelta a probabilidades normales # Usamos el truco: exp(log_prob - max_log_prob) para estabilidad num√©rica max_log_prob = max(log_probabilidades.values()) probabilidades = {} for categoria, log_prob in log_probabilidades.items(): probabilidades[categoria] = math.exp(log_prob - max_log_prob) # Normalizar para que sumen 1 total = sum(probabilidades.values()) for categoria in probabilidades: probabilidades[categoria] /= total return probabilidades Te estar√°s preguntando, ¬øpor qu√© usar logaritmos?, lo que sucede es que multiplicar muchas probabilidades peque√±as puede resultar en n√∫meros extremadamente peque√±os, esto puede conducir a lo que en computaci√≥n se denomina underflow. Esto significa que la computadora no puede representar un n√∫mero tan peque√±o y se pueden producir errores inesperados o excepciones.\nLos logaritmos transforman multiplicaciones en sumas y as√≠ evitamos el underflow.\n$$\\log(a \\times b \\times c) = \\log(a) + \\log(b) + \\log(c)$$ Probando el clasificador # Agregamos el siguiente c√≥digo a la funci√≥n main para ejecutar el clasificador en tickets diferentes utilizados en el entrenamiento.\n# Probar con tickets nuevos print(\u0026#34;\\n\\nPROBANDO CLASIFICADOR CON TICKETS NUEVOS:\u0026#34;) print(\u0026#34;=\u0026#34; * 60) tickets_prueba = [ \u0026#34;La pagina queda en blanco cuando cargo muchos productos\u0026#34;, \u0026#34;Me gustar√≠a poder ordenar la lista por fecha de creaci√≥n\u0026#34;, \u0026#34;No s√© c√≥mo resetear mi cuenta de usuario\u0026#34; ] for i, ticket in enumerate(tickets_prueba, 1): print(f\u0026#34;\\n#{i}: \u0026#39;{ticket}\u0026#39;\u0026#34;) resultados = clasificador.clasificar(ticket) # Mostrar probabilidades ordenadas for categoria, prob in sorted(resultados.items(), key=lambda x: x[1], reverse=True): print(f\u0026#34; {categoria}: {prob:.1%}\u0026#34;) # Mostrar predicci√≥n final mejor_categoria = max(resultados.items(), key=lambda x: x[1]) print(f\u0026#34; -\u0026gt; CLASIFICACI√ìN: {mejor_categoria[0]} ({mejor_categoria[1]:.1%} confianza)\u0026#34;) Obtenemos la siguiente respuesta:\nPROBANDO CLASIFICADOR CON TICKETS NUEVOS: ============================================================ #1: \u0026#39;La pagina queda en blanco cuando cargo muchos productos\u0026#39; BUG: 41.9% FEATURE: 32.6% SUPPORT: 25.5% -\u0026gt; CLASIFICACI√ìN: BUG (41.9% confianza) #2: \u0026#39;Me gustar√≠a poder ordenar la lista por fecha de creaci√≥n\u0026#39; FEATURE: 42.5% SUPPORT: 31.2% BUG: 26.4% -\u0026gt; CLASIFICACI√ìN: FEATURE (42.5% confianza) #3: \u0026#39;No s√© c√≥mo resetear mi cuenta de usuario\u0026#39; SUPPORT: 55.1% FEATURE: 28.5% BUG: 16.4% -\u0026gt; CLASIFICACI√ìN: SUPPORT (55.1% confianza) Entendiendo las decisiones (interpretabilidad) # Una ventaja clave de Naive Bayes es que podemos inspeccionar lo qu√© aprendi√≥:\ndef palabras_mas_representativas(self, n=10): \u0026#34;\u0026#34;\u0026#34; Encuentra las palabras que mejor distinguen entre categor√≠as. √ötil para entender lo que aprendi√≥ el modelo. \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\nTOP {n} PALABRAS M√ÅS REPRESENTATIVAS POR CATEGOR√çA:\u0026#34;) print(\u0026#34;=\u0026#34; * 60) for categoria in sorted(self.categorias): # Calculamos la \u0026#34;representatividad\u0026#34; de cada palabra # usando la frecuencia relativa en esta categor√≠a vs otras scores = {} for palabra in sorted(self.vocabulario): freq_categoria = self.palabras_por_categoria[categoria][palabra] total_categoria = sum(self.palabras_por_categoria[categoria].values()) # Frecuencia en otras categor√≠as freq_otras = 0 total_otras = 0 for otra_cat in self.categorias: if otra_cat != categoria: freq_otras += self.palabras_por_categoria[otra_cat][palabra] total_otras += sum(self.palabras_por_categoria[otra_cat].values()) if total_otras \u0026gt; 0: # Relaci√≥n de frecuencias relativas rel_freq_cat = (freq_categoria + 1) / (total_categoria + len(self.vocabulario)) rel_freq_otras = (freq_otras + 1) / (total_otras + len(self.vocabulario)) scores[palabra] = rel_freq_cat / rel_freq_otras # Mostrar palabras mas representativas top_palabras = sorted(scores.items(), key=lambda x: (-x[1], x[0]))[:n] print(f\u0026#34;\\n {categoria.upper()}:\u0026#34;) for palabra, score in top_palabras: print(f\u0026#34; ‚Ä¢ {palabra:\u0026lt;15} (score: {score:.2f})\u0026#34;) Esto nos muestra qu√© palabras son m√°s caracter√≠sticas de cada categor√≠a.\nDesde la funci√≥n main consultamos las palabras m√°s representativas.\n# Mostrar palabras m√°s representativas clasificador.palabras_mas_representativas(15) Obteniendo:\nTOP 15 PALABRAS M√ÅS REPRESENTATIVAS POR CATEGOR√çA: ============================================================ BUG: * error (score: 3.83) * actualizan (score: 2.55) * aplicacion (score: 2.55) * archivo (score: 2.55) * blanco (score: 2.55) * boton (score: 2.55) * cierra (score: 2.55) * click (score: 2.55) * correctamente (score: 2.55) * datos (score: 2.55) * despues (score: 2.55) * enviar (score: 2.55) * extrano (score: 2.55) * firefox (score: 2.55) * grande (score: 2.55) FEATURE: * agregar (score: 2.39) * avanzados (score: 2.39) * cada (score: 2.39) * calendar (score: 2.39) * dashboard (score: 2.39) * deberiamos (score: 2.39) * excel (score: 2.39) * exportar (score: 2.39) * falta (score: 2.39) * filtros (score: 2.39) * genial (score: 2.39) * google (score: 2.39) * idioma (score: 2.39) * integracion (score: 2.39) * interfaz (score: 2.39) SUPPORT: * como (score: 4.02) * avanzadas (score: 2.68) * ayuda (score: 2.68) * conectar (score: 2.68) * configurar (score: 2.68) * contrasena (score: 2.68) * donde (score: 2.68) * encuentro (score: 2.68) * entiendo (score: 2.68) * estadisticas (score: 2.68) * funciones (score: 2.68) * instrucciones (score: 2.68) * necesito (score: 2.68) * perfil (score: 2.68) * permisos (score: 2.68) An√°lisis y extensiones # ¬øPor qu√© se llama Naive (Ingenuo)? Porque asume que todas las palabras son independientes entre s√≠. En realidad, sabemos que esto no es cierto, \u0026ldquo;no funciona\u0026rdquo; tiene un significado diferente que \u0026ldquo;no\u0026rdquo; y \u0026ldquo;funciona\u0026rdquo; por separado.\nSin embargo, esta simplicidad es tambi√©n su fortaleza:\nEficiencia: requiere menos datos y c√≥mputo Robustez: funciona bien incluso cuando la suposici√≥n no se cumple perfectamente Interpretabilidad: f√°cil de entender y depurar Ventajas Limitaciones R√°pido de entrenar y clasificar Asume independencia de palabras Funciona bien con pocos datos Sensible a caracter√≠sticas irrelevantes Maneja bien m√∫ltiples categor√≠as Puede dar probabilidades mal calibradas Probabilidades interpretables No captura orden de palabras Resistente al sobreajuste Extensiones posibles # Una vez que domines este clasificador b√°sico, puedes explorar:\nN-gramas: Considerar procesar grupos de dos, tres o \\(N\\) palabras TF-IDF: Pesar palabras por su importancia relativa Validaci√≥n cruzada: Evaluar mejor el rendimiento Caracter√≠sticas adicionales: Longitud del texto, may√∫sculas, etc. ¬øQu√© aprendemos de este ejemplo? # El preprocesamiento es crucial: Limpiar y normalizar el texto afecta directamente la calidad del modelo.\nTeorema de Bayes en acci√≥n: Combinamos la probabilidad previa P(categor√≠a) con la evidencia P(palabras|categor√≠a).\nSuavizado de Laplace: T√©cnica esencial para manejar palabras que no vimos durante el entrenamiento.\nLog-probabilidades: Truco num√©rico para evitar underflow al multiplicar muchas probabilidades peque√±as.\nInterpretabilidad: Podemos entender qu√© palabras son m√°s importantes para cada categor√≠a.\nC√≥digo completo # Aqu√≠ tienes el c√≥digo completo del sistema. Tambi√©n puedes encontrarlo en el repositorio de ejemplos haciendo click en el siguiente enlace.\nlearn-software-engineering/examples Programming Course - Examples Python 1 0 Conclusi√≥n # ¬°Has construido tu primer clasificador de Machine Learning desde cero! Este clasificador Bayesiano Ingenuo (Naive Bayes) demuestra algunos conceptos fundamentales:\nAprendizaje supervisado: Aprender de ejemplos etiquetados Probabilidad: Cuantificar incertidumbre Generalizaci√≥n: Aplicar lo aprendido a casos nuevos Interpretabilidad: Entender las decisiones del modelo Aunque se vea simple, este tipo de clasificador se usa en aplicaciones reales como filtros de spam, an√°lisis de sentimientos, clasificaci√≥n de documentos, moderaci√≥n de contenido, entre otros.\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"26 agosto 2025","externalUrl":null,"permalink":"/ai/module1/sample2/","section":"Inteligencia Artificial","summary":"","title":"Machine Learning Ejemplo 2: Sistema de Clasificaci√≥n","type":"ai"},{"content":"In Object-Oriented Programming, classes don\u0026rsquo;t exist in isolation. They interact and relate to each other in various ways to model complex systems and relationships. Understanding these relationships is crucial for designing effective and maintainable object-oriented systems.\nThe main types of class relationships we\u0026rsquo;ll explore in depth are:\nAssociation (\u0026ldquo;uses-a\u0026rdquo;) Aggregation (weak \u0026ldquo;has-a\u0026rdquo; relationship) Composition (strong \u0026ldquo;has-a\u0026rdquo; relationship) Inheritance (\u0026ldquo;is-a\u0026rdquo; relationship) Realisation (Implementation) Dependency Each of these relationships represents a different way that classes can be connected and interact with each other. They vary in terms of the strength of the coupling between classes, the lifecycle dependencies, and the nature of the relationship.\nBefore we dive into each type of relationship, let\u0026rsquo;s visualise them using a UML class diagram:\nclassDiagram class ClassA class ClassB class ClassC class ClassD class ClassE class ClassF class InterfaceG ClassA --\u003e ClassB : Association ClassC o-- ClassD : Aggregation ClassE *-- ClassF : Composition ClassB --|\u003e ClassA : Inheritance ClassE ..|\u003e InterfaceG : Realisation ClassA ..\u003e ClassF : Dependency end This diagram provides a high-level overview of the different types of class relationships. In the following sections, we\u0026rsquo;ll explore each of these relationships in detail, providing explanations, examples, and more specific UML diagrams.\n","date":"07 diciembre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-introduction/","section":"Programming","summary":"","title":"Class relations","type":"programming"},{"content":"Un diccionario, o mapa, consiste en una colecci√≥n de pares clave-valor. La clave se utiliza para acceder al valor asociado. Las claves deben ser √∫nicas dentro de un diccionario. Los valores pueden repetirse.\nDiagrama de un diccionario Operaciones principales # A√±adir/actualizar: Inserta un par clave-valor. Si la clave exist√≠a, su valor es reemplazado. diccionario[\u0026#39;clave\u0026#39;] = \u0026#39;valor\u0026#39; Obtener valor: Acceder al valor dada una clave. valor = diccionario[\u0026#39;clave\u0026#39;] Eliminar: Remueve un par clave-valor del diccionario. del diccionario[\u0026#39;clave\u0026#39;] Recorrer: Iterar sobre las claves, valores o pares del diccionario. for clave in diccionario: print(clave, diccionario[clave]) # clave, valor Creaci√≥n de un diccionario o mapa # La sintaxis para crear mapas o diccionarios en Python es la siguiente:\ndiccionario_vacio = {} persona = { \u0026#39;nombre\u0026#39;: \u0026#39;Juan\u0026#39;, \u0026#39;edad\u0026#39;: 25 } Ejemplos de uso # Los diccionarios son √∫tiles en muchos casos. A continuaci√≥n se mencionan algunos de ellos.\nObjetos y mapeos # Podemos modelar objetos y entidades con atributos clave-valor:\nproducto = { \u0026#39;nombre\u0026#39;: \u0026#39;Smartphone\u0026#39;, \u0026#39;precio\u0026#39;: 500, \u0026#39;marca\u0026#39;: \u0026#39;XYZ\u0026#39; } Conteos y frecuencias # Contar ocurrencias de elementos en secuencias:\ntexto = \u0026#34;Hola mundo mundo\u0026#34; frecuencias = {} for palabra in texto.split(): if palabra in frecuencias: frecuencias[palabra] += 1 else: frecuencias[palabra] = 1 print(frecuencias) # {\u0026#39;Hola\u0026#39;: 1, \u0026#39;mundo\u0026#39;: 2} Almacenar y acceder a datos # Como alternativa de alta performance a lists y arrays.\nConclusi√≥n # Los diccionarios son estructuras de datos vers√°tiles gracias a su r√°pido acceso basado en claves √∫nicas. Tienen usos en casi todos los programas, por lo que dominar diccionarios es indispensable en cualquier lenguaje.\n¬°Felicitaciones por llegar hasta ac√°! Espero que este recorrido por el universo de la programaci√≥n te haya resultado tan interesante como lo fue para m√≠ al escribirlo.\nQueremos conocer tu opini√≥n, as√≠ que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro ten√©s.\nAdem√°s, para explorar m√°s all√° de estas l√≠neas, date una vuelta por los ejemplos pr√°cticos que armamos para vos. Todo el c√≥digo y los proyectos los encontrar√°s en nuestro repositorio de GitHub learn-software-engineering/examples.\nGracias por ser parte de esta comunidad de aprendizaje. ¬°Segu√≠ programando y explorando nuevas areas en este fascinante mundo del software!\n","date":"30 octubre 2023","externalUrl":null,"permalink":"/programming/data-structures/maps/","section":"Programaci√≥n","summary":"","title":"Mapas (Diccionarios)","type":"programming"},{"content":" Condiciones: tomando decisiones en el c√≥digo # La vida est√° llena de decisiones: \u0026ldquo;Si llueve, llevar√© un paraguas. De lo contrario, usar√© anteojos de sol\u0026rdquo;. Estas decisiones tambi√©n est√°n presentes en el mundo de la programaci√≥n. Las condiciones son como preguntas que la computadora se hace. Nos permiten tomar decisiones y ejecutar c√≥digo espec√≠fico dependiendo de una condici√≥n1. Pueden ser simples como \u0026ldquo;¬øEst√° lloviendo?\u0026rdquo; o complejas como \u0026ldquo;¬øEs fin de semana y tengo menos de $100 en mi cuenta bancaria?\u0026rdquo;.\nif # La estructura if nos permite evaluar condiciones y tomar decisiones basadas en el resultado de esa evaluaci√≥n.\nedad = 15 if edad \u0026gt;= 18: print(\u0026#34;Eres mayor de edad\u0026#34;) El c√≥digo anterior permite ejecutar una porci√≥n de c√≥digo si la edad de una persona es mayo o igual a 18 a√±os.\nif-else # Cuando se desea ejecutar un c√≥digo alternativo si la condici√≥n es falsa, utilizamos la estructura if-else\nedad = 21 if edad \u0026gt;= 18: print(\u0026#34;Eres mayor de edad\u0026#34;) else: print(\u0026#34;Eres menor de edad\u0026#34;) En este caso, se determina si la persona es mayor de edad, o menor de edad, el mensaje mostrado es diferente\nif-elif-else # Cuando las condiciones son m√∫ltiples y no es suficientes con dos caminos, se utiliza la estructura if-elif-else para evaluarlas forma encadenada.\nedad = 5 if edad \u0026lt;= 13: print(\u0026#34;Eres un ni√±o\u0026#34;) elif edad \u0026gt; 13 and edad \u0026lt; 18: print(\u0026#34;Eres un adolescente\u0026#34;) else: print(\u0026#34;Eres un adulto\u0026#34;) En el c√≥digo anterior se observan tres caminos claros, uno para cuando la edad es menor o igual a 13 a√±os, otro para cuando la edad esta entre 13 y 18 y otro para cuando es mayor o igual a 18.\nOtra manera de resolver este problema es mediante la estructura switch-case, que, aunque Python no incorpora de manera nativa, como si lo hacen otros lenguajes como Java o C++, es una herramienta importante para conocer. Esta estructura permite a los programadores manejar m√∫ltiples condiciones de manera m√°s organizada que una serie de if-elif-else.\nEn Java, por ejemplo:\nint dia = 3; switch(dia) { case 1: System.out.println(\u0026#34;Lunes\u0026#34;); break; case 2: System.out.println(\u0026#34;Martes\u0026#34;); break; case 3: System.out.println(\u0026#34;Mi√©rcoles\u0026#34;); break; // ... y as√≠ sucesivamente default: System.out.println(\u0026#34;D√≠a no v√°lido\u0026#34;); } En el ejemplo anterior, dependiendo del valor de dia, se imprimir√° el d√≠a correspondiente2.\nBucles: repitiendo acciones # A veces, en programaci√≥n, necesitamos repetir una acci√≥n varias veces. En lugar de escribir el mismo c√≥digo varias veces, podemos usar bucles. Estos, permiten repetir la ejecuci√≥n de un bloque de c√≥digo mientras se cumpla una condici√≥n3.\nwhile # El bucle while es √∫til cuando queremos repetir una acci√≥n basada en una condici√≥n.\n# Imprime del 1 al 5 i = 1 while i \u0026lt;= 5: print(i) i = i + 1 do-while # Similar a while pero garantiza al menos una ejecuci√≥n dado que primero se ejecuta el bloque de c√≥digo y luego se eval√∫a la condici√≥n. Python no implementa esta estructura, pero otros lenguajes como Java y C++ s√≠ lo hacen.\nint i = 1; do { System.out.println(i); i++; } while(i \u0026lt;= 5); int numero = 0; do { std::cout \u0026lt;\u0026lt; \u0026#34;Hola, mundo!\u0026#34; \u0026lt;\u0026lt; std::endl; numero++; } while (numero \u0026lt; 5); for # El bucle for es √∫til cuando sabemos cu√°ntas veces queremos repetir una acci√≥n.\nfor i in range(5): print(\u0026#34;Hola, mundo!\u0026#34;) El c√≥digo anterior imprimir√° \u0026ldquo;Hola, mundo!\u0026rdquo; cinco veces.\nTambi√©n podemos iterar sobre los elementos de una lista u objeto iterable:\nnombres = [\u0026#34;Mar√≠a\u0026#34;, \u0026#34;Florencia\u0026#34;, \u0026#34;Juli√°n\u0026#34;] for nombre in nombres: print(f\u0026#34;Hola {nombre}\u0026#34;) # Imprime # Hola Mar√≠a # Hola Florencia # Hola Juli√°n Las sentencias break y continue # Podemos usar break para terminar el bucle y continue para saltar a la siguiente iteraci√≥n.\nEl break se usa para terminar completamente el bucle cuando se cumple una condici√≥n, en el ejemplo siguiente, cuando i llega a 5.\n# Ejemplo de break i = 0 while i \u0026lt; 10: print(i) if i == 5: break i += 1 # Imprime: # 0 # 1 # 2 # 3 # 4 # 5 El continue se usa para saltarse una iteraci√≥n del bucle y continuar con la siguiente cuando se cumple una condici√≥n. Aqu√≠ lo usamos para saltarnos los n√∫meros pares.\n# Ejemplo de continue i = 0 while i \u0026lt; 10: i += 1 if i % 2 == 0: continue print(i) # Imprime: # 1 # 3 # 5 # 7 # 9 Anidamiento: combinando estructuras # Las estructuras de control de flujo pueden anidarse dentro de otras. Por ejemplo, podemos tener bucles dentro de bucles o condiciones dentro de bucles.\nfor i in range(5): for j in range(10): if (i % 2 == 0 and j % 3 == 0): print(f\u0026#34;i = {i}, j = {j}\u0026#34;) Este c√≥digo imprimir√° combinaciones de i y j s√≥lo cuando i sea divisible por 2 y j sea divisible por 3, demostrando c√≥mo los bucles se anidan y se ejecutan3.\nPatrones de uso comunes # Existen patrones espec√≠ficos para resolver necesidades habituales con control de flujo.\nB√∫squeda # Buscar un valor en una colecci√≥n:\nfrutas = [\u0026#34;manzana\u0026#34;, \u0026#34;naranja\u0026#34;] buscando = \u0026#34;naranja\u0026#34; encontrado = False for fruta in frutas: if fruta == buscando: encontrado = True break if encontrado: print(\u0026#34;Fruta encontrada!\u0026#34;) Acumulaci√≥n # Acumular valores incrementales en un bucle.\ntotal = 0 for i in range(10): total += i print(total) # Suma de 0..9 = 45 Diagramas de flujo: la ruta visual hacia el entendimiento del c√≥digo # Los programadores, sin importar si son principiantes o expertos, a menudo se encuentran enfrentando desaf√≠os que requieren una planificaci√≥n detallada antes de sumergirse en el c√≥digo. Aqu√≠ es donde los diagramas de flujo entran en juego como una herramienta esencial. Estos diagramas son representaciones gr√°ficas de los procesos y la l√≥gica detr√°s de un programa o sistema. En este art√≠culo, desentra√±aremos el mundo de los diagramas de flujo, desde sus conceptos b√°sicos hasta las t√©cnicas avanzadas, y c√≥mo pueden beneficiar a programadores de todos los niveles.\nUn diagrama de flujo es una representaci√≥n gr√°fica de un proceso. Utiliza s√≠mbolos espec√≠ficos para representar diferentes tipos de instrucciones o acciones. Su objetivo principal es simplificar la comprensi√≥n de un proceso, mostrando paso a paso c√≥mo fluye la informaci√≥n o las decisiones. Estos diagramas:\nFacilitan la comprensi√≥n de procesos complejos. Ayudan en la fase de dise√±o y planificaci√≥n de un programa. Sirven como documentaci√≥n y referencia para futuros desarrollos. Los diagramas de flujo son una herramienta poderosa que no solo beneficia a los principiantes, sino tambi√©n a los programadores experimentados. Ofrecen una visi√≥n clara y estructurada de un proceso o programa, facilitando la planificaci√≥n, el dise√±o y la comunicaci√≥n entre los miembros del equipo.\nElementos b√°sicos # Los diagramas de flujo constan de varios s√≠mbolos, cada uno con un significado espec√≠fico:\nOvalo: Representa el inicio o el fin de un proceso. Rect√°ngulo: Denota una operaci√≥n o instrucci√≥n. Diamante: Indica una decisi√≥n basada en una condici√≥n. Flechas: Muestran la direcci√≥n del flujo. graph TD; start((Inicio)) process[Proceso] decision{¬øRepetir?} final((Final)) start --\u003e process; process --\u003e decision; decision --\u003e |Si| process decision --\u003e |No| final end Ejemplos # Vamos a dise√±ar un diagrama de flujo para un programa que pida un n√∫mero y nos diga si es par o impar.\ngraph TB inicio((Inicio)) entrada[Ingresar n√∫mero] decision{¬øEs par?} esPar[Es par] esImpar[Es impar] final((Final)) inicio --\u003e entrada entrada --\u003e decision decision --\u003e |Si| esPar decision --\u003e |No| esImpar esPar --\u003e final esImpar --\u003e final end Conforme los programas se vuelven m√°s complejos, es posible que necesites incorporar bucles, m√∫ltiples condiciones y otros elementos avanzados en tu diagrama de flujo. Por ejemplo, aqu√≠ diagramamos un programa que sume los n√∫meros desde el 1 al n√∫mero ingresado por el usuario.\ngraph TD inicio((Inicio)) entrada[Ingresar n√∫mero] setVariables[Establecer suma=0 y contador=1] bucle_condicion{¬øcontador \u003c= N?} bucle_codigo[Sumar valor e incrementar el contador] resultado[Mostrar suma] final((Final)) inicio --\u003e entrada entrada --\u003e setVariables setVariables --\u003e bucle_condicion bucle_condicion --\u003e |Si| bucle_codigo bucle_codigo --\u003e bucle_condicion bucle_condicion --\u003e |No| resultado resultado --\u003e final end Conclusi√≥n # El control de flujo es el coraz√≥n de la programaci√≥n. Sin √©l, los programas ser√≠an secuencias lineales de acciones sin la capacidad de tomar decisiones o repetir tareas. Al dominar estas estructuras, no solo mejoras tu capacidad para escribir c√≥digo, sino tambi√©n tu capacidad para pensar l√≥gicamente y resolver problemas complejos.\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\nReferencias # Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDeitel, P., \u0026amp; Deitel, H. (2012). Java: How to program. Upper Saddle River, NJ: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMatthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. San Francisco, CA: No Starch Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"27 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/flow-control-structures/","section":"Programaci√≥n","summary":"","title":"Control de Flujo","type":"programming"},{"content":" El sistema decimal: la base de nuestra cotidianidad # Desde peque√±os, nos ense√±an a contar usando diez d√≠gitos: del 0 al 9. Este sistema, conocido como decimal, es la base de casi todas nuestras actividades matem√°ticas y financieras, desde sumar cuentas hasta calcular intereses en el banco1. Tiene su origen en la cantidad de dedos que tenemos en las manos, lo que lo convierte en el sistema m√°s intuitivo y natural para nosotros. Pero lo que lo hace especial es su naturaleza posicional.\nPara comprender este concepto, consideremos el n√∫mero 237:\nEl 7, situado a la derecha, est√° en la posici√≥n de las unidades. Es decir, \\(7 \\times 10^0\\) (cualquier n√∫mero elevado a la potencia de 0 es 1). Por lo tanto, su valor es simplemente 7. El 3, en la posici√≥n del medio, representa las decenas, es decir, \\(3 \\times 10^1 = 3 \\times 10 = 30\\). El 2, el n√∫mero m√°s a la izquierda, est√° en la posici√≥n de las centenas, traduci√©ndose a \\(2 \\times 10^2 = 2 \\times 100 = 200\\). Si sumamos estos valores,\n2 \\times 10^2 + 3 \\times 10^1 + 7 \\times 10^0 = 200 + 30 + 7 = 237 El sistema binario: el lenguaje secreto de las computadoras # Si bien el sistema decimal domina nuestra vida cotidiana, las m√°quinas que usamos todos los d√≠as, desde nuestros celulares hasta las computadoras, operan en un mundo completamente diferente: el mundo binario. En este sistema, solo existen dos d√≠gitos: 0 y 1. A primera vista, puede parecer limitante, pero este sistema es la esencia de la electr√≥nica digital. Los dispositivos electr√≥nicos, con sus millones de transistores, operan usando estos dos estados: encendido (1) y apagado (0)2.\nA pesar de su aparente simplicidad, el sistema binario puede representar cualquier cantidad o informaci√≥n que el sistema decimal pueda expresar. Por ejemplo, el n√∫mero decimal 5 se representa como 101 en binario.\nEl sistema binario, con sus unos y ceros, opera de manera similar al sistema decimal, pero en lugar de potencias de 10, usa potencias de 2.\nTomemos el n√∫mero binario 1011:\nEl bit m√°s a la derecha representa \\(1 \\times 2^0 = 1\\) El siguiente bit representa \\(1 \\times 2^1 = 2\\) Luego viene \\(0 \\times 2^2 = 0\\) El bit m√°s a la izquierda en este n√∫mero representa \\(1 \\times 2^3 = 8\\) Entonces, 1011 en binario se traduce a decimal de la siguiente manera:\n1011 = 1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 = 8 + 0 + 2 + 1 = 11 El sistema hexadecimal: un puente entre humanos y m√°quinas # Mientras que el sistema binario es perfecto para las m√°quinas, puede ser un poco engorroso para nosotros, especialmente cuando tratamos con n√∫meros binarios largos. Aqu√≠ es donde entra el sistema hexadecimal, que utiliza diecis√©is d√≠gitos distintos: 0-9 y A-F, donde A representa 10, B es 11, y as√≠ sucesivamente hasta F que es 153.\nEl hexadecimal es especialmente √∫til porque proporciona una forma m√°s compacta de representar n√∫meros binarios. Cada d√≠gito hexadecimal corresponde a exactamente cuatro d√≠gitos binarios (bits). Por ejemplo pensemos en la representaci√≥n en binario del n√∫mero 41279 y como el sistema hexadecimal consigue una representaci√≥n m√°s compacta:\n41279 = 1010 0001 0011 1111 = A13F Pero el sistema hexadecimal es m√°s que una representaci√≥n compacta de n√∫meros binarios, es un sistema de numeraci√≥n posicional como el decimal o binario con base 16 en lugar de 10 o 2. Veamos como conseguir la representaci√≥n decimal del n√∫mero del ejemplo anterior (A13F).\nEl d√≠gito m√°s a la derecha representa \\(F \\times 16^0 = 15 \\times 16^0 = 15\\) El siguiente representa \\(3 \\times 16^1 = 48\\) Luego viene \\(1 \\times 16^2 = 256\\) El d√≠gito m√°s a la izquierda en este n√∫mero representa \\(A \\times 16^3 = 10 \\times 16^3 = 40960\\) Entonces, A13F en hexadecimal se traduce a decimal de la siguiente manera:\nA13F = A \\times 16^3 + 1 \\times 16^2 + 3 \\times 16^1 + F \\times 16^0 = 10 \\times 4096 + 1 \\times 256 + 3 \\times 16 + 15 \\times 1 = 40960 + 256 + 48 + 15 = 41279 Conclusi√≥n # Los sistemas de numeraci√≥n son como lentes a trav√©s de los cuales vemos y entendemos el mundo de las matem√°ticas y la computaci√≥n. Aunque en nuestra vida diaria el sistema decimal sea el rey, es esencial apreciar y comprender los sistemas binario y hexadecimal, especialmente en esta era digital.\nAs√≠ que, la pr√≥xima vez que est√©s frente a tu computadora o usando una app en tu celular, record√° que detr√°s de esa interfaz amigable, hay un mundo binario en pleno funcionamiento, y que el sistema hexadecimal act√∫a como un traductor entre ese mundo y nosotros.\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\nReferencias # Ifrah, G. (2000). Historia universal de las cifras. Buenos Aires: Editorial Taurus.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A. (2012). Estructura de Computadoras. Buenos Aires: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKnuth, D. (2007). El Arte de Programar Computadoras: Sistemas de numeraci√≥n. Buenos Aires: Ediciones Omega.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"05 septiembre 2023","externalUrl":null,"permalink":"/programming/intro/numeral-systems/","section":"Programaci√≥n","summary":"","title":"Sistemas de Numeraci√≥n","type":"programming"},{"content":"","externalUrl":null,"permalink":"/programming/oop/","section":"Programaci√≥n","summary":"","title":"Programaci√≥n Orientada a Objetos","type":"programming"},{"content":" Para consolidar todo lo aprendido, vamos a crear un sistema de recomendaciones usando reglas l√≥gicas. Este tipo de sistema es com√∫n en e-commerce, plataformas de contenido y aplicaciones m√≥viles. Problema a resolver # Eres un ingeniero de software trabajando para una empresa de e-commerce que necesita implementar un sistema de recomendaciones para mejorar la experiencia de sus usuarios y aumentar las ventas.\nTu misi√≥n es desarrollar un sistema que pueda sugerir productos relevantes a los usuarios bas√°ndose en:\nSu perfil demogr√°fico (edad, ubicaci√≥n, intereses) Su historial de compras y navegaci√≥n El comportamiento de usuarios similares Caracter√≠sticas de los productos Reglas espec√≠ficas del negocio Datos disponibles # Para el desarrollo del sistema tenemos preparados un conjunto de datos que pod√©s usar para verificar el funcionamiento de tu c√≥digo.\nUsuarios: datos/usuarios.json\nDatos demogr√°ficos: edad, g√©nero, ubicaci√≥n Intereses: lista de categor√≠as preferidas Nivel de gasto: bajo, medio, alto Historial de actividad: compras, visualizaciones, ratings Productos: datos/productos.json\nInformaci√≥n b√°sica: nombre, categor√≠a, precio M√©tricas de calidad: rating promedio, popularidad Metadatos: tags descriptivos, p√∫blico objetivo Caracter√≠sticas comerciales: disponibilidad, promociones Interacciones: datos/interacciones.json\nTipos de interacci√≥n: compra, visualizaci√≥n, rating, wishlist Datos temporales: fecha y hora Valoraciones: puntuaciones de 1-5 estrellas Contexto: dispositivo, ubicaci√≥n, sesi√≥n Requerimientos Funcionales # Calcular similitud entre usuarios ENTRADA: ID de usuario PROCESO: Calcular similitud con otros usuarios bas√°ndose en: - Productos en com√∫n que han comprado o visto - Similitud demogr√°fica (edad, g√©nero, ubicaci√≥n) - Intereses compartidos SALIDA: Lista de usuarios similares ordenada por similitud Generar recomendaciones por filtrado colaborativo ENTRADA: ID de usuario, n√∫mero de recomendaciones deseadas PROCESO: - Encontrar usuarios similares - Identificar productos que les gustaron a esos usuarios - Filtrar productos ya conocidos por el usuario objetivo - Puntuar por similitud de usuarios y ratings SALIDA: Lista de productos recomendados con scores Generar recomendaciones por contenido ENTRADA: ID de usuario, n√∫mero de recomendaciones deseadas PROCESO: - Analizar perfil del usuario (intereses, demograf√≠a) - Evaluar cada producto por compatibilidad: * Matching con intereses del usuario * Adecuaci√≥n por edad y demograf√≠a * Calidad del producto (rating, popularidad) * Precio apropiado para nivel de gasto SALIDA: Lista de productos recomendados con scores Procesar reglas de negocio ENTRADA: Usuario, lista de recomendaciones preliminares PROCESO: Aplicar reglas como: - Boost a productos tech para usuarios j√≥venes - Promocionar productos premium a usuarios de gasto alto - Priorizar productos econ√≥micos para presupuesto bajo - Aplicar preferencias regionales SALIDA: Recomendaciones ajustadas por reglas de negocio Generar explicaciones para las recomendaciones ENTRADA: Usuario, producto recomendado PROCESO: Generar explicaci√≥n legible de por qu√© se recomienda: - \u0026#34;Coincide con tus intereses en tecnolog√≠a\u0026#34; - \u0026#34;A usuarios similares tambi√©n les gust√≥\u0026#34; - \u0026#34;Excelente rating (4.8/5)\u0026#34; - \u0026#34;Precio apropiado para tu perfil\u0026#34; SALIDA: Lista de razones explicativas M√©tricas de evaluaci√≥n # Eval√∫a tu sistema considerando:\nPrecisi√≥n\n¬øLas recomendaciones son relevantes para cada usuario? ¬øEvita recomendar productos ya conocidos? Diversidad\n¬øOfrece variedad de categor√≠as y precios? ¬øEvita el sesgo hacia productos populares √∫nicamente? Explicabilidad\n¬øLas razones son claras y convincentes? Eficiencia\n¬øResponde en tiempo razonable? Soluci√≥n # Haciendo click en el siguiente enlace, puedes encontrar una posible soluci√≥n para este problema. Incluye explicaciones detalladas.\n¬°Intent√° resolverlo por tu cuenta primero! üòÄüòÄüòÄ Ejecuci√≥n # Aqu√≠ hay algunos ejemplos de ejecuci√≥n:\nDemostraci√≥n completa # \u0026gt; python main.py Selecciona el tipo de demostraci√≥n: 1- Demostraci√≥n completa 2- Comparaci√≥n de algoritmos 3- Usuario espec√≠fico Opci√≥n (1-3): 1 Sistema de Recomendaciones - Demostraci√≥n Completa ================================================== Cargando la configuraci√≥n desde config.yaml Configuraci√≥n cargada desde config.yaml Configuraci√≥n validada exitosamente Inicializando Sistema de Recomendaciones * 6 usuarios cargados * 12 productos cargados * 22 interacciones cargadas Sistema listo! ======================== Estad√≠sticas del Sistema ======================== Analizando sistema Usuarios: 6 * Por g√©nero: {\u0026#39;F\u0026#39;: 3, \u0026#39;M\u0026#39;: 3} * Por ubicaci√≥n: {\u0026#39;Buenos Aires\u0026#39;: 2, \u0026#39;C√≥rdoba\u0026#39;: 1, \u0026#39;Rosario\u0026#39;: 1, \u0026#39;Mendoza\u0026#39;: 1, \u0026#39;La Plata\u0026#39;: 1} * Por nivel de gasto: {\u0026#39;medio\u0026#39;: 3, \u0026#39;alto\u0026#39;: 2, \u0026#39;bajo\u0026#39;: 1} * Edad promedio: 31.5 a√±os Productos: 12 * Por categor√≠a: {\u0026#39;tecnologia\u0026#39;: 4, \u0026#39;lectura\u0026#39;: 2, \u0026#39;gaming\u0026#39;: 2, \u0026#39;hogar\u0026#39;: 1, \u0026#39;fitness\u0026#39;: 2, \u0026#39;cocina\u0026#39;: 1} * Precio promedio: $37,950 * Calificaci√≥n promedio: 4.36/5 Interacciones: 22 * Por tipo: {\u0026#39;compra\u0026#39;: 11, \u0026#39;view\u0026#39;: 9, \u0026#39;wishlist\u0026#39;: 2} * Por usuario: {\u0026#39;user_001\u0026#39;: 4, \u0026#39;user_002\u0026#39;: 4, \u0026#39;user_003\u0026#39;: 4, \u0026#39;user_004\u0026#39;: 4, \u0026#39;user_005\u0026#39;: 3, \u0026#39;user_006\u0026#39;: 3} * Usuarios activos: 6 Similitudes: * Promedio: 0.162 * M√°xima: 0.398 * M√≠nima: 0.000 ============================= Reporte Detallado - ANA L√ìPEZ ============================= Perfil del usuario * Edad: 28 a√±os * G√©nero: F * Ubicaci√≥n: Buenos Aires * Intereses: tecnologia, fitness, lectura * Nivel de gasto: medio Historial de actividad (4 interacciones): ‚Ä¢ 2024-08-17: WISHLIST - C√°mara DSLR Canon EOS Rebel T7 ‚Ä¢ 2024-08-10: COMPRA - Prote√≠na Whey Gold Standard (Calificaci√≥n: 4/5) ‚Ä¢ 2024-08-05: VIEW - Auriculares Bluetooth Sport Pro ‚Ä¢ 2024-08-01: COMPRA - Smartphone Samsung Galaxy S24 (Calificaci√≥n: 5/5) 3 usuarios m√°s similares * Diego Silva: 0.398 (39.8% similar) * Roberto Garc√≠a: 0.322 (32.2% similar) * Laura Mart√≠nez: 0.246 (24.6% similar) Generando recomendaciones para Ana L√≥pez ======================================== Aplicando filtrado colaborativo para Ana L√≥pez... Usuarios similares encontrados: 5 6 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Ana L√≥pez... 8 recomendaciones por contenido generadas Combinando estrategias de recomendaci√≥n * Productos √∫nicos despu√©s de combinar: 8 Aplicando reglas de negocio * Los usuarios j√≥venes (\u0026lt;35) prefieren productos tecnol√≥gicos: 1 productos afectados 1 reglas aplicadas: boost_tecnologia_jovenes Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Tablet Samsung Galaxy Tab S9 Precio: $95,000 Calificaci√≥n: 4.4/5 Puntuaci√≥n: 3.214 Explicaci√≥n: Te gusta la categor√≠a tecnologia; Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoraci√≥n (4.4/5); Producto muy popular #2 - Set Pesas Ajustables 40kg Precio: $15,000 Calificaci√≥n: 4.1/5 Puntuaci√≥n: 3.179 Explicaci√≥n: Coincide con tu inter√©s en fitness; Te gusta la categor√≠a fitness; Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoraci√≥n (4.1/5); A usuarios con perfil similar tambi√©n les gust√≥ #3 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificaci√≥n: 4.5/5 Puntuaci√≥n: 2.808 Explicaci√≥n: Coincide con tu inter√©s en tecnologia; Te gusta la categor√≠a lectura; Apropiado para tu grupo de edad; Excelente valoraci√≥n (4.5/5) #4 - Libro: Cocina Mediterr√°nea Saludable Precio: $3,500 Calificaci√≥n: 4.8/5 Puntuaci√≥n: 2.14 Explicaci√≥n: Te gusta la categor√≠a lectura; Apropiado para tu grupo de edad; Excelente valoraci√≥n (4.8/5) #5 - Cafetera Espresso DeLonghi Precio: $32,000 Calificaci√≥n: 4.2/5 Puntuaci√≥n: 1.792 Explicaci√≥n: Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoraci√≥n (4.2/5); A usuarios con perfil similar tambi√©n les gust√≥ ================================= Reporte Detallado - CARLOS MENDEZ ================================= Perfil del usuario * Edad: 35 a√±os * G√©nero: M * Ubicaci√≥n: C√≥rdoba * Intereses: deportes, gaming, musica * Nivel de gasto: alto Historial de actividad (4 interacciones): ‚Ä¢ 2024-08-18: VIEW - Tablet Samsung Galaxy Tab S9 ‚Ä¢ 2024-08-12: COMPRA - Auriculares Gaming HyperX Cloud III (Calificaci√≥n: 5/5) ‚Ä¢ 2024-08-07: VIEW - Smartphone Samsung Galaxy S24 ‚Ä¢ 2024-08-03: COMPRA - Juego: Call of Duty Modern Warfare III (Calificaci√≥n: 4/5) 3 usuarios m√°s similares * Roberto Garc√≠a: 0.192 (19.2% similar) * Laura Mart√≠nez: 0.168 (16.8% similar) * Diego Silva: 0.120 (12.0% similar) Generando recomendaciones para Carlos Mendez ============================================ Aplicando filtrado colaborativo para Carlos Mendez... Usuarios similares encontrados: 5 6 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Carlos Mendez... 8 recomendaciones por contenido generadas Combinando estrategias de recomendaci√≥n * Productos √∫nicos despu√©s de combinar: 8 Aplicando reglas de negocio * Usuarios con gasto alto ven productos premium primero: 8 productos afectados 1 reglas aplicadas: usuarios_premium Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Auriculares Bluetooth Sport Pro Precio: $25,000 Calificaci√≥n: 4.2/5 Puntuaci√≥n: 2.392 Explicaci√≥n: Coincide con tu inter√©s en deportes; Apropiado para tu grupo de edad; Buena valoraci√≥n (4.2/5); Producto muy popular #2 - C√°mara DSLR Canon EOS Rebel T7 Precio: $85,000 Calificaci√≥n: 4.3/5 Puntuaci√≥n: 1.949 Explicaci√≥n: Apropiado para tu grupo de edad; Producto premium que se ajusta a tu perfil; Buena valoraci√≥n (4.3/5) #3 - Prote√≠na Whey Gold Standard Precio: $7,200 Calificaci√≥n: 4.6/5 Puntuaci√≥n: 1.697 Explicaci√≥n: Apropiado para tu grupo de edad; Excelente valoraci√≥n (4.6/5); Producto muy popular #4 - Cafetera Espresso DeLonghi Precio: $32,000 Calificaci√≥n: 4.2/5 Puntuaci√≥n: 1.689 Explicaci√≥n: Apropiado para tu grupo de edad; Buena valoraci√≥n (4.2/5) #5 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificaci√≥n: 4.5/5 Puntuaci√≥n: 1.633 Explicaci√≥n: Apropiado para tu grupo de edad; Excelente valoraci√≥n (4.5/5) =================================== Reporte Detallado - MAR√çA RODRIGUEZ =================================== Perfil del usuario * Edad: 42 a√±os * G√©nero: F * Ubicaci√≥n: Rosario * Intereses: cocina, jardineria, arte * Nivel de gasto: bajo Historial de actividad (4 interacciones): ‚Ä¢ 2024-08-20: VIEW - C√°mara DSLR Canon EOS Rebel T7 ‚Ä¢ 2024-08-15: COMPRA - Cafetera Espresso DeLonghi (Calificaci√≥n: 3/5) ‚Ä¢ 2024-08-06: VIEW - Kit Herramientas Jard√≠n Premium ‚Ä¢ 2024-08-02: COMPRA - Libro: Cocina Mediterr√°nea Saludable (Calificaci√≥n: 5/5) 3 usuarios m√°s similares * Roberto Garc√≠a: 0.193 (19.3% similar) * Laura Mart√≠nez: 0.120 (12.0% similar) * Ana L√≥pez: 0.060 (6.0% similar) Generando recomendaciones para Mar√≠a Rodriguez ============================================== Aplicando filtrado colaborativo para Mar√≠a Rodriguez... Usuarios similares encontrados: 5 7 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Mar√≠a Rodriguez... 8 recomendaciones por contenido generadas Combinando estrategias de recomendaci√≥n * Productos √∫nicos despu√©s de combinar: 8 Aplicando reglas de negocio * Usuarios con presupuesto bajo ven productos econ√≥micos: 2 productos afectados 1 reglas aplicadas: productos_economicos Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Prote√≠na Whey Gold Standard Precio: $7,200 Calificaci√≥n: 4.6/5 Puntuaci√≥n: 2.432 Explicaci√≥n: Apropiado para tu grupo de edad; Precio econ√≥mico y accesible; Excelente valoraci√≥n (4.6/5); Producto muy popular #2 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificaci√≥n: 4.5/5 Puntuaci√≥n: 2.313 Explicaci√≥n: Apropiado para tu grupo de edad; Precio econ√≥mico y accesible; Excelente valoraci√≥n (4.5/5) #3 - Set Pesas Ajustables 40kg Precio: $15,000 Calificaci√≥n: 4.1/5 Puntuaci√≥n: 1.588 Explicaci√≥n: Apropiado para tu grupo de edad; Precio econ√≥mico y accesible; Buena valoraci√≥n (4.1/5) #4 - Smartphone Samsung Galaxy S24 Precio: $150,000 Calificaci√≥n: 4.5/5 Puntuaci√≥n: 1.572 Explicaci√≥n: Apropiado para tu grupo de edad; Excelente valoraci√≥n (4.5/5); Producto muy popular #5 - Tablet Samsung Galaxy Tab S9 Precio: $95,000 Calificaci√≥n: 4.4/5 Puntuaci√≥n: 1.352 Explicaci√≥n: Apropiado para tu grupo de edad; Buena valoraci√≥n (4.4/5); Producto muy popular =============================== Reporte Detallado - DIEGO SILVA =============================== Perfil del usuario * Edad: 24 a√±os * G√©nero: M * Ubicaci√≥n: Buenos Aires * Intereses: tecnologia, gaming, fitness * Nivel de gasto: medio Historial de actividad (4 interacciones): ‚Ä¢ 2024-08-19: WISHLIST - Smartphone Samsung Galaxy S24 ‚Ä¢ 2024-08-14: COMPRA - Set Pesas Ajustables 40kg (Calificaci√≥n: 4/5) ‚Ä¢ 2024-08-08: VIEW - Juego: Call of Duty Modern Warfare III ‚Ä¢ 2024-08-04: COMPRA - Auriculares Bluetooth Sport Pro (Calificaci√≥n: 4/5) 3 usuarios m√°s similares * Ana L√≥pez: 0.398 (39.8% similar) * Roberto Garc√≠a: 0.310 (31.0% similar) * Carlos Mendez: 0.120 (12.0% similar) Generando recomendaciones para Diego Silva ========================================== Aplicando filtrado colaborativo para Diego Silva... Usuarios similares encontrados: 5 5 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Diego Silva... 8 recomendaciones por contenido generadas Combinando estrategias de recomendaci√≥n * Productos √∫nicos despu√©s de combinar: 8 Aplicando reglas de negocio * Los usuarios j√≥venes (\u0026lt;35) prefieren productos tecnol√≥gicos: 2 productos afectados 1 reglas aplicadas: boost_tecnologia_jovenes Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Tablet Samsung Galaxy Tab S9 Precio: $95,000 Calificaci√≥n: 4.4/5 Puntuaci√≥n: 3.214 Explicaci√≥n: Te gusta la categor√≠a tecnologia; Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoraci√≥n (4.4/5); Producto muy popular #2 - C√°mara DSLR Canon EOS Rebel T7 Precio: $85,000 Calificaci√≥n: 4.3/5 Puntuaci√≥n: 3.151 Explicaci√≥n: Te gusta la categor√≠a tecnologia; Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoraci√≥n (4.3/5) #3 - Auriculares Gaming HyperX Cloud III Precio: $18,000 Calificaci√≥n: 4.4/5 Puntuaci√≥n: 3.124 Explicaci√≥n: Coincide con tu inter√©s en gaming; Te gusta la categor√≠a gaming; Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoraci√≥n (4.4/5) #4 - Prote√≠na Whey Gold Standard Precio: $7,200 Calificaci√≥n: 4.6/5 Puntuaci√≥n: 2.979 Explicaci√≥n: Coincide con tu inter√©s en fitness; Te gusta la categor√≠a fitness; Apropiado para tu grupo de edad; Excelente valoraci√≥n (4.6/5); A usuarios con perfil similar tambi√©n les gust√≥; Producto muy popular #5 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificaci√≥n: 4.5/5 Puntuaci√≥n: 1.592 Explicaci√≥n: Coincide con tu inter√©s en tecnologia; Excelente valoraci√≥n (4.5/5) ================================== Reporte Detallado - LAURA MART√çNEZ ================================== Perfil del usuario * Edad: 31 a√±os * G√©nero: F * Ubicaci√≥n: Mendoza * Intereses: lectura, arte, musica * Nivel de gasto: medio Historial de actividad (3 interacciones): ‚Ä¢ 2024-08-13: VIEW - C√°mara DSLR Canon EOS Rebel T7 ‚Ä¢ 2024-08-11: COMPRA - Libro: El Arte de la Guerra Digital (Calificaci√≥n: 5/5) ‚Ä¢ 2024-08-09: VIEW - Libro: Cocina Mediterr√°nea Saludable 3 usuarios m√°s similares * Ana L√≥pez: 0.246 (24.6% similar) * Carlos Mendez: 0.168 (16.8% similar) * Roberto Garc√≠a: 0.144 (14.4% similar) Generando recomendaciones para Laura Mart√≠nez ============================================= Aplicando filtrado colaborativo para Laura Mart√≠nez... Usuarios similares encontrados: 5 7 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Laura Mart√≠nez... 9 recomendaciones por contenido generadas Combinando estrategias de recomendaci√≥n * Productos √∫nicos despu√©s de combinar: 9 Aplicando reglas de negocio * Los usuarios j√≥venes (\u0026lt;35) prefieren productos tecnol√≥gicos: 3 productos afectados 1 reglas aplicadas: boost_tecnologia_jovenes Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Auriculares Bluetooth Sport Pro Precio: $25,000 Calificaci√≥n: 4.2/5 Puntuaci√≥n: 2.186 Explicaci√≥n: Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoraci√≥n (4.2/5); Producto muy popular #2 - Tablet Samsung Galaxy Tab S9 Precio: $95,000 Calificaci√≥n: 4.4/5 Puntuaci√≥n: 2.174 Explicaci√≥n: Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoraci√≥n (4.4/5); Producto muy popular #3 - Smartphone Samsung Galaxy S24 Precio: $150,000 Calificaci√≥n: 4.5/5 Puntuaci√≥n: 2.15 Explicaci√≥n: Apropiado para tu grupo de edad; Excelente valoraci√≥n (4.5/5); Producto muy popular #4 - Juego: Call of Duty Modern Warfare III Precio: $12,000 Calificaci√≥n: 4.3/5 Puntuaci√≥n: 1.785 Explicaci√≥n: Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoraci√≥n (4.3/5); Producto muy popular #5 - Auriculares Gaming HyperX Cloud III Precio: $18,000 Calificaci√≥n: 4.4/5 Puntuaci√≥n: 1.753 Explicaci√≥n: Apropiado para tu grupo de edad; Precio equilibrado para tu rango; Buena valoraci√≥n (4.4/5) ================================== Reporte Detallado - ROBERTO GARC√çA ================================== Perfil del usuario * Edad: 29 a√±os * G√©nero: M * Ubicaci√≥n: La Plata * Intereses: deportes, tecnologia, cocina * Nivel de gasto: alto Historial de actividad (3 interacciones): ‚Ä¢ 2024-08-16: VIEW - Tablet Samsung Galaxy Tab S9 ‚Ä¢ 2024-08-09: COMPRA - Cafetera Espresso DeLonghi (Calificaci√≥n: 4/5) ‚Ä¢ 2024-08-05: COMPRA - Smartphone Samsung Galaxy S24 (Calificaci√≥n: 5/5) 3 usuarios m√°s similares * Ana L√≥pez: 0.322 (32.2% similar) * Diego Silva: 0.310 (31.0% similar) * Mar√≠a Rodriguez: 0.193 (19.3% similar) Generando recomendaciones para Roberto Garc√≠a ============================================= Aplicando filtrado colaborativo para Roberto Garc√≠a... Usuarios similares encontrados: 5 7 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Roberto Garc√≠a... 9 recomendaciones por contenido generadas Combinando estrategias de recomendaci√≥n * Productos √∫nicos despu√©s de combinar: 9 Aplicando reglas de negocio * Los usuarios j√≥venes (\u0026lt;35) prefieren productos tecnol√≥gicos: 2 productos afectados * Usuarios con gasto alto ven productos premium primero: 9 productos afectados 2 reglas aplicadas: boost_tecnologia_jovenes, usuarios_premium Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Auriculares Bluetooth Sport Pro Precio: $25,000 Calificaci√≥n: 4.2/5 Puntuaci√≥n: 4.5 Explicaci√≥n: Coincide con tu inter√©s en deportes; Te gusta la categor√≠a tecnologia; Apropiado para tu grupo de edad; Buena valoraci√≥n (4.2/5); A usuarios con perfil similar tambi√©n les gust√≥; Producto muy popular #2 - C√°mara DSLR Canon EOS Rebel T7 Precio: $85,000 Calificaci√≥n: 4.3/5 Puntuaci√≥n: 3.781 Explicaci√≥n: Te gusta la categor√≠a tecnologia; Apropiado para tu grupo de edad; Producto premium que se ajusta a tu perfil; Buena valoraci√≥n (4.3/5) #3 - Libro: Cocina Mediterr√°nea Saludable Precio: $3,500 Calificaci√≥n: 4.8/5 Puntuaci√≥n: 2.424 Explicaci√≥n: Coincide con tu inter√©s en cocina; Apropiado para tu grupo de edad; Excelente valoraci√≥n (4.8/5) #4 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificaci√≥n: 4.5/5 Puntuaci√≥n: 2.336 Explicaci√≥n: Coincide con tu inter√©s en tecnologia; Apropiado para tu grupo de edad; Excelente valoraci√≥n (4.5/5) #5 - Prote√≠na Whey Gold Standard Precio: $7,200 Calificaci√≥n: 4.6/5 Puntuaci√≥n: 1.851 Explicaci√≥n: Apropiado para tu grupo de edad; Excelente valoraci√≥n (4.6/5); A usuarios con perfil similar tambi√©n les gust√≥; Producto muy popular ===================================== Demostraci√≥n Completada Exitosamente! Revisa los reportes anteriores para entender c√≥mo funciona cada componente ===================================== Comparaci√≥n de algoritmos # \u0026gt; python main.py Selecciona el tipo de demostraci√≥n: 1- Demostraci√≥n completa 2- Comparaci√≥n de algoritmos 3- Usuario espec√≠fico Opci√≥n (1-3): 2 ========================= Comparaci√≥n de Algoritmos ========================= Cargando la configuraci√≥n desde config.yaml Configuraci√≥n cargada desde config.yaml Configuraci√≥n validada exitosamente Inicializando Sistema de Recomendaciones * 6 usuarios cargados * 12 productos cargados * 22 interacciones cargadas Sistema listo! Usuario de prueba: Ana L√≥pez Recomendaciones por filtrado colaborativo: Aplicando filtrado colaborativo para Ana L√≥pez... Usuarios similares encontrados: 5 5 recomendaciones colaborativas generadas 1. Set Pesas Ajustables 40kg (Puntuaci√≥n: 0.318) 2. Cafetera Espresso DeLonghi (Puntuaci√≥n: 0.294) 3. Libro: El Arte de la Guerra Digital (Puntuaci√≥n: 0.246) 4. Libro: Cocina Mediterr√°nea Saludable (Puntuaci√≥n: 0.060) 5. Auriculares Gaming HyperX Cloud III (Puntuaci√≥n: 0.054) Recomendaciones por filtrado por contenido: Aplicando filtrado por contenido para Ana L√≥pez... 5 recomendaciones por contenido generadas 1. Set Pesas Ajustables 40kg (Puntuaci√≥n: 7.470) 2. Libro: El Arte de la Guerra Digital (Puntuaci√≥n: 6.650) 3. Tablet Samsung Galaxy Tab S9 (Puntuaci√≥n: 6.180) 4. Libro: Cocina Mediterr√°nea Saludable (Puntuaci√≥n: 5.260) 5. Juego: Call of Duty Modern Warfare III (Puntuaci√≥n: 4.260) Sistema h√≠brido Generando recomendaciones para Ana L√≥pez ======================================== Aplicando filtrado colaborativo para Ana L√≥pez... Usuarios similares encontrados: 5 6 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Ana L√≥pez... 8 recomendaciones por contenido generadas Combinando estrategias de recomendaci√≥n * Productos √∫nicos despu√©s de combinar: 8 Aplicando reglas de negocio * Los usuarios j√≥venes (\u0026lt;35) prefieren productos tecnol√≥gicos: 1 productos afectados 1 reglas aplicadas: boost_tecnologia_jovenes Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 1. Tablet Samsung Galaxy Tab S9 (Puntuaci√≥n: 3.214) 2. Set Pesas Ajustables 40kg (Puntuaci√≥n: 3.179) 3. Libro: El Arte de la Guerra Digital (Puntuaci√≥n: 2.808) 4. Libro: Cocina Mediterr√°nea Saludable (Puntuaci√≥n: 2.14) 5. Cafetera Espresso DeLonghi (Puntuaci√≥n: 1.792) Observaciones * Colaborativo: Basado en usuarios similares * Contenido: Basado en perfil del usuario * H√≠brido: Combina ambos enfoques Usuario espec√≠fico # \u0026gt; python main.py Selecciona el tipo de demostraci√≥n: 1- Demostraci√≥n completa 2- Comparaci√≥n de algoritmos 3- Usuario espec√≠fico Opci√≥n (1-3): 3 Cargando la configuraci√≥n desde config.yaml Configuraci√≥n cargada desde config.yaml Configuraci√≥n validada exitosamente Inicializando Sistema de Recomendaciones * 6 usuarios cargados * 12 productos cargados * 22 interacciones cargadas Sistema listo! Usuarios disponibles: user_001: Ana L√≥pez user_002: Carlos Mendez user_003: Mar√≠a Rodriguez user_004: Diego Silva user_005: Laura Mart√≠nez user_006: Roberto Garc√≠a Ingresa ID de usuario: user_002 ================================= Reporte Detallado - CARLOS MENDEZ ================================= Perfil del usuario * Edad: 35 a√±os * G√©nero: M * Ubicaci√≥n: C√≥rdoba * Intereses: deportes, gaming, musica * Nivel de gasto: alto Historial de actividad (4 interacciones): ‚Ä¢ 2024-08-18: VIEW - Tablet Samsung Galaxy Tab S9 ‚Ä¢ 2024-08-12: COMPRA - Auriculares Gaming HyperX Cloud III (Calificaci√≥n: 5/5) ‚Ä¢ 2024-08-07: VIEW - Smartphone Samsung Galaxy S24 ‚Ä¢ 2024-08-03: COMPRA - Juego: Call of Duty Modern Warfare III (Calificaci√≥n: 4/5) 3 usuarios m√°s similares * Roberto Garc√≠a: 0.192 (19.2% similar) * Laura Mart√≠nez: 0.168 (16.8% similar) * Diego Silva: 0.120 (12.0% similar) Generando recomendaciones para Carlos Mendez ============================================ Aplicando filtrado colaborativo para Carlos Mendez... Usuarios similares encontrados: 5 6 recomendaciones colaborativas generadas Aplicando filtrado por contenido para Carlos Mendez... 8 recomendaciones por contenido generadas Combinando estrategias de recomendaci√≥n * Productos √∫nicos despu√©s de combinar: 8 Aplicando reglas de negocio * Usuarios con gasto alto ven productos premium primero: 8 productos afectados 1 reglas aplicadas: usuarios_premium Primeras 5 recomendaciones seleccionadas Recomendaciones generadas exitosamente! 5 recomendaciones generadas: #1 - Auriculares Bluetooth Sport Pro Precio: $25,000 Calificaci√≥n: 4.2/5 Puntuaci√≥n: 2.392 Explicaci√≥n: Coincide con tu inter√©s en deportes; Apropiado para tu grupo de edad; Buena valoraci√≥n (4.2/5); Producto muy popular #2 - C√°mara DSLR Canon EOS Rebel T7 Precio: $85,000 Calificaci√≥n: 4.3/5 Puntuaci√≥n: 1.949 Explicaci√≥n: Apropiado para tu grupo de edad; Producto premium que se ajusta a tu perfil; Buena valoraci√≥n (4.3/5) #3 - Prote√≠na Whey Gold Standard Precio: $7,200 Calificaci√≥n: 4.6/5 Puntuaci√≥n: 1.697 Explicaci√≥n: Apropiado para tu grupo de edad; Excelente valoraci√≥n (4.6/5); Producto muy popular #4 - Cafetera Espresso DeLonghi Precio: $32,000 Calificaci√≥n: 4.2/5 Puntuaci√≥n: 1.689 Explicaci√≥n: Apropiado para tu grupo de edad; Buena valoraci√≥n (4.2/5) #5 - Libro: El Arte de la Guerra Digital Precio: $4,200 Calificaci√≥n: 4.5/5 Puntuaci√≥n: 1.633 Explicaci√≥n: Apropiado para tu grupo de edad; Excelente valoraci√≥n (4.5/5) ¬øQu√© nos aporta esta soluci√≥n? # Sistema h√≠brido: Combinamos m√∫ltiples estrategias de recomendaci√≥n para obtener mejores resultados. Reglas de negocio: Implementamos l√≥gica espec√≠fica del dominio que puede adaptarse f√°cilmente. Explicabilidad: El sistema puede explicar por qu√© recomienda cada producto, generando confianza. Escalabilidad: La arquitectura permite agregar nuevas fuentes de datos y reglas f√°cilmente. Ejercicios para profundizar # A continuaci√≥n tienes algunos ejercicios que te ayudar√°n a profundizar tus conocimientos.\nEjercicio 1: Implementa una nueva regla de negocio que d√© boost a productos en oferta durante los fines de semana. Ejercicio 2: Implementa un sistema de feedback que aprenda de las interacciones del usuario (like/dislike). Por supuesto, no tienes porque detenerte en estas recomendaciones, dej√° volar tu imaginaci√≥n y utiliz√° los conceptos aprendidos para otros casos.\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"03 septiembre 2025","externalUrl":null,"permalink":"/ai/module1/project/","section":"Inteligencia Artificial","summary":"","title":"Proyecto usando Machine Learning: Sistema de Recomendaciones","type":"ai"},{"content":"Key characteristics of association:\nIt represents a loose coupling between classes. The associated classes can exist independently of each other. The lifetime of one class is not tied to the lifetime of the other. It can be unidirectional or bidirectional. There are two main types of association:\nUnidirectional Association Bidirectional Association Let\u0026rsquo;s explore each of these in more detail.\nUnidirectional association # In a unidirectional association, one class knows about and can interact with another class, but not vice versa. This is a one-way relationship.\nHere\u0026rsquo;s an example in Python:\nclass Customer: def __init__(self, name): self.name = name class Order: def __init__(self, order_number, customer): self.order_number = order_number self.customer = customer # This creates an association def display_info(self): return f\u0026#34;Order {self.order_number} placed by {self.customer.name}\u0026#34; # Creating instances customer = Customer(\u0026#34;John Doe\u0026#34;) order = Order(\u0026#34;12345\u0026#34;, customer) print(order.display_info()) # Output: Order 12345 placed by John Doe In this example, the Order class has a unidirectional association with the Customer class. An Order knows about its associated Customer, but a Customer doesn\u0026rsquo;t know about its Orders.\nHere\u0026rsquo;s a UML diagram representing this relationship:\nclassDiagram class Customer { +name: string } class Order { +order_number: string +customer: Customer +display_info() } Order --\u003e Customer : places end The arrow in the diagram points from Order to Customer, indicating that Order knows about Customer, but not the other way around.\nBidirectional association # In a bidirectional association, both classes are aware of each other and can interact with each other. This is a two-way relationship.\nHere\u0026rsquo;s an example in Python:\nclass Student: def __init__(self, name): self.name = name self.courses = [] def enrol(self, course): self.courses.append(course) course.add_student(self) def display_courses(self): return f\u0026#34;{self.name} is enrolled in: {\u0026#39;, \u0026#39;.join(course.name for course in self.courses)}\u0026#34; class Course: def __init__(self, name): self.name = name self.students = [] def add_student(self, student): self.students.append(student) def display_students(self): return f\u0026#34;{self.name} has students: {\u0026#39;, \u0026#39;.join(student.name for student in self.students)}\u0026#34; # Creating instances student1 = Student(\u0026#34;Alice\u0026#34;) student2 = Student(\u0026#34;Bob\u0026#34;) math_course = Course(\u0026#34;Mathematics\u0026#34;) physics_course = Course(\u0026#34;Physics\u0026#34;) # enrolling students in courses student1.enrol(math_course) student1.enrol(physics_course) student2.enrol(math_course) print(student1.display_courses()) print(math_course.display_students()) In this example, there\u0026rsquo;s a bidirectional association between Student and Course. A Student knows about their Courses, and a Course knows about its Students.\nHere\u0026rsquo;s a UML diagram representing this relationship:\nclassDiagram class Student { +name: string +courses: list +enrol(course) +display_courses() } class Course { +name: string +students: list +add_student(student) +display_students() } Student \"0..*\" \u003c--\u003e \"0..*\" Course : enrols in \u003e end The double-headed arrow in the diagram indicates that both Student and Course are aware of each other. The \u0026ldquo;0..*\u0026rdquo; notation indicates that a Student can be enrolled in zero or more Courses, and a Course can have zero or more Students.\nAssociation is a flexible relationship that can represent many real-world connections between objects. It\u0026rsquo;s important to choose between unidirectional and bidirectional associations carefully, as bidirectional associations can introduce more complexity and potential for errors if not managed properly.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy ‚Äì drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-association/","section":"Programming","summary":"","title":"Class relations: Association","type":"programming"},{"content":"Una lista enlazada se compone de nodos donde cada nodo tiene dos partes:\nDato o informaci√≥n Referencia al siguiente nodo Los nodos se organizan de forma secuencial, cada uno apuntando al siguiente. El √∫ltimo nodo apunta a nulo para indicar el final.\nEsta estructura din√°mica permite inserci√≥n y eliminaci√≥n eficiente de nodos.\nTipos de listas enlazadas # Existen varios tipos:\nSimplemente enlazada: Cada nodo apunta al siguiente. Son √∫tiles para colas (queues) y pilas (stacks). Diagrama de una lista simplemente enlazada Doblemente enlazada: Cada nodo tiene referencia al siguiente y al anterior. Permiten recorrer en ambos sentidos. Diagrama de una lista doblemente enlazada Circular: El √∫ltimo nodo apunta al primero formando un ciclo. √ötiles para buffers circulares. Diagrama de una lista circular Operaciones comunes # Insertar: Agregar nodos al inicio, final o medio de la lista.\nEliminar: Quitar nodos por valor o posici√≥n.\nBuscar: Encontrar nodos por valor recorriendo la lista.\nRecorrer: Iterar los nodos accediendo por las referencias.\nImplementaci√≥n # Las listas enlazadas se pueden implementar de la siguiente manera:\nUsa la clase ListNode para representar nodos:\nclass ListNode: def __init__(self, value): self.value = value self.next = None Luego para crear y usar una lista se define una clase LinkedList con m√©todos para las operaciones.\nclass LinkedList: def __init__(self): self.head = None def add_to_start(self, new_value): new_node = ListNode(new_value) new_node.next = self.head self.head = new_node def print(self): current = self.head while current != None: print(current.value) current = current.next def search(self, searched_value): current = self.head while current != None: if current.value == searched_value: return True current = current.next return False #...other methods Con esta clase LinkedList podemos crear una lista, agregar nodos, imprimirla, buscar elementos, etc.\nSe podr√≠an agregar otros m√©todos como insertar al final, eliminar por valor, obtener por √≠ndice, etc. Pero esto da una idea de c√≥mo encapsular la funcionalidad de la lista enlazada en una clase. Como pr√°ctica, pod√©s intentar agregar estos m√©todos por tu cuenta, ¬°no dudes en dejar tus comentarios y contactarte si necesitas ayuda!\nVentajas y desventajas # Ventajas:\nInsertar y eliminar nodos es eficiente. No requiere definir tama√±o fijo como los arrays. Estructura din√°mica y flexible. Desventajas:\nMayor uso de memoria por tener que almacenar referencias. El acceso a elementos por √≠ndice es m√°s costoso al ser secuencial. Ejemplos de uso # Implementar estructuras como pilas (stacks) y colas (queues). En listas doblemente enlazadas, recorrer la lista en el sentido ambos sentidos. Blockchains como la de Bitcoin. Reproducir elementos en orden como playlists de m√∫sica. Conclusi√≥n # Las listas enlazadas son una estructura de datos vers√°til para almacenar secuencias din√°micas de elementos. Tener un buen manejo de estas listas, sus operaciones y usos es indispensable para cualquier programador.\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"01 noviembre 2023","externalUrl":null,"permalink":"/programming/data-structures/linked-lists/","section":"Programaci√≥n","summary":"","title":"Listas Enlazadas","type":"programming"},{"content":" ¬øQu√© son las funciones? # Una funci√≥n, en t√©rminos simples, es un bloque de c√≥digo que se ejecuta s√≥lo cuando es llamado. Puedes pensar en ella como un peque√±o programa dentro de tu programa principal, dise√±ado para realizar una tarea espec√≠fica1. Una funci√≥n tambi√©n puede verse como una caja negra: le pasamos una entrada (par√°metros), ocurre alg√∫n procesamiento interno, y produce una salida (retorno).\nLas funciones nos permiten segmentar nuestro c√≥digo en partes l√≥gicas, donde cada parte realiza una √∫nica acci√≥n. Esto brinda varios beneficios2:\nReutilizaci√≥n: Una vez definida la funci√≥n, podemos ejecutar (llamar) ese c√≥digo desde cualquier lugar de nuestro programa cuantas veces sea necesario. Organizaci√≥n: Permite dividir un programa grande en partes m√°s peque√±as y manejables. Encapsulamiento: Las funciones reducen la complejidad escondiendo los detalles de implementaci√≥n internos. Mantenimiento: Si necesitamos realizar cambios, solo debemos modificar el c√≥digo en un lugar (la funci√≥n) en lugar de rastrear todas las instancias de ese c√≥digo. Procedimientos vs. Funciones\nEs vital distinguir entre estos dos conceptos. Mientras que una funci√≥n siempre devuelve un valor, un procedimiento realiza una tarea pero no devuelve nada. En algunos lenguajes, esta diferencia es m√°s clara que en otros. Python, por ejemplo, tiene funciones que pueden o no devolver valores.\nAnatom√≠a de una funci√≥n # En Python, una funci√≥n se declara usando la palabra clave def, seguida del nombre de la funci√≥n y par√©ntesis. El c√≥digo dentro de la funci√≥n se denomina el cuerpo de la funci√≥n3 y contiene el conjunto de instrucciones a ejecutar para cumplir con su tarea..\ndef mi_funcion(): print(\u0026#34;¬°Hola desde mi funci√≥n!\u0026#34;) Para llamar o invocar una funci√≥n, simplemente usamos su nombre seguido de par√©ntesis:\nmi_funcion() # Salida: ¬°Hola desde mi funci√≥n! Par√°metros y argumentos # Las funciones se vuelven a√∫n m√°s poderosas cuando les pasamos informaci√≥n, conocida como par√°metros. Estos act√∫an como \u0026ldquo;variables\u0026rdquo; dentro de la funci√≥n y permiten que la funci√≥n trabaje con diferentes datos cada vez que se llama.\nMientras que los par√°metros son variables definidas en la definici√≥n de la funci√≥n. Los argumentos son los valores reales pasados al llamar a la funci√≥n.\ndef saludo(nombre): print(f\u0026#34;¬°Hola {nombre}!\u0026#34;) saludo(\u0026#34;Mar√≠a\u0026#34;) # Salida: # ¬°Hola Mar√≠a! Podemos definir valores por defecto para los par√°metros Python permite par√°metros por defecto, que tienen un valor predeterminado, lo cual hace opcional pasar esos argumentos al llamar la funci√≥n. Tambi√©n permite par√°metros nombrados que permiten pasar los argumentos en cualquier orden, especificando su nombre.\ndef saludo(nombre=\u0026#34;Mar√≠a\u0026#34;, repeticiones=3): repeticion = 1 while repeticion \u0026lt;= repeticiones: print(f\u0026#34;¬°Hola {nombre}!\u0026#34;) repeticion += 1 saludo() # Salida: # ¬°Hola Mar√≠a! # ¬°Hola Mar√≠a! # ¬°Hola Mar√≠a! saludo(\u0026#34;Florencia\u0026#34;, 4) # Salida: # ¬°Hola Florencia! # ¬°Hola Florencia! # ¬°Hola Florencia! # ¬°Hola Florencia! saludo(repeticiones=2, nombre=\u0026#34;Juli√°n\u0026#34;) # Salida # ¬°Hola Juli√°n! # ¬°Hola Juli√°n! Retorno de valores # Las funciones pueden devolver un resultado o valor de retorno usando la palabra reservada return.\ndef area_circulo(radio): return 3.14 * (radio ** 2) resultado = area_circulo(10) print(resultado) # Salida: 314 El valor de retorno se pasa de vuelta a donde se llam√≥ la funci√≥n y se puede asignar a una variable para usarlo.\nLas funciones tambi√©n pueden ejecutar alguna tarea sin devolver nada expl√≠citamente. En Python esto se conoce como retornar None.\nVariables locales y globales # Las variables locales se definen dentro de una funci√≥n y solo existen en ese √°mbito, mientras que las variables globales est√°n definidas fuera y pueden ser accedidas desde cualquier parte del c√≥digo. Es crucial entender su alcance (d√≥nde puede ser accesible una variable) y duraci√≥n (cu√°nto tiempo vive una variable).\nx = 10 # x es global def suma(): y = 5 # y es local return x + y suma() # Salida: 15 print(y) # Error, y no existe fuera de la funci√≥n Podemos leer variables globales desde una funci√≥n, pero si necesitamos modificarla debemos declararla global.\nx = 10 def suma(): global x x = x + 5 suma() print(x) # 15 ","date":"29 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/functions/","section":"Programaci√≥n","summary":"","title":"Funciones","type":"programming"},{"content":"La l√≥gica booleana, nombrada en honor a George Boole, un matem√°tico ingl√©s del siglo XIX, es un sistema matem√°tico que se ocupa de operaciones que tienen solo dos resultados posibles: verdadero o falso, representados generalmente como 1 y 0, respectivamente1. En su obra \u0026ldquo;An Investigation of the Laws of Thought\u0026rdquo;, Boole estableci√≥ las bases de esta l√≥gica, presentando un sistema algebraico que podr√≠a utilizarse para representar estructuras l√≥gicas.\nOperaciones Booleanas # Dentro de la l√≥gica booleana, existen operaciones fundamentales que permiten manipular y combinar estas expresiones binarias:\nAND (Y): Esta operaci√≥n devuelve verdadero (1) solo si ambas entradas son verdaderas. Por ejemplo, si tenemos dos interruptores, ambos deben estar en la posici√≥n encendido para que una luz se encienda.\nOR (O): Devuelve verdadero si al menos una de las entradas es verdadera. Siguiendo con el ejemplo de los interruptores, con que uno de ellos est√© encendido, la luz se iluminar√°.\nNOT (NO): Es una operaci√≥n unaria, lo que significa que solo tiene una entrada. Simplemente invierte el valor de entrada. Si le das un 1, devuelve un 0 y viceversa.\nNAND (NO Y): Es la negaci√≥n de AND. Solo devuelve falso si ambas entradas son verdaderas.\nNOR (NO O): Es la negaci√≥n de OR. Devuelve verdadero solo si ambas entradas son falsas.\nXOR (O exclusivo): Devuelve verdadero si las entradas son diferentes. Si ambas son iguales, devuelve falso.\nXNOR (NO O exclusivo): Es la negaci√≥n de XOR. Devuelve verdadero si ambas entradas son iguales.\nLa importancia de esta l√≥gica en computaci√≥n y programaci√≥n # La computaci√≥n moderna, en su esencia, es la manipulaci√≥n de bits, esos unos y ceros que mencionamos. Cada operaci√≥n que realiza una computadora, desde simples c√°lculos hasta la renderizaci√≥n de gr√°ficos complejos, implica operaciones booleanas en alg√∫n nivel2.\nEn programaci√≥n, la l√≥gica booleana se utiliza en estructuras de control, como condiciones (if, else) y bucles, permitiendo a los programas tomar decisiones basadas en ciertas condiciones.\nTablas de verdad: el mapa de la l√≥gica Booleana # Una tabla de verdad es una representaci√≥n gr√°fica de una operaci√≥n booleana. Enumera todas las combinaciones posibles de entradas y muestra el resultado de la operaci√≥n para cada combinaci√≥n3.\nPor ejemplo,\nA B A AND B A OR B A XOR B A NOR B A NAND B NOT A A NXOR B 1 1 1 1 0 0 0 0 1 1 0 0 1 1 0 1 0 0 0 1 0 1 1 0 1 1 0 0 0 0 0 0 1 1 1 1 Conclusiones # La l√≥gica booleana es mucho m√°s que un conjunto de reglas matem√°ticas abstractas. Es el lenguaje fundamental de las m√°quinas, el c√≥digo que subyace a la era digital en la que vivimos. Al comprender sus principios, no solo nos volvemos m√°s adeptos a trabajar con tecnolog√≠a, sino que tambi√©n adquirimos una apreciaci√≥n m√°s profunda de las estructuras que sustentan nuestro mundo digital.\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\nReferencias # Boole, G. (1854). An Investigation of the Laws of Thought. Londres: Walton and Maberly.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A. (2012). Estructura de Computadoras. Buenos Aires: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMinsky, M. (1967). Computation: Finite and Infinite Machines. Buenos Aires: Prentice-Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"09 septiembre 2023","externalUrl":null,"permalink":"/programming/intro/boolean-logic/","section":"Programaci√≥n","summary":"","title":"L√≥gica Booleana","type":"programming"},{"content":"","externalUrl":null,"permalink":"/programming/data-structures/","section":"Programaci√≥n","summary":"","title":"Estructuras de Datos","type":"programming"},{"content":" Lleg√≥ el momento de cerrar nuestro paso por los fundamentos de la Inteligencia Artificial. Ahora vamos a repasar lo aprendido, aclarar algunas dudas y prepararnos para el pr√≥ximo m√≥dulo. FAQ: Dudas domunes # 1. ¬øPor qu√© empezamos con reglas en lugar de Machine Learning avanzado? # Las reglas l√≥gicas son la base de todo sistema inteligente. Antes de usar algoritmos complejos, necesitas entender:\nC√≥mo estructurar el conocimiento C√≥mo manejar incertidumbre C√≥mo combinar m√∫ltiples fuentes de informaci√≥n C√≥mo hacer sistemas explicables Estos conceptos se aplican igual en Deep Learning.\n2. ¬øCu√°ndo usar IA cl√°sica vs Machine Learning? # IA Cl√°sica (reglas, sistemas expertos):\n‚úÖ Conocimiento del dominio bien definido ‚úÖ Reglas claras y estables ‚úÖ Necesitas explicabilidad total ‚úÖ Pocos datos disponibles ‚ùå Patrones muy complejos ‚ùå Necesitas adaptaci√≥n autom√°tica Machine Learning:\n‚úÖ Muchos datos disponibles ‚úÖ Patrones complejos o desconocidos ‚úÖ El dominio cambia frecuentemente ‚úÖ Necesitas adaptaci√≥n autom√°tica ‚ùå Pocos datos de entrenamiento ‚ùå Explicabilidad cr√≠tica para el negocio 3. ¬øLos sistemas de reglas son obsoletos? # No, para nada. Muchos sistemas en producci√≥n combinan ambos enfoques:\nNetflix: Usa ML para analizar patrones de viewing, pero reglas de negocio para decidir qu√© mostrar en diferentes contextos Sistemas m√©dicos: Usan ML para an√°lisis de im√°genes, pero reglas expertas para diagn√≥sticos cr√≠ticos Trading algor√≠tmico: Combina ML para predicciones con reglas de gesti√≥n de riesgos 4. ¬øPor qu√© no usar directamente bibliotecas como scikit-learn? # En este primer m√≥dulo, la idea es que entiendas qu√© est√° pasando por debajo. Una vez que domines los conceptos fundamentales, las bibliotecas ser√°n herramientas poderosas, no cajas negras.\nPi√©nsalo as√≠: puedes usar un framework web como Django, pero es porque entiendes HTTP, requests, responses, etc.\n5. ¬øC√≥mo s√© si mi sistema de IA est√° funcionando bien? # Para sistemas de reglas:\nPrecisi√≥n: ¬øLas predicciones son correctas? Cobertura: ¬øEl sistema puede manejar todos los casos? Consistencia: ¬øLas reglas se contradicen entre s√≠? Performance: ¬øEs lo suficientemente r√°pido para producci√≥n? M√°s adelante veremos m√©tricas espec√≠ficas para ML.\nPr√≥ximos pasos: m√≥dulo 2 # En el pr√≥ximo m√≥dulo nos sumergiremos en las matem√°ticas esenciales para entender Machine Learning. No te preocupes, no vamos a ser acad√©micos aburridos. Vamos a cubrir solo las matem√°ticas que realmente necesitas:\n√Ålgebra Lineal pr√°ctica\nVectores y matrices (¬øpor qu√© importan?) Operaciones esenciales Representaci√≥n de datos como matrices Estad√≠stica\nProbabilidades b√°sicas Distribuciones importantes Correlaci√≥n vs causalidad C√°lculo para optimizaci√≥n\nDerivadas (solo las que necesitas) Gradientes y optimizaci√≥n ¬øPor qu√© necesitas estas matem√°ticas? # Cada algoritmo de ML es fundamentalmente:\nUna funci√≥n matem√°tica que mapea entradas a salidas Un proceso de optimizaci√≥n que encuentra los mejores par√°metros Un framework estad√≠stico que maneja incertidumbre Sin entender esto, estar√°s ajustando hiperpar√°metros al azar y rogando que funcione.\nReflexi√≥n final # Has completado tu primer m√≥dulo en el camino a convertirte en un ingeniero en IA. Cubriste mucho terreno:\n‚úÖ Desmitificaste la IA: ya sabes la diferencia real entre IA, ML y DL ‚úÖ Implementaste sistemas inteligentes: desde cero, sin bibliotecas m√°gicas ‚úÖ Entendiste los fundamentos: que se aplicar√°n a todo lo que aprendas despu√©s ‚úÖ Construiste un proyecto real: sistema de recomendaciones funcional Pero esto es solo el comienzo. La IA no es magia, es ingenier√≠a sistem√°tica aplicada a problemas complejos. Como cualquier habilidad de ingenier√≠a, se domina con pr√°ctica y fundamentos s√≥lidos.\nEn el pr√≥ximo m√≥dulo agregaremos las matem√°ticas que necesitas. No para ser un acad√©mico, sino para ser un practicante efectivo que entiende sus herramientas.\nRecuerda: Cada experto fue alguna vez un principiante. La diferencia est√° en la consistencia y la profundidad de comprensi√≥n, no en la velocidad.\n¬°Nos vemos en el siguiente m√≥dulo! üöÄ\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"04 septiembre 2025","externalUrl":null,"permalink":"/ai/module1/conclusion/","section":"Inteligencia Artificial","summary":"","title":"Fundamentos de Inteligencia Artificial: Conclusi√≥n","type":"ai"},{"content":"Key characteristics of aggregation:\nIt\u0026rsquo;s a stronger relationship than a simple association, but weaker than composition. The \u0026ldquo;part\u0026rdquo; object can exist independently of the \u0026ldquo;whole\u0026rdquo; object. Multiple \u0026ldquo;whole\u0026rdquo; objects can share the same \u0026ldquo;part\u0026rdquo; object. If the \u0026ldquo;whole\u0026rdquo; object is destroyed, the \u0026ldquo;part\u0026rdquo; object continues to exist. Let\u0026rsquo;s look at an example to illustrate aggregation:\nclass Department: def __init__(self, name): self.name = name self.employees = [] def add_employee(self, employee): self.employees.append(employee) def remove_employee(self, employee): self.employees.remove(employee) def list_employees(self): return f\u0026#34;Department {self.name} has employees: {\u0026#39;, \u0026#39;.join(emp.name for emp in self.employees)}\u0026#34; class Employee: def __init__(self, name, id): self.name = name self.id = id def __str__(self): return f\u0026#34;Employee(name={self.name}, id={self.id})\u0026#34; # Creating instances hr_dept = Department(\u0026#34;Human Resources\u0026#34;) it_dept = Department(\u0026#34;Information Technology\u0026#34;) emp1 = Employee(\u0026#34;Alice\u0026#34;, \u0026#34;E001\u0026#34;) emp2 = Employee(\u0026#34;Bob\u0026#34;, \u0026#34;E002\u0026#34;) emp3 = Employee(\u0026#34;Charlie\u0026#34;, \u0026#34;E003\u0026#34;) # Adding employees to departments hr_dept.add_employee(emp1) hr_dept.add_employee(emp2) it_dept.add_employee(emp2) # Note: Bob works in both HR and IT it_dept.add_employee(emp3) print(hr_dept.list_employees()) print(it_dept.list_employees()) # If we remove the HR department, the employees still exist del hr_dept print(emp1) # Employee still exists In this example, we have an aggregation relationship between Department and Employee. A Department has Employees, but Employees can exist independently of any particular Department. Also, an Employee can belong to multiple Departments (as we see with Bob).\nHere\u0026rsquo;s a UML diagram representing this aggregation relationship:\nclassDiagram class Department { +name: string +employees: list +add_employee(employee) +remove_employee(employee) +list_employees() } class Employee { +name: string +id: string +__str__() } Department o-- Employee : has end In this diagram, the open diamond on the Department side of the relationship indicates aggregation. This shows that Department is the \u0026ldquo;whole\u0026rdquo; and Employee is the \u0026ldquo;part\u0026rdquo; in this relationship.\nIt\u0026rsquo;s important to note that while aggregation implies a whole-part relationship, the \u0026ldquo;part\u0026rdquo; (in this case, Employee) can exist independently and can even be part of multiple \u0026ldquo;wholes\u0026rdquo; (multiple Departments).\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy ‚Äì drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-aggregation/","section":"Programming","summary":"","title":"Class relations: Aggregation","type":"programming"},{"content":"La naturaleza LIFO de las pilas se debe a que s√≥lo se puede acceder y manipular el elemento superior. La operaci√≥n de colocar un elemento sobre la pila se conoce como \u0026ldquo;push\u0026rdquo;, mientras que sacar un elemento de la pila es un \u0026ldquo;pop\u0026rdquo;. El funcionamiento LIFO provoca que el √∫ltimo elemento colocado en una pila sea el primero en ser retirado.\nDiagrama de una pila Operaciones principales # Las operaciones primarias que soporta una estructura de pila son:\nPush: agrega un elemento encima de la pila. Pop: saca el elemento de la pila que se encuentra en la cima. Peek: permite acceder al elemento de la cima sin sacarlo de la pila. isEmpty: consulta si la pila se encuentra vac√≠a. La mayor√≠a de los lenguajes como Python y Java proveen implementaciones de pilas en sus librer√≠as est√°ndar.\nImplementaci√≥n # Una pila puede implementarse utilizando una lista enlazada de manera que cada node apunte al nodo anterior.\nclass Node: def __init__(self, value): self.value = value self.previous = None class Stack: def __init__(self): self.top = None self.size = 0 def push(self, value): new_node = Node(value) if self.top is None: self.top = new_node else: new_node.previous = self.top self.top = new_node self.size += 1 def pop(self): if self.top is None: return None top_node = self.top self.top = self.top.previous self.size -= 1 return top_node.value def peek(self): if self.top is None: return None return self.top.value def is_empty(self): return self.top is None # Returns true if top is None def __len__(self): return self.size def __str__(self): values = [] current = self.top while current: values.append(str(current.value)) current = current.previous return \u0026#34;\\n\u0026#34;.join(values) print(\u0026#34;Creating a new stack\u0026#34;) stack = Stack() print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if stack is empty\u0026#34;) print(f\u0026#34;Is stack empty? {stack.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Push first element\u0026#34;) print(\u0026#34; stack.push(\\\u0026#34;First\\\u0026#34;)\u0026#34;) stack.push(\u0026#34;First\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print stack:\u0026#34;) print(stack) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print top element using peek\u0026#34;) print(f\u0026#34;stack.peek() =\u0026gt; {stack.peek()}\u0026#34;) print(\u0026#34;Add two more elements: stack.push(\\\u0026#34;\\\u0026#34;):\u0026#34;) print(\u0026#34; stack.push(\\\u0026#34;Second\\\u0026#34;)\u0026#34;) print(\u0026#34; stack.push(\\\u0026#34;Third\\\u0026#34;)\u0026#34;) stack.push(\u0026#34;Second\u0026#34;) stack.push(\u0026#34;Third\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print stack:\u0026#34;) print(stack) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print top element using peek\u0026#34;) print(f\u0026#34;stack.peek() =\u0026gt; {stack.peek()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if stack is empty\u0026#34;) print(f\u0026#34;Is stack empty? {stack.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get top element using pop\u0026#34;) print(f\u0026#34;stack.pop() =\u0026gt; {stack.pop()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print top element using peek\u0026#34;) print(f\u0026#34;stack.peek() =\u0026gt; {stack.peek()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get top element using pop\u0026#34;) print(f\u0026#34;stack.pop() =\u0026gt; {stack.pop()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get top element using pop\u0026#34;) print(f\u0026#34;stack.pop() =\u0026gt; {stack.pop()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if stack is empty\u0026#34;) print(f\u0026#34;Is stack empty? {stack.is_empty()}\u0026#34;) Ejemplos de uso # Las pilas tienen muchos usos en programaci√≥n:\nPila de ejecuci√≥n (call stack): registra las llamadas a funciones pendientes de resolver. Implementa el comportamiento LIFO esperado.\nPila de navegador: permite volver atr√°s (undo) en el historial de navegaci√≥n de forma similar a una pila LIFO.\nEjecuci√≥n de expresiones matem√°ticas: mediante una pila se puede verificar par√©ntesis, corchetes, llaves, etc.\nAlgoritmos y estructuras de datos: como en el algoritmo quicksort y en la implementaci√≥n de buses de datos (datapaths).\nConclusi√≥n # Las pilas son estructuras de datos vers√°tiles gracias a su principio de funcionamiento LIFO. Tener un buen dominio de pilas, sus usos y aplicaciones es esencial en la ciencia de la computaci√≥n.\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"02 noviembre 2023","externalUrl":null,"permalink":"/programming/data-structures/stacks/","section":"Programaci√≥n","summary":"","title":"Pilas","type":"programming"},{"content":" Recursi√≥n: el arte de llamarse a s√≠ mismo # Imagina una caja de espejos donde cada espejo refleja lo que ve en el siguiente, creando una serie infinita de reflejos. La recursi√≥n en programaci√≥n es algo similar. Es una t√©cnica donde una funci√≥n se llama a s√≠ misma directa o indirectamente[^1^]. Esto crea un ciclo en el cual la funci√≥n resuelve un problema dividi√©ndolo en instancias m√°s peque√±as del mismo problema, hasta llegar a un caso base sencillo de resolver.\nPor ejemplo, imaginemos una funci√≥n que imprime un contador regresivo:\ndef cuenta_regresiva(numero): if numero \u0026gt; 0: print(numero) cuenta_regresiva(numero - 1) else: print(\u0026#34;¬°Despegue!\u0026#34;) cuenta_regresiva(5) Esta funci√≥n se llama recursivamente reduciendo el n√∫mero cada vez hasta llegar a 0, y luego imprime el mensaje de despegue.\nLa recursi√≥n es un enfoque declarativo donde se enfoca en dividir un problema en casos recursivos sin necesidad de controlar expl√≠citamente el bucle usando iteradores o contadores como en la programaci√≥n imperativa.\nLa estructura de una funci√≥n recursiva # El poder de la recursi√≥n radica en su simplicidad. Sin embargo, es esencial entender su estructura para evitar caer en trampas comunes. Una funci√≥n recursiva t√≠pica tiene dos partes principales1:\nCaso base: El caso m√°s simple con una soluci√≥n conocida que no requiere recursi√≥n. Es la condici√≥n de parada, que detiene la recursi√≥n. Sin el caso base, caer√≠amos en una recursi√≥n infinita que eventualmente desborda la pila de llamadas. Caso recursivo: Es donde ocurre la m√°gica llamada recursiva. En este punto, la funci√≥n se llama a s√≠ misma con un argumento modificado, generalmente una versi√≥n reducida del problema original. Ejemplos cl√°sicos de recursi√≥n # Factorial # El factorial de un entero positivo \\(n\\) es el producto de todos los enteros positivos menores o iguales a \\(n\\). Por ejemplo:\n\\(5! = 5 * 4 * 3 * 2 * 1 = 120\\) \\(4! = 4 * 3 * 2 * 1 = 24\\) \\(3! = 3 * 2 * 1 = 6\\) Aqu√≠ est√° el c√≥digo en Python para calcular el factorial usando recursi√≥n:\ndef factorial(n): if n == 1: return 1 # Caso base return n * factorial(n-1) # Caso recursivo Caso base: El caso base es la instancia m√°s simple y peque√±a del problema que puede responderse directamente. Para el factorial, cuando \\(n = 1\\), el resultado es \\(1\\). Caso recursivo: Si \\(n\\) es mayor que \\(1\\), la funci√≥n se llama a s√≠ misma con \\(n-1\\), y multiplica el resultado por \\(n\\). Digamos que quieres calcular el factorial de \\(5\\), as√≠ que llamas a factorial(5).\nEsto es lo que sucede:\nPaso 1: Como \\(n = 5\\) no es \\(1\\), la funci√≥n llama a factorial(4), luego multiplica el resultado por \\(5\\). Paso 2: Ahora, dentro de factorial(4), \\(n = 4\\), entonces la funci√≥n llama a factorial(3), luego multiplica el resultado por \\(4\\). Paso 3: Dentro de factorial(3), \\(n = 3\\), as√≠ que llama a factorial(2), luego multiplica el resultado por \\(3\\). Paso 4: Dentro de factorial(2), \\(n = 2\\), as√≠ que llama a factorial(1), luego multiplica el resultado por \\(2\\). Paso 5: Finalmente, factorial(1) alcanza el caso base, donde \\(n = 1\\), as√≠ que retorna \\(1\\). Ahora los resultados se desenrollan:\nfactorial(2) retorna \\(2 * 1 = 2\\) factorial(3) retorna \\(3 * 2 = 6\\) factorial(4) retorna \\(4 * 6 = 24\\) factorial(5) retorna \\(5 * 24 = 120\\) El resultado final es \\(120\\), que es el valor de \\(5!\\).\nAqu√≠ hay una representaci√≥n visual de la pila de llamadas:\nfactorial(5) -\u0026gt; factorial(4) -\u0026gt; factorial(3) -\u0026gt; factorial(2) -\u0026gt; factorial(1) return 1 return 2 return 6 return 24 return 120 Serie de Fibonacci # La serie de Fibonacci es una secuencia de n√∫meros donde cada n√∫mero es la suma de los dos anteriores. Comienza con \\(0\\) y \\(1\\), y cada n√∫mero posterior es la suma de los dos n√∫meros anteriores. Los primeros n√∫meros de la secuencia son: \\(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \u0026hellip;\\)\nAqu√≠ est√° el c√≥digo en Python para calcular el \\(n^th\\) n√∫mero de Fibonacci usando recursi√≥n de cola:\ndef fibonacci(n, a=0, b=1): if n == 0: return a return fibonacci(n-1, b, a+b) La funci√≥n toma tres par√°metros:\n\\(n\\): La posici√≥n del n√∫mero deseado en la secuencia. \\(a\\) y \\(b\\): Dos n√∫meros que ayudan en el c√°lculo de la secuencia. Aqu√≠ hay un desglose de c√≥mo funciona la funci√≥n:\nCaso Base: Si \\(n\\) es \\(0\\), la funci√≥n devuelve \\(a\\). Este es el valor del \\(n^th\\) n√∫mero en la secuencia.\nCaso Recursivo: Si \\(n\\) no es \\(0\\), la funci√≥n se llama a s√≠ misma con \\(n-1\\), \\(b\\), y \\(a+b\\). Estos par√°metros cambian la posici√≥n en la secuencia y preparan los siguientes n√∫meros para la suma.\nSupongamos que queremos encontrar el \\(5^th\\) n√∫mero en la secuencia de Fibonacci llamando a fibonacci(5).\nEsto es lo que sucede:\nPaso 1: Dado que \\(n = 5\\), llama a fibonacci(4, 1, 1) (porque \\(a = 0\\), \\(b = 1\\), \\(a + b = 1\\)). Paso 2: Dado que \\(n = 4\\), llama a fibonacci(3, 1, 2) (porque \\(a = 1\\), \\(b = 1\\), \\(a + b = 2\\)). Paso 3: Dado que \\(n = 3\\), llama a fibonacci(2, 2, 3) (porque \\(a = 1\\), \\(b = 2\\), \\(a + b = 3\\)). Paso 4: Dado que \\(n = 2\\), llama a fibonacci(1, 3, 5) (porque \\(a = 2\\), \\(b = 3\\), \\(a + b = 5\\)). Paso 5: Dado que \\(n = 1\\), llama a fibonacci(0, 5, 8) (porque \\(a = 3\\), \\(b = 5\\), \\(a + b = 8\\)). Paso 6: Dado que \\(n = 0\\), devuelve \\(a\\), que es \\(5\\). El resultado es \\(5\\), que es el \\(5^th\\) n√∫mero en la secuencia de Fibonacci.\nAqu√≠ hay una representaci√≥n visual de la pila de llamadas:\nfibonacci(5, 0, 1) -\u0026gt; fibonacci(4, 1, 1) -\u0026gt; fibonacci(3, 1, 2) -\u0026gt; fibonacci(2, 2, 3) -\u0026gt; fibonacci(1, 3, 5) -\u0026gt; fibonacci(0, 5, 8) return 5 Ventajas y desventajas # La recursi√≥n tiene ciertas ventajas2:\nPuede resultar en soluciones simples y elegantes para problemas que se dividen f√°cilmente en subproblemas. Elimina la necesidad de control de bucles expl√≠cito. Sigue la estructura matem√°tica de una definici√≥n recursiva. Las desventajas incluyen:\nPuede ser menos eficiente (alto consumo de memoria) que la iteraci√≥n debido a las llamadas repetidas y creaci√≥n de marcos de pila. Demasiada recursi√≥n puede desbordar la pila de llamadas y causar errores. Puede ser m√°s dif√≠cil de depurar y analizar que la iteraci√≥n. Por lo tanto, la recursi√≥n es una herramienta poderosa que debe usarse con discreci√≥n en los casos apropiados.\nRecursi√≥n vs Iteraci√≥n # La recursi√≥n y la iteraci√≥n (usando ciclos) son paralelos y podemos usar cualquiera para resolver muchos problemas. Ambas t√©cnicas tienen el potencial de resolver los mismos problemas, pero su implementaci√≥n y eficiencia pueden variar. Tomemos el ejemplo del factorial:\nIterativo\ndef factorial_iterativo(n): resultado = 1 for i in range(1, n+1): resultado *= i return resultado Recursivo\ndef factorial_recursivo(n): if n == 1: return 1 return n * factorial(n-1) La versi√≥n iterativa es m√°s eficiente en t√©rminos de espacio, pero la recursiva es m√°s limpia y f√°cil de entender. La elecci√≥n entre recursi√≥n e iteraci√≥n a menudo depende del problema espec√≠fico, las restricciones de memoria y las preferencias del programador.\nConclusi√≥n # La recursi√≥n es una t√©cnica clave que permite escribir algoritmos elegante, naturales y eficientes si se utiliza adecuadamente. Entender c√≥mo dividir un problema en casos recursivos es esencial para dominar esta habilidad. La recursi√≥n ofrece una alternativa declarativa √∫nica para resolver problemas complejos sin necesidad de administrar bucles expl√≠citos. Sin embargo, es crucial recordar siempre definir un caso base adecuado y ser consciente de las limitaciones de la recursi√≥n en t√©rminos de eficiencia y uso de memoria. Saber combinar recursi√≥n e iteraci√≥n nos da flexibilidad al crear soluciones √≥ptimas.\nComo siempre, la clave est√° en encontrar el equilibrio adecuado y utilizar la herramienta correcta para el trabajo adecuado.\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\nReferencias # Kindler, E., \u0026amp; Krivy, I. (2011). Object-Oriented Simulation of systems with Java: A working introduction. BoD‚ÄìBooks on Demand.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"30 septiembre 2023","externalUrl":null,"permalink":"/programming/starting-concepts/recursive-functions/","section":"Programaci√≥n","summary":"","title":"Funciones Recursivas","type":"programming"},{"content":" Elegir un lenguaje de programaci√≥n # La elecci√≥n del lenguaje de programaci√≥n es el primer y quiz√°s el m√°s crucial paso en el proceso de aprendizaje. Hay varios factores a considerar al seleccionar un lenguaje, incluyendo:\nProp√≥sito: ¬øPara qu√© quieres programar? Si es para desarrollo web, JavaScript o PHP podr√≠an ser buenas opciones. Si est√°s interesado en la ciencia de datos, R o Python podr√≠an ser m√°s adecuados. Comunidad: Un lenguaje con una comunidad activa puede ser esencial para los principiantes. Una comunidad vibrante generalmente significa m√°s recursos, tutoriales y soluciones disponibles en l√≠nea. Curva de aprendizaje: Algunos lenguajes son m√°s f√°ciles de aprender que otros. Es fundamental elegir uno que coincida con tu nivel de experiencia y paciencia. Oportunidades de trabajo: Si est√°s buscando una carrera en programaci√≥n, investigar la demanda del mercado para diferentes lenguajes puede ser √∫til. Aunque hay muchos lenguajes valiosos y poderosos, para este curso, hemos elegido Python. Este lenguaje es conocido por su simplicidad y legibilidad, lo que lo hace ideal para aquellos que est√°n empezando. Adem√°s, Python cuenta con una comunidad activa y una amplia gama de aplicaciones, desde desarrollo web hasta inteligencia artificial1.\nInstalaci√≥n de Python # Para usuarios de Windows: # Descargar el instalador: Visita el sitio web oficial de Python en https://www.python.org/downloads/windows/ Haz clic en el enlace de descarga para la √∫ltima versi√≥n de Python 3.x. Ejecuta el instalador: Una vez completada la descarga, localiza y ejecuta el archivo instalador .exe. Aseg√∫rate de marcar la casilla que dice \u0026ldquo;Agregar Python al PATH\u0026rdquo; durante la instalaci√≥n. Este paso es crucial para hacer que Python sea accesible desde el S√≠mbolo del Sistema. Sigue las indicaciones de instalaci√≥n. Verifica la instalaci√≥n: Abre el S√≠mbolo del Sistema y escribe: python --version Esto deber√≠a mostrar la versi√≥n de Python que acabas de instalar. Para usuarios de Mac: # Descargar el instalador: Visita el sitio web oficial de Python en https://www.python.org/downloads/mac-osx/ Haz clic en el enlace de descarga para la √∫ltima versi√≥n de Python 3.x. Ejecuta el instalador: Una vez descargado, localiza y ejecuta el archivo .pkg. Sigue las indicaciones de instalaci√≥n. Verifica la instalaci√≥n: Abre la Terminal y escribe: python3 --version Esto deber√≠a mostrar la versi√≥n de Python que acabas de instalar. Para usuarios de Linux (Ubuntu/Debian): # Actualiza los paquetes: sudo apt update Instala Python: sudo apt install python3 Verifica la instalaci√≥n: Despu√©s de la instalaci√≥n, puedes comprobar la versi√≥n de Python instalada escribiendo: python3 --version Entornos de Desarrollo Integrado (IDEs) # Un IDE es una herramienta que facilita el desarrollo de aplicaciones al combinar com√∫nmente utilizadas en un solo software: editor de c√≥digo, compilador, depurador, entre otros. Elegir el IDE adecuado puede hacer que el proceso de programaci√≥n sea m√°s fluido y eficiente.\nAl evaluar IDEs, considera:\nCompatibilidad con el lenguaje: No todos los IDEs son compatibles con todos los lenguajes de programaci√≥n. Caracter√≠sticas: Algunos IDEs ofrecen funcionalidades como autocompletado, resaltado de sintaxis y herramientas de depuraci√≥n. Extensiones y plugins: La posibilidad de personalizar y extender tu IDE a trav√©s de plugins puede ser muy √∫til. Precio: Hay IDEs gratuitos y otros de pago. Eval√∫a si las caracter√≠sticas adicionales de un IDE de pago justifican el costo. Para este curso, hemos seleccionado Visual Studio Code (VS Code). Es un IDE popular que es gratuito y de c√≥digo abierto. Es conocido por su interfaz sencilla, amplia gama de plugins y capacidad para manejar m√∫ltiples lenguajes de programaci√≥n2. Su comunidad activa garantiza actualizaciones regulares y una amplia gama de recursos de aprendizaje.\nInstalaci√≥n de Visual Studio Code # Para usuarios de Windows: # Descargar el instalador: Visita el sitio web oficial de VS Code en https://code.visualstudio.com/ Haz clic en el bot√≥n \u0026ldquo;Descargar para Windows\u0026rdquo;. Ejecuta el instalador: Una vez completada la descarga, localiza y ejecuta el archivo instalador .exe. Sigue las indicaciones de instalaci√≥n, incluyendo aceptar el acuerdo de licencia y elegir la ubicaci√≥n de instalaci√≥n. Inicia VS Code: Tras la instalaci√≥n, puedes encontrar VS Code en tu men√∫ de inicio. L√°nzalo, ¬°y estar√°s listo para comenzar a programar! Para usuarios de Mac: # Descargar el instalador: Visita el sitio web oficial de VS Code en https://code.visualstudio.com/ Haz clic en el bot√≥n \u0026ldquo;Descargar para Mac\u0026rdquo;. Instala VS Code: Una vez descargado, abre el archivo .zip. Arrastra la aplicaci√≥n Visual Studio Code .app a la carpeta Aplicaciones, para que est√© disponible en el Launchpad. Inicia VS Code: Usa la b√∫squeda de Spotlight o navega hasta tu carpeta de Aplicaciones para iniciar VS Code. Para usuarios de Linux (Ubuntu/Debian): # Actualiza los paquetes e instala las dependencias: sudo apt update sudo apt install software-properties-common apt-transport-https wget **Descarga e instala la claves necesarias: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - A√±ade el repositorio de VS Code: sudo add-apt-repository \u0026#34;deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main\u0026#34; Instala Visual Studio Code: sudo apt update sudo apt install code Inicia VS Code: Puedes iniciar VS Code desde la terminal escribiendo code o encontrarlo en tu lista de aplicaciones instaladas. Escribe y ejecuta tu primer programa # Una vez que hayas configurado tu entorno de programaci√≥n, es hora de sumergirse en la codificaci√≥n.\n¬°Hola mundo! # Este es posiblemente el programa m√°s ic√≥nico para principiantes. Es simple, pero te introduce al proceso de escribir y ejecutar c√≥digo.\nprint(\u0026#34;¬°Hola mundo!\u0026#34;) Ejecuci√≥n del programa Hola Mundo C√°lculo de √°rea y per√≠metro de un tri√°ngulo # Este programa es un poco m√°s complejo. No solo imprime un mensaje, sino que tambi√©n realiza c√°lculos matem√°ticos.\n# Entrada del usuario lado1 = float(input(\u0026#34;Introduce la longitud del primer lado: \u0026#34;)) lado2 = float(input(\u0026#34;Introduce la longitud del segundo lado: \u0026#34;)) lado3 = float(input(\u0026#34;Introduce la longitud del tercer lado: \u0026#34;)) # C√°lculo del per√≠metro perimetro = lado1 + lado2 + lado3 # C√°lculo del √°rea usando la f√≥rmula de Her√≥n s = perimetro / 2 area = (s*(s-lado1)*(s-lado2)*(s-lado3)) ** 0.5 print(f\u0026#34;El per√≠metro del tri√°ngulo es: {perimetro}\u0026#34;) print(f\u0026#34;El √°rea del tri√°ngulo es: {area:.2f}\u0026#34;) Ejecuci√≥n del programa Triangulo Conclusi√≥n # Configurar un entorno de programaci√≥n puede parecer desalentador al principio, pero con las herramientas y recursos adecuados, se convierte en una tarea manejable y gratificante. Esperamos que este art√≠culo te haya proporcionado una base s√≥lida para comenzar tu viaje en programaci√≥n. ¬°Feliz codificaci√≥n!\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\nReferencias # Lutz, M. (2013). Learning Python. O\u0026rsquo;Reilly Media.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMicrosoft. (2020). Visual Studio Code Documentation. Microsoft Docs.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"10 septiembre 2023","externalUrl":null,"permalink":"/programming/intro/setup-dev-environment/","section":"Programaci√≥n","summary":"","title":"Configura tu Entorno de Desarrollo","type":"programming"},{"content":"Key characteristics of composition:\nIt represents a strong \u0026ldquo;has-a\u0026rdquo; relationship. The \u0026ldquo;part\u0026rdquo; object cannot exist independently of the \u0026ldquo;whole\u0026rdquo; object. When the \u0026ldquo;whole\u0026rdquo; object is destroyed, all its \u0026ldquo;part\u0026rdquo; objects are also destroyed. A \u0026ldquo;part\u0026rdquo; object belongs to only one \u0026ldquo;whole\u0026rdquo; object at a time. Let\u0026rsquo;s look at an example to illustrate composition:\nclass Engine: def __init__(self, horsepower): self.horsepower = horsepower def start(self): return \u0026#34;Engine started\u0026#34; class Car: def __init__(self, make, model, horsepower): self.make = make self.model = model self.engine = Engine(horsepower) # Composition: Car creates its own Engine def start_car(self): return f\u0026#34;{self.make} {self.model}: {self.engine.start()}\u0026#34; def __del__(self): print(f\u0026#34;{self.make} {self.model} is being destroyed, and so is its engine.\u0026#34;) # Creating a Car instance my_car = Car(\u0026#34;Toyota\u0026#34;, \u0026#34;Corolla\u0026#34;, 150) print(my_car.start_car()) # Output: Toyota Corolla: Engine started # When we delete the Car, its Engine is also deleted del my_car # This will print: Toyota Corolla is being destroyed, and so is its engine. In this example, we have a composition relationship between Car and Engine. A Car has an Engine, and the Engine cannot exist independently of the Car. When a Car object is created, it creates its own Engine. When the Car object is destroyed, its Engine is also destroyed.\nHere\u0026rsquo;s a UML diagram representing this composition relationship:\nclassDiagram class Car { +make: string +model: string -engine: Engine +start_car() +__del__() } class Engine { -horsepower: int +start() } Car *-- Engine : has end In this diagram, the filled diamond on the Car side of the relationship indicates composition. This shows that Car is the \u0026ldquo;whole\u0026rdquo; and Engine is the \u0026ldquo;part\u0026rdquo; in this relationship, and that the Engine\u0026rsquo;s lifetime is tied to the Car\u0026rsquo;s lifetime.\nThe key difference between aggregation and composition is the strength of the relationship and the lifecycle dependency. In aggregation, the \u0026ldquo;part\u0026rdquo; can exist independently of the \u0026ldquo;whole\u0026rdquo;, while in composition, the \u0026ldquo;part\u0026rdquo; cannot exist without the \u0026ldquo;whole\u0026rdquo;.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy ‚Äì drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-composition/","section":"Programming","summary":"","title":"Class relations: Composition","type":"programming"},{"content":"La naturaleza FIFO (first in, first out) de las colas se debe a que s√≥lo se puede acceder y manipular el elemento inicial. Cuando se agrega un elemento a la cola se conoce como \u0026ldquo;enqueue\u0026rdquo;, mientras que eliminar un elemento se denomina \u0026ldquo;dequeue\u0026rdquo;.\nEsto hace que el primer elemento en ser a√±adido a la cola tambi√©n sea el primero en ser retirado, de ah√≠ su comportamiento FIFO.\nDiagrama de una cola Operaciones principales # Las operaciones b√°sicas de una cola son:\nEnqueue: Agrega un elemento al final de la cola. Dequeue: Saca el elemento del frente de la cola. Peek: Obtiene el elemento al frente sin sacarlo. isEmpty: Consulta si la cola est√° vac√≠a. Implementaci√≥n # Al igual que las pilas, las colas se pueden implementar usando listas enlazadas. Se agrega al final y se saca del frente manteniendo referencias a ambos extremos.\nclass Node: def __init__(self, value): self.value = value self.next = None class Queue: def __init__(self): self.front = None self.end = None self.size = 0 def enqueue(self, value): new_node = Node(value) if self.end is None: self.end = new_node self.front = new_node return self.end.next = new_node self.end = new_node self.size += 1 def dequeue(self): if self.is_empty(): return None value = self.front.value self.front = self.front.next if self.front is None: self.end = None self.size -= 1 return value def peek(self): if self.is_empty(): return None return self.front.value def is_empty(self): return self.front is None # Returns true if front is None def __len__(self): return self.size def __str__(self): values = [] current = self.front while current: values.append(str(current.value)) current = current.next return \u0026#34;\\n\u0026#34;.join(values) print(\u0026#34;Creating a new queue\u0026#34;) queue = Queue() print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if queue is empty\u0026#34;) print(f\u0026#34;Is queue empty? {queue.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Enqueue three elements\u0026#34;) queue.enqueue(\u0026#34;ABC\u0026#34;) queue.enqueue(\u0026#34;DEF\u0026#34;) queue.enqueue(\u0026#34;GHI\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after enqueuing elements:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get front element using dequeue\u0026#34;) print(f\u0026#34;queue.dequeue() =\u0026gt; {queue.dequeue()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after dequeue element:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print front element using peek\u0026#34;) print(f\u0026#34;queue.peek() =\u0026gt; {queue.peek()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after peek:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get front element using dequeue\u0026#34;) print(f\u0026#34;queue.dequeue() =\u0026gt; {queue.dequeue()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after dequeue element:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if queue is empty\u0026#34;) print(f\u0026#34;Is queue empty? {queue.is_empty()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Get front element using dequeue\u0026#34;) print(f\u0026#34;queue.dequeue() =\u0026gt; {queue.dequeue()}\u0026#34;) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Print queue after dequeue element:\u0026#34;) print(queue) print(\u0026#34;==========\u0026#34;) print(\u0026#34;Check if queue is empty\u0026#34;) print(f\u0026#34;Is queue empty? {queue.is_empty()}\u0026#34;) Ejemplos de uso # Algunos usos comunes de colas:\nColas de impresi√≥n donde primero en entrar, primero en imprimir. Colas de tareas en sistemas operativos para orden de ejecuci√≥n. Simulaciones donde se debe respetar orden de llegada como en bancos. Canales de mensajes como los de RabbitMQ o Kafka. Buffers circulares en audio para streaming. Conclusi√≥n # Las colas son estructuras vers√°tiles gracias a su principio FIFO. Tener un buen manejo de colas, implementaci√≥n y aplicaciones reforzar√° tus habilidades como programador.\n¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"03 noviembre 2023","externalUrl":null,"permalink":"/programming/data-structures/queues/","section":"Programaci√≥n","summary":"","title":"Colas","type":"programming"},{"content":"Key characteristics of inheritance:\nIt promotes code reuse and establishes a hierarchy between classes. The subclass inherits all public and protected members from the superclass. The subclass can add its own members and override inherited members. It supports the concept of polymorphism. Let\u0026rsquo;s look at an example to illustrate inheritance:\nclass Animal: def __init__(self, name): self.name = name def speak(self): pass class Dog(Animal): def speak(self): return f\u0026#34;{self.name} says Woof!\u0026#34; class Cat(Animal): def speak(self): return f\u0026#34;{self.name} says Meow!\u0026#34; # Creating instances dog = Dog(\u0026#34;Buddy\u0026#34;) cat = Cat(\u0026#34;Whiskers\u0026#34;) print(dog.speak()) # Output: Buddy says Woof! print(cat.speak()) # Output: Whiskers says Meow! # Demonstrating polymorphism def animal_sound(animal): print(animal.speak()) animal_sound(dog) # Output: Buddy says Woof! animal_sound(cat) # Output: Whiskers says Meow! In this example, we have a base class Animal and two derived classes Dog and Cat. Both Dog and Cat inherit from Animal and override the speak method.\nHere\u0026rsquo;s a UML diagram representing this inheritance relationship:\nclassDiagram class Animal { +name: string +speak() } class Dog { +speak() } class Cat { +speak() } Animal \u003c|-- Dog Animal \u003c|-- Cat end In this diagram, the arrows pointing from Dog and Cat to Animal indicate inheritance. This shows that Dog and Cat are subclasses of Animal.\nInheritance is a powerful feature of OOP, but it should be used judiciously. Overuse of inheritance can lead to complex class hierarchies that are difficult to understand and maintain. The principle of \u0026ldquo;composition over inheritance\u0026rdquo; suggests that it\u0026rsquo;s often better to use composition (has-a relationship) rather than inheritance (is-a relationship) when designing class relationships.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy ‚Äì drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-inheritance/","section":"Programming","summary":"","title":"Class relations: Inheritance","type":"programming"},{"content":"Key characteristics of realisation:\nIt represents a contract that the implementing class must fulfil. The class must provide implementations for all methods declared in the interface. It allows for polymorphism through interfaces. Python doesn\u0026rsquo;t have a built-in interface concept like some other languages (e.g., Java), but we can simulate interfaces using abstract base classes. Here\u0026rsquo;s an example:\nfrom abc import ABC, abstractmethod class Drawable(ABC): @abstractmethod def draw(self): pass class Circle(Drawable): def draw(self): return \u0026#34;Drawing a circle\u0026#34; class Square(Drawable): def draw(self): return \u0026#34;Drawing a square\u0026#34; def draw_shape(shape: Drawable): print(shape.draw()) # Creating instances circle = Circle() square = Square() # Using polymorphism through the interface draw_shape(circle) # Output: Drawing a circle draw_shape(square) # Output: Drawing a square In this example, Drawable is an abstract base class that acts like an interface. Both Circle and Square implement the Drawable interface by providing their own implementation of the draw method.\nHere\u0026rsquo;s a UML diagram representing this realisation relationship:\nclassDiagram class Drawable { \u003c\u003e +draw() } class Circle { +draw() } class Square { +draw() } Drawable \u003c|.. Circle Drawable \u003c|.. Square end In this diagram, the dashed arrows pointing from Circle and Square to Drawable indicate realisation. This shows that Circle and Square implement the Drawable interface.\nRealisation is a powerful concept that allows for designing loosely coupled systems. By programming to interfaces rather than concrete implementations, we can create more flexible and extensible software.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy ‚Äì drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-realisation/","section":"Programming","summary":"","title":"Class relations: Realisation (Implementation)","type":"programming"},{"content":"Key characteristics of dependency:\nIt represents a \u0026ldquo;uses\u0026rdquo; relationship between classes. It\u0026rsquo;s a weaker relationship compared to association, aggregation, or composition. Changes in the used class may affect the using class. Here\u0026rsquo;s an example to illustrate dependency:\nclass Printer: def print_document(self, document): return f\u0026#34;Printing: {document.get_content()}\u0026#34; class PDFDocument: def get_content(self): return \u0026#34;PDF content\u0026#34; class WordDocument: def get_content(self): return \u0026#34;Word document content\u0026#34; # Using the Printer printer = Printer() pdf = PDFDocument() word = WordDocument() print(printer.print_document(pdf)) # Output: Printing: PDF content print(printer.print_document(word)) # Output: Printing: Word document content In this example, the Printer class has a dependency on both PDFDocument and WordDocument classes. The Printer uses these classes in its print_document method, but it doesn\u0026rsquo;t maintain a long-term relationship with them.\nHere\u0026rsquo;s a UML diagram representing these dependency relationships:\nclassDiagram class Printer { +print_document(document) } class PDFDocument { +get_content() } class WordDocument { +get_content() } Printer ..\u003e PDFDocument : uses Printer ..\u003e WordDocument : uses end In this diagram, the dashed arrows pointing from Printer to PDFDocument and WordDocument indicate dependency. This shows that Printer uses these classes, but doesn\u0026rsquo;t have a stronger relationship with them.\nDependency is often used to reduce coupling between classes. By depending on abstractions (like interfaces) rather than concrete classes, we can make our code more flexible and easier to change.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy ‚Äì drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-dependency/","section":"Programming","summary":"","title":"Class relations: Dependency","type":"programming"},{"content":" Comparing and contrasting relations # Now that we\u0026rsquo;ve explored the various types of class relations, let\u0026rsquo;s compare and contrast them to better understand when to use each:\nAssociation vs Aggregation vs Composition\nAssociation is the most general relationship, representing any connection between classes. Aggregation is a specialised association representing a whole-part relationship where the part can exist independently. Composition is the strongest whole-part relationship where the part cannot exist independently of the whole. Inheritance vs Composition\nInheritance represents an \u0026ldquo;is-a\u0026rdquo; relationship (e.g., a Dog is an Animal). Composition represents a \u0026ldquo;has-a\u0026rdquo; relationship (e.g., a Car has an Engine). The principle of \u0026ldquo;composition over inheritance\u0026rdquo; suggests favouring composition for more flexible designs. Realisation vs Inheritance\nRealisation is about implementing an interface, focusing on behaviour. Inheritance is about extending a class, inheriting both state and behaviour. Dependency vs Association\nDependency is a weaker, often temporary relationship (e.g., a method parameter). Association implies a more permanent relationship, often represented by a class attribute. Here\u0026rsquo;s a comparison table summarising these relationships:\nRelationship Strength Lifecycle Binding \u0026ldquo;Is-a\u0026rdquo; or \u0026ldquo;Has-a\u0026rdquo; Symbol in UML Dependency Weakest None Uses - - - - \u0026gt; Association Weak Independent Has-a (loose) ‚Äî‚Äî‚Äî\u0026gt; Aggregation Medium Independent Has-a ‚óá‚Äî‚Äî‚Äî\u0026gt; Composition Strong Dependent Has-a (strong) ‚ô¶‚Äî‚Äî‚Äî\u0026gt; Inheritance Strong N/A Is-a ‚Äî‚Äî‚Äî Realisation Medium N/A Behaves-as - - - Common pitfalls # While class relationships are powerful tools in OOP, they can also lead to common pitfalls if not used carefully. Here are some common issues and how to avoid them:\nOveruse of inheritance\nProblem: Creating deep inheritance hierarchies that are hard to understand and maintain. Solution: Prefer composition over inheritance. Use inheritance only for genuine \u0026ldquo;is-a\u0026rdquo; relationships. Tight coupling\nProblem: Creating strong dependencies between classes, making the system rigid and hard to change. Solution: Use interfaces and dependency injection to reduce coupling. Depend on abstractions rather than concrete classes. God objects\nProblem: Creating classes that try to do too much, violating the Single Responsibility Principle. Solution: Break large classes into smaller, more focused classes. Use composition to bring functionality together. Circular dependencies\nProblem: Creating mutual dependencies between classes, leading to complex and hard-to-maintain code. Solution: Refactor to remove circular dependencies. Consider using interfaces or introducing a new class to break the cycle. Leaky abstractions\nProblem: Exposing implementation details through interfaces or base classes. Solution: Design interfaces and base classes carefully. Hide implementation details and expose only what\u0026rsquo;s necessary. Inappropriate intimacy\nProblem: Classes that know too much about each other\u0026rsquo;s internal details. Solution: Encapsulate data and behaviour. Use public interfaces to interact between classes. Brittle base classes\nProblem: Changes to base classes breaking derived classes in unexpected ways. Solution: Design base classes for extension. Document how derived classes should interact with base classes. Diamond problem in multiple inheritance\nProblem: Ambiguity in method resolution when a class inherits from two classes with a common ancestor. Solution: Avoid multiple inheritance if possible. Use interfaces or mixins instead. Overuse of getters and setters\nProblem: Breaking encapsulation by providing unrestricted access to internal state. Solution: Use meaningful methods that represent behaviors rather than exposing internal data directly. Violation of Liskov Substitution Principle\nProblem: Derived classes that can\u0026rsquo;t be used interchangeably with their base classes. Solution: Ensure that derived classes truly represent specialisations of their base classes. Use composition if the \u0026ldquo;is-a\u0026rdquo; relationship doesn\u0026rsquo;t hold. By being aware of these pitfalls and following best practices, you can create more robust and maintainable object-oriented designs.\nConclusion # Key takeaways:\nAssociation is a general relationship between classes. Aggregation represents a whole-part relationship where parts can exist independently. Composition is a stronger whole-part relationship where parts cannot exist independently. Inheritance represents an \u0026ldquo;is-a\u0026rdquo; relationship and promotes code reuse. Realisation is about implementing interfaces and focusing on behaviour. Dependency is a weak, often temporary relationship between classes. Remember that good object-oriented design is not just about using these relationships, but about using them appropriately. Always consider the SOLID principles and the \u0026ldquo;composition over inheritance\u0026rdquo; guideline.\nReferences # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Fowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley. Bloch, J. (2018). Effective Java (3rd ed.). Addison-Wesley. Phillips, D. (2018). Python 3 Object-Oriented Programming (3rd ed.). Packt Publishing. Lott, S. F. (2020). Object-Oriented Python: Master OOP by Building Games and GUIs. No Starch Press. Booch, G., Rumbaugh, J., \u0026amp; Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd ed.). Addison-Wesley. Cheers for making it this far! I hope this journey through the programming universe has been as fascinating for you as it was for me to write down.\nWe\u0026rsquo;re keen to hear your thoughts, so don\u0026rsquo;t be shy ‚Äì drop your comments, suggestions, and those bright ideas you\u0026rsquo;re bound to have.\nAlso, to delve deeper than these lines, take a stroll through the practical examples we\u0026rsquo;ve cooked up for you. You\u0026rsquo;ll find all the code and projects in our GitHub repository learn-software-engineering/examples.\nThanks for being part of this learning community. Keep coding and exploring new territories in this captivating world of software!\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/programming/oop/class-relations-conclusion/","section":"Programming","summary":"","title":"Class relations: Conclusion","type":"programming"},{"content":"En el coraz√≥n de la Programaci√≥n Orientada a Objetos (POO) se encuentran cuatro conceptos fundamentales: Encapsulamiento, Herencia, Polimorfismo y Abstracci√≥n. Estos conceptos, conocidos como los \u0026ldquo;cuatro pilares\u0026rdquo; de la POO, constituyen la base sobre la cual se construyen sistemas de software complejos. En esta gu√≠a, profundizaremos en cada uno de estos conceptos, explorando sus definiciones, implementaciones y aplicaciones pr√°cticas. Utilizaremos Python, un lenguaje reconocido por su claridad y versatilidad, para demostrar estos conceptos en acci√≥n. Ya seas un principiante que comienza su viaje en la programaci√≥n o un profesional experimentado que busca refrescar sus conocimientos, este art√≠culo tiene como objetivo proporcionar informaci√≥n valiosa y una comprensi√≥n m√°s profunda de los principios de la POO.\nEl encapsulamiento nos permite agrupar datos y m√©todos, ocultando detalles internos y protegiendo la integridad de los datos. La herencia permite la reutilizaci√≥n de c√≥digo y la creaci√≥n de relaciones jer√°rquicas entre clases. El polimorfismo proporciona una forma de usar objetos de diferentes tipos a trav√©s de una interfaz com√∫n, mejorando la flexibilidad y extensibilidad. La abstracci√≥n nos permite crear modelos simplificados de sistemas complejos, enfoc√°ndonos en las caracter√≠sticas esenciales y ocultando los detalles innecesarios. A medida que contin√∫es tu viaje en el desarrollo de software, descubrir√°s que dominar estos conceptos abre nuevas formas de pensar y resolver problemas. Recuerda que la POO no se trata solo de sintaxis o caracter√≠sticas del lenguaje; es una mentalidad para modelar sistemas complejos y gestionar la complejidad en el software.\n","date":"07 diciembre 2024","externalUrl":null,"permalink":"/programming/oop/the-four-pillars-introduction/","section":"Programaci√≥n","summary":"","title":"Los Cuatro Pilares","type":"programming"},{"content":"La importancia del encapsulamiento radica en varios aspectos clave:\nProtecci√≥n de datos: Al controlar el acceso a los datos del objeto a trav√©s de m√©todos, podemos asegurar que los datos se mantengan consistentes y v√°lidos. Modularidad: El encapsulamiento permite que los objetos sean autocontenidos, facilitando la comprensi√≥n y el mantenimiento del c√≥digo. Flexibilidad: La implementaci√≥n interna puede ser modificada sin afectar otras partes del c√≥digo que utilizan el objeto. Reducci√≥n de complejidad: Al ocultar los detalles del funcionamiento interno, el encapsulamiento reduce la complejidad del sistema desde una perspectiva externa. Implementaci√≥n en Python # Python ofrece varios mecanismos para implementar el encapsulamiento. Exploremos estos con ejemplos:\n1. Uso de atributos privados # En Python, podemos crear atributos privados prefijando el nombre del atributo con doble guion bajo (__). Esto activa el \u0026ldquo;name mangling\u0026rdquo;, que hace que el atributo sea m√°s dif√≠cil de acceder desde fuera de la clase.\nclass CuentaBancaria: def __init__(self, numero_cuenta, saldo): self.__numero_cuenta = numero_cuenta # Atributo privado self.__saldo = saldo # Atributo privado def depositar(self, cantidad): if cantidad \u0026gt; 0: self.__saldo += cantidad return True return False def retirar(self, cantidad): if 0 \u0026lt; cantidad \u0026lt;= self.__saldo: self.__saldo -= cantidad return True return False def obtener_saldo(self): return self.__saldo # Uso cuenta = CuentaBancaria(\u0026#34;1234567890\u0026#34;, 1000) print(cuenta.obtener_saldo()) # Salida: 1000 cuenta.depositar(500) print(cuenta.obtener_saldo()) # Salida: 1500 cuenta.retirar(200) print(cuenta.obtener_saldo()) # Salida: 1300 # Esto generar√° un AttributeError # print(cuenta.__saldo) En este ejemplo:\n__numero_cuenta y __saldo son atributos privados. Proporcionamos m√©todos p√∫blicos (depositar, retirar, obtener_saldo) para interactuar con estos atributos privados. El acceso directo a __saldo desde fuera de la clase generar√° una excepci√≥n AttributeError. 2. Uso de propiedades # El decorador @property de Python nos permite definir m√©todos que pueden ser accedidos como atributos, proporcionando una forma m√°s pythonica de implementar getters y setters.\nclass Circulo: def __init__(self, radio): self._radio = radio @property def radio(self): return self._radio @radio.setter def radio(self, valor): if valor \u0026gt; 0: self._radio = valor else: raise ValueError(\u0026#34;El radio debe ser positivo\u0026#34;) @property def area(self): return 3.14159 * self._radio ** 2 # Uso circulo = Circulo(5) print(circulo.radio) # Salida: 5 print(circulo.area) # Salida: 78.53975 circulo.radio = 7 print(circulo.radio) # Salida: 7 print(circulo.area) # Salida: 153.93791 # Esto generar√° un ValueError # circulo.radio = -1 En este ejemplo:\n_radio es un atributo protegido (el guion bajo simple es una convenci√≥n para atributos protegidos en Python). La propiedad radio proporciona acceso de lectura y escritura a _radio con validaci√≥n. La propiedad area es de solo lectura y se calcula al vuelo. Beneficios y mejores pr√°cticas # Los beneficios del encapsulamiento son numerosos:\nMejora de la mantenibilidad: Los cambios en la implementaci√≥n interna no afectan al c√≥digo externo que utiliza la clase. Mayor seguridad: Los atributos privados no pueden ser modificados accidentalmente desde fuera de la clase. Flexibilidad en la implementaci√≥n: Puedes cambiar c√≥mo se almacenan o calculan los datos sin cambiar la interfaz p√∫blica. Mejor abstracci√≥n: Los usuarios de la clase no necesitan conocer su funcionamiento interno. Las mejores pr√°cticas para el encapsulamiento en Python incluyen:\nUsar atributos privados (prefijo de doble guion bajo) para datos que no deben ser accedidos directamente desde fuera de la clase. Proporcionar m√©todos p√∫blicos o propiedades para el acceso controlado a los datos internos. Usar propiedades en lugar de m√©todos get/set para un enfoque m√°s propio del paradigma Python. Documentar claramente la interfaz p√∫blica, incluyendo cualquier efecto secundario de los m√©todos. Veamos un ejemplo m√°s complejo que demuestra estas pr√°cticas:\nclass Empleado: def __init__(self, nombre, salario): self.__nombre = nombre self.__salario = salario self.__proyectos = [] @property def nombre(self): return self.__nombre @property def salario(self): return self.__salario @salario.setter def salario(self, valor): if valor \u0026gt; 0: self.__salario = valor else: raise ValueError(\u0026#34;El salario debe ser positivo\u0026#34;) def agregar_proyecto(self, proyecto): \u0026#34;\u0026#34;\u0026#34; Agrega un proyecto a la lista de proyectos del empleado. :param proyecto: cadena que representa el nombre del proyecto \u0026#34;\u0026#34;\u0026#34; self.__proyectos.append(proyecto) def eliminar_proyecto(self, proyecto): \u0026#34;\u0026#34;\u0026#34; Elimina un proyecto de la lista de proyectos del empleado. :param proyecto: cadena que representa el nombre del proyecto :return: True si el proyecto fue eliminado, False si no se encontr√≥ \u0026#34;\u0026#34;\u0026#34; if proyecto in self.__proyectos: self.__proyectos.remove(proyecto) return True return False @property def cantidad_proyectos(self): return len(self.__proyectos) def __str__(self): return f\u0026#34;Empleado: {self.__nombre}, Salario: ${self.__salario}, Proyectos: {self.cantidad_proyectos}\u0026#34; # Uso emp = Empleado(\u0026#34;Juan P√©rez\u0026#34;, 50000) print(emp.nombre) # Salida: Juan P√©rez print(emp.salario) # Salida: 50000 emp.agregar_proyecto(\u0026#34;Proyecto A\u0026#34;) emp.agregar_proyecto(\u0026#34;Proyecto B\u0026#34;) print(emp.cantidad_proyectos) # Salida: 2 emp.salario = 55000 print(emp) # Salida: Empleado: Juan P√©rez, Salario: $55000, Proyectos: 2 emp.eliminar_proyecto(\u0026#34;Proyecto A\u0026#34;) print(emp.cantidad_proyectos) # Salida: 1 # Esto generar√° un AttributeError # print(emp.__proyectos) Este ejemplo demuestra:\nAtributos privados (__nombre, __salario, __proyectos) Propiedades para acceso controlado (nombre, salario, cantidad_proyectos) M√©todos p√∫blicos para manipular datos privados (agregar_proyecto, eliminar_proyecto) Documentaci√≥n clara del comportamiento de los m√©todos Un m√©todo __str__ personalizado para una representaci√≥n de cadena agradable del objeto Siguiendo estas pr√°cticas, creamos una clase que es flexible y robusta, encarnando el principio de encapsulamiento.\nReferencias # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ ¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/programming/oop/the-four-pillars-encapsulation/","section":"Programaci√≥n","summary":"","title":"Los Cuatro Pilares: Encapsulamiento","type":"programming"},{"content":"Los aspectos clave de la herencia incluyen:\nReutilizaci√≥n de c√≥digo: La herencia permite reutilizar c√≥digo de clases existentes, reduciendo la redundancia y promoviendo un desarrollo eficiente. Clasificaci√≥n jer√°rquica: Permite la creaci√≥n de jerarqu√≠as de clases, representando relaciones y caracter√≠sticas comunes entre objetos. Extensibilidad: Se puede agregar nueva funcionalidad a las clases existentes sin modificarlas, siguiendo el principio abierto-cerrado. Polimorfismo: La herencia es un prerrequisito para el polimorfismo en tiempo de ejecuci√≥n (que discutiremos en detalle m√°s adelante). Tipos de herencia # Existen varios tipos de herencia, aunque no todos los lenguajes de programaci√≥n admiten todos los tipos. Los principales tipos son:\nHerencia simple: Una clase derivada hereda de una sola clase base. Herencia m√∫ltiple: Una clase derivada hereda de m√∫ltiples clases base. Herencia multinivel: Una clase derivada hereda de otra clase derivada. Herencia jer√°rquica: M√∫ltiples clases derivadas heredan de una sola clase base. Herencia h√≠brida: Una combinaci√≥n de dos o m√°s tipos de herencia. Python admite todos estos tipos de herencia. Exploremos cada uno con ejemplos.\nHerencia simple # La herencia simple es la forma m√°s b√°sica de herencia, donde una clase hereda de una sola clase base.\nclass Animal: def __init__(self, especie): self.especie = especie def hacer_sonido(self): pass class Perro(Animal): def __init__(self, nombre): super().__init__(\u0026#34;Canino\u0026#34;) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¬°Guau!\u0026#34; # Uso perro = Perro(\u0026#34;Buddy\u0026#34;) print(f\u0026#34;{perro.nombre} es un {perro.especie}\u0026#34;) # Salida: Buddy es un Canino print(perro.hacer_sonido()) # Salida: ¬°Guau! En este ejemplo:\nAnimal es la clase base con un m√©todo gen√©rico hacer_sonido. Perro es derivado de Animal, heredando sus atributos y m√©todos. Perro sobrescribe el m√©todo hacer_sonido con su propia implementaci√≥n. Usamos super().__init__() para llamar al inicializador de la clase base. Herencia m√∫ltiple # La herencia m√∫ltiple permite que una clase herede de m√∫ltiples clases base. Algunos lenguajes no permiten este tipo de herencia.\nclass Volador: def volar(self): return \u0026#34;¬°Puedo volar!\u0026#34; class Nadador: def nadar(self): return \u0026#34;¬°Puedo nadar!\u0026#34; class Pato(Animal, Volador, Nadador): def __init__(self, nombre): Animal.__init__(self, \u0026#34;Ave\u0026#34;) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¬°Cuac!\u0026#34; # Uso pato = Pato(\u0026#34;Donald\u0026#34;) print(f\u0026#34;{pato.nombre} es un {pato.especie}\u0026#34;) # Salida: Donald es un Ave print(pato.hacer_sonido()) # Salida: ¬°Cuac! print(pato.volar()) # Salida: ¬°Puedo volar! print(pato.nadar()) # Salida: ¬°Puedo nadar! Aqu√≠, Pato hereda de Animal, Volador y Nadador, combinando atributos y m√©todos de las tres clases.\nHerencia multinivel # En la herencia multinivel, una clase derivada hereda de otra clase derivada.\nclass Mamifero(Animal): def __init__(self, especie, es_de_sangre_caliente=True): super().__init__(especie) self.es_de_sangre_caliente = es_de_sangre_caliente def dar_a_luz(self): return \u0026#34;Dando a luz cr√≠as vivas\u0026#34; class Gato(Mamifero): def __init__(self, nombre): super().__init__(\u0026#34;Felino\u0026#34;) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¬°Miau!\u0026#34; # Uso gato = Gato(\u0026#34;Bigotes\u0026#34;) print(f\u0026#34;{gato.nombre} es un {gato.especie}\u0026#34;) # Salida: Bigotes es un Felino print(gato.hacer_sonido()) # Salida: ¬°Miau! print(gato.dar_a_luz()) # Salida: Dando a luz cr√≠as vivas print(f\u0026#34;¬øEs de sangre caliente? {gato.es_de_sangre_caliente}\u0026#34;) # Salida: ¬øEs de sangre caliente? True En este ejemplo, Gato hereda de Mamifero, que a su vez hereda de Animal, formando una cadena de herencia multinivel.\nHerencia jer√°rquica # La herencia jer√°rquica implica m√∫ltiples clases derivadas heredando de una sola clase base.\nclass Ave(Animal): def __init__(self, especie, puede_volar=True): super().__init__(especie) self.puede_volar = puede_volar class Loro(Ave): def __init__(self, nombre): super().__init__(\u0026#34;Psit√°cido\u0026#34;, puede_volar=True) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¬°Squawk!\u0026#34; class Pinguino(Ave): def __init__(self, nombre): super().__init__(\u0026#34;Esfenisciforme\u0026#34;, puede_volar=False) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¬°Honk!\u0026#34; # Uso loro = Loro(\u0026#34;Polly\u0026#34;) pinguino = Pinguino(\u0026#34;Pingu\u0026#34;) print(f\u0026#34;{loro.nombre} puede volar: {loro.puede_volar}\u0026#34;) # Salida: Polly puede volar: True print(f\u0026#34;{pinguino.nombre} puede volar: {pinguino.puede_volar}\u0026#34;) # Salida: Pingu puede volar: False Aqu√≠, tanto Loro como Pinguino heredan de Ave, lo que demuestra la herencia jer√°rquica.\nHerencia h√≠brida # La herencia h√≠brida es una combinaci√≥n de m√∫ltiples tipos de herencia. Veamos un ejemplo m√°s complejo para ilustrar esto:\nclass Terrestre: def caminar(self): return \u0026#34;Caminando en tierra\u0026#34; class Acuatico: def nadar(self): return \u0026#34;Nadando en el agua\u0026#34; class Anfibio(Animal, Terrestre, Acuatico): def __init__(self, especie): Animal.__init__(self, especie) def adaptarse(self): return \u0026#34;Puede sobrevivir tanto en tierra como en agua\u0026#34; class Rana(Anfibio): def __init__(self, nombre): super().__init__(\u0026#34;Anuro\u0026#34;) self.nombre = nombre def hacer_sonido(self): return \u0026#34;¬°Croac!\u0026#34; # Uso rana = Rana(\u0026#34;Kermit\u0026#34;) print(f\u0026#34;{rana.nombre} es un {rana.especie}\u0026#34;) # Salida: Kermit es un Anuro print(rana.hacer_sonido()) # Salida: ¬°Croac! print(rana.caminar()) # Salida: Caminando en tierra print(rana.nadar()) # Salida: Nadando en el agua print(rana.adaptarse()) # Salida: Puede sobrevivir tanto en tierra como en agua Este ejemplo demuestra la herencia h√≠brida:\nRana hereda de Anfibio Anfibio hereda de Animal, Terrestre, y Acuatico Esto crea una combinaci√≥n de herencia multinivel y m√∫ltiple Consideraciones # La herencia ofrece varias ventajas. Sin embargo, tambi√©n hay consideraciones importantes:\nComplejidad: Las jerarqu√≠as de herencia profundas pueden volverse dif√≠ciles de entender y mantener. Acoplamiento fuerte: La herencia crea un acoplamiento fuerte entre las clases base y derivadas. Problema de la clase base fr√°gil: Los cambios en la clase base pueden afectar inesperadamente a las clases derivadas. Problema del diamante: En la herencia m√∫ltiple, pueden surgir conflictos si dos clases base tienen m√©todos con el mismo nombre. Para abordar estas consideraciones:\nPrefiere la composici√≥n sobre la herencia cuando sea posible. Mant√©n las jerarqu√≠as de herencia poco profundas y enfocadas. Utiliza clases base abstractas para definir interfaces claras. Ten cuidado con la herencia m√∫ltiple y resuelve los conflictos expl√≠citamente. Visualicemos las relaciones de herencia que hemos discutido utilizando un diagrama de clases UML:\nclassDiagram Animal \u0026lt;|-- Mam√≠fero Animal \u0026lt;|-- Ave Mam√≠fero \u0026lt;|-- Perro Mam√≠fero \u0026lt;|-- Gato Ave \u0026lt;|-- Loro Ave \u0026lt;|-- Ping√ºino Animal \u0026lt;|-- Anfibio Terrestre \u0026lt;|-- Anfibio Acu√°tico \u0026lt;|-- Anfibio Anfibio \u0026lt;|-- Rana class Animal { +especie: str +hacer_sonido() } class Mam√≠fero { +es_de_sangre_caliente: bool +dar_a_luz() } class Ave { +puede_volar: bool } class Anfibio { +adaptarse() } class Terrestre { +caminar() } class Acu√°tico { +nadar() } Este diagrama ilustra las relaciones de herencia entre las clases que hemos discutido, mostrando tanto la herencia simple como la m√∫ltiple.\nReferencias # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ ¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/programming/oop/the-four-pillars-inheritance/","section":"Programaci√≥n","summary":"","title":"Los Cuatro Pilares: Herencia","type":"programming"},{"content":"El polimorfismo permite escribir c√≥digo flexible y reutilizable al permitirnos trabajar con objetos a un nivel m√°s abstracto, sin necesidad de conocer sus tipos espec√≠ficos.\nExisten dos tipos principales de polimorfismo en la programaci√≥n orientada a objetos:\nPolimorfismo en tiempo de compilaci√≥n (Polimorfismo est√°tico)\nSe logra a trav√©s de la sobrecarga de m√©todos. Se resuelve en tiempo de compilaci√≥n. Polimorfismo en tiempo de ejecuci√≥n (Polimorfismo din√°mico)\nSe logra a trav√©s de la sobrescritura de m√©todos. Se resuelve en tiempo de ejecuci√≥n. Python admite principalmente el polimorfismo en tiempo de ejecuci√≥n, ya que es un lenguaje de tipado din√°mico. Sin embargo, podemos demostrar conceptos similares al polimorfismo en tiempo de compilaci√≥n tambi√©n.\nExploremos diferentes aspectos del polimorfismo en Python:\nDuck typing # Python utiliza el duck typing, que es una forma de polimorfismo. La idea es: \u0026ldquo;Si camina como un pato y grazna como un pato, entonces debe ser un pato\u0026rdquo;. En otras palabras, Python se preocupa m√°s por los m√©todos que tiene un objeto que por el tipo del objeto en s√≠.\nclass Pato: def hablar(self): return \u0026#34;¬°Cuac cuac!\u0026#34; class Perro: def hablar(self): return \u0026#34;¬°Guau guau!\u0026#34; class Gato: def hablar(self): return \u0026#34;¬°Miau miau!\u0026#34; def sonido_animal(animal): return animal.hablar() # Uso pato = Pato() perro = Perro() gato = Gato() print(sonido_animal(pato)) # Salida: ¬°Cuac cuac! print(sonido_animal(perro)) # Salida: ¬°Guau guau! print(sonido_animal(gato)) # Salida: ¬°Miau miau! En este ejemplo, sonido_animal() funciona con cualquier objeto que tenga un m√©todo hablar(), independientemente de su clase.\nSobrescritura de m√©todos # La sobrescritura de m√©todos es un aspecto clave del polimorfismo en tiempo de ejecuci√≥n. Ocurre cuando una clase derivada define un m√©todo con el mismo nombre que un m√©todo en su clase base.\nclass Figura: def area(self): pass class Rectangulo(Figura): def __init__(self, ancho, alto): self.ancho = ancho self.alto = alto def area(self): return self.ancho * self.alto class Circulo(Figura): def __init__(self, radio): self.radio = radio def area(self): return 3.14159 * self.radio ** 2 # Uso figuras = [Rectangulo(5, 4), Circulo(3)] for figura in figuras: print(f\u0026#34;√Årea: {figura.area()}\u0026#34;) # Salida: # √Årea: 20 # √Årea: 28.27431 Aqu√≠, Rectangulo y Circulo sobrescriben el m√©todo area() de la clase Figura.\nSobrecarga de operadores # Python permite la sobrecarga de operadores, que es una forma de polimorfismo en tiempo de compilaci√≥n. Permite que el mismo operador tenga diferentes significados seg√∫n los operandos.\nclass Vector: def __init__(self, x, y): self.x = x self.y = y def __add__(self, otro): return Vector(self.x + otro.x, self.y + otro.y) def __str__(self): return f\u0026#34;Vector({self.x}, {self.y})\u0026#34; # Uso v1 = Vector(2, 3) v2 = Vector(3, 4) v3 = v1 + v2 print(v3) # Salida: Vector(5, 7) Aqu√≠, hemos sobrecargado el operador + para nuestra clase Vector.\nClases base abstractas # El m√≥dulo abc de Python proporciona infraestructura para definir clases base abstractas, que son una forma poderosa de definir interfaces en Python.\nfrom abc import ABC, abstractmethod class Animal(ABC): @abstractmethod def hacer_sonido(self): pass class Perro(Animal): def hacer_sonido(self): return \u0026#34;¬°Guau!\u0026#34; class Gato(Animal): def hacer_sonido(self): return \u0026#34;¬°Miau!\u0026#34; # Uso def sonido_animal(animal): return animal.hacer_sonido() perro = Perro() gato = Gato() print(sonido_animal(perro)) # Salida: ¬°Guau! print(sonido_animal(gato)) # Salida: ¬°Miau! # Esto generar√° un TypeError # animal = Animal() Las clases base abstractas no pueden ser instanciadas y obligan a las clases derivadas a implementar ciertos m√©todos, asegurando una interfaz consistente.\nAplicaciones en el mundo real # El polimorfismo se utiliza ampliamente en aplicaciones del mundo real:\nFrameworks de GUI: Diferentes widgets (botones, cajas de texto) pueden responder a eventos comunes (clic, hover) de sus propias maneras. Interfaces de bases de datos: Diferentes sistemas de bases de datos pueden implementar una interfaz com√∫n para consultas, permitiendo que las aplicaciones trabajen con varias bases de datos sin cambiar el c√≥digo. Sistemas de plugins: Las aplicaciones pueden trabajar con plugins a trav√©s de una interfaz com√∫n, independientemente de la implementaci√≥n espec√≠fica de cada plugin. Desarrollo de juegos: Diferentes entidades del juego pueden compartir comportamientos comunes (mover, colisionar) pero implementarlos de manera diferente. Aqu√≠ hay un ejemplo simple de un sistema de plugins:\nclass Plugin(ABC): @abstractmethod def procesar(self, datos): pass class PluginMayusculas(Plugin): def procesar(self, datos): return datos.upper() class PluginInvertir(Plugin): def procesar(self, datos): return datos[::-1] class Aplicacion: def __init__(self): self.plugins = [] def agregar_plugin(self, plugin): self.plugins.append(plugin) def procesar_datos(self, datos): for plugin in self.plugins: datos = plugin.procesar(datos) return datos # Uso app = Aplicacion() app.agregar_plugin(PluginMayusculas()) app.agregar_plugin(PluginInvertir()) resultado = app.procesar_datos(\u0026#34;Hola, Mundo!\u0026#34;) print(resultado) # Salida: !ODNUM ,ALOH Este ejemplo demuestra c√≥mo el polimorfismo permite que la clase Aplicacion trabaje con diferentes plugins a trav√©s de una interfaz com√∫n.\nReferencias # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ ¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/programming/oop/the-four-pillars-polymorphism/","section":"Programaci√≥n","summary":"","title":"Los Cuatro Pilares: Polimorfismo","type":"programming"},{"content":"Los aspectos clave de la abstracci√≥n incluyen:\nSimplificaci√≥n: La abstracci√≥n reduce la complejidad ocultando detalles innecesarios. Enfoque en caracter√≠sticas esenciales: Enfatiza lo que hace un objeto en lugar de c√≥mo lo hace. Separaci√≥n de preocupaciones: Permite separar la interfaz de una clase de su implementaci√≥n. Modularidad: La abstracci√≥n promueve el dise√±o modular al definir l√≠mites claros entre componentes. Clases abstractas e interfaces # En muchos lenguajes orientados a objetos, la abstracci√≥n se implementa a trav√©s de clases abstractas e interfaces. Aunque Python no tiene un concepto integrado de interfaz, podemos lograr una funcionalidad similar usando clases base abstractas. El m√≥dulo abc de Python proporciona infraestructura para definir clases base abstractas:\nfrom abc import ABC, abstractmethod class Figura(ABC): @abstractmethod def area(self): pass @abstractmethod def perimetro(self): pass class Rectangulo(Figura): def __init__(self, ancho, alto): self.ancho = ancho self.alto = alto def area(self): return self.ancho * self.alto def perimetro(self): return 2 * (self.ancho + self.alto) class Circulo(Figura): def __init__(self, radio): self.radio = radio def area(self): return 3.14159 * self.radio ** 2 def perimetro(self): return 2 * 3.14159 * self.radio # Uso # figuras = [Figura()] # Esto generar√≠a TypeError figuras = [Rectangulo(5, 4), Circulo(3)] for figura in figuras: print(f\u0026#34;√Årea: {figura.area()}, Per√≠metro: {figura.perimetro()}\u0026#34;) # Salida: # √Årea: 20, Per√≠metro: 18 # √Årea: 28.27431, Per√≠metro: 18.84954 En este ejemplo:\nFigura es una clase base abstracta que define la interfaz para todas las figuras. Rectangulo y Circulo son clases concretas que implementan la interfaz Figura. No podemos instanciar Figura directamente, pero podemos usarla como un tipo com√∫n para todas las figuras. Implementando abstracci√≥n en Python # Aunque Python proporciona clases base abstractas para definir interfaces formalmente, tambi√©n podemos lograr la abstracci√≥n mediante convenciones y documentaci√≥n. Veamos un ejemplo sin utilizar ABC:\nclass BaseDeDatos: def conectar(self): raise NotImplementedError(\u0026#34;La subclase debe implementar este m√©todo abstracto\u0026#34;) def ejecutar(self, consulta): raise NotImplementedError(\u0026#34;La subclase debe implementar este m√©todo abstracto\u0026#34;) class BaseDeDatosMySQL(BaseDeDatos): def conectar(self): print(\u0026#34;Conectando a la base de datos MySQL...\u0026#34;) def ejecutar(self, consulta): print(f\u0026#34;Ejecutando consulta MySQL: {consulta}\u0026#34;) class BaseDeDatosPostgreSQL(BaseDeDatos): def conectar(self): print(\u0026#34;Conectando a la base de datos PostgreSQL...\u0026#34;) def ejecutar(self, consulta): print(f\u0026#34;Ejecutando consulta PostgreSQL: {consulta}\u0026#34;) def realizar_operacion_en_bd(base_de_datos): base_de_datos.conectar() base_de_datos.ejecutar(\u0026#34;SELECT * FROM usuarios\u0026#34;) # Uso bd_mysql = BaseDeDatosMySQL() bd_postgres = BaseDeDatosPostgreSQL() realizar_operacion_en_bd(bd_mysql) realizar_operacion_en_bd(bd_postgres) # Salida: # Conectando a la base de datos MySQL... # Ejecutando consulta MySQL: SELECT * FROM usuarios # Conectando a la base de datos PostgreSQL... # Ejecutando consulta PostgreSQL: SELECT * FROM usuarios En este ejemplo:\nBaseDeDatos es una clase base abstracta (aunque no usa ABC) que define la interfaz para todos los tipos de bases de datos. BaseDeDatosMySQL y BaseDeDatosPostgreSQL son implementaciones concretas. realizar_operacion_en_bd trabaja con cualquier objeto que cumpla con la interfaz de BaseDeDatos. Principios de dise√±o y patrones # La abstracci√≥n es un componente clave de varios principios y patrones de dise√±o importantes:\nPrincipios SOLID:\nPrincipio de Responsabilidad √önica (SRP). Principio de Abierto/Cerrado (OCP). Principio de Sustituci√≥n de Liskov (LSP). Principio de Segregaci√≥n de Interfaces (ISP). Principio de Inversi√≥n de Dependencias (DIP). Patrones de Dise√±o:\nPatr√≥n m√©todo de f√°brica. Patr√≥n f√°brica abstracta. Patr√≥n estrategia. Patr√≥n m√©todo plantilla. Veamos una implementaci√≥n del patr√≥n estrategia:\nfrom abc import ABC, abstractmethod class EstrategiaOrdenamiento(ABC): @abstractmethod def ordenar(self, datos): pass class OrdenamientoBurbuja(EstrategiaOrdenamiento): def ordenar(self, datos): print(\u0026#34;Realizando ordenamiento de burbuja\u0026#34;) return sorted(datos) # Usamos sorted() de Python por simplicidad class OrdenamientoRapido(EstrategiaOrdenamiento): def ordenar(self, datos): print(\u0026#34;Realizando ordenamiento r√°pido\u0026#34;) return sorted(datos) # Usamos sorted() de Python por simplicidad class Ordenador: def __init__(self, estrategia): self.estrategia = estrategia def ordenar(self, datos): return self.estrategia.ordenar(datos) # Uso datos = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] ordenador_burbuja = Ordenador(OrdenamientoBurbuja()) print(ordenador_burbuja.ordenar(datos)) ordenador_rapido = Ordenador(OrdenamientoRapido()) print(ordenador_rapido.ordenar(datos)) # Salida: # Realizando ordenamiento de burbuja # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Realizando ordenamiento r√°pido # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] Este ejemplo del Patr√≥n Estrategia muestra c√≥mo la abstracci√≥n nos permite definir una familia de algoritmos, encapsular cada uno y hacerlos intercambiables. La clase Ordenador no necesita conocer los detalles de c√≥mo funciona cada algoritmo de ordenamiento; solo sabe que puede llamar al m√©todo ordenar en cualquier objeto EstrategiaOrdenamiento.\nReferencias # Gamma, E., Helm, R., Johnson, R., \u0026amp; Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Martin, R. C. (2017). Clean Architecture: A Craftsman\u0026rsquo;s Guide to Software Structure and Design. Prentice Hall. Phillips, D. (2010). Python 3 Object Oriented Programming. Packt Publishing. Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media. Ramalho, L. (2015). Fluent Python: Clear, Concise, and Effective Programming. O\u0026rsquo;Reilly Media. Van Rossum, G., Warsaw, B., \u0026amp; Coghlan, N. (2001). PEP 8 \u0026ndash; Style Guide for Python Code. Python.org. https://www.python.org/dev/peps/pep-0008/ Python Software Foundation. (n.d.). The Python Standard Library. Python.org. https://docs.python.org/3/library/ ¬°Gracias por haber llegado hasta ac√°!\nSi te gust√≥ el art√≠culo, por favor ¬°no olvides compartirlo con tu familia, amigos y colegas!\nY si puedes, env√≠a tus comentarios, sugerencias, cr√≠ticas a nuestro mail o por redes sociales, nos ayudar√≠as a generar mejor contenido y sobretodo m√°s relevante para vos.\n","date":"12 octubre 2024","externalUrl":null,"permalink":"/programming/oop/the-four-pillars-abstraction/","section":"Programaci√≥n","summary":"","title":"Los Cuatro Pilares: Abstracci√≥n","type":"programming"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/%C3%A1lgebra-lineal/","section":"Etiquetas","summary":"","title":"√Ålgebra Lineal","type":"tags"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/aprendizaje-autom%C3%A1tico/","section":"Etiquetas","summary":"","title":"Aprendizaje Autom√°tico","type":"tags"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/inteligencia-artificial/","section":"Etiquetas","summary":"","title":"Inteligencia Artificial","type":"tags"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/machine-learning/","section":"Etiquetas","summary":"","title":"Machine Learning","type":"tags"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/matem%C3%A1tica/","section":"Etiquetas","summary":"","title":"Matem√°tica","type":"tags"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/series/matem%C3%A1tica-para-machine-learning/","section":"Series","summary":"","title":"Matem√°tica Para Machine Learning","type":"series"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/matrices/","section":"Etiquetas","summary":"","title":"Matrices","type":"tags"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/recomendaciones/","section":"Etiquetas","summary":"","title":"Recomendaciones","type":"tags"},{"content":"","date":"14 septiembre 2025","externalUrl":null,"permalink":"/tags/vectores/","section":"Etiquetas","summary":"","title":"Vectores","type":"tags"},{"content":"","date":"04 septiembre 2025","externalUrl":null,"permalink":"/series/fundamentos-de-ia-para-programadores/","section":"Series","summary":"","title":"Fundamentos De IA Para Programadores","type":"series"},{"content":"","date":"26 agosto 2025","externalUrl":null,"permalink":"/tags/clasificaci%C3%B3n/","section":"Etiquetas","summary":"","title":"Clasificaci√≥n","type":"tags"},{"content":"","date":"22 agosto 2025","externalUrl":null,"permalink":"/tags/sistema-experto/","section":"Etiquetas","summary":"","title":"Sistema Experto","type":"tags"},{"content":"","date":"05 agosto 2025","externalUrl":null,"permalink":"/tags/kubernetes/","section":"Etiquetas","summary":"","title":"Kubernetes","type":"tags"},{"content":" Luego de desplegar una aplicaci√≥n en Kubernetes, independientemente del m√©todo elegido para ello, si queremos que sea alcanzable por otras aplicaciones necesitamos crear un servicio. En este art√≠culo vamos a explicar que es un servicio, como se utilizan y a repasar los cuatro tipos de servicios que est√°n disponibles en Kubernetes, ClusterIP, NodePort, LoadBalancer y ExternalName, revisaremos sus detalles y cuando se debe utilizar cada uno. Al desplegar una aplicaci√≥n en Kubernetes utilizando un objeto del tipo Deployment, los pods pertenecientes a dicho Deployment pueden ser creados y destruidos en cualquier momento en base a su funcionamiento, por ejemplo si en nuestro Deployment pedimos que existan 3 r√©plicas y por cualquier raz√≥n alguna de ellas deja de funcionar, una nueva r√©plica ser√° creada autom√°ticamente para reemplazar a la que fall√≥.\nCada pod tiene su propia direcci√≥n IP dentro del cluster. En general, las dem√°s aplicaciones que necesitan interactuar con nuestra aplicaci√≥n desconocen el nombre de cada una de sus replicas, su estado y su direcci√≥n IP para iniciar una comunicaci√≥n. Kubernetes nos provee el objeto Service como una forma nativa de Service Discovery sin que necesitemos hacer cambios en nuestra aplicaci√≥n o en las que necesitan comunicarse con ella. Entonces, el fin para el cual creamos un servicio es para exponer una aplicaci√≥n que puede estar constituida por m√∫ltiples pods a traves de un √∫nico punto de acceso. De esta manera otras aplicaci√≥n contactaran al Service y este redirigir√° la comunicaci√≥n a alguno de los pods de nuestra aplicaci√≥n.\nPods detr√°s de un servicio en Kubernetes Creando un servicio # Un Service puede crearse mediante una declaraci√≥n en un archivo .yaml al igual que otros objetos de Kubernetes. Por ejemplo:\napiVersion: v1 kind: Service metadata: name: servicio-de-prueba spec: type: ClusterIP selector: app_name: mi-aplicacion ports: - protocol: TCP port: 8080 targetPort: 1234 En dicho ejemplo, estaremos creando un servicio llamado my-service del tipo ClusterIP que redirige las comunicaciones que llegan al puerto 8080 hacia el puerto 1234 de cualquier Pod que tenga la etiqueta app-name: my-app.\nEl nombre del servicio debe ser una etiqueta v√°lida bajo las reglas de RFC 1035 Como se ve en el archivo, el campo ports es del tipo array, lo que significa que pueden mapearse m√∫ltiples puertos.\nCada definici√≥n de un puerto debe contener los siguientes campos:\nport: es el puerto en el que el servicio estar√° accesible dentro del cluster. No puede omitirse. targetPort: es un valor opcional, indica el puerto en el cual el pod estar√° recibiendo las comunicaciones. Si se omite, se asume que es el mismo valor que el indicado en el campo port. Puede ser un n√∫mero o el nombre del puerto si es que en el pod se especificaron nombres. Se recomienda utilizarlo s√≥lo cuando difiere del valor de port. protocol: establece el protocolo utilizado para las comunicaciones, los valores v√°lidos son: SCTP, TCP y UDP. En caso de no indicarse expl√≠citamente, el valor por defecto es TCP. name: permite darle un nombre al puerto. Es √∫til para referenciar por DNS o en situaciones donde hay m√∫ltiples puertos en un mismo servicio. Es un valor opcional, pero dentro de un mismo servicio, cada puerto debe tener un nombre √∫nico. Tipos de servicios # Como se muestra en la secci√≥n anterior, el tipo de servicio se especifica mediante el valor spec.type:\napiVersion: v1 kind: Service metadata: name: servicio-de-prueba spec: ... type: \u0026lt;TIPO_DE_SERVICIO\u0026gt; ... A continuaci√≥n veremos cada uno de ellos.\nClusterIP # Es el tipo de servicio por defecto. Kubernetes asigna una direcci√≥n IP al servicio que las dem√°s aplicaciones pueden utilizar para comunicarse. La direcci√≥n asignada proviene de un grupo de direcciones reservadas para este fin mediante el valor service-cluster-ip-range en el servidor de API de Kubernetes.\nCuando se crea un servicio del tipo ClusterIP el servicio no es accesible desde el exterior y los pods detr√°s de este servicio solo pueden ser contactados por otros pods del mismo cluster. Si se desea exponer el servicio al exterior se debe utilizar un objeto del tipo Ingress.\nEsquema de un servicio del tipo ClusterIP NodePort # En este caso, Kubernetes asigna al servicio un puerto del rango definido en la configuraci√≥n service-node-port-range, usualmente entre los puertos 30000 y 32767. Luego, cada nodo abre dicho puerto para las comunicaciones hacia el servicio.\nEste tipo de servicio, permite un r√°pido acceso desde el exterior sin necesidad de infraestructura adicional, pero no contempla un mecanismo de balance de carga (load balancing), lo que puede provocar la saturaci√≥n de alguno de ellos. Por otro lado, en un sistema donde existan m√∫ltiples servicios, la gesti√≥n de puertos puede volverse demasiado compleja.\nEsquema de un servicio del tipo NodePort LoadBalancer # En proveedores de servicios en la nube que soporten load balancers como Amazon Web Services, Google Cloud Platform o Microsoft Azure, crear un servicio de este tipo dispara la creaci√≥n de un load balancer externo en la platform de nube utilizada. La creaci√≥n ocurre de manera as√≠ncrona e informaci√≥n sobre su estado es publicada en el estado del servicio (.status.loadbalancer).\nEl proveedor de servicios en la nube decide como se balancea la carga.\nLa gran ventaja de este tipo de servicio es que mediante el uso de servicios en la nube se obtiene un balanceo de carga autom√°tico y de alta disponibilidad. La desventaja es que puede generar costos adicionales.\nEsquema de un servicio del tipo LoadBalancer ExternalName # Este tipo de servicio redirecciona el tr√°fico a un nombre de DNS en lugar de a un conjunto de pods. El DNS al cual se apunta, se indica mediante el campo .spec.externalName\nPor ejemplo, redirige las comunicaciones hacia la direcci√≥n learn-software.com.\napiVersion: v1 kind: Service metadata: name: mi-servicio spec: type: ExternalName externalName: learn-software.com Esquema de un servicio del tipo ExternalName Headless Services # Existen casos en los que, por ejemplo, es necesario utilizar otros mecanismos de Service Discovery o en los que necesitemos conocer las direcciones IP de todos aquellos pods que podr√≠amos contactar. Para ello existen los headless services. Se crean indicando el valor None en el campo .spec.clusterIP.\nUn headless service no tiene asignada una direcci√≥n IP √∫nica del cluster. Retorna directamente las direcciones IPs de pods en una respuesta DNS. Esto es √∫til para descubrimiento de servicios personalizados, bases de datos distribuidas o control detallado del balanceo. La desventaja es que el cliente del servicio debe ser capaz de resolver y gestionar por s√≠ mismo una respuesta DNS conteniendo m√∫ltiples direcciones.\nEsquema de un Headless Service Referencias # Puedes leer m√°s sobre el tema en la documentaci√≥n oficial de Kubernetes ","date":"05 agosto 2025","externalUrl":null,"permalink":"/blog/k8s-services/","section":"Blog","summary":"","title":"Kubernetes Services","type":"blog"},{"content":"","date":"05 agosto 2025","externalUrl":null,"permalink":"/tags/service-discovery/","section":"Etiquetas","summary":"","title":"Service Discovery","type":"tags"},{"content":"","date":"05 agosto 2025","externalUrl":null,"permalink":"/tags/services/","section":"Etiquetas","summary":"","title":"Services","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/en/tags/data-structures/","section":"Tags","summary":"","title":"Data Structures","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/tags/estructuras-de-datos/","section":"Etiquetas","summary":"","title":"Estructuras De Datos","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/en/tags/object-oriented-programming/","section":"Tags","summary":"","title":"Object-Oriented Programming","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/tags/programaci%C3%B3n/","section":"Etiquetas","summary":"","title":"Programaci√≥n","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/tags/programaci%C3%B3n-orientada-a-objetos/","section":"Etiquetas","summary":"","title":"Programaci√≥n Orientada a Objetos","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/series/programaci%C3%B3n-aprendiendo-estructuras-de-datos/","section":"Series","summary":"","title":"Programaci√≥n: Aprendiendo Estructuras De Datos","type":"series"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/series/programaci%C3%B3n-aprendiendo-orientaci%C3%B3n-a-objetos/","section":"Series","summary":"","title":"Programaci√≥n: Aprendiendo Orientaci√≥n a Objetos","type":"series"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/en/tags/programming/","section":"Tags","summary":"","title":"Programming","type":"tags"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/en/series/programming-learning-data-structures/","section":"Series","summary":"","title":"Programming: Learning Data Structures","type":"series"},{"content":"","date":"04 agosto 2025","externalUrl":null,"permalink":"/en/series/programming-learning-object-oriented-concepts/","section":"Series","summary":"","title":"Programming: Learning Object-Oriented Concepts","type":"series"},{"content":"","date":"03 agosto 2025","externalUrl":null,"permalink":"/series/programaci%C3%B3n-aprendiendo-las-bases/","section":"Series","summary":"","title":"Programaci√≥n: Aprendiendo Las Bases","type":"series"},{"content":"","date":"03 agosto 2025","externalUrl":null,"permalink":"/en/series/programming-learning-the-bases/","section":"Series","summary":"","title":"Programming: Learning the Bases","type":"series"},{"content":"","date":"07 diciembre 2024","externalUrl":null,"permalink":"/en/tags/class-relations/","section":"Tags","summary":"","title":"Class Relations","type":"tags"},{"content":"","date":"07 diciembre 2024","externalUrl":null,"permalink":"/tags/los-cuatro-pilares/","section":"Etiquetas","summary":"","title":"Los Cuatro Pilares","type":"tags"},{"content":"","date":"07 diciembre 2024","externalUrl":null,"permalink":"/tags/oop/","section":"Etiquetas","summary":"","title":"OOP","type":"tags"},{"content":"","date":"07 diciembre 2024","externalUrl":null,"permalink":"/en/tags/the-four-pillars/","section":"Tags","summary":"","title":"The Four Pillars","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/tags/abstracci%C3%B3n/","section":"Etiquetas","summary":"","title":"Abstracci√≥n","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/abstraction/","section":"Tags","summary":"","title":"Abstraction","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/aggregation/","section":"Tags","summary":"","title":"Aggregation","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/association/","section":"Tags","summary":"","title":"Association","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/composition/","section":"Tags","summary":"","title":"Composition","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/dependency/","section":"Tags","summary":"","title":"Dependency","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/tags/encapsulamiento/","section":"Etiquetas","summary":"","title":"Encapsulamiento","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/encapsulation/","section":"Tags","summary":"","title":"Encapsulation","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/tags/herencia/","section":"Etiquetas","summary":"","title":"Herencia","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/implementation/","section":"Tags","summary":"","title":"Implementation","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/inheritance/","section":"Tags","summary":"","title":"Inheritance","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/tags/polimorfismo/","section":"Etiquetas","summary":"","title":"Polimorfismo","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/polymorphism/","section":"Tags","summary":"","title":"Polymorphism","type":"tags"},{"content":"","date":"12 octubre 2024","externalUrl":null,"permalink":"/en/tags/realisation/","section":"Tags","summary":"","title":"Realisation","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/tags/colas/","section":"Etiquetas","summary":"","title":"Colas","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/en/tags/linked-lists/","section":"Tags","summary":"","title":"Linked Lists","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/tags/listas/","section":"Etiquetas","summary":"","title":"Listas","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/tags/listas-enlazadas/","section":"Etiquetas","summary":"","title":"Listas Enlazadas","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/en/tags/lists/","section":"Tags","summary":"","title":"Lists","type":"tags"},{"content":"","date":"03 noviembre 2023","externalUrl":null,"permalink":"/en/tags/queues/","section":"Tags","summary":"","title":"Queues","type":"tags"},{"content":"","date":"02 noviembre 2023","externalUrl":null,"permalink":"/tags/pilas/","section":"Etiquetas","summary":"","title":"Pilas","type":"tags"},{"content":"","date":"02 noviembre 2023","externalUrl":null,"permalink":"/en/tags/stacks/","section":"Tags","summary":"","title":"Stacks","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/en/tags/arrays/","section":"Tags","summary":"","title":"Arrays","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/tags/arreglos/","section":"Etiquetas","summary":"","title":"Arreglos","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/tags/diccionarios/","section":"Etiquetas","summary":"","title":"Diccionarios","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/en/tags/dictionaries/","section":"Tags","summary":"","title":"Dictionaries","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/tags/mapas/","section":"Etiquetas","summary":"","title":"Mapas","type":"tags"},{"content":"","date":"30 octubre 2023","externalUrl":null,"permalink":"/en/tags/maps/","section":"Tags","summary":"","title":"Maps","type":"tags"},{"content":"","date":"02 octubre 2023","externalUrl":null,"permalink":"/tags/clases/","section":"Etiquetas","summary":"","title":"Clases","type":"tags"},{"content":"","date":"02 octubre 2023","externalUrl":null,"permalink":"/en/tags/classes/","section":"Tags","summary":"","title":"Classes","type":"tags"},{"content":"","date":"02 octubre 2023","externalUrl":null,"permalink":"/en/tags/objects/","section":"Tags","summary":"","title":"Objects","type":"tags"},{"content":"","date":"02 octubre 2023","externalUrl":null,"permalink":"/tags/objetos/","section":"Etiquetas","summary":"","title":"Objetos","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/tags/conceptos-iniciales/","section":"Etiquetas","summary":"","title":"Conceptos Iniciales","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/tags/funciones/","section":"Etiquetas","summary":"","title":"Funciones","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/en/tags/functions/","section":"Tags","summary":"","title":"Functions","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/en/tags/methods/","section":"Tags","summary":"","title":"Methods","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/tags/m%C3%A9todos/","section":"Etiquetas","summary":"","title":"M√©todos","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/series/programaci%C3%B3n-aprendiendo-los-conceptos-iniciales/","section":"Series","summary":"","title":"Programaci√≥n: Aprendiendo Los Conceptos Iniciales","type":"series"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/en/series/programming-learning-the-starting-concepts/","section":"Series","summary":"","title":"Programming: Learning the Starting Concepts","type":"series"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/en/tags/recursion/","section":"Tags","summary":"","title":"Recursion","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/tags/recursi%C3%B3n/","section":"Etiquetas","summary":"","title":"Recursi√≥n","type":"tags"},{"content":"","date":"30 septiembre 2023","externalUrl":null,"permalink":"/en/tags/starting-concepts/","section":"Tags","summary":"","title":"Starting Concepts","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/en/tags/boolean-logic/","section":"Tags","summary":"","title":"Boolean Logic","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/tags/bucles/","section":"Etiquetas","summary":"","title":"Bucles","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/tags/condicionales/","section":"Etiquetas","summary":"","title":"Condicionales","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/en/tags/conditionals/","section":"Tags","summary":"","title":"Conditionals","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/tags/control-de-flujo/","section":"Etiquetas","summary":"","title":"Control De Flujo","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/en/tags/flow-control/","section":"Tags","summary":"","title":"Flow Control","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/tags/l%C3%B3gica-booleana/","section":"Etiquetas","summary":"","title":"L√≥gica Booleana","type":"tags"},{"content":"","date":"27 septiembre 2023","externalUrl":null,"permalink":"/en/tags/loops/","section":"Tags","summary":"","title":"Loops","type":"tags"},{"content":"","date":"19 septiembre 2023","externalUrl":null,"permalink":"/tags/entrada/salida/","section":"Etiquetas","summary":"","title":"Entrada/Salida","type":"tags"},{"content":"","date":"19 septiembre 2023","externalUrl":null,"permalink":"/tags/i/o/","section":"Etiquetas","summary":"","title":"I/O","type":"tags"},{"content":"","date":"19 septiembre 2023","externalUrl":null,"permalink":"/en/tags/input/output/","section":"Tags","summary":"","title":"Input/Output","type":"tags"},{"content":"","date":"18 septiembre 2023","externalUrl":null,"permalink":"/en/tags/data-types/","section":"Tags","summary":"","title":"Data Types","type":"tags"},{"content":"","date":"18 septiembre 2023","externalUrl":null,"permalink":"/tags/tipos-de-datos/","section":"Etiquetas","summary":"","title":"Tipos De Datos","type":"tags"},{"content":"","date":"18 septiembre 2023","externalUrl":null,"permalink":"/tags/variables/","section":"Etiquetas","summary":"","title":"Variables","type":"tags"},{"content":"","date":"10 septiembre 2023","externalUrl":null,"permalink":"/tags/herramientas/","section":"Etiquetas","summary":"","title":"Herramientas","type":"tags"},{"content":"","date":"10 septiembre 2023","externalUrl":null,"permalink":"/tags/ide/","section":"Etiquetas","summary":"","title":"IDE","type":"tags"},{"content":"","date":"10 septiembre 2023","externalUrl":null,"permalink":"/tags/python/","section":"Etiquetas","summary":"","title":"Python","type":"tags"},{"content":"","date":"10 septiembre 2023","externalUrl":null,"permalink":"/en/tags/tools/","section":"Tags","summary":"","title":"Tools","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/tags/binario/","section":"Etiquetas","summary":"","title":"Binario","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/en/tags/binary/","section":"Tags","summary":"","title":"Binary","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/tags/decimal/","section":"Etiquetas","summary":"","title":"Decimal","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/tags/hexadecimal/","section":"Etiquetas","summary":"","title":"Hexadecimal","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/en/tags/numeral-systems/","section":"Tags","summary":"","title":"Numeral Systems","type":"tags"},{"content":"","date":"05 septiembre 2023","externalUrl":null,"permalink":"/tags/sistemas-de-numeraci%C3%B3n/","section":"Etiquetas","summary":"","title":"Sistemas De Numeraci√≥n","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/tags/cd/","section":"Tags","summary":"","title":"CD","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/tags/computadoras/","section":"Etiquetas","summary":"","title":"Computadoras","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/tags/computers/","section":"Tags","summary":"","title":"Computers","type":"tags"},{"content":"Continuous Delivery (CD) is deeply rooted in the first principle of the Agile Manifesto posted in 20011:\nOur highest priority is to satisfy the customer through early and continuous delivery of valuable software.\nAccording to Martin Fowler2, a project is truly embracing Continuous Delivery when:\nThe software can be deployed at any stage of its lifecycle. The team values keeping the software deployment-ready over adding new features. Any software version can be deployed to any environment on-demand. In many ways, Continuous Delivery is the next step from Continuous Integration, seamlessly automating processes all the way to the software\u0026rsquo;s end user.\nMuch like in Continuous Integration, the pipeline stands as the cornerstone of Continuous Delivery. However, it\u0026rsquo;s not just about integrating code, testing it, and generating a deliverable artifact. With CD, this artifact progresses through a series of test phases in environments that increasingly resemble production settings. After passing through the Continuous Integration pipeline, what emerges is a potentially deployable artifact. CD then takes this artifact and puts it through the necessary tests, ensuring it\u0026rsquo;s primed for a live deployment.\nThe delivery process # The following figure illustrates the fundamental steps of a Continuous Delivery (CD) process. It\u0026rsquo;s vital to note that an effective CD process presupposes a well-oiled Continuous Integration (CI) system as its foundation.\nCD process flowchart The CD process adds two distinct phases to the CI system: deployment stages and system validation and verification testing. A critical premise is that the deployment process is paramount to product delivery. Thus, automating and frequently testing it is essential. Ideally, testing should also be automated to facilitate execution, especially if you aim for Continuous Deployment. However, it\u0026rsquo;s not imperative to automate all tests, especially at the beginning of the CD process implementation.\nUpon creating a potentially deliverable artifact in the CI pipeline, the initial step is to deploy it in a testing or QA environment. The primary goal of this environment is to offer a space where software tests, both automatic and manual, can be run. The only possible variations between the QA and actual production environment (the one used by customers) may pertain to its capacity or resource size. This scaled-down capacity, whether in processing, memory, storage, or database size, is typically a cost-saving measure.\nIf system and acceptance tests are successful in the QA environment, the next phase is to deploy the artifact in a staging environment. This environment should be an exact replica of the production setting. Its purpose is to facilitate performance and load testing on the system, effectively putting it under stress to validate its functionality under high loads and assess its processing and response times.\nWhen the previous tests are satisfactory, the artifact is ready to be deployed in a production environment. This space is also referred to as the live environment, where users interact with the system.\nAs evident, the product deployment method is exercised at least twice before the final production deployment, considerably reducing risks associated with potential errors as the final delivery approaches.\nCore principles and practices # One of CD\u0026rsquo;s primary objectives is to boost delivery frequency. This naturally means that each release should minimize its size. A smaller delivery not only implies fewer potential errors but also facilitates their identification and resolution2. To achieve this, the code must always be in a deploy-ready state.\nRapid automated testing is crucial for today\u0026rsquo;s software development3. In the context of CD, automated tests are of utmost importance as they must ensure comprehensive system quality without hampering the delivery cycle\u0026rsquo;s speed4. Lengthy test runs force the team to await results, leading to wasted time3. If these tests aren\u0026rsquo;t parallelized and optimized, developers may start sidelining them5. To ensure test optimization, it\u0026rsquo;s recommended to fail tests that exceed a reasonable limit6.\nThe software should always be potentially deliverable. It\u0026rsquo;s essential for the software\u0026rsquo;s build status to remain \u0026lsquo;green\u0026rsquo; consistently. This means if a new repository commit breaks the build, this error must be rectified before any new commit is made. Adhering to this practice simplifies error tracing, while deviating may condition developers to overlook a broken or \u0026lsquo;red\u0026rsquo; build6. Broken builds signify product flaws and render it undeliverable.\nIn using CD, the aim is to ensure each commit results in a production-ready artifact. If this artifact is rebuilt at every process stage, there\u0026rsquo;s no guarantee of their identical nature, and validation and verification test results from one artifact cannot be applied to others. This could lead to deploying untested artifacts6. Hence, artifacts should be produced only once and undergo all tests on that single artifact before deploying that very software piece to production.\nSoftware should always be deployed identically across all environments. Otherwise, there\u0026rsquo;s no assurance of the deployment process\u0026rsquo;s efficacy. If environment differences exist, they should be managed using configuration files, but the deployment process should remain consistent6.\nDeployment should be achievable with a mere button press. The ability to deploy the latest product version anytime with a single button press is a robust indicator of CD implementation2. This not only requires the aforementioned steps but also mandates version-controlled software deployment scripts that are regularly checked and validated6.\nAs mentioned earlier, CD\u0026rsquo;s main objective is to ascertain the product\u0026rsquo;s readiness post each commit2. For this, aside from ensuring a swift compilation and testing process, process outcomes should be visible and shared with the team. Display screens showcasing the current status, build times, test coverage, and more, offer a way to maintain constant visibility6. Presenting these results not only supports CD but, as some authors suggest, also bolsters team motivation4.\nBenefits of Continuous Delivery # With the rise of Continuous Delivery (CD) practices, businesses are realizing numerous advantages:\nSwift value delivery: the adoption of CD practices facilitates a faster rollout of features and error rectifications to end users7. This speed is attributed to the code becoming potentially deployable to users as it traverses through the Continuous Integration (CI) pipeline4.\nDiminished delivery failures: frequent releases lead to fewer delivery risks since each release embodies fewer changes. This, in turn, means there\u0026rsquo;s a reduced margin for errors2. Even if an error emerges, its origin is easier to trace and correct. Plus, reverting to a previous version in the face of complications becomes straightforward8. A delightful by-product of this streamlined process is the diminished stress levels amongst stakeholders7 5. Furthermore, the consistency and quality in the delivery process cement trust between the development team and clients7.\nProductivity amplification: Chen\u0026rsquo;s study reveals that, in the absence of CD practices, teams spent nearly \\(20%\\) of their time setting up and maintaining environments7. The introduction of CD automates this ordeal, which translates to heightened productivity by phasing out manual, non-value-add tasks6.\nPrompt feedback: a consensus among experts highlights the value of early feedback during the development phase2 7 4. Regular releases not only fetch this feedback promptly but also ensure that the developed product aligns seamlessly with customer requirements2. The agility to swiftly address customer needs, fix reported bugs, and introduce demanded features can significantly elevate customer satisfaction4.\nEnhanced software quality: the rigorous automation of software tests (unit, integration, and system), essential for implementing CD, combined with more frequent software deliveries encapsulating fewer changes, culminates in a notable boost in software quality4.\nTransparency in progress: thanks to frequent releases, clients find it easier to stay abreast of the latest product updates, embracing novel features and bug fixes with open arms.\nChallenges in adopting Continuous Delivery # The journey to incorporate Continuous Delivery (CD) isn‚Äôt without its hurdles. Here\u0026rsquo;s a look at some of the key challenges faced by businesses:\nProduct complexity: certain products consist of myriad interconnected modules or possess dependencies with other projects. This can create bottlenecks when automating CD pipelines4. Such complexities might frustrate teams, pushing them to retain manual processes or longer integration procedures.\nTest suite creation: crafting a comprehensive test suite to ensure product quality is labour-intensive. All team members must allocate significant time to pen tests, which might require extra training. Besides, tests can be time-consuming, so the trick lies in devising effective yet swift tests4.\nLegacy code: systems that have been in development for an extended period and weren\u0026rsquo;t designed with automated testing in mind can pose a significant challenge. Transitioning such systems to CD is not only a technical endeavour but also a social and cultural shift4.\nEnvironmental discrepancies: all environments in the CI pipeline should mirror the production setting (\u0026lsquo;production-like\u0026rsquo;)6. If not, unforeseen errors can arise, demanding valuable time on non-value-add tasks4. Ensuring multiple deployment stages in similar environments means that the deployment process is tested repetitively.\nClient restrictions: not every client might desire or require a shortened product delivery cycle4. Such client limitations aren\u0026rsquo;t direct obstacles to CD implementation but play a pivotal role when aiming for Continuous Deployment. This could potentially sideline some CD benefits, like swift client feedback or minimal change deliveries. Moreover, the domain itself can act as a bottleneck. Software related to heavily-regulated sectors like healthcare and defence may find CD implementation challenging, if not nearly impossible4.\nTransparency and reporting: a successful CD adoption hinges on collaboration and transparency, introducing challenges tied to providing effective status reports to stakeholders9. This encompasses technical hurdles around automated report generation and analytics challenges to pinpoint essential information.\nResistance to change: any transformative change, like adopting CD, faces the innate human trait of resistance. Convincing the team to adapt to new practices and modify their workflow is a task. On a higher level, management might also be hesitant to experiment with fresh processes.\nContinuous Deployment # The notion of Continuous Deployment was popularized by Fitz10. The standout distinction between this method and Continuous Delivery (CD) is that, once the product is deemed ready for release, there\u0026rsquo;s no waiting for manual intervention to launch it into production11 6. If CD is properly executed, the step towards Continuous Deployment should demand no extra efforts from the development perspective8. In essence, the core difference lies in decision-making: with CD, releasing the product to production remains a business decision, whereas with Continuous Deployment, the launch is automated.\nIt\u0026rsquo;s worth noting that when we discuss CD, it inherently includes Continuous Delivery but may or may not encompass Continuous Deployment.\nReferences # Beck, Kent, Mike Beedle, Arie van Bennekum, Alistair Cockburn, Ward Cunningham, Martin Fowler, James Grenning, Jim Highsmith, Andrew Hunt, Ron Jeffries, Jon Kern, Brian Marick, Robert C. Martin, Steve Mellor, Ken Schwaber, Jeff Sutherland, and Dave Thomas. Manifesto for Agile Software Development, 2001.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, Martin. Continuous Delivery, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUdd, Raoul. Adopting Continuous Delivery: A Case Study, 2016.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLeppanen, Marko, Simo Makinen, Max Pagels, Veli-Pekka Eloranta, Juha Itkonen, Mika V. Mantyla, and Tomi Mannisto. The highways and country roads to continuous deployment. IEEE Software, 32(2):64-72, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNeely, Steve, and Steve Stolt. Continuous delivery? Easy! Just change everything (well, maybe it is not that easy). Proceedings - AGILE 2013, pp.121-128, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez, and David Farley. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nChen, Lianping. Continuous Delivery: Huge Benefits, but Challenges Too. IEEE Software, 32(2):50-54, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez. Continuous Delivery vs Continuous Deployment, 2010.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nOlsson, Helena Holmstrom, Hiva Alahyari, and Jan Bosch. Climbing the \u0026ldquo;Stairway to Heaven\u0026rdquo; \u0026ndash; A Multiple-Case Study Exploring Barriers in the Transition from Agile Development towards Continuous Deployment of Software. 2012 38th Euromicro Conference on Software Engineering and Advanced Applications, pp.392-399, 2012.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFitz, Timothy. Continuous Deployment, 2009.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPulkkinen, Ville. Continuous Deployment of Software. Proceedings of Cloud-Based Software Engineering, pp.46-52, 2013.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/blog/continuous-delivery/","section":"Blog","summary":"","title":"Continuous Delivery","type":"blog"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/tags/continuous-delivery/","section":"Tags","summary":"","title":"Continuous Delivery","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/tags/continuous-deployment/","section":"Tags","summary":"","title":"Continuous Deployment","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/tags/cpu/","section":"Etiquetas","summary":"","title":"CPU","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/tags/hardware/","section":"Etiquetas","summary":"","title":"Hardware","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/tags/memoria/","section":"Etiquetas","summary":"","title":"Memoria","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/en/tags/memory/","section":"Tags","summary":"","title":"Memory","type":"tags"},{"content":"","date":"02 septiembre 2023","externalUrl":null,"permalink":"/tags/software/","section":"Etiquetas","summary":"","title":"Software","type":"tags"},{"content":"","date":"19 agosto 2023","externalUrl":null,"permalink":"/en/tags/ci/","section":"Tags","summary":"","title":"CI","type":"tags"},{"content":"One of the most pivotal challenges in the realm of software development is effectively integrating changes 1. In a small-scale project steered by a single developer, this challenge might appear to be trivial. However, as the magnitude of the project escalates and more individuals join the development fold, the significance of seamless integration becomes paramount.\nHistorically, integration was often an afterthought, relegated to the tail end of the software development process 2. Postponing it to such a late stage not only amplifies the risk of complex, undetected errors but also heightens the tension as delivery dates loom.\nHowever, the paradigm shifted around the turn of the millennium. Continuous Integration (CI) was formally introduced in 2000 by Kent Beck as an intrinsic part of the \u0026lsquo;Extreme Programming\u0026rsquo; methodology 3. CI emphasizes the frequent and early-stage integration of code. By continuously amalgamating new code into the system, developers can gauge its impact promptly. This approach streamlines error detection, enabling developers to tackle issues as they emerge 2. The ability to tie an error to a specific code change reduces error complexity and promotes efficient troubleshooting. Today, CI has become an indispensable practice in software development projects 4.\nMartin Fowler, a luminary in the field, eloquently defined CI as:\nContinuous Integration is a software development practice where team members integrate their work frequently, typically multiple times a day. Each integration is verified by an automated build system that runs test suites to swiftly detect any integration anomalies. Teams adopting this methodology often witness a significant reduction in integration hiccups, empowering them to produce cohesive software at an accelerated pace2.\nBuilding upon Fowler‚Äôs definition, Duvall 5 underscored several vital facets:\nDevelopers must maintain a conducive local environment for code construction and testing, ensuring their updates do not disrupt the established integration. Team members should commit their code to the Version Control System (VCS) daily. The integration process must be undertaken on a distinct machine, aptly termed the CI server. Only builds that pass all tests can be deemed deliverable. Error resolution is of paramount importance. A central repository displaying build and test results‚Äîoften a website‚Äîis essential. Most CI tools readily offer such platforms. Furthermore, Patrick Cauldwell 6 advocates for frequent and early integration. The rationale? The more regular the integration, the less overhead for the team down the line. He distilled the primary goals of CI into:\nEnsuring a consistently available, tested version of the product with the latest modifications. Keeping the team abreast of any integration issues as early as possible. The impetus behind CI is to maintain an error-free, tested product throughout the development life cycle. This avoids the pitfalls of a last-minute integration phase, which is often fraught with errors and consumes both time and resources. More crucially, if project components aren\u0026rsquo;t integrated during their development, there\u0026rsquo;s no guarantee they\u0026rsquo;ll gel cohesively in the final product 7.\nTechnical implementation of CI revolves around two core components: process automation and a system to showcase results, thereby fuelling the developmental feedback loop 7.\nIn summing up the tenets of CI, Martin Fowler 1 emphasizes:\nRetaining code in a singular repository. Streamlining software construction through automation. Implementing automated testing processes. Ensuring new code additions undergo integration and construction on the CI system\u0026rsquo;s machine. Keeping the build process agile and swift. Providing easy access to the product\u0026rsquo;s latest executable version. Ensuring product status transparency for all stakeholders. Elements of a CI system # A basic Continuous Integration (CI) pipeline initiates when a new code change is pushed to the repository. The CI server, linked to the repository, gets notified of every new change, subsequently downloading the latest version to initiate the integration process, which will be elaborated on in the subsequent section. Once completed, it communicates the system\u0026rsquo;s status to the team members.\nIn computer science, a \u0026ldquo;pipeline\u0026rdquo; refers to a sequence of processes or tasks linked such that the output of one becomes the input for the next.\nFigure 1: Basic elements of CI The system\u0026rsquo;s primary component consists of the developers. After making code modifications, they run tests locally and compile the code to ensure that they haven\u0026rsquo;t introduced new errors.\nAn essential part of every CI system is the Version Control System (VCS). It oversees the changes made to the code and other significant elements. This system establishes a unified access point for all source code, enabling the CI system to fetch the most recent version for integration. Most software development projects utilize a VCS even if they don\u0026rsquo;t implement CI processes.\nThe CI Server is responsible for initiating a new build (comprising both compilation and tests) every time a change is added to the repository. They offer configurations to simplify the creation of integration pipelines. Additionally, most come with a web interface to display the build status and previous results. Currently, numerous powerful options are available, both free and paid. It\u0026rsquo;s worth noting that the CI server should operate on a dedicated machine and not on team members\u0026rsquo; computers.\nThe CI server must automatically conduct software tests, source code analysis, and compile to produce the deliverable product. Therefore, build and test execution scripts are vital. These scripts outline the necessary steps to be executed. Popular tools for this purpose include Make, Ant, Maven, Gradle, among others.\nEvery CI system should have a notification mechanism to relay results to the team. This mechanism ensures that in the event of an error, the team becomes aware as soon as possible, enabling them to address the issue. While most CI tools offer a web interface to view results, they also support other notification methods like emails, messaging applications, etc.\nThe integration process # The figure below broadly illustrates the stages of the integration process taking place within the Continuous Integration (CI) system.\nFigure 2: CI process flowchart Initially, the system must retrieve the latest source code version each time a new change is pushed to the Version Control System (VCS). Two mechanisms facilitate this. The first involves setting up the CI server to periodically check the VCS for updates. The alternative is to establish a commit hook within the VCS, ensuring that the CI server receives notifications whenever changes are made.\nAfter obtaining the code, the CI server can be configured to scrutinize the source code for potential undetected errors, be they syntactic, logical, or patterns that might lead to faults. Various tools aid this process. For instance, Java boasts utilities like FindBugs, CheckStyle, and PMD, while Python has Pylint. JavaScript can be analysed with tools like JSLint or JSHint. An example of a code analysis criterion could be ensuring every developed method has a cyclomatic complexity8 under 10. By employing automated source code inspection, one can assess code correctness, spot duplicate portions, and expedite the time between error detection and rectification. While automated inspection might not catch every error, the results can approximate those of peer reviews, thereby lightening the team\u0026rsquo;s review load.\nThe subsequent step revolves around automated test execution on the product. This automation is paramount to successfully implementing a CI system. Thus, developers can confidently make alterations, knowing a robust testing framework safeguards against compromising existing functionalities. Some popular tools in this domain include Junit, JBehave, and Selenium, which not only facilitate test drafting but also generate comprehensive reports, often as visualizations or web pages. Several software testing levels exist, such as unit tests, integration tests, and system tests. In the CI pipeline context, the focus rests on automating unit and integration tests, with system tests\u0026rsquo; automation being recommended but not mandatory.\nOnce the tests pass, the CI pipeline advances to compiling the source code. During this phase, the source code morphs into one or multiple files or packages, ready for distribution and user execution. This process\u0026rsquo;s specifics hinge on the employed programming language. For instance, languages like Java necessitate code compilation, resulting in an executable. Conversely, languages like Python might involve stricter code structure checks without generating any binary files.\nThroughout this integration journey, the team should steadfastly adhere to three fundamental rules:\nLocally run tests and compile software before integrating it into the VCS to minimize error introduction chances (avoiding \u0026ldquo;breaking the build\u0026rdquo;). Avoid pushing new code to the VCS if the CI server flags errors (indicative of a \u0026ldquo;broken build\u0026rdquo;). Should the CI server report faults, code modifications should exclusively aim at rectifying them. Core principles and practices # Martin Fowler2 identifies a set of foundational elements intrinsic to every Continuous Integration (CI) system. While some of these have been touched upon earlier in this chapter, we will succinctly encapsulate them here for clarity:\nCentralized Code Repository: Retain all code within a singular, unified repository. Streamlined Compilation and Build Process: Entirely automate the compilation and construction workflows, negating manual intervention. Full-Spectrum Automated Testing: Ensure all software tests are automated, driving efficiency and precision. Daily Commitment: Encourage the team to consistently merge their changes to the repository on a daily basis. Stringent Integration Checks: Each alteration made to the Version Control System (VCS) undergoes rigorous integration processes within the CI system. Prompt Error Rectification: Should the CI system flag any issues (indicative of a \u0026ldquo;broken build\u0026rdquo;), immediate action is imperative. Either rectify the flaw or reverse the change to ensure the repository\u0026rsquo;s latest version remains operational. Swift CI Procedures: Aim to complete the CI process rapidly‚Äîideally within 15 minutes or less. This approach ensures timely integration and facilitates the expedited delivery of results. Universal Access to Latest Executables: Always provide the team with access to the most recent executable or deliverable package, promoting transparency. Real-time Product Status Visibility: Grant every team member the ability to monitor the product\u0026rsquo;s status at any given moment, fostering informed decision-making. Benefits # The overarching consensus within the software community is that the implementation of a Continuous Integration (CI) process yields an array of substantial advantages. Duvall5 outlines these core benefits in his publication.\nRisk Mitigation: Adopting frequent integration minimizes project risks. It facilitates early detection of issues and offers a continuous snapshot of the product\u0026rsquo;s health. By identifying these issues early in the development cycle, there\u0026rsquo;s a consequent reduction in both the cost of fixes and the risk of releasing a subpar product. Furthermore, automated inspections provide real-time insights into the product\u0026rsquo;s size, code complexity, and other metrics. This automation diminishes the chance of human-induced errors.\nMinimization of Manual Repetitive Tasks: Automation curtails the need for recurring manual tasks such as compilation, inspection, test execution, and report generation. This efficiency not only leads to significant time and cost savings but also allows teams to focus on activities that directly enhance product value. It liberates team members to dedicate more time to addressing new requirements or rectifying existing product issues.\nOn-Demand Availability of a Functional Product: A hallmark of CI is its ability to deliver a functional software product at any given moment. This is invaluable for stakeholders, offering them a rapid glance into product development progress. By leveraging CI, errors can be swiftly detected and remedied soon after a new change is introduced. This is far more efficient than uncovering them close to the release date when they are more expensive and challenging to amend. Such issues, if left unchecked, can lead to delivery delays, unsatisfied clients, escalated costs, and more. This ties back to the concept of the \u0026ldquo;Broken Window Theory\u0026rdquo;9, which, in essence, postulates that a product marred by numerous issues or perceived disorder can demotivate teams from addressing them.\nEnhanced Project Transparency: Implementing CI augments visibility into the project, rendering the development process more transparent. It aids project management with up-to-the-minute information, making it straightforward to gauge product quality, error trends, and more.\nElevated Product Confidence: The CI environment bolsters confidence in the product. Team members gain immediate insights into the ramifications of their changes, enabling them to promptly rectify any emergent issues.\nChallenges # While Duvall5 has extolled the virtues of Continuous Integration (CI) in his works, he also highlights potential challenges that might deter development teams from embracing it fully or realizing its benefits.\nBias: A widespread misconception is that CI system implementation is exorbitant and would escalate development costs due to its prolonged setup and maintenance. Contrarily, most software development projects already involve phases like inspection, testing, compilation, and integration, even if they don‚Äôt explicitly use a CI system. A common refrain is that there\u0026rsquo;s insufficient time or funds for CI system implementation, but the reality is that far more resources are spent performing redundant manual tasks throughout the development cycle. Furthermore, an automated CI system is infinitely more manageable and consistent compared to disparate manual processes.\nDisruption Fears: Projects in advanced development stages often fret that integrating a CI system would overhaul their established workflows, spawning significant delays. It‚Äôs pivotal to recognize that CI system implementation can be incremental. Teams can address one integration stage at a time, gradually ramping up the integration frequency as confidence builds.\nOverwhelming Failed Integrations: When CI practices aren‚Äôt diligently applied, there\u0026rsquo;s a risk of encountering an excessive number of failed integrations or \u0026ldquo;broken builds.\u0026rdquo; This could stem from developers bypassing local tests before uploading their changes to the Version Control System (VCS). A surge in failed integrations can erode trust in the CI system, reminiscent of the \u0026ldquo;Broken Window Theory\u0026rdquo;9.\nPerceived Additional Costs: There\u0026rsquo;s an apprehension among organizations about incurring extra expenses either for procuring CI product licenses or securing hardware to support these systems. However, this expenditure pales in comparison to the latent costs of late-stage integrations, where issues are discovered near the release date, far removed from their inception. On a brighter note, the current landscape is rife with a myriad of free and open-source alternatives, obviating any additional costs.\nReferences # Continuous integration. ThoughtWorks, 2018.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFowler, Martin. Continuous Integration. 2006.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBeck, Kent. Embrace Change with Extreme Programming. IEEE Computer Magazine, (c), 70-77. 1999.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRodriguez Pilar, Markkula, Jouni, Oivo, Markku, \u0026amp; Turula, Kimmo. Survey on agile and lean usage in Finnish software industry. In Proceedings of the ACM-IEEE international symposium on Empirical software engineering and measurement - ESEM \u0026lsquo;12 (p. 139). ACM Press. DOI: 10.1145/2372251.2372275. 2012.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDuvall, Paul M., Matyas, Steve, \u0026amp; Glover, Andrew. Continuous integration: improving software quality and reducing risk. Pearson Education, Inc., 2007.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCauldwell, Patrick. Code Leader: Using people, tools and processes to build successful software. Wiley Publishing, Inc., 2008.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHumble, Jez \u0026amp; Farley, David. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCyclomatic Complexity Explanation\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThe Broken Window Theory in Software Development\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"19 agosto 2023","externalUrl":null,"permalink":"/en/blog/continuous-integration/","section":"Blog","summary":"","title":"Continuous Integration","type":"blog"},{"content":"","date":"19 agosto 2023","externalUrl":null,"permalink":"/en/tags/continuous-integration/","section":"Tags","summary":"","title":"Continuous Integration","type":"tags"},{"content":"","date":"10 agosto 2023","externalUrl":null,"permalink":"/en/series/learning-software-engineering/","section":"Series","summary":"","title":"Learning Software Engineering","type":"series"},{"content":"","date":"10 agosto 2023","externalUrl":null,"permalink":"/en/tags/software-engineering/","section":"Tags","summary":"","title":"Software Engineering","type":"tags"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/en/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/en/tags/revert/","section":"Tags","summary":"","title":"Revert","type":"tags"},{"content":" Reverting a commit before pushing # When we have created a commit locally but have not published it to the remote yet, we can use git reset to undo the commit and, if we wish, discard the changes. Although there are several options for git reset the most used are:\n--soft: Does not touch the index file or the working tree at all (but resets the head to , just like all modes do). This leaves all your changed files \u0026ldquo;Changes to be committed\u0026rdquo;, as git status would put it. --hard: Resets the index and working tree. Any changes to tracked files in the working tree since are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted. Git reset documentation {: style=\u0026ldquo;text-align: right;\u0026rdquo;}\nHere there is an example about using git reset. We start by changing a file and creating a commit with the change.\nbash-3.2$ cat README.md # Index 1 bash-3.2$ bash-3.2$ cat README.md # Index 1 2 bash-3.2$ bash-3.2$ git add README.md bash-3.2$ bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md\u0026#34; [main 3734fd5] Add number 2 in README.md 1 file changed, 1 insertion(+) git status shows there is one commit pending to be published.\nbash-3.2$ git status On branch main Your branch is ahead of \u0026#39;origin/main\u0026#39; by 1 commit. (use \u0026#34;git push\u0026#34; to publish your local commits) nothing to commit, working tree clean Using git reflog to see the history.\n3734fd5 (HEAD -\u0026gt; main) HEAD@{0}: commit: Add number 2 in README.md 866bfa8 (origin/main) HEAD@{1}: revert: Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; e2f6d08 HEAD@{2}: merge feature-1: Merge made by the \u0026#39;ort\u0026#39; strategy. 23644da HEAD@{3}: checkout: moving from feature-1 to main Now we can use git reset --soft \u0026lt;COMMIT_ID\u0026gt; to undo the commit but keep the changes.\nbash-3.2$ git reset --soft 866bfa8 bash-3.2$ bash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: README.md git log after using git reset\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. We create a new commit so we can test the git reset --hard command.\nbash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: README.md bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md - NEW COMMIT\u0026#34; [main 2e7193d] Add number 2 in README.md - NEW COMMIT 1 file changed, 1 insertion(+) git log now shows the new commit.\ncommit 2e7193db650b9ba0762fe73525df599a08f8577d (HEAD -\u0026gt; main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Thu Jan 19 08:32:57 2023 -0300 Add number 2 in README.md - NEW COMMIT commit 866bfa8a952d11240707ebfc87f3266034d42443 (origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. Now we can use git reset --hard \u0026lt;COMMIT_ID\u0026gt; to undo the commit and discard all the changes.\nbash-3.2$ git reset --hard 866bfa8 HEAD is now at 866bfa8 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; bash-3.2$ bash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean git log remains as it nothing had happened.\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. Reverting a commit after it was pushed # When we realized that the last commit was a mistake but we already published it, the command to use is git revert \u0026lt;COMMIT_HASH\u0026gt;.\nFirst we need to locate the ID of the commit we want to revert, it can be done with git log or git reflog commands. Then, run the git revert \u0026lt;COMMIT_HASH\u0026gt; command using the ID obtained in the previous step. Use the options -e or --edit to edit the commit message if we like. Push our changes so the revert is available for everyone in our group. Reverting multiple commits # If we need to revert multiple commits we can revert them one by one using the --no-commit option in order to create a single revert commit at the end.\nImagine the history is like the following and we need to go back to COMMIT-3.\nCOMMIT-1 -\u0026gt; COMMIT-2 -\u0026gt; COMMIT-3 -\u0026gt; COMMIT-4 -\u0026gt; COMMIT-5 -\u0026gt; COMMIT-6 -\u0026gt; HEAD This sequence of commands will get our files to the version of COMMIT-3:\nbash-3.2$ git revert --no-commit COMMIT-6 bash-3.2$ git revert --no-commit COMMIT-5 bash-3.2$ git revert --no-commit COMMIT-4 bash-3.2$ git commit -m \u0026#34;Revert to version in COMMIT-3\u0026#34; bash-3.2$ git push Reverting a merge commit # -m parent-number, \u0026ndash;mainline parent-number\nUsually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.\nGit revert documentation {: style=\u0026ldquo;text-align: right;\u0026rdquo;}\nWhen we need to revert a merge commit git revert command needs to be run with the -m or --mainline option to indicate the parent number because a merge commit has more than one parent and Git does not know which parent was target branch and which was the branch with the changes that should be reverted.\nHere there is an example showing how to revert a merge commit.\nCreate the first commit in main branch.\nbash-3.2$ cat README.md # Index 1 bash-3.2$ bash-3.2$ git commit -m \u0026#34;Add number 1 in README.md - main branch\u0026#34; [main (root-commit) 23644da] Add number 1 in README.md - main branch 1 file changed, 3 insertions(+) create mode 100644 README.md bash-3.2$ bash-3.2$ git push -u origin main Enumerating objects: 3, done. Counting objects: 100% (3/3), done. Writing objects: 100% (3/3), 254 bytes | 254.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git * [new branch] main -\u0026gt; main branch \u0026#39;main\u0026#39; set up to track \u0026#39;origin/main\u0026#39;. bash-3.2$ The state of the README.md file in main branch.\nbash-3.2$git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 Branch feature-1 created and added one commit.\nbash-3.2$ git checkout -b feature-1 Switched to a new branch \u0026#39;feature-1\u0026#39; bash-3.2$ bash-3.2$ cat README.md # Index 1 2 bash-3.2$ bash-3.2$ git add README.md bash-3.2$ bash-3.2$ git commit -m \u0026#34;Add number 2 in README.md - feature-1 branch\u0026#34; [feature-1 83ea1a3] Add number 2 in README.md - feature-1 branch 1 file changed, 1 insertion(+) bash-3.2$ bash-3.2$ git push --set-upstream origin feature-1 Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 292 bytes | 292.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 remote: remote: Create a pull request for \u0026#39;feature-1\u0026#39; on GitHub by visiting: remote: https://github.com/jnonino/test-repo/pull/new/feature-1 remote: To github.com:jnonino/test-repo.git * [new branch] feature-1 -\u0026gt; feature-1 branch \u0026#39;feature-1\u0026#39; set up to track \u0026#39;origin/feature-1\u0026#39;. bash-3.2$ The state of README.md in the feature-1 branch.\nbash-3.2$ git status On branch feature-1 Your branch is up to date with \u0026#39;origin/feature-1\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 2 Merge the feature-1 branch into the main branch.\nbash-3.2$ git checkout main Switched to branch \u0026#39;main\u0026#39; Your branch is up to date with \u0026#39;origin/main\u0026#39;. bash-3.2$ bash-3.2$ git merge --no-ff feature-1 Merge made by the \u0026#39;ort\u0026#39; strategy. README.md | 1 + 1 file changed, 1 insertion(+) bash-3.2$ bash-3.2$ git push Enumerating objects: 1, done. Counting objects: 100% (1/1), done. Writing objects: 100% (1/1), 233 bytes | 233.00 KiB/s, done. Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git 23644da..e2f6d08 main -\u0026gt; main bash-3.2$ Current state of README.md in main branch.\nbash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 2 git log after merging feature-1 into main branch.\ncommit e2f6d08d3b38a02a1c026cfb879f3131536757ac (HEAD -\u0026gt; main, origin/main) Merge: 23644da 83ea1a3 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:58:19 2023 -0300 Merge branch \u0026#39;feature-1\u0026#39; commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:53:38 2023 -0300 Add number 2 in README.md - feature-1 branch commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:48:37 2023 -0300 Add number 1 in README.md - main branch To revert the merge commit, as it was stated above we need to pay attention to the merge field.\nMerge: 23644da 83ea1a3 Running git revert e2f6d08 -m 1 will reinstate the tree as it was in 23644da, and git revert e2f6d08 -m 2 will set the tree as it was in 83ea1a3. In this example we would like to leave the main branch as it was before the merge commit. For doing that, we need to run git revert e2f6d08 -m 1.\nbash-3.2$ git revert e2f6d08 -m 1 [main 866bfa8] Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; 1 file changed, 1 deletion(-) bash-3.2$ bash-3.2$ git status On branch main Your branch is ahead of \u0026#39;origin/main\u0026#39; by 1 commit. (use \u0026#34;git push\u0026#34; to publish your local commits) nothing to commit, working tree clean bash-3.2$ bash-3.2$ git push Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 344 bytes | 344.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git e2f6d08..866bfa8 main -\u0026gt; main git log after reverting the merge commit.\ncommit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -\u0026gt; main, origin/main) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 20:06:40 2023 -0300 Revert \u0026#34;Merge branch \u0026#39;feature-1\u0026#39;\u0026#34; This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546. commit e2f6d08d3b38a02a1c026cfb879f3131536757ac Merge: 23644da 83ea1a3 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:58:19 2023 -0300 Merge branch \u0026#39;feature-1\u0026#39; commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:53:38 2023 -0300 Add number 2 in README.md - feature-1 branch commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 Author: Julian Nonino \u0026lt;learn.software.eng+jnonino@gmail.com\u0026gt; Date: Wed Jan 18 19:48:37 2023 -0300 Add number 1 in README.md - main branch Current state of README.md in main branch.\nbash-3.2$ git status On branch main Your branch is up to date with \u0026#39;origin/main\u0026#39;. nothing to commit, working tree clean bash-3.2$ bash-3.2$ cat README.md # Index 1 ","date":"18 enero 2023","externalUrl":null,"permalink":"/en/blog/git-revert/","section":"Blog","summary":"","title":"Reverting changes in Git","type":"blog"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/en/tags/vcs/","section":"Tags","summary":"","title":"VCS","type":"tags"},{"content":"","date":"18 enero 2023","externalUrl":null,"permalink":"/en/tags/version-control/","section":"Tags","summary":"","title":"Version Control","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Autores","summary":"","title":"Autores","type":"authors"},{"content":" Ultimas noticias y tutoriales sobre programaci√≥n, ingenier√≠a de software, DevOps, y ¬°mucho m√°s! ","externalUrl":null,"permalink":"/blog/","section":"Blog","summary":"","title":"Blog","type":"blog"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Etiquetas","summary":"","title":"Etiquetas","type":"tags"},{"content":"","externalUrl":null,"permalink":"/software-engineering/","section":"Ingenier√≠a de Software","summary":"","title":"Ingenier√≠a de Software","type":"software-engineering"},{"content":" Te invito a acompa√±arme en un recorrido claro y concreto: pasar de saber programar en Python a desempe√±arte como ingeniero en Inteligencia Artificial. Vamos a ir publicando m√≥dulos con ejemplos reales, c√≥digo funcional y un desaf√≠o que pod√©s resolver en tu propio entorno. El objetivo es avanzar sin saturarte, aprendiendo de verdad y disfrutando cada paso.\nEste espacio es para vos, que est√°s comenzando, y tambi√©n para aquellos profesionales que quieren refrescar ideas, encontrar recursos √∫tiles o incluso descubrir soluciones que no se usaron en el d√≠a a d√≠a. Cada art√≠culo es una pieza aut√≥noma, directa y pr√°ctica: te sirve tanto si necesit√°s cimentar tu aprendizaje como si ven√≠s con experiencia y quer√©s repasar o inspirarte. Arrancamos desde Python y caminaremos juntos hasta llegar al mundo profesional de IA.\nEn los ejemplos, no se hace menci√≥n a las pr√°cticas esenciales para desarrollar software, como por ejemplo, utilizar un sistema de control de versiones, generar casos de prueba, etc√©tera.\nEsto se debe a que la intenci√≥n es hacer foco en los conceptos de IA y ML, pero a la hora de encarar un proyecto real siempre debes tener en cuenta las mejores pr√°cticas y proceso para el desarrollo profesional de software.\n","externalUrl":null,"permalink":"/ai/","section":"Inteligencia Artificial","summary":"","title":"Inteligencia Artificial","type":"ai"},{"content":"","externalUrl":null,"permalink":"/authors/jnonino/","section":"Autores","summary":"","title":"Juli√°n Nonino","type":"authors"},{"content":"","externalUrl":null,"permalink":"/","section":"Learn-Software.com","summary":"","title":"Learn-Software.com","type":"page"},{"content":"","externalUrl":null,"permalink":"/programming/","section":"Programaci√≥n","summary":"","title":"Programaci√≥n","type":"programming"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]