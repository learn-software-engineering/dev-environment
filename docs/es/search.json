[{"content":"","date":1696032e3,"headings":[],"kind":"taxonomy","lang":"es","summary":"","title":"Autores","url":"/es/authors/","year":"2023"},{"content":"","date":1696032e3,"headings":[],"kind":"section","lang":"es","summary":"","title":"Conceptos Iniciales","url":"/es/programming/0200-starting-concepts/","year":"2023"},{"content":"","date":1696032e3,"headings":[],"kind":"taxonomy","lang":"es","summary":"","title":"Etiquetas","url":"/es/tags/","year":"2023"},{"content":"","date":1696032e3,"headings":[],"kind":"term","lang":"es","summary":"","title":"factorial","url":"/es/tags/factorial/","year":"2023"},{"content":"","date":1696032e3,"headings":[],"kind":"term","lang":"es","summary":"","title":"fibonacci\"","url":"/es/tags/fibonacci/","year":"2023"},{"authors":["Julián Nonino"],"content":"Recursión: el arte de llamarse a sí mismo Imagina una caja de espejos donde cada espejo refleja lo que ve en el siguiente, creando una serie infinita de reflejos. La recursión en programación es algo similar. Es una técnica donde una función se llama a sí misma directa o indirectamente[^1^]. Esto crea un ciclo en el cual la función resuelve un problema dividiéndolo en instancias más pequeñas del mismo problema, hasta llegar a un caso base sencillo de resolver.\nPor ejemplo, imaginemos una función que imprime un contador regresivo:\n1def cuenta_regresiva(numero): 2 3 if numero \u0026gt; 0: 4 print(numero) 5 cuenta_regresiva(numero - 1) 6 else: 7 print(\u0026#34;¡Despegue!\u0026#34;) 8 9cuenta_regresiva(5) Esta función se llama recursivamente reduciendo el número cada vez hasta llegar a 0, y luego imprime el mensaje de despegue.\nLa recursión es un enfoque declarativo donde se enfoca en dividir un problema en casos recursivos sin necesidad de controlar explícitamente el bucle usando iteradores o contadores como en la programación imperativa.\nLa estructura de una función recursiva El poder de la recursión radica en su simplicidad. Sin embargo, es esencial entender su estructura para evitar caer en trampas comunes. Una función recursiva típica tiene dos partes principales1:\nCaso base: El caso más simple con una solución conocida que no requiere recursión. Es la condición de parada, que detiene la recursión. Sin el caso base, caeríamos en una recursión infinita que eventualmente desborda la pila de llamadas. Caso recursivo: Es donde ocurre la mágica llamada recursiva. En este punto, la función se llama a sí misma con un argumento modificado, generalmente una versión reducida del problema original. Ejemplos clásicos de recursión Factorial El factorial de un entero positivo \\(n\\) es el producto de todos los enteros positivos menores o iguales a \\(n\\) . Por ejemplo:\n\\(5! = 5 * 4 * 3 * 2 * 1 = 120\\) \\(4! = 4 * 3 * 2 * 1 = 24\\) \\(3! = 3 * 2 * 1 = 6\\) Aquí está el código en Python para calcular el factorial usando recursión:\n1def factorial(n): 2 if n == 1: 3 return 1 # Caso base 4 return n * factorial(n-1) # Caso recursivo Caso base: El caso base es la instancia más simple y pequeña del problema que puede responderse directamente. Para el factorial, cuando \\(n = 1\\) , el resultado es \\(1\\) . Caso recursivo: Si \\(n\\) es mayor que \\(1\\) , la función se llama a sí misma con \\(n-1\\) , y multiplica el resultado por \\(n\\) . Digamos que quieres calcular el factorial de \\(5\\) , así que llamas a factorial(5).\nEsto es lo que sucede:\nPaso 1: Como \\(n = 5\\) no es \\(1\\) , la función llama a factorial(4), luego multiplica el resultado por \\(5\\) . Paso 2: Ahora, dentro de factorial(4), \\(n = 4\\) , entonces la función llama a factorial(3), luego multiplica el resultado por \\(4\\) . Paso 3: Dentro de factorial(3), \\(n = 3\\) , así que llama a factorial(2), luego multiplica el resultado por \\(3\\) . Paso 4: Dentro de factorial(2), \\(n = 2\\) , así que llama a factorial(1), luego multiplica el resultado por \\(2\\) . Paso 5: Finalmente, factorial(1) alcanza el caso base, donde \\(n = 1\\) , así que retorna \\(1\\) . Ahora los resultados se desenrollan:\nfactorial(2) retorna \\(2 * 1 = 2\\) factorial(3) retorna \\(3 * 2 = 6\\) factorial(4) retorna \\(4 * 6 = 24\\) factorial(5) retorna \\(5 * 24 = 120\\) El resultado final es \\(120\\) , que es el valor de \\(5!\\) .\nAquí hay una representación visual de la pila de llamadas:\n1factorial(5) 2 -\u0026gt; factorial(4) 3 -\u0026gt; factorial(3) 4 -\u0026gt; factorial(2) 5 -\u0026gt; factorial(1) 6 return 1 7 return 2 8 return 6 9 return 24 10 return 120 Serie de Fibonacci La serie de Fibonacci es una secuencia de números donde cada número es la suma de los dos anteriores. Comienza con \\(0\\) y \\(1\\) , y cada número posterior es la suma de los dos números anteriores. Los primeros números de la secuencia son: \\(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\\) Aquí está el código en Python para calcular el \\(n^th\\) número de Fibonacci usando recursión de cola:\n1def fibonacci(n, a=0, b=1): 2 if n == 0: 3 return a 4 return fibonacci(n-1, b, a+b) La función toma tres parámetros:\n\\(n\\) : La posición del número deseado en la secuencia. \\(a\\) y \\(b\\) : Dos números que ayudan en el cálculo de la secuencia. Aquí hay un desglose de cómo funciona la función:\nCaso Base: Si \\(n\\) es \\(0\\) , la función devuelve \\(a\\) . Este es el valor del \\(n^th\\) número en la secuencia.\nCaso Recursivo: Si \\(n\\) no es \\(0\\) , la función se llama a sí misma con \\(n-1\\) , \\(b\\) , y \\(a\u0026#43;b\\) . Estos parámetros cambian la posición en la secuencia y preparan los siguientes números para la suma.\nSupongamos que queremos encontrar el \\(5^th\\) número en la secuencia de Fibonacci llamando a fibonacci(5).\nEsto es lo que sucede:\nPaso 1: Dado que \\(n = 5\\) , llama a fibonacci(4, 1, 1) (porque \\(a = 0\\) , \\(b = 1\\) , \\(a \u0026#43; b = 1\\) ). Paso 2: Dado que \\(n = 4\\) , llama a fibonacci(3, 1, 2) (porque \\(a = 1\\) , \\(b = 1\\) , \\(a \u0026#43; b = 2\\) ). Paso 3: Dado que \\(n = 3\\) , llama a fibonacci(2, 2, 3) (porque \\(a = 1\\) , \\(b = 2\\) , \\(a \u0026#43; b = 3\\) ). Paso 4: Dado que \\(n = 2\\) , llama a fibonacci(1, 3, 5) (porque \\(a = 2\\) , \\(b = 3\\) , \\(a \u0026#43; b = 5\\) ). Paso 5: Dado que \\(n = 1\\) , llama a fibonacci(0, 5, 8) (porque \\(a = 3\\) , \\(b = 5\\) , \\(a \u0026#43; b = 8\\) ). Paso 6: Dado que \\(n = 0\\) , devuelve \\(a\\) , que es \\(5\\) . El resultado es \\(5\\) , que es el \\(5^th\\) número en la secuencia de Fibonacci.\nAquí hay una representación visual de la pila de llamadas:\n1fibonacci(5, 0, 1) 2 -\u0026gt; fibonacci(4, 1, 1) 3 -\u0026gt; fibonacci(3, 1, 2) 4 -\u0026gt; fibonacci(2, 2, 3) 5 -\u0026gt; fibonacci(1, 3, 5) 6 -\u0026gt; fibonacci(0, 5, 8) 7 return 5 Ventajas y desventajas La recursión tiene ciertas ventajas2:\nPuede resultar en soluciones simples y elegantes para problemas que se dividen fácilmente en subproblemas. Elimina la necesidad de control de bucles explícito. Sigue la estructura matemática de una definición recursiva. Las desventajas incluyen:\nPuede ser menos eficiente (alto consumo de memoria) que la iteración debido a las llamadas repetidas y creación de marcos de pila. Demasiada recursión puede desbordar la pila de llamadas y causar errores. Puede ser más difícil de depurar y analizar que la iteración. Por lo tanto, la recursión es una herramienta poderosa que debe usarse con discreción en los casos apropiados.\nRecursión vs Iteración La recursión y la iteración (usando ciclos) son paralelos y podemos usar cualquiera para resolver muchos problemas. Ambas técnicas tienen el potencial de resolver los mismos problemas, pero su implementación y eficiencia pueden variar. Tomemos el ejemplo del factorial:\nIterativo\n1def factorial_iterativo(n): 2 resultado = 1 3 for i in range(1, n+1): 4 resultado *= i 5 return resultado Recursivo\n1def factorial_recursivo(n): 2 if n == 1: 3 return 1 4 return n * factorial(n-1) La versión iterativa es más eficiente en términos de espacio, pero la recursiva es más limpia y fácil de entender. La elección entre recursión e iteración a menudo depende del problema específico, las restricciones de memoria y las preferencias del programador.\nConclusión La recursión es una técnica clave que permite escribir algoritmos elegante, naturales y eficientes si se utiliza adecuadamente. Entender cómo dividir un problema en casos recursivos es esencial para dominar esta habilidad. La recursión ofrece una alternativa declarativa única para resolver problemas complejos sin necesidad de administrar bucles explícitos. Sin embargo, es crucial recordar siempre definir un caso base adecuado y ser consciente de las limitaciones de la recursión en términos de eficiencia y uso de memoria. Saber combinar recursión e iteración nos da flexibilidad al crear soluciones óptimas.\nComo siempre, la clave está en encontrar el equilibrio adecuado y utilizar la herramienta correcta para el trabajo adecuado.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias Kindler, E., \u0026amp; Krivy, I. (2011). Object-Oriented Simulation of systems with Java: A working introduction. BoD–Books on Demand.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1696032e3,"headings":[{"anchor":"conclusión","title":"Conclusión"},{"anchor":"ejemplos-clásicos-de-recursión","title":"Ejemplos clásicos de recursión"},{"anchor":"factorial","title":"Factorial"},{"anchor":"la-estructura-de-una-función-recursiva","title":"La estructura de una función recursiva"},{"anchor":"recursión-el-arte-de-llamarse-a-sí-mismo","title":"Recursión: el arte de llamarse a sí mismo"},{"anchor":"recursión-vs-iteración","title":"Recursión vs Iteración"},{"anchor":"referencias","title":"Referencias"},{"anchor":"serie-de-fibonacci","title":"Serie de Fibonacci"},{"anchor":"ventajas-y-desventajas","title":"Ventajas y desventajas"}],"kind":"page","lang":"es","series":["Programming"],"summary":"La recursión es un concepto fundamental en programación que permite que una función se llame a sí misma. A primera vista puede parecer contraintuitivo, pero dominar este enfoque abre la puerta a soluciones elegantes para ciertos problemas.","tags":["programming","functions","recursion","factorial","fibonacci\""],"title":"Funciones Recursivas","url":"/es/programming/0200-starting-concepts/0205-recursive-functions/","year":"2023"},{"content":"","date":1696032e3,"headings":[],"kind":"term","lang":"es","summary":"","title":"functions","url":"/es/tags/functions/","year":"2023"},{"content":"","date":1696032e3,"headings":[],"kind":"term","lang":"es","summary":"","title":"Julián Nonino","url":"/es/authors/jnonino/","year":"2023"},{"content":"Bienvenidos a nuestra serie integral para emprender tu camino en el mundo de la programación. Creada para aquellos nuevos en el mundo de la codificación, esta colección de artículos ofrece un enfoque paso a paso para comprender los fundamentos de la programación. Empezaremos desde lo básico, como entender variables, tipos de datos y estructuras de control, hasta explorar gradualmente temas más complejos como algoritmos, estructuras de datos y principios de diseño de software.\nYa sea que nunca hayas escrito una línea de código o estés buscando una revisión estructurada, en esta serie encontraras la explicaciones y guías que necesitas para desenvolverte en la industria del software. Nuestros tutoriales prácticos, explicaciones claras y ejemplos aplicados tienen como objetivo hacer que el proceso de aprendizaje sea a la vez atractivo e intuitivo. Unite en esta aventura de codificación con nosotros, y al final, estarás equipado con las habilidades y conocimientos para enfrentar desafíos reales de programación.\n","date":1696032e3,"headings":[],"kind":"section","lang":"es","summary":"Bienvenidos a nuestra serie integral para emprender tu camino en el mundo de la programación. Creada para aquellos nuevos en el mundo de la codificación, esta colección de artículos ofrece un enfoque paso a paso para comprender los fundamentos de la programación. Empezaremos desde lo básico, como entender variables, tipos de datos y estructuras de control, hasta explorar gradualmente temas más complejos como algoritmos, estructuras de datos y principios de diseño de software.","title":"Programación","url":"/es/programming/","year":"2023"},{"content":"","date":1696032e3,"headings":[],"kind":"term","lang":"es","summary":"","title":"programming","url":"/es/tags/programming/","year":"2023"},{"content":"","date":1696032e3,"headings":[],"kind":"term","lang":"es","summary":"","title":"Programming","url":"/es/series/programming/","year":"2023"},{"content":"","date":1696032e3,"headings":[],"kind":"term","lang":"es","summary":"","title":"recursion","url":"/es/tags/recursion/","year":"2023"},{"content":"","date":1696032e3,"headings":[],"kind":"taxonomy","lang":"es","summary":"","title":"Series","url":"/es/series/","year":"2023"},{"authors":["Julián Nonino"],"content":"¿Qué son las funciones? Una función, en términos simples, es un bloque de código que se ejecuta sólo cuando es llamado. Puedes pensar en ella como un pequeño programa dentro de tu programa principal, diseñado para realizar una tarea específica1. Una función también puede verse como una caja negra: le pasamos una entrada (parámetros), ocurre algún procesamiento interno, y produce una salida (retorno).\nLas funciones nos permiten segmentar nuestro código en partes lógicas, donde cada parte realiza una única acción. Esto brinda varios beneficios2:\nReutilización: Una vez definida la función, podemos ejecutar (llamar) ese código desde cualquier lugar de nuestro programa cuantas veces sea necesario. Organización: Permite dividir un programa grande en partes más pequeñas y manejables. Encapsulamiento: Las funciones reducen la complejidad escondiendo los detalles de implementación internos. Mantenimiento: Si necesitamos realizar cambios, solo debemos modificar el código en un lugar (la función) en lugar de rastrear todas las instancias de ese código. Procedimientos vs. Funciones\nEs vital distinguir entre estos dos conceptos. Mientras que una función siempre devuelve un valor, un procedimiento realiza una tarea pero no devuelve nada. En algunos lenguajes, esta diferencia es más clara que en otros. Python, por ejemplo, tiene funciones que pueden o no devolver valores.\nAnatomía de una función En Python, una función se declara usando la palabra clave def, seguida del nombre de la función y paréntesis. El código dentro de la función se denomina el cuerpo de la función3 y contiene el conjunto de instrucciones a ejecutar para cumplir con su tarea..\n1def mi_funcion(): 2 print(\u0026#34;¡Hola desde mi función!\u0026#34;) Para llamar o invocar una función, simplemente usamos su nombre seguido de paréntesis:\n1mi_funcion() # Salida: ¡Hola desde mi función! Parámetros y argumentos Las funciones se vuelven aún más poderosas cuando les pasamos información, conocida como parámetros. Estos actúan como \u0026ldquo;variables\u0026rdquo; dentro de la función y permiten que la función trabaje con diferentes datos cada vez que se llama.\nMientras que los parámetros son variables definidas en la definición de la función. Los argumentos son los valores reales pasados al llamar a la función.\n1def saludo(nombre): 2 print(f\u0026#34;¡Hola {nombre}!\u0026#34;) 3 4 5saludo(\u0026#34;María\u0026#34;) 6# Salida: 7# ¡Hola María! Podemos definir valores por defecto para los parámetros Python permite parámetros por defecto, que tienen un valor predeterminado, lo cual hace opcional pasar esos argumentos al llamar la función. También permite parámetros nombrados que permiten pasar los argumentos en cualquier orden, especificando su nombre.\n1def saludo(nombre=\u0026#34;María\u0026#34;, repeticiones=3): 2 repeticion = 1 3 while repeticion \u0026lt;= repeticiones: 4 print(f\u0026#34;¡Hola {nombre}!\u0026#34;) 5 repeticion += 1 6 7 8saludo() 9# Salida: 10# ¡Hola María! 11# ¡Hola María! 12# ¡Hola María! 13 14 15saludo(\u0026#34;Florencia\u0026#34;, 4) 16# Salida: 17# ¡Hola Florencia! 18# ¡Hola Florencia! 19# ¡Hola Florencia! 20# ¡Hola Florencia! 21 22 23saludo(repeticiones=2, nombre=\u0026#34;Julián\u0026#34;) 24# Salida 25# ¡Hola Julián! 26# ¡Hola Julián! Retorno de valores Las funciones pueden devolver un resultado o valor de retorno usando la palabra reservada return.\n1def area_circulo(radio): 2 return 3.14 * (radio ** 2) 3 4 5resultado = area_circulo(10) 6print(resultado) # Salida: 314 El valor de retorno se pasa de vuelta a donde se llamó la función y se puede asignar a una variable para usarlo.\nLas funciones también pueden ejecutar alguna tarea sin devolver nada explícitamente. En Python esto se conoce como retornar None.\nVariables locales y globales Las variables locales se definen dentro de una función y solo existen en ese ámbito, mientras que las variables globales están definidas fuera y pueden ser accedidas desde cualquier parte del código. Es crucial entender su alcance (dónde puede ser accesible una variable) y duración (cuánto tiempo vive una variable).\n1x = 10 # x es global 2 3def suma(): 4 y = 5 # y es local 5 return x + y 6 7suma() # Salida: 15 8print(y) # Error, y no existe fuera de la función Podemos leer variables globales desde una función, pero si necesitamos modificarla debemos declararla global.\n1x = 10 2 3def suma(): 4 global x 5 x = x + 5 6 7suma() 8print(x) # 15 Idealmente las funciones solo deben trabajar con variables locales y parámetros. Limita el uso de variables globales. Si bien pueden ser útiles, también pueden hacer que el código sea difícil de leer y mantener. Buenas prácticas Al crear funciones debemos seguir ciertos principios y patrones4:\nEl nombre de una función debe indicar claramente su propósito. Hacer las funciones pequeñas, simples y enfocadas en una tarea. Una función debe hacer una cosa y hacerla bien. Utilizar nombres descriptivos para las funciones y sus parámetros. Evitar efectos secundarios y modificación de variables globales. Documentar adecuadamente el propósito y uso de cada función. Limitar el número de parámetros, idealmente de 0 a 3 parámetros. Seguir estas buenas prácticas nos ayudará a crear funciones reutilizables, encapsuladas y fáciles de mantener.\nConclusión Las funciones son componentes fundamentales en la programación, permitiéndonos organizar, reutilizar y encapsular código. Definiendo funciones que realicen una sola tarea mantenemos nuestros programas simplificados, fáciles de entender y modificar. Al comprender y dominar este concepto, no solo mejoras la calidad de tu código sino también tu eficiencia como desarrollador.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias McConnell, S. (2004). Code Complete. Microsoft Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nJoyanes Aguilar, L. (2008). Fundamentos de programación: algoritmos, estructura de datos y objetos. McGraw-Hill.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPython Software Foundation. (2022). Documentación oficial de Python.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKindler, E., \u0026amp; Krivy, I. (2011). Object-Oriented Simulation of systems with Java: A working introduction. BoD–Books on Demand.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1695945600,"headings":[{"anchor":"anatomía-de-una-función","title":"Anatomía de una función"},{"anchor":"buenas-prácticas","title":"Buenas prácticas"},{"anchor":"conclusión","title":"Conclusión"},{"anchor":"parámetros-y-argumentos","title":"Parámetros y argumentos"},{"anchor":"qué-son-las-funciones","title":"¿Qué son las funciones?"},{"anchor":"referencias","title":"Referencias"},{"anchor":"retorno-de-valores","title":"Retorno de valores"},{"anchor":"variables-locales-y-globales","title":"Variables locales y globales"}],"kind":"page","lang":"es","series":["Programming"],"summary":"En el vasto y emocionante mundo de la programación, existen conceptos que son pilares fundamentales para cualquier desarrollador, sin importar su nivel de experiencia. Uno de estos conceptos es el de las funciones. ¿Qué son? ¿Por qué son tan cruciales? ¡Vamos a descubrirlo!","tags":["intro","programming","functions","methods"],"title":"Funciones","url":"/es/programming/0200-starting-concepts/0204-functions/","year":"2023"},{"content":"","date":1695945600,"headings":[],"kind":"term","lang":"es","summary":"","title":"intro","url":"/es/tags/intro/","year":"2023"},{"content":"","date":1695945600,"headings":[],"kind":"term","lang":"es","summary":"","title":"methods","url":"/es/tags/methods/","year":"2023"},{"content":"","date":1695772800,"headings":[],"kind":"term","lang":"es","summary":"","title":"bucles","url":"/es/tags/bucles/","year":"2023"},{"content":"","date":1695772800,"headings":[],"kind":"term","lang":"es","summary":"","title":"condicionales","url":"/es/tags/condicionales/","year":"2023"},{"authors":["Julián Nonino"],"content":"Condiciones: tomando decisiones en el código La vida está llena de decisiones: \u0026ldquo;Si llueve, llevaré un paraguas. De lo contrario, usaré anteojos de sol\u0026rdquo;. Estas decisiones también están presentes en el mundo de la programación. Las condiciones son como preguntas que la computadora se hace. Nos permiten tomar decisiones y ejecutar código específico dependiendo de una condición1. Pueden ser simples como \u0026ldquo;¿Está lloviendo?\u0026rdquo; o complejas como \u0026ldquo;¿Es fin de semana y tengo menos de $100 en mi cuenta bancaria?\u0026rdquo;.\nif La estructura if nos permite evaluar condiciones y tomar decisiones basadas en el resultado de esa evaluación.\n1edad = 15 2 3if edad \u0026gt;= 18: 4 print(\u0026#34;Eres mayor de edad\u0026#34;) El código anterior permite ejecutar una porción de código si la edad de una persona es mayo o igual a 18 años.\nif-else Cuando se desea ejecutar un código alternativo si la condición es falsa, utilizamos la estructura if-else\n1edad = 21 2if edad \u0026gt;= 18: 3 print(\u0026#34;Eres mayor de edad\u0026#34;) 4else: 5 print(\u0026#34;Eres menor de edad\u0026#34;) En este caso, se determina si la persona es mayor de edad, o menor de edad, el mensaje mostrado es diferente\nif-elif-else Cuando las condiciones son múltiples y no es suficientes con dos caminos, se utiliza la estructura if-elif-else para evaluarlas forma encadenada.\n1edad = 5 2if edad \u0026lt;= 13: 3 print(\u0026#34;Eres un niño\u0026#34;) 4elif edad \u0026gt; 13 and edad \u0026lt; 18: 5 print(\u0026#34;Eres un adolescente\u0026#34;) 6else: 7 print(\u0026#34;Eres un adulto\u0026#34;) En el código anterior se observan tres caminos claros, uno para cuando la edad es menor o igual a 13 años, otro para cuando la edad esta entre 13 y 18 y otro para cuando es mayor o igual a 18.\nOtra manera de resolver este problema es mediante la estructura switch-case, que, aunque Python no incorpora de manera nativa, como si lo hacen otros lenguajes como Java o C++, es una herramienta importante para conocer. Esta estructura permite a los programadores manejar múltiples condiciones de manera más organizada que una serie de if-elif-else.\nEn Java, por ejemplo:\n1int dia = 3; 2switch(dia) { 3 case 1: 4 System.out.println(\u0026#34;Lunes\u0026#34;); 5 break; 6 case 2: 7 System.out.println(\u0026#34;Martes\u0026#34;); 8 break; 9 case 3: 10 System.out.println(\u0026#34;Miércoles\u0026#34;); 11 break; 12 // ... y así sucesivamente 13 default: 14 System.out.println(\u0026#34;Día no válido\u0026#34;); 15} En el ejemplo anterior, dependiendo del valor de dia, se imprimirá el día correspondiente2.\nBucles: repitiendo acciones A veces, en programación, necesitamos repetir una acción varias veces. En lugar de escribir el mismo código varias veces, podemos usar bucles. Estos, permiten repetir la ejecución de un bloque de código mientras se cumpla una condición3.\nwhile El bucle while es útil cuando queremos repetir una acción basada en una condición.\n1# Imprime del 1 al 5 2i = 1 3while i \u0026lt;= 5: 4 print(i) 5 i = i + 1 do-while Similar a while pero garantiza al menos una ejecución dado que primero se ejecuta el bloque de código y luego se evalúa la condición. Python no implementa esta estructura, pero otros lenguajes como Java y C++ sí lo hacen.\n1int i = 1; 2 3do { 4 System.out.println(i); 5 i++; 6} while(i \u0026lt;= 5); 1int numero = 0; 2do { 3 std::cout \u0026lt;\u0026lt; \u0026#34;Hola, mundo!\u0026#34; \u0026lt;\u0026lt; std::endl; 4 numero++; 5} while (numero \u0026lt; 5); for El bucle for es útil cuando sabemos cuántas veces queremos repetir una acción.\n1for i in range(5): 2 print(\u0026#34;Hola, mundo!\u0026#34;) El código anterior imprimirá \u0026ldquo;Hola, mundo!\u0026rdquo; cinco veces.\nTambién podemos iterar sobre los elementos de una lista u objeto iterable:\n1nombres = [\u0026#34;María\u0026#34;, \u0026#34;Florencia\u0026#34;, \u0026#34;Julián\u0026#34;] 2for nombre in nombres: 3 print(f\u0026#34;Hola {nombre}\u0026#34;) 4 5# Imprime 6# Hola María 7# Hola Florencia 8# Hola Julián Las sentencias break y continue Podemos usar break para terminar el bucle y continue para saltar a la siguiente iteración.\nEl break se usa para terminar completamente el bucle cuando se cumple una condición, en el ejemplo siguiente, cuando i llega a 5.\n1# Ejemplo de break 2i = 0 3while i \u0026lt; 10: 4 print(i) 5 if i == 5: 6 break 7 i += 1 8 9# Imprime: 10# 0 11# 1 12# 2 13# 3 14# 4 15# 5 El continue se usa para saltarse una iteración del bucle y continuar con la siguiente cuando se cumple una condición. Aquí lo usamos para saltarnos los números pares.\n1# Ejemplo de continue 2i = 0 3while i \u0026lt; 10: 4 i += 1 5 if i % 2 == 0: 6 continue 7 print(i) 8 9# Imprime: 10# 1 11# 3 12# 5 13# 7 14# 9 Anidamiento: combinando estructuras Las estructuras de control de flujo pueden anidarse dentro de otras. Por ejemplo, podemos tener bucles dentro de bucles o condiciones dentro de bucles.\n1for i in range(5): 2 for j in range(10): 3 if (i % 2 == 0 and j % 3 == 0): 4 print(f\u0026#34;i = {i}, j = {j}\u0026#34;) Este código imprimirá combinaciones de i y j sólo cuando i sea divisible por 2 y j sea divisible por 3, demostrando cómo los bucles se anidan y se ejecutan3.\nPatrones de uso comunes Existen patrones específicos para resolver necesidades habituales con control de flujo.\nBúsqueda Buscar un valor en una colección:\n1frutas = [\u0026#34;manzana\u0026#34;, \u0026#34;naranja\u0026#34;] 2 3buscando = \u0026#34;naranja\u0026#34; 4encontrado = False 5 6for fruta in frutas: 7 if fruta == buscando: 8 encontrado = True 9 break 10 11if encontrado: 12 print(\u0026#34;Fruta encontrada!\u0026#34;) Acumulación Acumular valores incrementales en un bucle.\n1total = 0 2 3for i in range(10): 4 total += i 5 6print(total) # Suma de 0..9 = 45 Diagramas de flujo: la ruta visual hacia el entendimiento del código Los programadores, sin importar si son principiantes o expertos, a menudo se encuentran enfrentando desafíos que requieren una planificación detallada antes de sumergirse en el código. Aquí es donde los diagramas de flujo entran en juego como una herramienta esencial. Estos diagramas son representaciones gráficas de los procesos y la lógica detrás de un programa o sistema. En este artículo, desentrañaremos el mundo de los diagramas de flujo, desde sus conceptos básicos hasta las técnicas avanzadas, y cómo pueden beneficiar a programadores de todos los niveles.\nUn diagrama de flujo es una representación gráfica de un proceso. Utiliza símbolos específicos para representar diferentes tipos de instrucciones o acciones. Su objetivo principal es simplificar la comprensión de un proceso, mostrando paso a paso cómo fluye la información o las decisiones. Estos diagramas:\nFacilitan la comprensión de procesos complejos. Ayudan en la fase de diseño y planificación de un programa. Sirven como documentación y referencia para futuros desarrollos. Los diagramas de flujo son una herramienta poderosa que no solo beneficia a los principiantes, sino también a los programadores experimentados. Ofrecen una visión clara y estructurada de un proceso o programa, facilitando la planificación, el diseño y la comunicación entre los miembros del equipo.\nElementos básicos Los diagramas de flujo constan de varios símbolos, cada uno con un significado específico:\nOvalo: Representa el inicio o el fin de un proceso. Rectángulo: Denota una operación o instrucción. Diamante: Indica una decisión basada en una condición. Flechas: Muestran la dirección del flujo. graph TD; start((Inicio)) process[Proceso] decision{¿Repetir?} final((Final)) start --\u003e process; process --\u003e decision; decision --\u003e |Si| process decision --\u003e |No| final Ejemplos Vamos a diseñar un diagrama de flujo para un programa que pida un número y nos diga si es par o impar.\ngraph TB inicio((Inicio)) entrada[Ingresar número] decision{¿Es par?} esPar[Es par] esImpar[Es impar] final((Final)) inicio --\u003e entrada entrada --\u003e decision decision --\u003e |Si| esPar decision --\u003e |No| esImpar esPar --\u003e final esImpar --\u003e final Conforme los programas se vuelven más complejos, es posible que necesites incorporar bucles, múltiples condiciones y otros elementos avanzados en tu diagrama de flujo. Por ejemplo, aquí diagramamos un programa que sume los números desde el 1 al número ingresado por el usuario.\ngraph TD inicio((Inicio)) entrada[Ingresar número] setVariables[Establecer suma=0 y contador=1] bucle_condicion{¿contador \u003c= N?} bucle_codigo[Sumar valor e incrementar el contador] resultado[Mostrar suma] final((Final)) inicio --\u003e entrada entrada --\u003e setVariables setVariables --\u003e bucle_condicion bucle_condicion --\u003e |Si| bucle_codigo bucle_codigo --\u003e bucle_condicion bucle_condicion --\u003e |No| resultado resultado --\u003e final Conclusión El control de flujo es el corazón de la programación. Sin él, los programas serían secuencias lineales de acciones sin la capacidad de tomar decisiones o repetir tareas. Al dominar estas estructuras, no solo mejoras tu capacidad para escribir código, sino también tu capacidad para pensar lógicamente y resolver problemas complejos.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias Lutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDeitel, P., \u0026amp; Deitel, H. (2012). Java: How to program. Upper Saddle River, NJ: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMatthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. San Francisco, CA: No Starch Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1695772800,"headings":[{"anchor":"acumulación","title":"Acumulación"},{"anchor":"anidamiento-combinando-estructuras","title":"Anidamiento: combinando estructuras"},{"anchor":"bucles-repitiendo-acciones","title":"Bucles: repitiendo acciones"},{"anchor":"búsqueda","title":"Búsqueda"},{"anchor":"conclusión","title":"Conclusión"},{"anchor":"condiciones-tomando-decisiones-en-el-código","title":"Condiciones: tomando decisiones en el código"},{"anchor":"diagramas-de-flujo-la-ruta-visual-hacia-el-entendimiento-del-código","title":"Diagramas de flujo: la ruta visual hacia el entendimiento del código"},{"anchor":"do-while","title":"do-while"},{"anchor":"ejemplos","title":"Ejemplos"},{"anchor":"elementos-básicos","title":"Elementos básicos"},{"anchor":"for","title":"for"},{"anchor":"if","title":"if"},{"anchor":"if-elif-else","title":"if-elif-else"},{"anchor":"if-else","title":"if-else"},{"anchor":"las-sentencias-break-y-continue","title":"Las sentencias break y continue"},{"anchor":"patrones-de-uso-comunes","title":"Patrones de uso comunes"},{"anchor":"referencias","title":"Referencias"},{"anchor":"while","title":"while"}],"kind":"page","lang":"es","series":["Programming"],"summary":"Cuando nos embarcamos en la emocionante travesía de aprender a programar, no tardamos en descubrir que la programación no es solo acerca de escribir código, sino también sobre cómo controlar el flujo de ese código. Podemos compararlo con el flujo de decisiones que tomamos en nuestra vida diaria. Por ejemplo, si hace frío afuera, nos ponemos un abrigo antes de salir. Si no tenemos tareas pendientes, vamos al cine. Nuestras acciones dependen de estas evaluaciones y decisiones. El control de flujo es, en esencia, la manera en que decidimos qué parte del código se ejecuta, cuándo se ejecuta y cuántas veces lo hace. Para ello, contamos con una variedad de estructuras que nos permiten tomar decisiones, repetir acciones y dividir nuestro código en bloques lógicos.","tags":["intro","programming","control-flujo","condicionales","if","bucles","for","while"],"title":"Control de Flujo","url":"/es/programming/0200-starting-concepts/0203-flow-control-structures/","year":"2023"},{"content":"","date":1695772800,"headings":[],"kind":"term","lang":"es","summary":"","title":"control-flujo","url":"/es/tags/control-flujo/","year":"2023"},{"content":"","date":1695772800,"headings":[],"kind":"term","lang":"es","summary":"","title":"for","url":"/es/tags/for/","year":"2023"},{"content":"","date":1695772800,"headings":[],"kind":"term","lang":"es","summary":"","title":"if","url":"/es/tags/if/","year":"2023"},{"content":"","date":1695772800,"headings":[],"kind":"term","lang":"es","summary":"","title":"while","url":"/es/tags/while/","year":"2023"},{"authors":["Julián Nonino"],"content":"Salida a pantalla Python también provee funciones para enviar la salida de un programa a la \u0026ldquo;salida estándar\u0026rdquo;, generalmente la pantalla o terminal1.\nLa función print() muestra el valor pasado como parámetro:\n1nombre = \u0026#34;Eric\u0026#34; 2print(nombre) # muestra \u0026#34;Eric\u0026#34; Podemos imprimir múltiples valores separados por comas2:\n1print(\u0026#34;Hola\u0026#34;, nombre, \u0026#34;!\u0026#34;) # muestra \u0026#34;Hola Eric!\u0026#34; También podemos usar valores literales sin asignar a variables3:\n1print(\u0026#34;2 + 3 =\u0026#34;, 2 + 3) # muestra \u0026#34;2 + 3 = 5\u0026#34; Formateo de salida Python provee varias formas de dar formato a la salida4:\nf-Strings: Permiten insertar variables dentro de una cadena:\n1nombre = \u0026#34;Eric\u0026#34; 2print(f\u0026#34;Hola {nombre}\u0026#34;) # muestra \u0026#34;Hola Eric\u0026#34; %s: Inserta cadenas de texto en una cadena de formato:\n1nombre = \u0026#34;Eric\u0026#34; 2print(\u0026#34;Hola %s\u0026#34; % nombre) # muestra \u0026#34;Hola Eric\u0026#34; %d: Inserta números enteros:\n1valor = 15 2print(\u0026#34;El valor es %d\u0026#34; % valor) # muestra \u0026#34;El valor es 15\u0026#34; .format(): Inserta valores en una cadena de formato:\n1nombre = \u0026#34;Eric\u0026#34; 2print(\u0026#34;Hola {}. Bienvenido\u0026#34;.format(nombre)) 3# muestra \u0026#34;Hola Eric. Bienvenido\u0026#34; Estas opciones de formateo nos permiten interpolar variables y valores en cadenas de texto para generar outputs personalizados. Podemos combinar múltiples valores y formateos en una sola cadena de salida2.\nEntrada desde el teclado Python provee funciones incorporadas para leer datos ingresados por el usuario en tiempo de ejecución. Esto se conoce como \u0026ldquo;entrada estándar\u0026rdquo;4.\nLa función input() permite leer un valor ingresado por el usuario y asignarlo a una variable. Por ejemplo:\n1nombre = input(\u0026#34;Ingresa tu nombre: \u0026#34;) Esto muestra el mensaje \u0026ldquo;Ingresa tu nombre: \u0026quot; y espera a que el usuario escriba un texto y presione Enter. Ese valor se asigna a la variable nombre2.\nLa función input() siempre regresa una cadena de texto. Si queremos pedir un número u otro tipo de dato, debemos convertirlo usando int(), float(), etc1:\n1edad = int(input(\u0026#34;Ingresa tu edad: \u0026#34;)) 2pi = float(input(\u0026#34;Ingresa el valor de pi: \u0026#34;)) Leyendo múltiples valores Podemos pedir y leer varios valores en una misma línea separándolos con comas3:\n1nombre, edad = input(\u0026#34;Ingresa nombre y edad: \u0026#34;).split() El método split() divide la entrada en partes y retorna una lista de cadenas. Luego asignamos los elementos de la lista a variables separadas.\nTambién podemos leer varias líneas de entrada con un ciclo4:\n1nombres = [] # lista vacía 2 3for x in range(3): 4 nombre = input(\u0026#34;Ingresa un nombre: \u0026#34;) 5 nombres.append(nombre) Este código lee 3 nombres ingresados por el usuario y los agrega a una lista.\nSalida a un archivo Además de imprimir a pantalla, podemos escribir la salida a un archivo usando la función open()1:\n1archivo = open(\u0026#34;datos.txt\u0026#34;, \u0026#34;w\u0026#34;) Esto abre datos.txt para escritura (\u0026ldquo;w\u0026rdquo;) y retorna un objeto archivo.\nLuego usamos archivo.write() para escribir a ese archivo3:\n1archivo.write(\u0026#34;Hola mundo!\u0026#34;) 2archivo.write(\u0026#34;Este texto va al archivo\u0026#34;) Debemos cerrar el archivo con archivo.close() cuando terminamos4:\n1archivo.close() También podemos usar with para abrir y cerrar automáticamente2:\n1with open(\u0026#34;datos.txt\u0026#34;, \u0026#34;w\u0026#34;) as archivo: 2 archivo.write(\u0026#34;Hola mundo!\u0026#34;) 3 # no hace falta cerrar, es automático Lectura de archivos Para leer un archivo usamos open() con modo \u0026ldquo;r\u0026rdquo; y iteramos sobre el objeto archivo1:\n1with open(\u0026#34;datos.txt\u0026#34;, \u0026#34;r\u0026#34;) as archivo: 2 for linea in archivo: 3 print(linea) # muestra cada línea del archivo Esto imprime cada línea, incluyendo los saltos de línea.\nPodemos leer todas las líneas a una lista con readlines()3:\n1linenas = archivo.readlines() 2print(linenas) Para leer el contenido completo a una cadena usamos read()4:\n1texto = archivo.read() 2print(texto) También podemos leer un número determinado de bytes o caracteres con read(n)2.\nOperaciones para el manejo de archivos Existen varias funciones incorporadas para manipular archivos en Python1:\nopen() - Abre un archivo y retorna un objeto archivo close() - Cierra el archivo write() - Escribe datos al archivo read() - Lee datos del archivo readline() - Lee una línea del archivo truncate() - Vacía el archivo seek() - Mueve la posición de lectura/escritura rename() - Renombra el archivo remove() - Elimina el archivo Estas funciones nos permiten efectuar operaciones avanzadas para leer, escribir y mantener archivos.\nConclusión En este artículo explicamos en detalle operaciones de entrada y salida en Python, incluyendo leer de entrada estándar y escribir a salida estándar o archivos. Manejar correctamente la entrada y salida es esencial para muchas aplicaciones de Python. Recomiendo practicar con ejemplos propios para dominar estas funciones3.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias McKinney, W. (2018). Python for data analysis: Data wrangling with Pandas, NumPy, and IPython. O\u0026rsquo;Reilly Media.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLutz, M. (2013). Learning Python: Powerful Object-Oriented Programming. O\u0026rsquo;Reilly Media, Incorporated.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMatthes, E. (2015). Python crash course: A hands-on, project-based introduction to programming. No Starch Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDowney, A. B. (2015). Think Python: How to think like a computer scientist. Needham, Massachusetts: Green Tea Press.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1695081600,"headings":[{"anchor":"conclusión","title":"Conclusión"},{"anchor":"entrada-desde-el-teclado","title":"Entrada desde el teclado"},{"anchor":"formateo-de-salida","title":"Formateo de salida"},{"anchor":"lectura-de-archivos","title":"Lectura de archivos"},{"anchor":"leyendo-múltiples-valores","title":"Leyendo múltiples valores"},{"anchor":"operaciones-para-el-manejo-de-archivos","title":"Operaciones para el manejo de archivos"},{"anchor":"referencias","title":"Referencias"},{"anchor":"salida-a-pantalla","title":"Salida a pantalla"},{"anchor":"salida-a-un-archivo","title":"Salida a un archivo"}],"kind":"page","lang":"es","series":["Programming"],"summary":"Las operaciones de entrada y salida (input/output o I/O) permiten que un programa se comunique e intercambie datos con el mundo exterior. En este artículo veremos en detalle operaciones de entrada desde el teclado o un archivo, y salida hacia la pantalla o un archivo.","tags":["intro","programming","input/output","I/O"],"title":"Operaciones de Entrada y Salida","url":"/es/programming/0200-starting-concepts/0202-io-operations/","year":"2023"},{"content":"","date":1694995200,"headings":[],"kind":"term","lang":"es","summary":"","title":"data-types","url":"/es/tags/data-types/","year":"2023"},{"content":"","date":1694995200,"headings":[],"kind":"term","lang":"es","summary":"","title":"variables","url":"/es/tags/variables/","year":"2023"},{"authors":["Julián Nonino"],"content":"Variables Una variable es un contenedor para almacenar datos en la memoria de la computadora. Podemos pensar en ella como una caja con una etiqueta. La etiqueta es el nombre de la variable y dentro de la caja se almacena su valor.\nPara declarar una variable en Python solo escribimos el nombre y le asignamos un valor:\n1edad = 28 2precio = 19.95 3soltero = True Los nombres de variables deben comenzar con letras o guión bajo, y sólo pueden contener letras, números y guiones bajos. Se recomienda usar nombres significativos que representen el propósito de la variable.\nEn Python las variables no necesitan ser declaradas con un tipo particular. El tipo se infiere automáticamente al asignar el valor:\n1edad = 28 # edad es de tipo entero (int) 2precio = 19.95 # precio es de tipo float 3estudiante = True # soltero es de tipo booleano Una vez asignada, una variable puede cambiar su valor en cualquier momento:\n1edad = 30 # Cambiamos edad a 30 Alcance y tiempo de vida El alcance de una variable se refiere a las partes del código donde está disponible. Las variables declaradas fuera de funciones son globales y están disponibles en todo el archivo. Las variables dentro de una función son locales y solo visibles dentro de ella.\nEl tiempo de vida es el período durante el cual existe la variable en memoria. Las variables locales existen mientras se ejecuta la función, luego son destruidas. Las globales existen mientras el programa está en ejecución.\nAsignación La asignación con el operador = permite cambiar o inicializar el valor de una variable:\n1numero = 10 2numero = 20 # Ahora numero vale 20 También existen los operadores de asignación compuesta como += y -= que combinan una operación y asignación:\n1numero += 5 # Suma 5 a numero (numero = numero + 5) 2numero -= 2 # Resta 2 a numero Tipos de datos Los tipos de datos definen el tipo de valor que puede almacenar una variable. Python tiene varios tipos incorporados, incluyendo:\nNuméricos: Para almacenar valores numéricos como enteros, flotantes, complejos:\n1entero = 10 2flotante = 10.5 3complejo = 3 + 4j Cadenas: Para almacenar texto:\n1texto = \u0026#34;Hola Mundo\u0026#34; Booleano: Para valores lógicos Verdadero o Falso:\n1variable_verdadera = True 2variable_falsa = False Colecciones: Para almacenar múltiples valores como listas, tuplas y diccionarios:\nListas: Secuencias mutables de valores:\n1lista = [1, 2, 3] Tuplas: Secuencias inmutables de valores:\n1tupla = (1, 2, 3) Diccionarios: Estructuras de pares llave-valor:\n1diccionario = {\u0026#34;nombre\u0026#34;:\u0026#34;Juan\u0026#34;, \u0026#34;edad\u0026#34;: 20} Es importante elegir el tipo de dato que mejor represente la información que queremos almacenar.\nOperadores Los operadores nos permiten realizar operaciones con valores y variables en Python. Algunos operadores comunes son:\nAritméticos: +, -, *, /, %, //, **\nComparación: ==, !=, \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;=\nLógicos: and, or, not\nAsignación: =, +=, -=, *=, /=\nVeamos ejemplos concretos de expresiones usando estos operadores en Python:\n1# Aritméticos 25 + 4 # Suma, resultado 9 310 - 3 # Resta, resultado 7 44 * 5 # Multiplicación, resultado 20 5 6# Comparación 75 \u0026gt; 4 # Mayor que, resultado Verdadero 87 \u0026lt; 10 # Menor que, resultado Verdadero 9 10# Lógicos 11True and False # Resultado False 12True or False # Resultado True 13not True # Resultado False 14 15# Asignación 16numero = 10 17numero += 5 # Suma 5 a numero, equivalente a numero = numero + 5 Cada tipo de operador trabaja con tipos de datos específicos. Debemos usarlos de forma consistente según el tipo de datos de nuestras variables.\nConversiones de tipo A veces necesitamos convertir un tipo de dato a otro para realizar ciertas operaciones. En Python podemos convertir de forma explícita o implícita:\nExplícita: Usando funciones como int(), float(), str():\n1flotante = 13.5 2entero = int(flotante) # convierte 13.5 a 13 3 4texto = \u0026#34;100\u0026#34; 5numero = int(texto) # convierte \u0026#34;100\u0026#34; a 100 Implícita: Python convierte automáticamente en algunos casos:\n1entero = 100 2flotante = 3.5 3resultado = entero + flotante # resultado es 103.5, entero se convirtió a float Algunas conversiones pueden generar pérdida de datos o errores:\n1flotante = 13.5 2entero = int(flotante) 3 4print(entero) # 13, se pierden los decimales Para prevenir esto debemos elegir explícitamente conversiones que tengan sentido para nuestros datos.\nConclusión En este artículo revisamos conceptos clave como variables, operadores, tipos de datos y conversiones en Python. Aplicar bien estos conceptos te permitirá manipular datos de forma eficiente en tus programas. Recomiendo practicar con ejemplos propios para ganar experiencia en usar estas características. ¡Éxitos en tu aprendizaje de Python!\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\n","date":1694995200,"headings":[{"anchor":"alcance-y-tiempo-de-vida","title":"Alcance y tiempo de vida"},{"anchor":"asignación","title":"Asignación"},{"anchor":"conclusión","title":"Conclusión"},{"anchor":"conversiones-de-tipo","title":"Conversiones de tipo"},{"anchor":"operadores","title":"Operadores"},{"anchor":"tipos-de-datos","title":"Tipos de datos"},{"anchor":"variables","title":"Variables"}],"kind":"page","lang":"es","series":["Programming"],"summary":"Entender cómo funcionan las variables y los tipos de datos es fundamental para dominar cualquier lenguaje de programación. En este artículo repasaremos los conceptos básicos sobre variables, operadores, tipos de datos y conversiones de tipo utilizando el lenguaje Python. Cubriremos tanto la teoría como ejemplos prácticos para que puedas aplicar estos conceptos en tus propios programas.","tags":["intro","programming","variables","data-types"],"title":"Variables y Tipos de Datos","url":"/es/programming/0200-starting-concepts/0201-variables-data-types/","year":"2023"},{"authors":["Julián Nonino"],"content":" Elegir un lenguaje de programación La elección del lenguaje de programación es el primer y quizás el más crucial paso en el proceso de aprendizaje. Hay varios factores a considerar al seleccionar un lenguaje, incluyendo:\nPropósito: ¿Para qué quieres programar? Si es para desarrollo web, JavaScript o PHP podrían ser buenas opciones. Si estás interesado en la ciencia de datos, R o Python podrían ser más adecuados. Comunidad: Un lenguaje con una comunidad activa puede ser esencial para los principiantes. Una comunidad vibrante generalmente significa más recursos, tutoriales y soluciones disponibles en línea. Curva de aprendizaje: Algunos lenguajes son más fáciles de aprender que otros. Es fundamental elegir uno que coincida con tu nivel de experiencia y paciencia. Oportunidades de trabajo: Si estás buscando una carrera en programación, investigar la demanda del mercado para diferentes lenguajes puede ser útil. Aunque hay muchos lenguajes valiosos y poderosos, para este curso, hemos elegido Python. Este lenguaje es conocido por su simplicidad y legibilidad, lo que lo hace ideal para aquellos que están empezando. Además, Python cuenta con una comunidad activa y una amplia gama de aplicaciones, desde desarrollo web hasta inteligencia artificial1.\nInstalación de Python Para usuarios de Windows: Descargar el instalador: Visita el sitio web oficial de Python en https://www.python.org/downloads/windows/ Haz clic en el enlace de descarga para la última versión de Python 3.x. Ejecuta el instalador: Una vez completada la descarga, localiza y ejecuta el archivo instalador .exe. Asegúrate de marcar la casilla que dice \u0026ldquo;Agregar Python al PATH\u0026rdquo; durante la instalación. Este paso es crucial para hacer que Python sea accesible desde el Símbolo del Sistema. Sigue las indicaciones de instalación. Verifica la instalación: Abre el Símbolo del Sistema y escribe: 1python --version Esto debería mostrar la versión de Python que acabas de instalar. Para usuarios de Mac: Descargar el instalador: Visita el sitio web oficial de Python en https://www.python.org/downloads/mac-osx/ Haz clic en el enlace de descarga para la última versión de Python 3.x. Ejecuta el instalador: Una vez descargado, localiza y ejecuta el archivo .pkg. Sigue las indicaciones de instalación. Verifica la instalación: Abre la Terminal y escribe: 1python3 --version Esto debería mostrar la versión de Python que acabas de instalar. Para usuarios de Linux (Ubuntu/Debian): Actualiza los paquetes: 1sudo apt update Instala Python: 1sudo apt install python3 Verifica la instalación: Después de la instalación, puedes comprobar la versión de Python instalada escribiendo: 1python3 --version Entornos de Desarrollo Integrado (IDEs) Un IDE es una herramienta que facilita el desarrollo de aplicaciones al combinar comúnmente utilizadas en un solo software: editor de código, compilador, depurador, entre otros. Elegir el IDE adecuado puede hacer que el proceso de programación sea más fluido y eficiente.\nAl evaluar IDEs, considera:\nCompatibilidad con el lenguaje: No todos los IDEs son compatibles con todos los lenguajes de programación. Características: Algunos IDEs ofrecen funcionalidades como autocompletado, resaltado de sintaxis y herramientas de depuración. Extensiones y plugins: La posibilidad de personalizar y extender tu IDE a través de plugins puede ser muy útil. Precio: Hay IDEs gratuitos y otros de pago. Evalúa si las características adicionales de un IDE de pago justifican el costo. Para este curso, hemos seleccionado Visual Studio Code (VS Code). Es un IDE popular que es gratuito y de código abierto. Es conocido por su interfaz sencilla, amplia gama de plugins y capacidad para manejar múltiples lenguajes de programación2. Su comunidad activa garantiza actualizaciones regulares y una amplia gama de recursos de aprendizaje.\nInstalación de Visual Studio Code Para usuarios de Windows: Descargar el instalador: Visita el sitio web oficial de VS Code en https://code.visualstudio.com/ Haz clic en el botón \u0026ldquo;Descargar para Windows\u0026rdquo;. Ejecuta el instalador: Una vez completada la descarga, localiza y ejecuta el archivo instalador .exe. Sigue las indicaciones de instalación, incluyendo aceptar el acuerdo de licencia y elegir la ubicación de instalación. Inicia VS Code: Tras la instalación, puedes encontrar VS Code en tu menú de inicio. Lánzalo, ¡y estarás listo para comenzar a programar! Para usuarios de Mac: Descargar el instalador: Visita el sitio web oficial de VS Code en https://code.visualstudio.com/ Haz clic en el botón \u0026ldquo;Descargar para Mac\u0026rdquo;. Instala VS Code: Una vez descargado, abre el archivo .zip. Arrastra la aplicación Visual Studio Code .app a la carpeta Aplicaciones, para que esté disponible en el Launchpad. Inicia VS Code: Usa la búsqueda de Spotlight o navega hasta tu carpeta de Aplicaciones para iniciar VS Code. Para usuarios de Linux (Ubuntu/Debian): Actualiza los paquetes e instala las dependencias: 1sudo apt update 2sudo apt install software-properties-common apt-transport-https wget **Descarga e instala la claves necesarias: 1wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Añade el repositorio de VS Code: 1sudo add-apt-repository \u0026#34;deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main\u0026#34; Instala Visual Studio Code: 1sudo apt update 2sudo apt install code Inicia VS Code: Puedes iniciar VS Code desde la terminal escribiendo code o encontrarlo en tu lista de aplicaciones instaladas. Escribe y ejecuta tu primer programa Una vez que hayas configurado tu entorno de programación, es hora de sumergirse en la codificación.\n¡Hola mundo! Este es posiblemente el programa más icónico para principiantes. Es simple, pero te introduce al proceso de escribir y ejecutar código.\n1print(\u0026#34;¡Hola mundo!\u0026#34;) Ejecución del programa Hola Mundo\nCálculo de área y perímetro de un triángulo Este programa es un poco más complejo. No solo imprime un mensaje, sino que también realiza cálculos matemáticos.\n1# Entrada del usuario 2lado1 = float(input(\u0026#34;Introduce la longitud del primer lado: \u0026#34;)) 3lado2 = float(input(\u0026#34;Introduce la longitud del segundo lado: \u0026#34;)) 4lado3 = float(input(\u0026#34;Introduce la longitud del tercer lado: \u0026#34;)) 5 6# Cálculo del perímetro 7perimetro = lado1 + lado2 + lado3 8 9# Cálculo del área usando la fórmula de Herón 10s = perimetro / 2 11area = (s*(s-lado1)*(s-lado2)*(s-lado3)) ** 0.5 12 13print(f\u0026#34;El perímetro del triángulo es: {perimetro}\u0026#34;) 14print(f\u0026#34;El área del triángulo es: {area:.2f}\u0026#34;) Ejecución del programa Triangulo\nConclusión Configurar un entorno de programación puede parecer desalentador al principio, pero con las herramientas y recursos adecuados, se convierte en una tarea manejable y gratificante. Esperamos que este artículo te haya proporcionado una base sólida para comenzar tu viaje en programación. ¡Feliz codificación!\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias Lutz, M. (2013). Learning Python. O\u0026rsquo;Reilly Media.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMicrosoft. (2020). Visual Studio Code Documentation. Microsoft Docs.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1694304e3,"headings":[{"anchor":"conclusión","title":"Conclusión"},{"anchor":"cálculo-de-área-y-perímetro-de-un-triángulo","title":"Cálculo de área y perímetro de un triángulo"},{"anchor":"elegir-un-lenguaje-de-programación","title":"Elegir un lenguaje de programación"},{"anchor":"entornos-de-desarrollo-integrado-ides","title":"Entornos de Desarrollo Integrado (IDEs)"},{"anchor":"escribe-y-ejecuta-tu-primer-programa","title":"Escribe y ejecuta tu primer programa"},{"anchor":"hola-mundo","title":"¡Hola mundo!"},{"anchor":"instalación-de-python","title":"Instalación de Python"},{"anchor":"instalación-de-visual-studio-code","title":"Instalación de Visual Studio Code"},{"anchor":"para-usuarios-de-linux-ubuntudebian","title":"Para usuarios de Linux (Ubuntu/Debian):"},{"anchor":"para-usuarios-de-linux-ubuntudebian-1","title":"Para usuarios de Linux (Ubuntu/Debian):"},{"anchor":"para-usuarios-de-mac","title":"Para usuarios de Mac:"},{"anchor":"para-usuarios-de-mac-1","title":"Para usuarios de Mac:"},{"anchor":"para-usuarios-de-windows","title":"Para usuarios de Windows:"},{"anchor":"para-usuarios-de-windows-1","title":"Para usuarios de Windows:"},{"anchor":"referencias","title":"Referencias"}],"kind":"page","lang":"es","series":["Programming"],"summary":"Adentrarse en el mundo de la programación puede parecer una tarea titánica, especialmente cuando te encuentras frente a la decisión inicial: ¿por dónde empezar? Este artículo te guiará a través de los pasos esenciales para configurar tu entorno de programación, garantizando una base sólida para tu viaje codificador.","tags":["intro","programming","ide","python","install","tools"],"title":"Configura tu Entorno de Desarrollo","url":"/es/programming/0100-intro/0104-setup-dev-environment/","year":"2023"},{"content":"","date":1694304e3,"headings":[],"kind":"term","lang":"es","summary":"","title":"ide","url":"/es/tags/ide/","year":"2023"},{"content":"","date":1694304e3,"headings":[],"kind":"term","lang":"es","summary":"","title":"install","url":"/es/tags/install/","year":"2023"},{"content":"La programación, en su esencia, es el acto de instruir a una máquina sobre cómo realizar una tarea específica. Es como si le estuvieras enseñando a tu perro a buscar la pelota, pero en este caso, el perro es tu computadora y la pelota es, por ejemplo, mostrar una foto en tu pantalla.\nAhora, es posible que pienses que programar es simplemente escribir líneas de código. En realidad, la programación es un proceso más amplio que incluye no solo escribir código, sino también resolver problemas, diseñar sistemas y pensar lógicamente.\nEn el universo de la programación, hay lenguajes de alto nivel y lenguajes de bajo nivel. Un lenguaje de bajo nivel, como el ensamblador, está más cerca de lo que la máquina entiende, mientras que un lenguaje de alto nivel, como Python o JavaScript, es más amigable para nosotros, los humanos. Imagina tener una conversación: los lenguajes de alto nivel son como charlar con un amigo en un café, mientras que los lenguajes de bajo nivel son como intentar comunicarte con alguien que habla un dialecto muy particular y localizado.\nAdemás, algunos lenguajes de programación son compilados y otros son interpretados. Si un lenguaje es compilado, significa que se traduce a un lenguaje que la máquina entiende antes de ser ejecutado. Por otro lado, los lenguajes interpretados son traducidos en tiempo real, mientras se ejecutan.\nBreve historia de la programación La programación no es un concepto nuevo. De hecho, ha estado con nosotros desde mucho antes de que las computadoras existieran en la forma que las conocemos hoy. Dispositivos como el ábaco y el astrolabio son ejemplos tempranos de herramientas que usamos para realizar cálculos complejos.\nPero fue con la llegada de las máquinas mecánicas, como la Máquina Analítica de Charles Babbage, que se sentaron las bases para la programación moderna. ¡Estamos hablando del siglo XIX!\nCon el paso del tiempo, nacieron lenguajes que marcaron hitos, como Fortran y COBOL. Estos lenguajes sentaron las bases para las revoluciones tecnológicas que vendrían. Con la evolución de los lenguajes, también surgieron nuevos paradigmas: primero el Procedural, luego el Orientado a Objetos y más recientemente, el Funcional.\nHoy, estamos en una era moderna, dominada por la programación para la web, móviles y la nube. Cada vez que deslizas tu dedo por la pantalla de tu celular o compras algo online, hay líneas y líneas de código trabajando detrás de escena.\nLa programación hoy La programación es el motor de nuestra sociedad moderna. Desde aplicaciones para pedir comida hasta sistemas avanzados de inteligencia artificial que ayudan en investigaciones médicas, la programación está en todas partes.\nAdemás de simplificar nuestras vidas cotidianas, la programación tiene un impacto profundo en la sociedad. Ha permitido avances en la automatización, el análisis de datos y el entretenimiento. Y lo que es aún más emocionante, es que apenas estamos rasguñando la superficie. Con los avances en inteligencia artificial, computación cuántica y el Internet de las Cosas (IoT), ¿quién sabe qué maravillas nos esperan en mundo de la programación?\n","date":1694304e3,"headings":[{"anchor":"breve-historia-de-la-programación","title":"Breve historia de la programación"},{"anchor":"la-programación-hoy","title":"La programación hoy"}],"kind":"section","lang":"es","summary":"La programación, en su esencia, es el acto de instruir a una máquina sobre cómo realizar una tarea específica. Es como si le estuvieras enseñando a tu perro a buscar la pelota, pero en este caso, el perro es tu computadora y la pelota es, por ejemplo, mostrar una foto en tu pantalla.\nAhora, es posible que pienses que programar es simplemente escribir líneas de código. En realidad, la programación es un proceso más amplio que incluye no solo escribir código, sino también resolver problemas, diseñar sistemas y pensar lógicamente.","title":"Introducción a la Programación","url":"/es/programming/0100-intro/","year":"2023"},{"content":"","date":1694304e3,"headings":[],"kind":"term","lang":"es","summary":"","title":"python","url":"/es/tags/python/","year":"2023"},{"content":"","date":1694304e3,"headings":[],"kind":"term","lang":"es","summary":"","title":"tools","url":"/es/tags/tools/","year":"2023"},{"content":"","date":1694217600,"headings":[],"kind":"term","lang":"es","summary":"","title":"boolean-logic","url":"/es/tags/boolean-logic/","year":"2023"},{"authors":["Julián Nonino"],"content":"La lógica booleana, nombrada en honor a George Boole, un matemático inglés del siglo XIX, es un sistema matemático que se ocupa de operaciones que tienen solo dos resultados posibles: verdadero o falso, representados generalmente como 1 y 0, respectivamente1. En su obra \u0026ldquo;An Investigation of the Laws of Thought\u0026rdquo;, Boole estableció las bases de esta lógica, presentando un sistema algebraico que podría utilizarse para representar estructuras lógicas.\nOperaciones Booleanas Dentro de la lógica booleana, existen operaciones fundamentales que permiten manipular y combinar estas expresiones binarias:\nAND (Y): Esta operación devuelve verdadero (1) solo si ambas entradas son verdaderas. Por ejemplo, si tenemos dos interruptores, ambos deben estar en la posición encendido para que una luz se encienda.\nOR (O): Devuelve verdadero si al menos una de las entradas es verdadera. Siguiendo con el ejemplo de los interruptores, con que uno de ellos esté encendido, la luz se iluminará.\nNOT (NO): Es una operación unaria, lo que significa que solo tiene una entrada. Simplemente invierte el valor de entrada. Si le das un 1, devuelve un 0 y viceversa.\nNAND (NO Y): Es la negación de AND. Solo devuelve falso si ambas entradas son verdaderas.\nNOR (NO O): Es la negación de OR. Devuelve verdadero solo si ambas entradas son falsas.\nXOR (O exclusivo): Devuelve verdadero si las entradas son diferentes. Si ambas son iguales, devuelve falso.\nXNOR (NO O exclusivo): Es la negación de XOR. Devuelve verdadero si ambas entradas son iguales.\nLa importancia de esta lógica en computación y programación La computación moderna, en su esencia, es la manipulación de bits, esos unos y ceros que mencionamos. Cada operación que realiza una computadora, desde simples cálculos hasta la renderización de gráficos complejos, implica operaciones booleanas en algún nivel2.\nEn programación, la lógica booleana se utiliza en estructuras de control, como condiciones (if, else) y bucles, permitiendo a los programas tomar decisiones basadas en ciertas condiciones.\nTablas de verdad: el mapa de la lógica Booleana Una tabla de verdad es una representación gráfica de una operación booleana. Enumera todas las combinaciones posibles de entradas y muestra el resultado de la operación para cada combinación3.\nPor ejemplo,\nA B A AND B A OR B A XOR B A NOR B A NAND B NOT A A NXOR B 1 1 1 1 0 0 0 0 1 1 0 0 1 1 0 1 0 0 0 1 0 1 1 0 1 1 0 0 0 0 0 0 1 1 1 1 Conclusiones La lógica booleana es mucho más que un conjunto de reglas matemáticas abstractas. Es el lenguaje fundamental de las máquinas, el código que subyace a la era digital en la que vivimos. Al comprender sus principios, no solo nos volvemos más adeptos a trabajar con tecnología, sino que también adquirimos una apreciación más profunda de las estructuras que sustentan nuestro mundo digital.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias Boole, G. (1854). An Investigation of the Laws of Thought. Londres: Walton and Maberly.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A. (2012). Estructura de Computadoras. Buenos Aires: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMinsky, M. (1967). Computation: Finite and Infinite Machines. Buenos Aires: Prentice-Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1694217600,"headings":[{"anchor":"conclusiones","title":"Conclusiones"},{"anchor":"la-importancia-de-esta-lógica-en-computación-y-programación","title":"La importancia de esta lógica en computación y programación"},{"anchor":"operaciones-booleanas","title":"Operaciones Booleanas"},{"anchor":"referencias","title":"Referencias"},{"anchor":"tablas-de-verdad-el-mapa-de-la-lógica-booleana","title":"Tablas de verdad: el mapa de la lógica Booleana"}],"kind":"page","lang":"es","series":["Programming"],"summary":"En la vida, a menudo buscamos certezas. ¿Es cierto o falso que va a llover mañana? ¿Es correcto o incorrecto actuar de cierta manera? Esta dicotomía, esta división entre dos estados opuestos, se encuentra en el núcleo mismo de una rama esencial de las matemáticas y la informática: la lógica booleana.","tags":["intro","programming","boolean-logic"],"title":"Lógica Booleana","url":"/es/programming/0100-intro/0103-boolean-logic/","year":"2023"},{"content":"Últimos artículos Programación 30 sept. 2023 Funciones Recursivas La recursión es un concepto fundamental en programación que permite que una función se llame a sí misma. A primera vista... Leer más Programación 29 sept. 2023 Funciones En el vasto y emocionante mundo de la programación, existen conceptos que son pilares fundamentales para cualquier... Leer más Programación 27 sept. 2023 Control de Flujo Cuando nos embarcamos en la emocionante travesía de aprender a programar, no tardamos en descubrir que la programación... Leer más Programación 19 sept. 2023 Operaciones de Entrada y Salida Las operaciones de entrada y salida (input/output o I/O) permiten que un programa se comunique e intercambie datos con... Leer más Programación 18 sept. 2023 Variables y Tipos de Datos Entender cómo funcionan las variables y los tipos de datos es fundamental para dominar cualquier lenguaje de... Leer más Programación 10 sept. 2023 Configura tu Entorno de Desarrollo Adentrarse en el mundo de la programación puede parecer una tarea titánica, especialmente cuando te encuentras frente a... Leer más Programación 9 sept. 2023 Lógica Booleana En la vida, a menudo buscamos certezas. ¿Es cierto o falso que va a llover mañana? ¿Es correcto o incorrecto actuar de... Leer más Programación 5 sept. 2023 Sistemas de Numeración En nuestro día a día, estamos rodeados de números. Desde la hora que marca el reloj cuando suena la alarma por la... Leer más Programación 2 sept. 2023 La Computadora En el mundo actual, donde las tecnologías digitales se han convertido en una extensión de nuestras vidas diarias,... Leer más ","date":1693958400,"headings":[{"anchor":"últimos-artículos","title":"Últimos artículos"}],"kind":"home","lang":"es","summary":"Últimos artículos Programación 30 sept. 2023 Funciones Recursivas La recursión es un concepto fundamental en programación que permite que una función se llame a sí misma. A primera vista... Leer más Programación 29 sept. 2023 Funciones En el vasto y emocionante mundo de la programación, existen conceptos que son pilares fundamentales para cualquier... Leer más Programación 27 sept. 2023 Control de Flujo Cuando nos embarcamos en la emocionante travesía de aprender a programar, no tardamos en descubrir que la programación.","title":"Learn-Software.com","url":"/es/","year":"2023"},{"content":"","date":1693872e3,"headings":[],"kind":"term","lang":"es","summary":"","title":"binario","url":"/es/tags/binario/","year":"2023"},{"content":"","date":1693872e3,"headings":[],"kind":"term","lang":"es","summary":"","title":"decimal","url":"/es/tags/decimal/","year":"2023"},{"content":"","date":1693872e3,"headings":[],"kind":"term","lang":"es","summary":"","title":"hexadecimal","url":"/es/tags/hexadecimal/","year":"2023"},{"authors":["Julián Nonino"],"content":"El sistema decimal: la base de nuestra cotidianidad Desde pequeños, nos enseñan a contar usando diez dígitos: del 0 al 9. Este sistema, conocido como decimal, es la base de casi todas nuestras actividades matemáticas y financieras, desde sumar cuentas hasta calcular intereses en el banco1. Tiene su origen en la cantidad de dedos que tenemos en las manos, lo que lo convierte en el sistema más intuitivo y natural para nosotros. Pero lo que lo hace especial es su naturaleza posicional.\nPara comprender este concepto, consideremos el número 237:\nEl 7, situado a la derecha, está en la posición de las unidades. Es decir, \\(7 \\times 10^0\\) (cualquier número elevado a la potencia de 0 es 1). Por lo tanto, su valor es simplemente 7. El 3, en la posición del medio, representa las decenas, es decir, \\(3 \\times 10^1 = 3 \\times 10 = 30\\) . El 2, el número más a la izquierda, está en la posición de las centenas, traduciéndose a \\(2 \\times 10^2 = 2 \\times 100 = 200\\) . Si sumamos estos valores,\n$$2 \\times 10^2 \u0026#43; 3 \\times 10^1 \u0026#43; 7 \\times 10^0 = 200 \u0026#43; 30 \u0026#43; 7 = 237$$ El sistema binario: el lenguaje secreto de las computadoras Si bien el sistema decimal domina nuestra vida cotidiana, las máquinas que usamos todos los días, desde nuestros celulares hasta las computadoras, operan en un mundo completamente diferente: el mundo binario. En este sistema, solo existen dos dígitos: 0 y 1. A primera vista, puede parecer limitante, pero este sistema es la esencia de la electrónica digital. Los dispositivos electrónicos, con sus millones de transistores, operan usando estos dos estados: encendido (1) y apagado (0)2.\nA pesar de su aparente simplicidad, el sistema binario puede representar cualquier cantidad o información que el sistema decimal pueda expresar. Por ejemplo, el número decimal 5 se representa como 101 en binario.\nEl sistema binario, con sus unos y ceros, opera de manera similar al sistema decimal, pero en lugar de potencias de 10, usa potencias de 2.\nTomemos el número binario 1011:\nEl bit más a la derecha representa \\(1 \\times 2^0 = 1\\) El siguiente bit representa \\(1 \\times 2^1 = 2\\) Luego viene \\(0 \\times 2^2 = 0\\) El bit más a la izquierda en este número representa \\(1 \\times 2^3 = 8\\) Entonces, 1011 en binario se traduce a decimal de la siguiente manera:\n$$1011 = 1 \\times 2^3 \u0026#43; 0 \\times 2^2 \u0026#43; 1 \\times 2^1 \u0026#43; 1 \\times 2^0 = 8 \u0026#43; 0 \u0026#43; 2 \u0026#43; 1 = 11$$ El sistema hexadecimal: un puente entre humanos y máquinas Mientras que el sistema binario es perfecto para las máquinas, puede ser un poco engorroso para nosotros, especialmente cuando tratamos con números binarios largos. Aquí es donde entra el sistema hexadecimal, que utiliza dieciséis dígitos distintos: 0-9 y A-F, donde A representa 10, B es 11, y así sucesivamente hasta F que es 153.\nEl hexadecimal es especialmente útil porque proporciona una forma más compacta de representar números binarios. Cada dígito hexadecimal corresponde a exactamente cuatro dígitos binarios (bits). Por ejemplo pensemos en la representación en binario del número 41279 y como el sistema hexadecimal consigue una representación más compacta:\n$$41279 = 1010 0001 0011 1111 = A13F$$ Pero el sistema hexadecimal es más que una representación compacta de números binarios, es un sistema de numeración posicional como el decimal o binario con base 16 en lugar de 10 o 2. Veamos como conseguir la representación decimal del número del ejemplo anterior (A13F).\nEl dígito más a la derecha representa \\(F \\times 16^0 = 15 \\times 16^0 = 15\\) El siguiente representa \\(3 \\times 16^1 = 48\\) Luego viene \\(1 \\times 16^2 = 256\\) El dígito más a la izquierda en este número representa \\(A \\times 16^3 = 10 \\times 16^3 = 40960\\) Entonces, A13F en hexadecimal se traduce a decimal de la siguiente manera:\n$$A13F = A \\times 16^3 \u0026#43; 1 \\times 16^2 \u0026#43; 3 \\times 16^1 \u0026#43; F \\times 16^0 = 10 \\times 4096 \u0026#43; 1 \\times 256 \u0026#43; 3 \\times 16 \u0026#43; 15 \\times 1 = 40960 \u0026#43; 256 \u0026#43; 48 \u0026#43; 15 = 41279$$ Conclusión Los sistemas de numeración son como lentes a través de los cuales vemos y entendemos el mundo de las matemáticas y la computación. Aunque en nuestra vida diaria el sistema decimal sea el rey, es esencial apreciar y comprender los sistemas binario y hexadecimal, especialmente en esta era digital.\nAsí que, la próxima vez que estés frente a tu computadora o usando una app en tu celular, recordá que detrás de esa interfaz amigable, hay un mundo binario en pleno funcionamiento, y que el sistema hexadecimal actúa como un traductor entre ese mundo y nosotros.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias Ifrah, G. (2000). Historia universal de las cifras. Buenos Aires: Editorial Taurus.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A. (2012). Estructura de Computadoras. Buenos Aires: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nKnuth, D. (2007). El Arte de Programar Computadoras: Sistemas de numeración. Buenos Aires: Ediciones Omega.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1693872e3,"headings":[{"anchor":"conclusión","title":"Conclusión"},{"anchor":"el-sistema-binario-el-lenguaje-secreto-de-las-computadoras","title":"El sistema binario: el lenguaje secreto de las computadoras"},{"anchor":"el-sistema-decimal-la-base-de-nuestra-cotidianidad","title":"El sistema decimal: la base de nuestra cotidianidad"},{"anchor":"el-sistema-hexadecimal-un-puente-entre-humanos-y-máquinas","title":"El sistema hexadecimal: un puente entre humanos y máquinas"},{"anchor":"referencias","title":"Referencias"}],"kind":"page","lang":"es","series":["Programming"],"summary":"En nuestro día a día, estamos rodeados de números. Desde la hora que marca el reloj cuando suena la alarma por la mañana, hasta el precio del café que compramos en la esquina. Pero, ¿alguna vez te detuviste a pensar en la naturaleza de esos números? En este artículo, nos sumergiremos en el fascinante mundo de los sistemas de numeración y aprenderemos cómo, dependiendo del contexto, un número puede tener múltiples representaciones.","tags":["intro","programming","sistemas-numeracion","decimal","binario","hexadecimal"],"title":"Sistemas de Numeración","url":"/es/programming/0100-intro/0102-numerical-systems/","year":"2023"},{"content":"","date":1693872e3,"headings":[],"kind":"term","lang":"es","summary":"","title":"sistemas-numeracion","url":"/es/tags/sistemas-numeracion/","year":"2023"},{"content":"","date":1693612800,"headings":[],"kind":"term","lang":"es","summary":"","title":"computer","url":"/es/tags/computer/","year":"2023"},{"content":"","date":1693612800,"headings":[],"kind":"term","lang":"es","summary":"","title":"cpu","url":"/es/tags/cpu/","year":"2023"},{"content":"","date":1693612800,"headings":[],"kind":"term","lang":"es","summary":"","title":"hardware","url":"/es/tags/hardware/","year":"2023"},{"authors":["Julián Nonino"],"content":"Si alguna vez te has preguntado qué es lo que hace \u0026ldquo;tictac\u0026rdquo; dentro de esa caja metálica que llamamos computadora, estás en el lugar indicado. En esencia, una computadora es una combinación de hardware y software que trabajan juntos para llevar a cabo tareas específicas.\nEl hardware es toda la parte física de la computadora: el CPU (que es como el cerebro de la máquina), la RAM (donde la computadora guarda la información con la que está trabajando en un momento determinado), dispositivos de almacenamiento (donde se guardan los datos de forma permanente) y periféricos (como el teclado, el mouse o la pantalla)1.\nPor otro lado, el software es el conjunto de instrucciones que le dice al hardware qué hacer. Hay varios tipos de software, desde el software del sistema, como el sistema operativo que coordina todas las acciones de la máquina, hasta software de aplicación que nos permite hacer cosas como escribir documentos o jugar videojuegos2.\nEl papel del sistema operativo es crucial. Es el mediador entre el usuario y el hardware, asegurando que todo funcione armónicamente. Si el hardware fuera una orquesta, el sistema operativo sería el director que asegura que cada instrumento toque en el momento y de la manera correcta.\nEl sistema binario: el lenguaje secreto de las computadoras A diferencia de nosotros, que usamos un sistema decimal basado en diez dígitos (del 0 al 9), las computadoras usan el sistema binario, que solo tiene dos dígitos: 0 y 1. ¿Por qué? Bueno, en el nivel más básico, una computadora está hecha de millones de transistores que pueden estar en uno de dos estados: encendido o apagado. Estos estados se representan con esos dígitos: 0 para apagado y 1 para encendido3.\nLos términos \u0026ldquo;bit\u0026rdquo; y \u0026ldquo;byte\u0026rdquo; son fundamentales aquí. Un bit es la unidad más pequeña de datos en una computadora y puede tener un valor de 0 o 1. Un byte, por otro lado, es un conjunto de 8 bits y puede representar 256 valores diferentes (desde \\(00000000\\) hasta \\(11111111\\) en binario)4.\nEste sistema binario no solo representa números, sino también texto, imágenes y cualquier tipo de dato. Por ejemplo, en el código ASCII (un estándar de codificación de caracteres), la letra \u0026ldquo;A\u0026rdquo; se representa como \\(01000001\\) en binario.\nEn un artículo posterior, vamos a hablar en detalle acerca del sistema binario y otro sistema muy utilizado en el ambiente de la computación, el hexadecimal.\nMemoria y almacenamiento: donde residen nuestros datos La memoria y el almacenamiento son dos conceptos cruciales en la informática. Si bien a menudo se usan indistintamente, tienen roles muy diferentes.\nLa memoria, específicamente la RAM, es volátil. Esto significa que la información se pierde cuando apagamos la computadora. La RAM es esencialmente el \u0026ldquo;espacio de trabajo\u0026rdquo; de la computadora, donde almacena datos e instrucciones mientras está en uso. Hay varios tipos de RAM, siendo DRAM y SRAM los más comunes5.\nPor otro lado, tenemos la ROM (Memoria de Solo Lectura). A diferencia de la RAM, la ROM no es volátil y se utiliza para almacenar firmware, es decir, software que está íntimamente ligado al hardware y que no necesita cambios frecuentes.\nEn cuanto al almacenamiento, dispositivos como discos duros, SSDs y unidades flash nos permiten guardar información de manera permanente. Estos dispositivos forman parte de lo que se conoce como la jerarquía de memoria, que va desde la memoria caché (rápida pero pequeña) hasta el almacenamiento secundario (más lento pero con gran capacidad)6.\n¡Felicitaciones por llegar hasta acá! Espero que este recorrido por el universo de la programación te haya resultado tan interesante como lo fue para mí al escribirlo.\nQueremos conocer tu opinión, así que no dudes en compartir tus comentarios, sugerencias y esas ideas brillantes que seguro tenés.\nAdemás, para explorar más allá de estas líneas, date una vuelta por los ejemplos prácticos que armamos para vos. Todo el código y los proyectos los encontrás en nuestro repositorio de GitHub learn-software-engineering/examples-programming.\nGracias por ser parte de esta comunidad de aprendizaje. ¡Seguí programando y explorando nuevas areas en este fascinante mundo del software!\nReferencias Patterson, D. \u0026amp; Hennessy, J. (2014). Arquitectura de Computadoras. Buenos Aires: Ediciones Omega.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSilberschatz, A., Galvin, P. B., \u0026amp; Gagne, G. (2009). Fundamentos de Sistemas Operativos. Buenos Aires: Ediciones M.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTanenbaum, A. (2012). Estructura de Computadoras. Buenos Aires: Prentice Hall.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nBrookshear, J. G. (2011). Ciencia de la Computación: Una visión general. Buenos Aires: Pearson Educación.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nJacob, B., Ng, S. W., \u0026amp; Wang, D. T. (2007). Arquitecturas de memoria en sistemas de computadoras. Buenos Aires: Wiley-Interscience.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSiewiorek, D. P. \u0026amp; Swarz, R. S. (2017). Principios de diseño de sistemas computacionales. Buenos Aires: Morgan Kaufmann.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1693612800,"headings":[{"anchor":"el-sistema-binario-el-lenguaje-secreto-de-las-computadoras","title":"El sistema binario: el lenguaje secreto de las computadoras"},{"anchor":"memoria-y-almacenamiento-donde-residen-nuestros-datos","title":"Memoria y almacenamiento: donde residen nuestros datos"},{"anchor":"referencias","title":"Referencias"}],"kind":"page","lang":"es","series":["Programming"],"summary":"En el mundo actual, donde las tecnologías digitales se han convertido en una extensión de nuestras vidas diarias, resulta esencial comprender los cimientos sobre los que se construyen nuestras herramientas digitales. En esta ocasión, nos sumergiremos en el corazón de las computadoras para entender cómo funcionan y por qué son esenciales en nuestra sociedad moderna.","tags":["intro","programming","computer","hardware","software","cpu","memory"],"title":"La Computadora","url":"/es/programming/0100-intro/0101-computers/","year":"2023"},{"content":"","date":1693612800,"headings":[],"kind":"term","lang":"es","summary":"","title":"memory","url":"/es/tags/memory/","year":"2023"},{"content":"","date":1693612800,"headings":[],"kind":"term","lang":"es","summary":"","title":"software","url":"/es/tags/software/","year":"2023"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"2023","url":"/es/archives/2023/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"Abril","url":"/es/archives/2023/04/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"Agosto","url":"/es/archives/2023/08/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"Archivo","url":"/es/archives/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"Blog","url":"/es/blog/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"Blog","url":"/es/posts/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"taxonomy","lang":"es","summary":"","title":"Categories","url":"/es/categories/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"Diciembre","url":"/es/archives/2023/12/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"Enero","url":"/es/archives/2023/01/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"Febrero","url":"/es/archives/2023/02/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"term","lang":"es","summary":"","title":"I/O","url":"/es/tags/i/o/","year":"0001"},{"content":"Bienvenidos a esta serie exclusiva de artículos que componen un completo curso sobre Ingeniería de Software. Desde las raíces teóricas hasta las prácticas contemporáneas, este conjunto de escritos ha sido diseñado meticulosamente para brindar a los lectores una comprensión profunda y práctica de los diversos aspectos de la Ingeniería de Software.\nYa sea que seas un estudiante ansioso por adentrarte en los fundamentos, un profesional buscando refrescar conocimientos o simplemente alguien curioso por entender la magia detrás del desarrollo de software, esta colección te guiará paso a paso. A través de cada artículo, exploraremos conceptos clave, técnicas emergentes, herramientas esenciales y las mejores prácticas que definen nuestra industria hoy en día.\nTe invitamos a embarcarte en este viaje educativo. Cada artículo es una lección en sí mismo, diseñada para brindarte una experiencia de aprendizaje rica y aplicable en el mundo real. Prepárate para sumergirte en la apasionante disciplina de la Ingeniería de Software y descubrir las metodologías y herramientas que dan forma al mundo digital que nos rodea.\n","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"Bienvenidos a esta serie exclusiva de artículos que componen un completo curso sobre Ingeniería de Software. Desde las raíces teóricas hasta las prácticas contemporáneas, este conjunto de escritos ha sido diseñado meticulosamente para brindar a los lectores una comprensión profunda y práctica de los diversos aspectos de la Ingeniería de Software.\nYa sea que seas un estudiante ansioso por adentrarte en los fundamentos, un profesional buscando refrescar conocimientos o simplemente alguien curioso por entender la magia detrás del desarrollo de software, esta colección te guiará paso a paso.","title":"Ingeniería de Software","url":"/es/software-engineering/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"term","lang":"es","summary":"","title":"input/output","url":"/es/tags/input/output/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"Julio","url":"/es/archives/2023/07/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"Junio","url":"/es/archives/2023/06/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"term","lang":"es","summary":"","title":"María Florencia Caro","url":"/es/authors/mfcaro/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"Marzo","url":"/es/archives/2023/03/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"Mayo","url":"/es/archives/2023/05/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"Noviembre","url":"/es/archives/2023/11/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"Octubre","url":"/es/archives/2023/10/","year":"0001"},{"content":"La Programación Orientada a Objetos (POO) es un paradigma de programación que se ha vuelto indispensable en la actualidad. Este enfoque modela elementos del mundo real como \u0026ldquo;objetos\u0026rdquo; que tienen propiedades y comportamientos, lo cual permite crear programas más intuitivos y fáciles de mantener. En este artículo veremos los conceptos básicos de POO y sus ventajas frente a otros paradigmas como la programación procedural. ¡Empecemos!\nEste paradigma se basa en dos conceptos fundamentales:\nObjetos: entidades que combinan estado (datos) y comportamiento (operaciones) en una misma unidad. Por ejemplo, un objeto \u0026ldquo;coche\u0026rdquo; tendría propiedades como color, número de puertas, velocidad máxima, etc. Y comportamientos como acelerar, frenar, girar, etc. Clases: especificaciones que definen la estructura y comportamiento común de un grupo de objetos. La clase \u0026ldquo;coche\u0026rdquo; serviría como molde para crear objetos coche con las mismas características. Como explica el programador Alan Kay, uno de los creadores de la POO:\n\u0026ldquo;La idea central de POO es que los usuarios deben manipular objetos conceptuales más que máquinas de Turing. Las interfaces con el mundo real deben, por lo tanto, ser construidas en términos de objetos conceptuales.\u0026rdquo;1\nEs decir, la POO modela conceptualmente elementos del mundo real para hacer la programación más intuitiva.\nParadigmas de programación Antes de profundizar en la POO, conviene entender que existen diferentes paradigmas o enfoques para abordar la programación. Los principales son:\nProgramación procedural Secuencia ordenada de instrucciones que el programa debe seguir paso a paso. El foco está en procedimientos y funciones. Por ejemplo, C es un lenguaje orientado a la programación procedural.\nLa programación procedural es mejor para:\nProblemas sencillos o algoritmos secuenciales. Código que no necesitará reusarse ni expandirse mucho. Casos donde el rendimiento y eficiencia son críticos. Programación orientada a objetos Modelo basado en objetos que contienen datos y código en unidades cohesivas. El foco está en las clases y en la interacción entre objetos. Por ejemplo, Java y Python son lenguajes orientados a objetos.\nLa POO permite modelar de forma más directa elementos del mundo real, encapsular mejor los datos y reutilizar código a través de la herencia entre clases.\nLas principales ventajas de POO frente a la programación procedural son:\nModularidad: los objetos agrupan datos y operaciones relacionadas, encapsulando la complejidad interna. Esto permite trabajar con módulos independientes. Ocultación de información: Los objetos pueden exponer una interfaz simple y ocultar detalles de implementación internos. Esto reduce acoplamientos. Reusabilidad: Las clases permiten reuse de código. Una clase abstracta puede heredar a múltiples subclases. Extensibilidad: Podemos extender el comportamiento de clases padres creando nuevas subclases. Mapeo conceptual: Los objetos representan entidades del mundo real, lo cual facilita la traducción de requerimientos a código. Sin embargo, la POO también tiene desventajas. Según el programador Paul Graham:\n\u0026ldquo;La programación orientada a objetos suele ser una molestia. Hace que las cosas sean más difíciles de lo que deberían ser.\u0026rdquo;2\nPor ejemplo, para problemas simples la POO puede resultar excesiva. Y en proyectos grandes existe el riesgo de abusar de la herencia y el polimorfismo, volviendo el código difícil de seguir.\nEn definitiva, la POO es más adecuada cuando:\nEl problema a modelar tiene entidades claras y estructuradas. Queremos reutilizar código encapsulado en clases modulares. Trabajamos en sistemas que deben extenderse y mantenerse con facilidad. Conceptos básicos de POO Ahora que conocemos las ideas generales detrás de la POO, veamos algunos de los conceptos clave:\nObjetos Un objeto es una combinación de datos (propiedades) y comportamientos (métodos). Por ejemplo, un objeto Coche tendría propiedades como marca, modelo, color y métodos como acelerar, frenar, etc.\n1# Clase Coche 2class Coche: 3 4 def __init__(self, marca, color): 5 self.marca = marca 6 self.color = color 7 8 def acelerar(self): 9 print(\u0026#34;Acelerando\u0026#34;, self.marca) 10 11# Crear Objeto 12mi_coche = Coche(\u0026#34;Toyota\u0026#34;, \u0026#34;Rojo\u0026#34;) mi_coche es ahora un objeto Coche con propiedades y métodos definidos en su clase. Clases Una clase define los atributos (propiedades) y métodos (funciones) comunes a un grupo de objetos. Funciona como un molde para crear objetos similares.\nPor convención las clases se definen con la primera letra en mayúscula. Las propiedades y métodos de una clase reciben el prefijo self para indicar que pertenecen a esa instancia de objeto.\n1class Circulo: 2 3 def __init__(self, radio): 4 self.radio = radio 5 6 def area(self): 7 return 3.1416 * (self.radio ** 2) Circulo define la clase con propiedad radio y método area(). Métodos Los métodos son funciones que definen el comportamiento de un objeto. Se declaran dentro de la clase y pueden acceder a las propiedades del objeto mediante self.\nUn constructor es un método especial (__init__) que se ejecuta al crear objetos para inicializar sus propiedades.\n1class Persona: 2 3 def __init__(self, nombre, edad): 4 self.nombre = nombre 5 self.edad = edad 6 7 def saludar(self): 8 print(f\u0026#34;Hola! Soy {self.nombre}\u0026#34;) 9 10juan = Persona(\u0026#34;Juan\u0026#34;, 30) # Ejecuta __init__ 11juan.saludar() # \u0026#34;Hola! Soy Juan\u0026#34; El constructor asigna nombre y edad. El método saludar() accede al atributo nombre. Propiedades Las propiedades son variables asociadas a un objeto que definen sus características o estado. Se declaran en la clase y se accede a ellas mediante la referencia del objeto.\n1class Rectangulo: 2 3 def __init__(self, alto, ancho): 4 self.alto = alto 5 self.ancho = ancho 6 7r = Rectangulo(3,4) 8print(r.alto) # 3 9r.ancho = 8 10print(r.ancho) # 8 Se recomienda declarar las propiedades como privadas y acceder mediante métodos getters/setters para respetar el encapsulamiento.\nEncapsulamiento Consiste en ocultar los detalles de implementación internos de un objeto exponiendo solo una interfaz pública. Esto se logra declarando métodos y propiedades con los modificadores public o private.\nEn Python se denota con guion bajo prefijo para métodos/propiedades privadas:\n1class CuentaBancaria: 2 3 def __init__(self, saldo=0): 4 self.saldo = saldo 5 6 def depositar(self, monto): 7 self._saldo += monto 8 9 def consultar_saldo(self): 10 return self._saldo _saldo es privado, solo se accede internamente o por consultar_saldo(). El encapsulamiento facilita cambiar partes internas de una clase sin afectar su interfaz pública.\nConclusión La Programación Orientada a Objetos modela elementos del mundo real como clases y objetos, priorizando la modularidad, ocultación de información y reuso de código para crear programas más robustos y fáciles de mantener.\nAunque puede resultar excesiva para problemas simples, la POO es ideal para sistemas de mediana/gran escala que necesitan expandirse y evolucionar en complejidad con el tiempo.\nConceptos como herencia, polimorfismo, abstracción e interfaces permiten aprovechar al máximo las ventajas de este paradigma. Con una comprensión sólida de sus fundamentos estamos listos para aplicar la POO en cualquier lenguaje y proyecto de programación.\nReferencias Kay, Alan. The early history of Smalltalk. http://gagne.homedns.org/~tgagne/contrib/EarlyHistoryST.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nGraham, Paul. Why Arc Isn\u0026rsquo;t Especially Object-Oriented. http://www.paulgraham.com/noop.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":-62135596800,"headings":[{"anchor":"clases","title":"Clases"},{"anchor":"conceptos-básicos-de-poo","title":"Conceptos básicos de POO"},{"anchor":"conclusión","title":"Conclusión"},{"anchor":"encapsulamiento","title":"Encapsulamiento"},{"anchor":"métodos","title":"Métodos"},{"anchor":"objetos","title":"Objetos"},{"anchor":"paradigmas-de-programación","title":"Paradigmas de programación"},{"anchor":"programación-orientada-a-objetos","title":"Programación orientada a objetos"},{"anchor":"programación-procedural","title":"Programación procedural"},{"anchor":"propiedades","title":"Propiedades"},{"anchor":"referencias","title":"Referencias"}],"kind":"section","lang":"es","summary":"La Programación Orientada a Objetos (POO) es un paradigma de programación que se ha vuelto indispensable en la actualidad. Este enfoque modela elementos del mundo real como “objetos” que tienen propiedades y comportamientos, lo cual permite crear programas más intuitivos y fáciles de mantener. En este artículo veremos los conceptos básicos de POO y sus ventajas frente a otros paradigmas como la programación procedural. ¡Empecemos!\nEste paradigma se basa en dos conceptos fundamentales:","title":"Programación Orientada a Objetos","url":"/es/programming/0300-oop/","year":"0001"},{"content":"","date":-62135596800,"headings":[],"kind":"section","lang":"es","summary":"","title":"Septiembre","url":"/es/archives/2023/09/","year":"0001"}]