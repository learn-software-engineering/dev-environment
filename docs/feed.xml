<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://learn-software.com/dev-environment/feed.xml" rel="self" type="application/atom+xml" /><link href="https://learn-software.com/dev-environment/" rel="alternate" type="text/html" /><updated>2023-08-20T09:59:24+00:00</updated><id>https://learn-software.com/dev-environment/feed.xml</id><title type="html">Learn Software Engineering</title><subtitle>&quot;A place to learn about Software Engineering.&quot;</subtitle><entry><title type="html">Post: future date</title><link href="https://learn-software.com/dev-environment/future/draft/future-post-template-for-new-posts/" rel="alternate" type="text/html" title="Post: future date" /><published>9999-12-31T00:00:00+00:00</published><updated>9999-12-31T00:00:00+00:00</updated><id>https://learn-software.com/dev-environment/future/draft/future-post-template-for-new-posts</id><content type="html" xml:base="https://learn-software.com/dev-environment/future/draft/future-post-template-for-new-posts/"><![CDATA[<p>Test future post in draft folder.</p>]]></content><author><name>Maria Florencia Caro</name><email>learn.software.eng+mfcaro@gmail.com</email></author><category term="Future" /><category term="Draft" /><category term="Future" /><category term="Draft" /><category term="Test" /><summary type="html"><![CDATA[Test future post in draft folder.]]></summary></entry><entry><title type="html">Continuous Integration</title><link href="https://learn-software.com/dev-environment/continuous%20integration/ci/" rel="alternate" type="text/html" title="Continuous Integration" /><published>2023-08-19T00:00:00+00:00</published><updated>2023-08-19T00:00:00+00:00</updated><id>https://learn-software.com/dev-environment/continuous%20integration/ci</id><content type="html" xml:base="https://learn-software.com/dev-environment/continuous%20integration/ci/"><![CDATA[<p>One of the most pivotal challenges in the realm of software development is effectively integrating changes <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>. In a small-scale project steered by a single developer, this challenge might appear to be trivial. However, as the magnitude of the project escalates and more individuals join the development fold, the significance of seamless integration becomes paramount.</p>

<p>Historically, integration was often an afterthought, relegated to the tail end of the software development process <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>. Postponing it to such a late stage not only amplifies the risk of complex, undetected errors but also heightens the tension as delivery dates loom.</p>

<p>However, the paradigm shifted around the turn of the millennium. Continuous Integration (CI) was formally introduced in 2000 by Kent Beck as an intrinsic part of the ‘Extreme Programming’ methodology <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>. CI emphasizes the frequent and early-stage integration of code. By continuously amalgamating new code into the system, developers can gauge its impact promptly. This approach streamlines error detection, enabling developers to tackle issues as they emerge <sup id="fnref:2:1" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>. The ability to tie an error to a specific code change reduces error complexity and promotes efficient troubleshooting. Today, CI has become an indispensable practice in software development projects <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>.</p>

<p>Martin Fowler, a luminary in the field, eloquently defined CI as:</p>

<blockquote>
  <p>Continuous Integration is a software development practice where team members integrate their work frequently, typically multiple times a day. Each integration is verified by an automated build system that runs test suites to swiftly detect any integration anomalies. Teams adopting this methodology often witness a significant reduction in integration hiccups, empowering them to produce cohesive software at an accelerated pace<sup id="fnref:2:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>.</p>
</blockquote>

<p>Building upon Fowler’s definition, Duvall <sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup> underscored several vital facets:</p>

<ol>
  <li>Developers must maintain a conducive local environment for code construction and testing, ensuring their updates do not disrupt the established integration.</li>
  <li>Team members should commit their code to the Version Control System (VCS) daily.</li>
  <li>The integration process must be undertaken on a distinct machine, aptly termed the CI server.</li>
  <li>Only builds that pass all tests can be deemed deliverable.</li>
  <li>Error resolution is of paramount importance.</li>
  <li>A central repository displaying build and test results—often a website—is essential. Most CI tools readily offer such platforms.</li>
</ol>

<p>Furthermore, Patrick Cauldwell <sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup> advocates for frequent and early integration. The rationale? The more regular the integration, the less overhead for the team down the line. He distilled the primary goals of CI into:</p>

<ul>
  <li>Ensuring a consistently available, tested version of the product with the latest modifications.</li>
  <li>Keeping the team abreast of any integration issues as early as possible.</li>
</ul>

<p>The impetus behind CI is to maintain an error-free, tested product throughout the development life cycle. This avoids the pitfalls of a last-minute integration phase, which is often fraught with errors and consumes both time and resources. More crucially, if project components aren’t integrated during their development, there’s no guarantee they’ll gel cohesively in the final product <sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>.</p>

<p>Technical implementation of CI revolves around two core components: process automation and a system to showcase results, thereby fueling the developmental feedback loop <sup id="fnref:7:1" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>.</p>

<p>In summing up the tenets of CI, Martin Fowler <sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> emphasizes:</p>

<ul>
  <li>Retaining code in a singular repository.</li>
  <li>Streamlining software construction through automation.</li>
  <li>Implementing automated testing processes.</li>
  <li>Ensuring new code additions undergo integration and construction on the CI system’s machine.</li>
  <li>Keeping the build process agile and swift.</li>
  <li>Providing easy access to the product’s latest executable version.</li>
  <li>Ensuring product status transparency for all stakeholders.</li>
</ul>

<hr />

<h2 id="elements-of-a-ci-system">Elements of a CI system</h2>

<p>A basic Continuous Integration (CI) pipeline initiates when a new code change is pushed to the repository. The CI server, linked to the repository, gets notified of every new change, subsequently downloading the latest version to initiate the integration process, which will be elaborated on in the subsequent section. Once completed, it communicates the system’s status to the team members.</p>

<p><em>In computer science, a “pipeline” refers to a sequence of processes or tasks linked such that the output of one becomes the input for the next.</em></p>

<p><img src="/assets/images/collections/posts/ci/ci_elements.png" alt="Figure representing the basic elements of a CI system" />
<em>Figure 1: Basic elements of CI (Duvall<sup id="fnref:5:1" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>)</em></p>

<p>The system’s primary component consists of the <strong>developers</strong>. After making code modifications, they run tests locally and compile the code to ensure that they haven’t introduced new errors.</p>

<p>An essential part of every CI system is the <strong>Version Control System (VCS)</strong>. It oversees the changes made to the code and other significant elements. This system establishes a unified access point for all source code, enabling the CI system to fetch the most recent version for integration. Most software development projects utilize a VCS even if they don’t implement CI processes.</p>

<p>The <strong>CI Server</strong> is responsible for initiating a new build (comprising both compilation and tests) every time a change is added to the repository. They offer configurations to simplify the creation of integration pipelines. Additionally, most come with a web interface to display the build status and previous results. Currently, numerous powerful options are available, both free and paid. It’s worth noting that the CI server should operate on a dedicated machine and not on team members’ computers.</p>

<p>The CI server must automatically conduct software tests, source code analysis, and compile to produce the deliverable product. Therefore, <strong>build and test execution scripts</strong> are vital. These scripts outline the necessary steps to be executed. Popular tools for this purpose include Make, Ant, Maven, Gradle, among others.</p>

<p>Every CI system should have a <strong>notification mechanism</strong> to relay results to the team. This mechanism ensures that in the event of an error, the team becomes aware as soon as possible, enabling them to address the issue. While most CI tools offer a web interface to view results, they also support other notification methods like emails, messaging applications, etc.</p>

<hr />

<h2 id="the-integration-process">The integration process</h2>

<p>The figure below broadly illustrates the stages of the integration process taking place within the Continuous Integration (CI) system.</p>

<p><img src="/assets/images/collections/posts/ci/ci_process.png" alt="Illustration of the CI process" />
<em>Figure 2: CI process flowchart</em></p>

<p>Initially, the system must <strong>retrieve the latest source code version</strong> each time a new change is pushed to the Version Control System (VCS). Two mechanisms facilitate this. The first involves setting up the CI server to periodically check the VCS for updates. The alternative is to establish a <em>commit hook</em> within the VCS, ensuring that the CI server receives notifications whenever changes are made.</p>

<p>After obtaining the code, the CI server can be configured to <strong>scrutinize the source code</strong> for potential undetected errors, be they syntactic, logical, or patterns that might lead to faults. Various tools aid this process. For instance, Java boasts utilities like FindBugs, CheckStyle, and PMD, while Python has Pylint. JavaScript can be analyzed with tools like JSLint or JSHint. An example of a code analysis criterion could be ensuring every developed method has a cyclomatic complexity<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup> under 10. By employing automated source code inspection, one can assess code correctness, spot duplicate portions, and expedite the time between error detection and rectification. While automated inspection might not catch every error, the results can approximate those of peer reviews, thereby lightening the team’s review load.</p>

<p>The subsequent step revolves around <strong>automated test execution</strong> on the product. This automation is paramount to successfully implementing a CI system. Thus, developers can confidently make alterations, knowing a robust testing framework safeguards against compromising existing functionalities. Some popular tools in this domain include Junit, JBehave, and Selenium, which not only facilitate test drafting but also generate comprehensive reports, often as visualizations or web pages. Several software testing levels exist, such as <em>unit tests</em>, <em>integration tests</em>, and <em>system tests</em>. In the CI pipeline context, the focus rests on automating unit and integration tests, with system tests’ automation being recommended but not mandatory.</p>

<p>Once the tests pass, the CI pipeline advances to <strong>compiling the source code</strong>. During this phase, the source code morphs into one or multiple files or packages, ready for distribution and user execution. This process’s specifics hinge on the employed programming language. For instance, languages like Java necessitate code compilation, resulting in an executable. Conversely, languages like Python might involve stricter code structure checks without generating any binary files.</p>

<p>Throughout this integration journey, the team should steadfastly adhere to three fundamental rules:</p>
<ol>
  <li>Locally run tests and compile software before integrating it into the VCS to minimize error introduction chances (avoiding “breaking the build”).</li>
  <li>Avoid pushing new code to the VCS if the CI server flags errors (indicative of a “broken build”).</li>
  <li>Should the CI server report faults, code modifications should exclusively aim at rectifying them.</li>
</ol>

<hr />

<h2 id="core-principles-and-practices">Core principles and practices</h2>

<p>Martin Fowler<sup id="fnref:2:3" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> identifies a set of foundational elements intrinsic to every Continuous Integration (CI) system. While some of these have been touched upon earlier in this chapter, we will succinctly encapsulate them here for clarity:</p>

<ol>
  <li><strong>Centralized Code Repository</strong>: Retain all code within a singular, unified repository.</li>
  <li><strong>Streamlined Compilation and Build Process</strong>: Entirely automate the compilation and construction workflows, negating manual intervention.</li>
  <li><strong>Full-Spectrum Automated Testing</strong>: Ensure all software tests are automated, driving efficiency and precision.</li>
  <li><strong>Daily Commitment</strong>: Encourage the team to consistently merge their changes to the repository on a daily basis.</li>
  <li><strong>Stringent Integration Checks</strong>: Each alteration made to the Version Control System (VCS) undergoes rigorous integration processes within the CI system.</li>
  <li><strong>Prompt Error Rectification</strong>: Should the CI system flag any issues (indicative of a “broken build”), immediate action is imperative. Either rectify the flaw or reverse the change to ensure the repository’s latest version remains operational.</li>
  <li><strong>Swift CI Procedures</strong>: Aim to complete the CI process rapidly—ideally within 15 minutes or less. This approach ensures timely integration and facilitates the expedited delivery of results.</li>
  <li><strong>Universal Access to Latest Executables</strong>: Always provide the team with access to the most recent executable or deliverable package, promoting transparency.</li>
  <li><strong>Real-time Product Status Visibility</strong>: Grant every team member the ability to monitor the product’s status at any given moment, fostering informed decision-making.</li>
</ol>

<hr />

<h2 id="benefits">Benefits</h2>

<p>The overarching consensus within the software community is that the implementation of a Continuous Integration (CI) process yields an array of substantial advantages. Duvall<sup id="fnref:5:2" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup> outlines these core benefits in his publication.</p>

<ol>
  <li>
    <p><strong>Risk Mitigation</strong>: Adopting frequent integration minimizes project risks. It facilitates early detection of issues and offers a continuous snapshot of the product’s health. By identifying these issues early in the development cycle, there’s a consequent reduction in both the cost of fixes and the risk of releasing a subpar product. Furthermore, automated inspections provide real-time insights into the product’s size, code complexity, and other metrics. This automation diminishes the chance of human-induced errors.</p>
  </li>
  <li>
    <p><strong>Minimization of Manual Repetitive Tasks</strong>: Automation curtails the need for recurring manual tasks such as compilation, inspection, test execution, and report generation. This efficiency not only leads to significant time and cost savings but also allows teams to focus on activities that directly enhance product value. It liberates team members to dedicate more time to addressing new requirements or rectifying existing product issues.</p>
  </li>
  <li>
    <p><strong>On-Demand Availability of a Functional Product</strong>: A hallmark of CI is its ability to deliver a functional software product at any given moment. This is invaluable for stakeholders, offering them a rapid glance into product development progress. By leveraging CI, errors can be swiftly detected and remedied soon after a new change is introduced. This is far more efficient than uncovering them close to the release date when they are more expensive and challenging to amend. Such issues, if left unchecked, can lead to delivery delays, unsatisfied clients, escalated costs, and more. This ties back to the concept of the “Broken Window Theory”<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup>, which, in essence, postulates that a product marred by numerous issues or perceived disorder can demotivate teams from addressing them.</p>
  </li>
  <li>
    <p><strong>Enhanced Project Transparency</strong>: Implementing CI augments visibility into the project, rendering the development process more transparent. It aids project management with up-to-the-minute information, making it straightforward to gauge product quality, error trends, and more.</p>
  </li>
  <li>
    <p><strong>Elevated Product Confidence</strong>: The CI environment bolsters confidence in the product. Team members gain immediate insights into the ramifications of their changes, enabling them to promptly rectify any emergent issues.</p>
  </li>
</ol>

<hr />

<h2 id="challenges">Challenges</h2>

<p>While Duvall<sup id="fnref:5:3" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup> has extolled the virtues of Continuous Integration (CI) in his works, he also highlights potential challenges that might deter development teams from embracing it fully or realizing its benefits.</p>

<ol>
  <li>
    <p><strong>Bias</strong>: A widespread misconception is that CI system implementation is exorbitant and would escalate development costs due to its prolonged setup and maintenance. Contrarily, most software development projects already involve phases like inspection, testing, compilation, and integration, even if they don’t explicitly use a CI system. A common refrain is that there’s insufficient time or funds for CI system implementation, but the reality is that far more resources are spent performing redundant manual tasks throughout the development cycle. Furthermore, an automated CI system is infinitely more manageable and consistent compared to disparate manual processes.</p>
  </li>
  <li>
    <p><strong>Disruption Fears</strong>: Projects in advanced development stages often fret that integrating a CI system would overhaul their established workflows, spawning significant delays. It’s pivotal to recognize that CI system implementation can be incremental. Teams can address one integration stage at a time, gradually ramping up the integration frequency as confidence builds.</p>
  </li>
  <li>
    <p><strong>Overwhelming Failed Integrations</strong>: When CI practices aren’t diligently applied, there’s a risk of encountering an excessive number of failed integrations or “broken builds.” This could stem from developers bypassing local tests before uploading their changes to the Version Control System (VCS). A surge in failed integrations can erode trust in the CI system, reminiscent of the “Broken Window Theory”<sup id="fnref:9:1" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup>.</p>
  </li>
  <li>
    <p><strong>Perceived Additional Costs</strong>: There’s an apprehension among organizations about incurring extra expenses either for procuring CI product licenses or securing hardware to support these systems. However, this expenditure pales in comparison to the latent costs of late-stage integrations, where issues are discovered near the release date, far removed from their inception. On a brighter note, the current landscape is rife with a myriad of free and open-source alternatives, obviating any additional costs.</p>
  </li>
</ol>

<hr />

<h2 id="references">References</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="https://www.thoughtworks.com/continuous-integration">Continuous integration</a>. ThoughtWorks, 2018. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Fowler, Martin. <a href="https://martinfowler.com/articles/continuousIntegration.html">Continuous Integration</a>. 2006. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:2:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:2:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:2:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Beck, Kent. Embrace Change with Extreme Programming. <em>IEEE Computer Magazine</em>, (c), 70-77. 1999. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>Rodriguez Pilar, Markkula, Jouni, Oivo, Markku, &amp; Turula, Kimmo. <a href="http://dl.acm.org/citation.cfm?doid=2372251.2372275">Survey on agile and lean usage in Finnish software industry</a>. In <em>Proceedings of the ACM-IEEE international symposium on Empirical software engineering and measurement - ESEM ‘12</em> (p. 139). ACM Press. DOI: 10.1145/2372251.2372275. 2012. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>Duvall, Paul M., Matyas, Steve, &amp; Glover, Andrew. Continuous integration: improving software quality and reducing risk. Pearson Education, Inc., 2007. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:5:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:5:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:5:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>Cauldwell, Patrick. Code Leader: Using people, tools and processes to build successful software. Wiley Publishing, Inc., 2008. <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>Humble, Jez &amp; Farley, David. Continuous Delivery: Reliable Software Releases through Build, Test and Deployment Automation. Addison-Wesley, 2011. <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:7:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p><a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Cyclomatic Complexity Explanation</a> <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p><a href="https://www.linkedin.com/pulse/broken-window-theory-software-development-leon-lahoud">The Broken Window Theory in Software Development</a> <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:9:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
  </ol>
</div>]]></content><author><name>Julian Nonino</name><email>learn.software.eng+jnonino@gmail.com</email></author><category term="Continuous Integration" /><category term="CI" /><category term="Continuous Integration" /><category term="DevOps" /><summary type="html"><![CDATA[Keep calm and merge on]]></summary></entry><entry><title type="html">Revert a local change in Git</title><link href="https://learn-software.com/dev-environment/version%20control/git-revert-local/" rel="alternate" type="text/html" title="Revert a local change in Git" /><published>2023-01-18T00:00:00+00:00</published><updated>2023-01-18T00:00:00+00:00</updated><id>https://learn-software.com/dev-environment/version%20control/git-revert-local</id><content type="html" xml:base="https://learn-software.com/dev-environment/version%20control/git-revert-local/"><![CDATA[<p>When we have created a commit locally but have not published it to the remote yet, we can use <code class="language-plaintext highlighter-rouge">git reset</code> to undo the commit and, if we wish, discard the changes.
Although there are several options for <code class="language-plaintext highlighter-rouge">git reset</code> the most used are:</p>

<blockquote>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">--soft</code>: Does not touch the index file or the working tree at all (but resets the head to <COMMIT>, just like all modes do). This leaves all your changed files "Changes to be committed", as git status would put it.</COMMIT></li>
    <li><code class="language-plaintext highlighter-rouge">--hard</code>: Resets the index and working tree. Any changes to tracked files in the working tree since <COMMIT> are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted.</COMMIT></li>
  </ul>

  <p style="text-align: right;"><a href="https://git-scm.com/docs/git-reset">Git reset documentation</a></p>
</blockquote>

<p>Here there is an example about using <code class="language-plaintext highlighter-rouge">git reset</code>. We start by changing a file and creating a commit with the change.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash-3.2$  cat README.md
# Index

1
bash-3.2$
bash-3.2$  cat README.md
# Index

1
2
bash-3.2$
bash-3.2$  git add README.md
bash-3.2$
bash-3.2$  git commit -m "Add number 2 in README.md"
[main 3734fd5] Add number 2 in README.md
 1 file changed, 1 insertion(+)
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">git status</code> shows there is one commit pending to be published.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash-3.2$  git status
On branch main
Your branch is ahead of 'origin/main' by 1 commit.
  (use "git push" to publish your local commits)

nothing to commit, working tree clean
</code></pre></div></div>

<p>Using <code class="language-plaintext highlighter-rouge">git reflog</code> to see the history.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3734fd5 (HEAD -&gt; main) HEAD@{0}: commit: Add number 2 in README.md
866bfa8 (origin/main) HEAD@{1}: revert: Revert "Merge branch 'feature-1'"
e2f6d08 HEAD@{2}: merge feature-1: Merge made by the 'ort' strategy.
23644da HEAD@{3}: checkout: moving from feature-1 to main
</code></pre></div></div>

<p>Now we can use <code class="language-plaintext highlighter-rouge">git reset --soft &lt;COMMIT_ID&gt;</code> to undo the commit but keep the changes.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash-3.2$  git reset --soft 866bfa8
bash-3.2$
bash-3.2$  git status
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged &lt;file&gt;..." to unstage)
        modified:   README.md

</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">git log</code> after using <code class="language-plaintext highlighter-rouge">git reset</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>commit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -&gt; main, origin/main)
Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt;
Date:   Wed Jan 18 20:06:40 2023 -0300

    Revert "Merge branch 'feature-1'"

    This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing
    changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546.
</code></pre></div></div>

<p>We create a new commit so we can test the <code class="language-plaintext highlighter-rouge">git reset --hard</code> command.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash-3.2$  git status
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged &lt;file&gt;..." to unstage)
        modified:   README.md

bash-3.2$  git commit -m "Add number 2 in README.md - NEW COMMIT"
[main 2e7193d] Add number 2 in README.md - NEW COMMIT
 1 file changed, 1 insertion(+)
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">git log</code> now shows the new commit.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>commit 2e7193db650b9ba0762fe73525df599a08f8577d (HEAD -&gt; main)
Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt;
Date:   Thu Jan 19 08:32:57 2023 -0300

    Add number 2 in README.md - NEW COMMIT

commit 866bfa8a952d11240707ebfc87f3266034d42443 (origin/main)
Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt;
Date:   Wed Jan 18 20:06:40 2023 -0300

    Revert "Merge branch 'feature-1'"

    This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing
    changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546.
</code></pre></div></div>

<p>Now we can use <code class="language-plaintext highlighter-rouge">git reset --hard &lt;COMMIT_ID&gt;</code> to undo the commit and discard all the changes.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash-3.2$  git reset --hard 866bfa8
HEAD is now at 866bfa8 Revert "Merge branch 'feature-1'"
bash-3.2$
bash-3.2$  git status
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">git log</code> remains as it nothing had happened.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>commit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -&gt; main, origin/main)
Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt;
Date:   Wed Jan 18 20:06:40 2023 -0300

    Revert "Merge branch 'feature-1'"

    This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing
    changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546.
</code></pre></div></div>]]></content><author><name>Julian Nonino</name><email>learn.software.eng+jnonino@gmail.com</email></author><category term="Version Control" /><category term="Git" /><category term="Version Control" /><summary type="html"><![CDATA[When we have created a commit locally but have not published it to the remote yet, we can use git reset to undo the commit and, if we wish, discard the changes. Although there are several options for git reset the most used are:]]></summary></entry><entry><title type="html">Revert a pushed change in Git</title><link href="https://learn-software.com/dev-environment/version%20control/git-revert-pushed/" rel="alternate" type="text/html" title="Revert a pushed change in Git" /><published>2023-01-18T00:00:00+00:00</published><updated>2023-01-18T00:00:00+00:00</updated><id>https://learn-software.com/dev-environment/version%20control/git-revert-pushed</id><content type="html" xml:base="https://learn-software.com/dev-environment/version%20control/git-revert-pushed/"><![CDATA[<p>When we realized that the last commit was a mistake but we already published it, the command to use is <code class="language-plaintext highlighter-rouge">git revert &lt;COMMIT_HASH&gt;</code>.</p>

<ul>
  <li>First we need to locate the ID of the commit we want to revert, it can be done with <code class="language-plaintext highlighter-rouge">git log</code> or <code class="language-plaintext highlighter-rouge">git reflog</code> commands.</li>
  <li>Then, run the <code class="language-plaintext highlighter-rouge">git revert &lt;COMMIT_HASH&gt;</code> command using the ID obtained in the previous step. Use the options <code class="language-plaintext highlighter-rouge">-e</code> or <code class="language-plaintext highlighter-rouge">--edit</code> to edit the commit message if we like.</li>
  <li>Push our changes so the revert is available for everyone in our group.</li>
</ul>

<h2 id="reverting-multiple-commits">Reverting multiple commits</h2>

<p>If we need to revert multiple commits we can revert them one by one using the <code class="language-plaintext highlighter-rouge">--no-commit</code> option in order to create a single revert commit at the end.</p>

<p>Imagine the history is like the following and we need to go back to <code class="language-plaintext highlighter-rouge">COMMIT-3</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>COMMIT-1 -&gt; COMMIT-2 -&gt; COMMIT-3 -&gt; COMMIT-4 -&gt; COMMIT-5 -&gt; COMMIT-6 -&gt; HEAD
</code></pre></div></div>

<p>This sequence of commands will get our files to the version of <code class="language-plaintext highlighter-rouge">COMMIT-3</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash-3.2$  git revert --no-commit COMMIT-6
bash-3.2$  git revert --no-commit COMMIT-5
bash-3.2$  git revert --no-commit COMMIT-4
bash-3.2$  git commit -m "Revert to version in COMMIT-3"
bash-3.2$  git push
</code></pre></div></div>

<h2 id="reverting-a-merge-commit">Reverting a merge commit</h2>

<blockquote>
  <p>-m parent-number, –mainline parent-number</p>

  <p>Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.</p>

  <p style="text-align: right;"><a href="https://git-scm.com/docs/git-revert">Git revert documentation</a></p>
</blockquote>

<p>When we need to revert a merge commit <code class="language-plaintext highlighter-rouge">git revert</code> command needs to be run with the <code class="language-plaintext highlighter-rouge">-m</code> or <code class="language-plaintext highlighter-rouge">--mainline</code> option to indicate the <strong>parent number</strong> because a <code class="language-plaintext highlighter-rouge">merge commit</code> has more than one parent and Git does not know which parent was target branch and which was the branch with the changes that should be reverted.</p>

<p>Here there is an example showing how to revert a merge commit.</p>

<p>Create the first commit in <code class="language-plaintext highlighter-rouge">main</code> branch.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash-3.2$  cat README.md
# Index

1
bash-3.2$
bash-3.2$  git commit -m "Add number 1 in README.md - main branch"
[main (root-commit) 23644da] Add number 1 in README.md - main branch
 1 file changed, 3 insertions(+)
 create mode 100644 README.md
bash-3.2$
bash-3.2$  git push -u origin main
Enumerating objects: 3, done.
Counting objects: 100% (3/3), done.
Writing objects: 100% (3/3), 254 bytes | 254.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
To github.com:jnonino/test-repo.git
 * [new branch]      main -&gt; main
branch 'main' set up to track 'origin/main'.
bash-3.2$
</code></pre></div></div>

<p>The state of the <code class="language-plaintext highlighter-rouge">README.md</code> file in <code class="language-plaintext highlighter-rouge">main</code> branch.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash-3.2$git status
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean
bash-3.2$
bash-3.2$  cat README.md
# Index

1
</code></pre></div></div>

<p>Branch <code class="language-plaintext highlighter-rouge">feature-1</code> created and added one commit.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash-3.2$  git checkout -b feature-1
Switched to a new branch 'feature-1'
bash-3.2$
bash-3.2$  cat README.md
# Index

1
2
bash-3.2$
bash-3.2$  git add README.md
bash-3.2$
bash-3.2$  git commit -m "Add number 2 in README.md - feature-1 branch"
[feature-1 83ea1a3] Add number 2 in README.md - feature-1 branch
 1 file changed, 1 insertion(+)
bash-3.2$
bash-3.2$  git push --set-upstream origin feature-1
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Writing objects: 100% (3/3), 292 bytes | 292.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
remote:
remote: Create a pull request for 'feature-1' on GitHub by visiting:
remote:      https://github.com/jnonino/test-repo/pull/new/feature-1
remote:
To github.com:jnonino/test-repo.git
 * [new branch]      feature-1 -&gt; feature-1
branch 'feature-1' set up to track 'origin/feature-1'.
bash-3.2$
</code></pre></div></div>

<p>The state of <code class="language-plaintext highlighter-rouge">README.md</code> in the <code class="language-plaintext highlighter-rouge">feature-1</code> branch.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash-3.2$  git status
On branch feature-1
Your branch is up to date with 'origin/feature-1'.

nothing to commit, working tree clean
bash-3.2$
bash-3.2$  cat README.md
# Index

1
2
</code></pre></div></div>

<p>Merge the <code class="language-plaintext highlighter-rouge">feature-1</code> branch into the <code class="language-plaintext highlighter-rouge">main</code> branch.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash-3.2$  git checkout main
Switched to branch 'main'
Your branch is up to date with 'origin/main'.
bash-3.2$
bash-3.2$  git merge --no-ff feature-1
Merge made by the 'ort' strategy.
 README.md | 1 +
 1 file changed, 1 insertion(+)
bash-3.2$
bash-3.2$  git push
Enumerating objects: 1, done.
Counting objects: 100% (1/1), done.
Writing objects: 100% (1/1), 233 bytes | 233.00 KiB/s, done.
Total 1 (delta 0), reused 0 (delta 0), pack-reused 0
To github.com:jnonino/test-repo.git
   23644da..e2f6d08  main -&gt; main
bash-3.2$
</code></pre></div></div>

<p>Current state of <code class="language-plaintext highlighter-rouge">README.md</code> in <code class="language-plaintext highlighter-rouge">main</code> branch.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash-3.2$  git status
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean
bash-3.2$
bash-3.2$  cat README.md
# Index

1
2
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">git log</code> after merging <code class="language-plaintext highlighter-rouge">feature-1</code> into <code class="language-plaintext highlighter-rouge">main</code> branch.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>commit e2f6d08d3b38a02a1c026cfb879f3131536757ac (HEAD -&gt; main, origin/main)
Merge: 23644da 83ea1a3
Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt;
Date:   Wed Jan 18 19:58:19 2023 -0300

    Merge branch 'feature-1'

commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1)
Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt;
Date:   Wed Jan 18 19:53:38 2023 -0300

    Add number 2 in README.md - feature-1 branch

commit 23644dab9fc5828ecdd358c6d3acb4196ed23546
Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt;
Date:   Wed Jan 18 19:48:37 2023 -0300

    Add number 1 in README.md - main branch
</code></pre></div></div>

<p>To revert the merge commit, as it was stated above we need to pay attention to the <code class="language-plaintext highlighter-rouge">merge</code> field.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Merge: 23644da 83ea1a3
</code></pre></div></div>

<p>Running <code class="language-plaintext highlighter-rouge">git revert e2f6d08 -m 1</code> will reinstate the tree as it was in <code class="language-plaintext highlighter-rouge">23644da</code>, and <code class="language-plaintext highlighter-rouge">git revert e2f6d08 -m 2</code> will set the tree as it was in <code class="language-plaintext highlighter-rouge">83ea1a3</code>.
In this example we would like to leave the <code class="language-plaintext highlighter-rouge">main</code> branch as it was before the merge commit. For doing that, we need to run <code class="language-plaintext highlighter-rouge">git revert e2f6d08 -m 1</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash-3.2$  git revert e2f6d08 -m 1
[main 866bfa8] Revert "Merge branch 'feature-1'"
 1 file changed, 1 deletion(-)
bash-3.2$
bash-3.2$  git status
On branch main
Your branch is ahead of 'origin/main' by 1 commit.
  (use "git push" to publish your local commits)

nothing to commit, working tree clean
bash-3.2$
bash-3.2$  git push
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Writing objects: 100% (3/3), 344 bytes | 344.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
To github.com:jnonino/test-repo.git
   e2f6d08..866bfa8  main -&gt; main
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">git log</code> after reverting the merge commit.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>commit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -&gt; main, origin/main)
Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt;
Date:   Wed Jan 18 20:06:40 2023 -0300

    Revert "Merge branch 'feature-1'"

    This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing
    changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546.

commit e2f6d08d3b38a02a1c026cfb879f3131536757ac
Merge: 23644da 83ea1a3
Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt;
Date:   Wed Jan 18 19:58:19 2023 -0300

    Merge branch 'feature-1'

commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1)
Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt;
Date:   Wed Jan 18 19:53:38 2023 -0300

    Add number 2 in README.md - feature-1 branch

commit 23644dab9fc5828ecdd358c6d3acb4196ed23546
Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt;
Date:   Wed Jan 18 19:48:37 2023 -0300

    Add number 1 in README.md - main branch
</code></pre></div></div>

<p>Current state of <code class="language-plaintext highlighter-rouge">README.md</code> in <code class="language-plaintext highlighter-rouge">main</code> branch.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash-3.2$  git status
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean
bash-3.2$
bash-3.2$  cat README.md
# Index

1
</code></pre></div></div>]]></content><author><name>Julian Nonino</name><email>learn.software.eng+jnonino@gmail.com</email></author><category term="Version Control" /><category term="Git" /><category term="Version Control" /><summary type="html"><![CDATA[When we realized that the last commit was a mistake but we already published it, the command to use is git revert &lt;COMMIT_HASH&gt;.]]></summary></entry><entry><title type="html">Post: Standard with long title to test overlay image</title><link href="https://learn-software.com/dev-environment/drafts/post-standard/" rel="alternate" type="text/html" title="Post: Standard with long title to test overlay image" /><published>2022-10-15T00:00:00+00:00</published><updated>2022-10-15T00:00:00+00:00</updated><id>https://learn-software.com/dev-environment/drafts/post-standard</id><content type="html" xml:base="https://learn-software.com/dev-environment/drafts/post-standard/"><![CDATA[<p>First paragraph to test.</p>

<!--more-->

<p>This post has a manual excerpt <code class="language-plaintext highlighter-rouge">&lt;!--more--&gt;</code> set after the second paragraph. The following YAML Front Matter has also be applied:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">excerpt_separator</span><span class="pi">:</span> <span class="s2">"</span><span class="s">&lt;!--more--&gt;"</span>
</code></pre></div></div>

<h2 id="section-1">Section 1</h2>

<p>Second paragraph.</p>

<h3 id="section-11">Section 1.1</h3>

<p>Third paragraph.</p>

<h4 id="section-111">Section 1.1.1</h4>

<p>Fourth paragraph.</p>

<h4 id="section-112">Section 1.1.2</h4>

<p>Fifth paragraph.</p>

<h3 id="section-12">Section 1.2</h3>

<p>Sixth paragraph.</p>

<h2 id="section-2">Section 2</h2>

<p>Seventh paragraph.</p>

<h3 id="section-21">Section 2.1</h3>

<p>Eighth paragraph.</p>

<h3 id="section-22">Section 2.2</h3>

<p>Ninth paragraph.</p>

<h4 id="section-221">Section 2.2.1</h4>

<p>Tenth paragraph.</p>

<h4 id="section-222">Section 2.2.2</h4>

<p>Eleventh paragraph.</p>]]></content><author><name>Julian Nonino</name><email>learn.software.eng+jnonino@gmail.com</email></author><category term="Drafts" /><category term="Draft" /><category term="Test" /><summary type="html"><![CDATA[First paragraph to test.]]></summary></entry><entry><title type="html">Post: Modified Date</title><link href="https://learn-software.com/dev-environment/drafts/post-modified/" rel="alternate" type="text/html" title="Post: Modified Date" /><published>2022-10-15T00:00:00+00:00</published><updated>2022-10-15T21:20:02+00:00</updated><id>https://learn-software.com/dev-environment/drafts/post-modified</id><content type="html" xml:base="https://learn-software.com/dev-environment/drafts/post-modified/"><![CDATA[<p>This post has been updated and should show a modified date if used in a layout.</p>

<p>First paragraph to test.</p>

<p>Second paragraph.</p>

<p>Third paragraph.</p>

<p>Fourth paragraph.</p>

<p>Fifth paragraph.</p>]]></content><author><name>Maria Florencia Caro</name><email>learn.software.eng+mfcaro@gmail.com</email></author><category term="Drafts" /><category term="Draft" /><category term="Test" /><summary type="html"><![CDATA[This post has been updated and should show a modified date if used in a layout.]]></summary></entry></feed>