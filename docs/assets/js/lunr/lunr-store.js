var store = [{
        "title": "Post: Modified Date",
        "excerpt":"This post has been updated and should show a modified date if used in a layout.   First paragraph to test.   Second paragraph.   Third paragraph.   Fourth paragraph.   Fifth paragraph.  ","categories": ["Drafts"],
        "tags": ["Draft","Test"],
        "url": "/dev-environment/drafts/post-modified/",
        "teaser": null
      },{
        "title": "Post: Standard with long title to test overlay image",
        "excerpt":"First paragraph to test.     This post has a manual excerpt &lt;!--more--&gt; set after the second paragraph. The following YAML Front Matter has also be applied:   excerpt_separator: \"&lt;!--more--&gt;\"   Section 1   Second paragraph.   Section 1.1   Third paragraph.   Section 1.1.1   Fourth paragraph.   Section 1.1.2   Fifth paragraph.   Section 1.2   Sixth paragraph.   Section 2   Seventh paragraph.   Section 2.1   Eighth paragraph.   Section 2.2   Ninth paragraph.   Section 2.2.1   Tenth paragraph.   Section 2.2.2   Eleventh paragraph.  ","categories": ["Drafts"],
        "tags": ["Draft","Test"],
        "url": "/dev-environment/drafts/post-standard/",
        "teaser": null
      },{
        "title": "Revert a local change in Git",
        "excerpt":"When we have created a commit locally but have not published it to the remote yet, we can use git reset to undo the commit and, if we wish, discard the changes. Although there are several options for git reset the most used are:           --soft: Does not touch the index file or the working tree at all (but resets the head to , just like all modes do). This leaves all your changed files \"Changes to be committed\", as git status would put it.     --hard: Resets the index and working tree. Any changes to tracked files in the working tree since  are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted.       Git reset documentation    Here there is an example about using git reset. We start by changing a file and creating a commit with the change.  bash-3.2$  cat README.md # Index  1 bash-3.2$ bash-3.2$  cat README.md # Index  1 2 bash-3.2$ bash-3.2$  git add README.md bash-3.2$ bash-3.2$  git commit -m \"Add number 2 in README.md\" [main 3734fd5] Add number 2 in README.md  1 file changed, 1 insertion(+)   git status shows there is one commit pending to be published.  bash-3.2$  git status On branch main Your branch is ahead of 'origin/main' by 1 commit.   (use \"git push\" to publish your local commits)  nothing to commit, working tree clean   Using git reflog to see the history.  3734fd5 (HEAD -&gt; main) HEAD@{0}: commit: Add number 2 in README.md 866bfa8 (origin/main) HEAD@{1}: revert: Revert \"Merge branch 'feature-1'\" e2f6d08 HEAD@{2}: merge feature-1: Merge made by the 'ort' strategy. 23644da HEAD@{3}: checkout: moving from feature-1 to main   Now we can use git reset --soft &lt;COMMIT_ID&gt; to undo the commit but keep the changes.  bash-3.2$  git reset --soft 866bfa8 bash-3.2$ bash-3.2$  git status On branch main Your branch is up to date with 'origin/main'.  Changes to be committed:   (use \"git restore --staged &lt;file&gt;...\" to unstage)         modified:   README.md    git log after using git reset  commit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -&gt; main, origin/main) Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt; Date:   Wed Jan 18 20:06:40 2023 -0300      Revert \"Merge branch 'feature-1'\"      This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing     changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546.   We create a new commit so we can test the git reset --hard command.  bash-3.2$  git status On branch main Your branch is up to date with 'origin/main'.  Changes to be committed:   (use \"git restore --staged &lt;file&gt;...\" to unstage)         modified:   README.md  bash-3.2$  git commit -m \"Add number 2 in README.md - NEW COMMIT\" [main 2e7193d] Add number 2 in README.md - NEW COMMIT  1 file changed, 1 insertion(+)   git log now shows the new commit.  commit 2e7193db650b9ba0762fe73525df599a08f8577d (HEAD -&gt; main) Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt; Date:   Thu Jan 19 08:32:57 2023 -0300      Add number 2 in README.md - NEW COMMIT  commit 866bfa8a952d11240707ebfc87f3266034d42443 (origin/main) Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt; Date:   Wed Jan 18 20:06:40 2023 -0300      Revert \"Merge branch 'feature-1'\"      This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing     changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546.   Now we can use git reset --hard &lt;COMMIT_ID&gt; to undo the commit and discard all the changes.  bash-3.2$  git reset --hard 866bfa8 HEAD is now at 866bfa8 Revert \"Merge branch 'feature-1'\" bash-3.2$ bash-3.2$  git status On branch main Your branch is up to date with 'origin/main'.  nothing to commit, working tree clean   git log remains as it nothing had happened.  commit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -&gt; main, origin/main) Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt; Date:   Wed Jan 18 20:06:40 2023 -0300      Revert \"Merge branch 'feature-1'\"      This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing     changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546.  ","categories": ["Version Control"],
        "tags": ["Git","Version Control"],
        "url": "/dev-environment/version%20control/git-revert-local/",
        "teaser": null
      },{
        "title": "Revert a pushed change in Git",
        "excerpt":"When we realized that the last commit was a mistake but we already published it, the command to use is git revert &lt;COMMIT_HASH&gt;.      First we need to locate the ID of the commit we want to revert, it can be done with git log or git reflog commands.   Then, run the git revert &lt;COMMIT_HASH&gt; command using the ID obtained in the previous step. Use the options -e or --edit to edit the commit message if we like.   Push our changes so the revert is available for everyone in our group.   Reverting multiple commits   If we need to revert multiple commits we can revert them one by one using the --no-commit option in order to create a single revert commit at the end.   Imagine the history is like the following and we need to go back to COMMIT-3.   COMMIT-1 -&gt; COMMIT-2 -&gt; COMMIT-3 -&gt; COMMIT-4 -&gt; COMMIT-5 -&gt; COMMIT-6 -&gt; HEAD   This sequence of commands will get our files to the version of COMMIT-3:   bash-3.2$  git revert --no-commit COMMIT-6 bash-3.2$  git revert --no-commit COMMIT-5 bash-3.2$  git revert --no-commit COMMIT-4 bash-3.2$  git commit -m \"Revert to version in COMMIT-3\" bash-3.2$  git push   Reverting a merge commit      -m parent-number, –mainline parent-number     Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.     Git revert documentation    When we need to revert a merge commit git revert command needs to be run with the -m or --mainline option to indicate the parent number because a merge commit has more than one parent and Git does not know which parent was target branch and which was the branch with the changes that should be reverted.   Here there is an example showing how to revert a merge commit.   Create the first commit in main branch.  bash-3.2$  cat README.md # Index  1 bash-3.2$ bash-3.2$  git commit -m \"Add number 1 in README.md - main branch\" [main (root-commit) 23644da] Add number 1 in README.md - main branch  1 file changed, 3 insertions(+)  create mode 100644 README.md bash-3.2$ bash-3.2$  git push -u origin main Enumerating objects: 3, done. Counting objects: 100% (3/3), done. Writing objects: 100% (3/3), 254 bytes | 254.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git  * [new branch]      main -&gt; main branch 'main' set up to track 'origin/main'. bash-3.2$   The state of the README.md file in main branch.  bash-3.2$git status On branch main Your branch is up to date with 'origin/main'.  nothing to commit, working tree clean bash-3.2$ bash-3.2$  cat README.md # Index  1   Branch feature-1 created and added one commit.  bash-3.2$  git checkout -b feature-1 Switched to a new branch 'feature-1' bash-3.2$ bash-3.2$  cat README.md # Index  1 2 bash-3.2$ bash-3.2$  git add README.md bash-3.2$ bash-3.2$  git commit -m \"Add number 2 in README.md - feature-1 branch\" [feature-1 83ea1a3] Add number 2 in README.md - feature-1 branch  1 file changed, 1 insertion(+) bash-3.2$ bash-3.2$  git push --set-upstream origin feature-1 Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 292 bytes | 292.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 remote: remote: Create a pull request for 'feature-1' on GitHub by visiting: remote:      https://github.com/jnonino/test-repo/pull/new/feature-1 remote: To github.com:jnonino/test-repo.git  * [new branch]      feature-1 -&gt; feature-1 branch 'feature-1' set up to track 'origin/feature-1'. bash-3.2$   The state of README.md in the feature-1 branch.  bash-3.2$  git status On branch feature-1 Your branch is up to date with 'origin/feature-1'.  nothing to commit, working tree clean bash-3.2$ bash-3.2$  cat README.md # Index  1 2   Merge the feature-1 branch into the main branch.  bash-3.2$  git checkout main Switched to branch 'main' Your branch is up to date with 'origin/main'. bash-3.2$ bash-3.2$  git merge --no-ff feature-1 Merge made by the 'ort' strategy.  README.md | 1 +  1 file changed, 1 insertion(+) bash-3.2$ bash-3.2$  git push Enumerating objects: 1, done. Counting objects: 100% (1/1), done. Writing objects: 100% (1/1), 233 bytes | 233.00 KiB/s, done. Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git    23644da..e2f6d08  main -&gt; main bash-3.2$   Current state of README.md in main branch.  bash-3.2$  git status On branch main Your branch is up to date with 'origin/main'.  nothing to commit, working tree clean bash-3.2$ bash-3.2$  cat README.md # Index  1 2   git log after merging feature-1 into main branch.  commit e2f6d08d3b38a02a1c026cfb879f3131536757ac (HEAD -&gt; main, origin/main) Merge: 23644da 83ea1a3 Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt; Date:   Wed Jan 18 19:58:19 2023 -0300      Merge branch 'feature-1'  commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt; Date:   Wed Jan 18 19:53:38 2023 -0300      Add number 2 in README.md - feature-1 branch  commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt; Date:   Wed Jan 18 19:48:37 2023 -0300      Add number 1 in README.md - main branch   To revert the merge commit, as it was stated above we need to pay attention to the merge field.  Merge: 23644da 83ea1a3   Running git revert e2f6d08 -m 1 will reinstate the tree as it was in 23644da, and git revert e2f6d08 -m 2 will set the tree as it was in 83ea1a3. In this example we would like to leave the main branch as it was before the merge commit. For doing that, we need to run git revert e2f6d08 -m 1.   bash-3.2$  git revert e2f6d08 -m 1 [main 866bfa8] Revert \"Merge branch 'feature-1'\"  1 file changed, 1 deletion(-) bash-3.2$ bash-3.2$  git status On branch main Your branch is ahead of 'origin/main' by 1 commit.   (use \"git push\" to publish your local commits)  nothing to commit, working tree clean bash-3.2$ bash-3.2$  git push Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 344 bytes | 344.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:jnonino/test-repo.git    e2f6d08..866bfa8  main -&gt; main   git log after reverting the merge commit.  commit 866bfa8a952d11240707ebfc87f3266034d42443 (HEAD -&gt; main, origin/main) Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt; Date:   Wed Jan 18 20:06:40 2023 -0300      Revert \"Merge branch 'feature-1'\"      This reverts commit e2f6d08d3b38a02a1c026cfb879f3131536757ac, reversing     changes made to 23644dab9fc5828ecdd358c6d3acb4196ed23546.  commit e2f6d08d3b38a02a1c026cfb879f3131536757ac Merge: 23644da 83ea1a3 Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt; Date:   Wed Jan 18 19:58:19 2023 -0300      Merge branch 'feature-1'  commit 83ea1a347e0e87b19a611997219089b5b9247d1f (origin/feature-1, feature-1) Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt; Date:   Wed Jan 18 19:53:38 2023 -0300      Add number 2 in README.md - feature-1 branch  commit 23644dab9fc5828ecdd358c6d3acb4196ed23546 Author: Julian Nonino &lt;learn.software.eng+jnonino@gmail.com&gt; Date:   Wed Jan 18 19:48:37 2023 -0300      Add number 1 in README.md - main branch   Current state of README.md in main branch.  bash-3.2$  git status On branch main Your branch is up to date with 'origin/main'.  nothing to commit, working tree clean bash-3.2$ bash-3.2$  cat README.md # Index  1  ","categories": ["Version Control"],
        "tags": ["Git","Version Control"],
        "url": "/dev-environment/version%20control/git-revert-pushed/",
        "teaser": null
      },{
        "title": "Post: future date",
        "excerpt":"Test future post in draft folder.  ","categories": ["Future","Draft"],
        "tags": ["Future","Draft","Test"],
        "url": "/dev-environment/future/draft/future-post-template-for-new-posts/",
        "teaser": null
      },{
        "title": "Introduction to Programming",
        "excerpt":"Programming is the process of creating instructions that a computer can understand and execute. It is the backbone of modern technology and is used in a wide range of fields, from finance and healthcare to gaming and entertainment. Whether you are building a website, an app, or a complex piece of software, programming is at the core of it all.   Before diving into programming, it is important to understand some basic concepts about how computers work. A computer consists of a central processing unit (CPU) and memory. The CPU is responsible for executing instructions, while memory stores data and instructions. Programs are a set of instructions that are stored in memory and executed by the CPU. These instructions tell the computer what to do, such as performing calculations, displaying information on a screen, or interacting with other devices.   Programming languages are used to write instructions that can be understood by the computer. There are many different programming languages, each with its own set of rules, syntax, and capabilities. Some popular programming languages include Python, JavaScript, C++, Java, and C#. Each language has its own strengths and weaknesses, and is suited for different types of tasks.   One of the most important concepts in programming is algorithm. An algorithm is a set of steps that can be followed to solve a problem or accomplish a task. Algorithms are the building blocks of programs and are used to perform calculations, sort data, and make decisions.   Another important concept in programming is data types. Data types are categories of data that have specific characteristics and can be used in different ways. Some common data types include integers, floating-point numbers, strings, and Boolean values.   Control flow is the order in which the computer executes instructions. It allows you to create logic and make decisions in your program. Control flow statements, such as if-else statements and loops, allow you to control the flow of execution and change the behavior of your program based on certain conditions.   Here is an example of a simple program written in Python that demonstrates some of these concepts:   # This program calculates the area of a rectangle  # Get the length of the rectangle from the user length = float(input(\"Enter the length of the rectangle: \"))  # Get the width of the rectangle from the user width = float(input(\"Enter the width of the rectangle: \"))  # Calculate the area of the rectangle area = length * width  # Print the result print(\"The area of the rectangle is\", area)   In this example, we use the input function to get the length and width of the rectangle from the user, and then use these values to calculate the area using a simple mathematical formula. The result is then printed using the print function.   This is just a simple example of what you can do with programming. With the right knowledge and tools, you can create much more complex and powerful programs. As you learn more about programming, you will discover new concepts, such as functions, classes, and modules, and learn how to use them to structure your code and solve more complex problems.   There are many resources available for learning programming, including online tutorials, interactive coding environments, and programming bootcamps. Start with the basics and gradually increase complexity as you gain more confidence and understanding.   In conclusion, programming is a powerful tool that can be used to solve problems and create new technologies. Understanding the basic concepts of computer architecture, programming languages, algorithms, data types, and control flow is essential for becoming a successful programmer. With time, patience and practice, you will be able to master the art of programming and create your own powerful applications.  ","categories": [],
        "tags": [],
        "url": "/dev-environment/programming/intro-programming/",
        "teaser": null
      },{
        "title": "Variables and Data Types",
        "excerpt":"The second article in our series on learning programming from scratch will focus on variables and data types.   A variable is a named storage location in a computer’s memory that can be used to store data. In programming, variables are used to store and manipulate data. They are the basic building blocks of any program and are used to store values such as numbers, text, and other data.   There are several types of data that can be stored in variables, including:      Numbers: Integers (whole numbers) and floating-point numbers (numbers with decimal points) are examples of numeric data types.   Strings: Strings are sequences of characters, such as words or sentences. They are usually enclosed in quotation marks.   Boolean: A Boolean data type can only have two values: True or False. It is often used to represent conditions or states.   Lists: A list is a collection of items that can be of any data type. Lists are ordered and can be accessed by index.   Dictionaries: Dictionaries are similar to lists, but instead of being accessed by index, they are accessed by keys.   Each programming language has its own specific way of defining and using variables. In Python, for example, you can create a variable by assigning a value to a name, like this:   x = 5 name = \"John Doe\" is_happy = True   In this example, x is an integer variable with a value of 5, name is a string variable with a value of \"John Doe\" and is_happy is a Boolean variable with a value of True.   It’s important to note that variable names must follow certain rules, such as not starting with a number, not using spaces and not using any reserved keywords.   Another important concept related to variables is data type conversion. Data type conversion allows you to convert a variable from one data type to another. For example, you can convert a string to an integer or a floating-point number to a string. Here’s an example of data type conversion in Python:   # Converting a string to an integer age = \"25\" age = int(age)  # Converting a floating-point number to a string price = 19.99 price = str(price)   In this example, we first assign the value \"25\" to the variable age, which is a string. We then convert the string to an integer using the int() function. We do the same with the variable price, but this time we convert it from a floating-point number to a string using the str() function.   It’s important to note that data type conversion can lead to errors if the data type cannot be converted.   In conclusion, variables and data types are fundamental concepts in programming. They allow you to store and manipulate data in your programs. Understanding how to define variables, assign values to them, and convert them between data types is essential for creating powerful and efficient programs.   In the next article, we will delve deeper into control flow, which is the order in which the computer executes instructions and allow you to create logic and make decisions in your program.  ","categories": [],
        "tags": [],
        "url": "/dev-environment/programming/vars-data-types/",
        "teaser": null
      },{
        "title": "Control Flow",
        "excerpt":"The third article in our series on learning programming from scratch will focus on control flow.   Control flow refers to the order in which the computer executes instructions in a program. It allows you to create logic and make decisions in your program.   There are several control flow statements that you can use to control the flow of your program, including:      if-else: The if-else statement is used to make a decision based on a certain condition. The condition is evaluated as either true or false. If the condition is true, the code block following the if statement will be executed. If the condition is false, the code block following the else statement will be executed.   if condition:     # code block to execute if the condition is true else:     # code block to execute if the condition is false      for loops: A for loop allows you to execute a block of code for a specified number of times. It is often used to iterate through a list or range of numbers.   for i in range(5):     print(i)      while loops: A while loop allows you to execute a block of code as long as a certain condition is true.   while condition:     # code block to execute   Another important concept related to control flow is the use of Boolean expressions. A Boolean expression is an expression that evaluates to either true or false. They are often used in control flow statements to make decisions. Here’s an example of a Boolean expression in Python:   x = 5 y = 10  result = x &gt; y   In this example, the Boolean expression x &gt; y evaluates to false, because 5 is not greater than 10.   You can also use logical operators such as and, or, and not to create more complex Boolean expressions.   x = 5 y = 10 z = 15  result = (x &lt; y) and (y &lt; z)   In this example, the Boolean expression (x &lt; y) and (y &lt; z) evaluates to true, because 5 is less than 10 and 10 is less than 15.   In conclusion, control flow is an essential concept in programming. It allows you to create logic and make decisions in your program. Understanding how to use control flow statements such as if-else, for loops, and while loops, as well as how to use Boolean expressions, is essential for creating powerful and efficient programs.   In the next article, we will delve deeper into functions, which are reusable blocks of code that can be called multiple times throughout your program.  ","categories": [],
        "tags": [],
        "url": "/dev-environment/programming/control-flow/",
        "teaser": null
      },{
        "title": "Functions",
        "excerpt":"The fourth article in our series on learning programming from scratch will focus on functions.   Functions are reusable blocks of code that can be called multiple times throughout your program. They are used to organize and structure your code, making it more readable and maintainable.   Here is an example of a simple function in Python:   def greet(name):     print(\"Hello, \" + name)  greet(\"John\") # prints \"Hello, John\" greet(\"Samantha\") # prints \"Hello, Samantha\"   In this example, the function greet takes in a single parameter, name, and uses it to print out a greeting. The function is called twice, once with the argument \"John\" and once with the argument \"Samantha\".   Functions can also return a value, which can be used by the code that calls the function. Here’s an example of a function that takes in two numbers and returns their sum:   def add(x, y):     return x + y  result = add(5, 3) # returns 8 print(result) # prints 8   In this example, the function add takes in two parameters, x and y, and returns their sum. The function is called with the arguments 5 and 3, and the returned value is stored in the variable result and printed out.   Functions can also have default values for their parameters. This allows you to call the function without passing in a value for that parameter, in which case the default value will be used. Here’s an example:   def divide(x, y=1):     return x / y  result = divide(5) # returns 5, because y is 1 by default print(result) # prints 5  result = divide(5, 2) # returns 2.5 print(result) # prints 2.5   In this example, the function divide takes in two parameters, x and y, with a default value of 1 for y. When the function is called with a single argument, 5, the default value of 1 is used for y, so the function returns 5. When the function is called with two arguments, 5 and 2, the returned value is 2.5.   Functions can also be used to create more complex programs by breaking them down into smaller, more manageable chunks. This makes it easier to understand, test, and debug your code.   In conclusion, functions are an essential concept in programming. They allow you to organize and structure your code, making it more readable and maintainable. Understanding how to create, call, and use functions is essential for creating powerful and efficient programs.   In the next article, we will delve deeper into working with data, including data types, data structures and algorithms.  ","categories": [],
        "tags": [],
        "url": "/dev-environment/programming/functions/",
        "teaser": null
      },{
        "title": "Working with data",
        "excerpt":"The fifth article in our series on learning programming from scratch will focus on working with data.   Data is the foundation of any program, and understanding how to work with different types of data is essential for creating powerful and efficient programs. In this article, we’ll discuss data types, data structures, and algorithms.   Data types refer to the different types of data that can be used in a program. The most common data types include numbers, strings, and booleans. Here’s an example of some basic data types in Python:   # Numbers x = 5 # Integer y = 3.14 # Float  # Strings name = \"John\" greeting = \"Hello, \"  # Booleans is_raining = True is_sunny = False   In this example, we have an integer, a float, a string, a boolean, and a variable that stores the string “John”.   Data structures are ways of organizing data in a program. The most common data structures include lists, tuples, and dictionaries. Here’s an example of some basic data structures in Python:   # Lists numbers = [1, 2, 3, 4, 5] names = [\"John\", \"Samantha\", \"Alex\"]  # Tuples coordinates = (4, 5) colors = (\"red\", \"green\", \"blue\")  # Dictionaries person = {     \"name\": \"John\",     \"age\": 30,     \"is_employee\": True }   In this example, we have a list of numbers, a list of names, a tuple of coordinates, a tuple of colors and a dictionary with the name, age and occupation of a person.   Algorithms are sets of instructions for solving a specific problem. They are used to process data and make decisions based on that data. Here’s an example of a simple algorithm in Python:   def find_largest(numbers):     largest = numbers[0]     for number in numbers:         if number &gt; largest:             largest = number     return largest  numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] result = find_largest(numbers) print(result) # prints 9   In this example, we have a function called find_largest that takes in a list of numbers and returns the largest number in the list. The function uses a for loop to iterate through the list of numbers and compares each number to a variable called largest, which is initially set to the first number in the list. If a larger number is found, largest is updated to that number. Once the loop is finished, the function returns the value of largest.   In conclusion, working with data is an essential part of programming. Understanding data types, data structures, and algorithms is essential for creating powerful and efficient programs. In the next article, we will delve deeper into the topic of object-oriented programming, which is a powerful paradigm for organizing and structuring code.  ","categories": [],
        "tags": [],
        "url": "/dev-environment/programming/working-with-data/",
        "teaser": null
      },{
        "title": "Object-Oriented Programming",
        "excerpt":"The sixth article in our series on learning programming from scratch will focus on object-oriented programming (OOP).   OOP is a programming paradigm that organizes code into objects, which are instances of classes. Classes are templates that define the properties and methods of an object. In OOP, objects interact with each other by sending messages to each other.   The main concepts of OOP are classes, objects, methods and properties.   Here’s an example of a simple class in Python:   class Person:     def __init__(self, name, age):         self.name = name         self.age = age      def say_hello(self):         print(f\"Hello, my name is {self.name} and I am {self.age} years old.\")  person = Person(\"John\", 30) person.say_hello()   In this example, we have a class called Person with two properties, name and age and one method say_hello. The __init__ method is a special method that is called when an object is created from the class. It’s also known as a constructor.   We also have an object called person which is an instance of the class Person. We can access the properties and methods of the object by using the dot notation, for example, person.name or person.say_hello().   Classes can also inherit properties and methods from other classes. This is called inheritance. Here’s an example of a subclass in Python:   class Employee(Person):     def __init__(self, name, age, salary):         super().__init__(name, age)         self.salary = salary      def say_hello(self):         super().say_hello()         print(f\"I earn ${self.salary} per year.\")  employee = Employee(\"Samantha\", 25, 50000) employee.say_hello()   In this example, we have a class called Employee that inherits from the class Person. The Employee class has an additional property salary and a modified version of the say_hello method. The super().__init__(name, age) calls the constructor of the parent class (Person) and super().say_hello() call the method of the parent class.   In conclusion, OOP is a powerful programming paradigm that allows for the organization and structuring of code. Classes and objects are the building blocks of OOP, and understanding how to create and use them is essential for creating powerful and efficient programs. In the next article, we will delve deeper into the topic of error handling and debugging, which are essential for ensuring the reliability and maintainability of your code.  ","categories": [],
        "tags": [],
        "url": "/dev-environment/programming/oop/",
        "teaser": null
      },{
        "title": "Error Handling and Debugging",
        "excerpt":"The seventh article in our series on learning programming from scratch will focus on error handling and debugging.   Error handling is the process of anticipating and dealing with errors that may occur in your program. These errors can be caused by a variety of things, such as invalid user input, bugs in your code, or problems with external resources (e.g. a database or API).   Debugging is the process of identifying and fixing errors in your code.   In most programming languages, errors are signaled using exceptions. An exception is an abnormal event that occurs during the execution of a program, which disrupts the normal flow of instructions.   Here’s an example of a simple exception in Python:   def divide(a, b):     if b == 0:         raise ZeroDivisionError(\"division by zero\")     return a / b  try:     result = divide(10, 0)     print(result) except ZeroDivisionError as e:     print(e)   In this example, we have a function called divide that raises an exception when the divisor is zero. The try-except block is used to catch the exception and handle it in a way that doesn’t cause the program to crash.   You can also use else block to run a block of code if the code in the try block did not raise an exception.   try:     result = divide(10, 2)     print(result) except ZeroDivisionError as e:     print(e) else:     print(\"No exception was raised\")   Debugging is the process of identifying and fixing errors in your code. The most common way to debug code is by using a tool called a “debugger.” A debugger is a program that allows you to step through your code line by line, inspect the values of variables, and set breakpoints to pause the execution of the program at a certain point. Most modern IDEs have built-in debuggers, but you can also use command-line debuggers.   In conclusion, error handling and debugging are essential skills for any programmer. Being able to anticipate and handle errors in your code, as well as being able to quickly identify and fix bugs, will make your code more reliable and maintainable. In the next article, we will focus on the topic of software testing, which is another important aspect of developing high-quality software.  ","categories": [],
        "tags": [],
        "url": "/dev-environment/programming/error-handling-debugging/",
        "teaser": null
      },{
        "title": "Testing",
        "excerpt":"The eighth article in our series on learning programming from scratch will focus on software testing.   Software testing is the process of evaluating a system or its component(s) with the intent to find whether it satisfies the specified requirements or not. There are many different types of software testing, but the most common are unit testing, integration testing, and acceptance testing.   Unit testing is the process of testing individual units of code, typically small functions or methods, in isolation from the rest of the system. The goal of unit testing is to ensure that each unit of code behaves as expected and that any interactions between units of code are handled correctly. Here’s an example of a simple unit test in Python:   def test_divide():     assert divide(10, 2) == 5     assert divide(10, 0) == ZeroDivisionError   Integration testing is the process of testing how different units of code work together. The goal of integration testing is to ensure that the interactions between different parts of the system are handled correctly. This type of testing typically involves testing the integration of different modules, components, or systems.   Acceptance testing is the process of testing a system or its component(s) to determine whether it satisfies the business and technical requirements that guided its design and development. Acceptance testing is typically the last step in the software development process and is performed by the customer or end-user.   In addition to these types of testing, there are also other specialized forms of testing such as performance testing, security testing, and usability testing.   Testing helps to ensure that your code is working as expected, and it makes it easier to find and fix bugs. It also helps to ensure that your code is maintainable, by making it clear what the code is supposed to do.   In conclusion, software testing is an essential part of developing high-quality software. It helps to ensure that your code is working as expected and that it is maintainable. By using a combination of different types of testing, you can ensure that your code is robust and reliable. In the next article, we will focus on the topic of software design patterns, which are reusable solutions to common programming problems.  ","categories": [],
        "tags": [],
        "url": "/dev-environment/programming/testing/",
        "teaser": null
      },{
        "title": "Design Patterns",
        "excerpt":"The ninth article in our series on learning programming from scratch will focus on software design patterns.   A software design pattern is a general repeatable solution to a commonly occurring problem in software design. Design patterns are a proven solution that can be adapted to different situations. They are not specific to any programming language, but rather a general concept that can be implemented in many different ways.   There are several types of design patterns, but the most common ones are creational, structural, and behavioral patterns.   Creational patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. One of the most popular creational pattern is the Factory pattern, which provides an interface for creating objects in a super class, but allows subclasses to alter the type of objects that will be created.   class Dog:     def __init__(self, name):         self._name = name      def speak(self):         return \"Woof!\"  class Cat:     def __init__(self, name):         self._name = name      def speak(self):         return \"Meow!\"  def get_pet(pet=\"dog\"):     pets = dict(dog=Dog(\"Hope\"), cat=Cat(\"Peace\"))     return pets[pet]  d = get_pet(\"dog\") print(d.speak())  c = get_pet(\"cat\") print(c.speak())   Structural patterns deal with object composition. They use inheritance to compose interfaces and define ways to compose objects to obtain new functionalities. An example of a structural pattern is the Adapter pattern, which allows classes with incompatible interfaces to work together.   class EuropeanSocketInterface:     def voltage(self): pass     def live(self): pass     def neutral(self): pass     def earth(self): pass  class USASocketInterface:     def voltage(self): pass     def live(self): pass     def neutral(self): pass  class Adapter:     def __init__(self, socket):         self._socket = socket     def voltage(self):         return 110     def live(self):         return self._socket.live()     def neutral(self):         return self._socket.neutral()  class AmericanKettle:     def __init__(self, power_supply):         self._power = power_supply     def boil(self):         if self._power.voltage() &gt; 110:             print(\"Kettle on fire!\")         else:             if self._power.live() == 1 and self._power.neutral() == -1:                 print(\"Coffee time!\")             else:                 print(\"No power.\")  socket = EuropeanSocketInterface() adapter = Adapter(socket) kettle = AmericanKettle(adapter) kettle.boil()   Behavioral patterns focus on communication between objects. One of the most popular behavioral patterns is the Observer pattern, which allows an object to notify other objects about changes in its state.   class Subject:     def __init__(self):         self._observers = []     def attach(self, observer):         self._observers.append(observer)     def detach(self, observer):         self._observers.remove(observer)     def notify(self):  ","categories": [],
        "tags": [],
        "url": "/dev-environment/programming/design-patterns/",
        "teaser": null
      }]
