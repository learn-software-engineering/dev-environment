<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on Learn-Software.com</title><link>/blog/</link><description>Recent content in Blog on Learn-Software.com</description><generator>Hugo</generator><language>en</language><atom:link href="/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Continuous Delivery</title><link>/blog/2023-09-02-continuous-delivery/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>/blog/2023-09-02-continuous-delivery/</guid><description>&lt;p>Continuous Delivery (CD) is deeply rooted in the first principle of the Agile Manifesto posted in 2001&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>:&lt;/p>
&lt;blockquote>
&lt;p>Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.&lt;/p>
&lt;/blockquote>
&lt;p>According to Martin Fowler&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>, a project is truly embracing Continuous Delivery when:&lt;/p>
&lt;ul>
&lt;li>The software can be deployed at any stage of its lifecycle.&lt;/li>
&lt;li>The team values keeping the software deployment-ready over adding new features.&lt;/li>
&lt;li>Any software version can be deployed to any environment on-demand.&lt;/li>
&lt;/ul>
&lt;p>In many ways, Continuous Delivery is the next step from &lt;a href="/blog/2023-08-08-continuous-integration/">Continuous Integration&lt;/a>, seamlessly automating processes all the way to the software&amp;rsquo;s end user.&lt;/p></description></item><item><title>Continuous Integration</title><link>/blog/2023-08-08-continuous-integration/</link><pubDate>Sat, 19 Aug 2023 00:00:00 +0000</pubDate><guid>/blog/2023-08-08-continuous-integration/</guid><description>&lt;p>One of the most pivotal challenges in the realm of software development is effectively integrating changes &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. In a small-scale project steered by a single developer, this challenge might appear to be trivial. However, as the magnitude of the project escalates and more individuals join the development fold, the significance of seamless integration becomes paramount.&lt;/p>
&lt;p>Historically, integration was often an afterthought, relegated to the tail end of the software development process &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. Postponing it to such a late stage not only amplifies the risk of complex, undetected errors but also heightens the tension as delivery dates loom.&lt;/p></description></item><item><title>Revert a local change in Git</title><link>/blog/2023-01-28-git-revert-local/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>/blog/2023-01-28-git-revert-local/</guid><description>&lt;p>When we have created a commit locally but have not published it to the remote yet, we can use &lt;code>git reset&lt;/code> to undo the commit and, if we wish, discard the changes.
Although there are several options for &lt;code>git reset&lt;/code> the most used are:&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>--soft&lt;/code>: Does not touch the index file or the working tree at all (but resets the head to &lt;COMMIT>, just like all modes do). This leaves all your changed files &amp;ldquo;Changes to be committed&amp;rdquo;, as git status would put it.&lt;/li>
&lt;li>&lt;code>--hard&lt;/code>: Resets the index and working tree. Any changes to tracked files in the working tree since &lt;COMMIT> are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted.&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://git-scm.com/docs/git-reset">Git reset documentation&lt;/a>
{: style=&amp;ldquo;text-align: right;&amp;rdquo;}&lt;/p></description></item><item><title>Revert a pushed change in Git</title><link>/blog/2023-01-18-git-revert-pushed/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>/blog/2023-01-18-git-revert-pushed/</guid><description>&lt;p>When we realized that the last commit was a mistake but we already published it, the command to use is &lt;code>git revert &amp;lt;COMMIT_HASH&amp;gt;&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>First we need to locate the ID of the commit we want to revert, it can be done with &lt;code>git log&lt;/code> or &lt;code>git reflog&lt;/code> commands.&lt;/li>
&lt;li>Then, run the &lt;code>git revert &amp;lt;COMMIT_HASH&amp;gt;&lt;/code> command using the ID obtained in the previous step. Use the options &lt;code>-e&lt;/code> or &lt;code>--edit&lt;/code> to edit the commit message if we like.&lt;/li>
&lt;li>Push our changes so the revert is available for everyone in our group.&lt;/li>
&lt;/ul>
&lt;h2 id="reverting-multiple-commits">Reverting multiple commits&lt;/h2>
&lt;p>If we need to revert multiple commits we can revert them one by one using the &lt;code>--no-commit&lt;/code> option in order to create a single revert commit at the end.&lt;/p></description></item></channel></rss>